/****************************************************************************
 **
 ** This file is part of yFiles for HTML 1.3.0.5.
 ** 
 ** yWorks proprietary/confidential. Use is subject to license terms.
 **
 ** Copyright (c) 2016 by yWorks GmbH, Vor dem Kreuzberg 28, 
 ** 72070 Tuebingen, Germany. All rights reserved.
 **
 ***************************************************************************/
declare module system{
}
declare module yfiles{
  /**
  * A lazy enum type which delays the creation of the enum until it is used.
  */
  export interface EnumDefinition extends Object{
  }
  var EnumDefinition:{
    $class:yfiles.lang.Class;
    /**
    * A lazy enum type which delays the creation of the enum until it is used.
    * @param {function():Object} callback Returns the enum definition as required by {@link yfiles.lang.Enum}.
    */
    new (callback:()=>Object):yfiles.EnumDefinition;
  };
  /**
  * A lazy attribute definition which delays the creation of the attribute until it is used.
  */
  export interface AttributeDefinition extends Object{
  }
  var AttributeDefinition:{
    $class:yfiles.lang.Class;
    /**
    * A lazy attribute definition which delays the creation of the attribute until it is used.
    * @param {function():Object} callback Returns the attribute definition as required by {@link yfiles.lang.Attribute}.
    */
    new (callback:()=>Object):yfiles.AttributeDefinition;
  };
  /**
  * A lazy struct type which delays the creation of the struct until it is used.
  */
  export interface StructDefinition extends Object{
  }
  var StructDefinition:{
    $class:yfiles.lang.Class;
    /**
    * A lazy struct type which delays the creation of the struct until it is used.
    * @param {function():Object} callback Returns the struct definition as required by {@link yfiles.lang.Struct}.
    */
    new (callback:()=>Object):yfiles.StructDefinition;
  };
  /**
  * A lazy class type which delays the creation of the class until it is used.
  */
  export interface ClassDefinition extends Object{
  }
  var ClassDefinition:{
    $class:yfiles.lang.Class;
    /**
    * A lazy class type which delays the creation of the class until it is used.
    * @param {function():Object} callback Returns the class definition as required by {@link yfiles.lang.Class}.
    */
    new (callback:()=>Object):yfiles.ClassDefinition;
  };
  /**
  * A lazy interface type which delays the creation of the interface until it is used.
  */
  export interface InterfaceDefinition extends Object{
  }
  var InterfaceDefinition:{
    $class:yfiles.lang.Class;
    /**
    * A lazy interface type which delays the creation of the interface until it is used.
    * @param {function():Object} callback Returns the interface definition as required by {@link yfiles.lang.Trait}.
    */
    new (callback:()=>Object):yfiles.InterfaceDefinition;
  };
  export module algorithms{
    /**
    * An implementation of a doubly linked list that provides direct access to the
    * cells that store the elements.
    * The cells are represented by class {@link yfiles.algorithms.ListCell}.
    * This class supports fast access and removal operations, specifically, it is possible
    * to remove an element in constant time (i.e. O(1)) given a reference to its list
    * cell.
    * Class YList supports iteration over the elements either by using the list cells
    * directly (methods {@link yfiles.algorithms.YList#firstCell}/{@link yfiles.algorithms.YList#lastCell} together with
    * {@link yfiles.algorithms.YList#succCell}/{@link yfiles.algorithms.YList#predCell}, respectively) or by
    * means of a cursor ({@link yfiles.algorithms.YList#cursor}).
    * Furthermore, YList offers its own {@link yfiles.algorithms.YList#sort} method.
    * Note that this class also provides all relevant methods to use the list like
    * a stack data type.
    * This implementation permits <code>null</code> as values.
    * It implements the {@link yfiles.algorithms.IList} interface but does not support the
    * {@link yfiles.algorithms.YList#subList} method. The implementation of this method will throw an
    * {@link yfiles.system.NotSupportedException} if invoked.
    * The {@link yfiles.algorithms.YList#iterator}s returned by instances of this class are fail fast, however
    * the {@link yfiles.algorithms.YList#cursor} implementation is not.
    */
    export interface YList extends Object,yfiles.algorithms.ICollection,yfiles.algorithms.IList{
      /**
      * Inserts the given object at the head of this list.
      * @return {yfiles.algorithms.ListCell} The newly created ListCell object that stores the given object.
      */
      addFirst(o:Object):yfiles.algorithms.ListCell;
      /**
      * Inserts the given object at the tail of this list.
      * @return {yfiles.algorithms.ListCell} The newly created ListCell object that stores the given object.
      */
      addLast(o:Object):yfiles.algorithms.ListCell;
      /**
      * Adds a formerly removed ListCell object at the tail of this list.
      * <b>Attention:</b> If the ListCell object is still part of any list, then that
      * list will be corrupted afterwards.
      * @param {yfiles.algorithms.ListCell} cell A list cell which is not part of any list.
      */
      addLastCell(cell:yfiles.algorithms.ListCell):void;
      /**
      * Adds a formerly removed ListCell object at the head of this list.
      * <b>Attention:</b> If the ListCell object is still part of any list, then that
      * list will be corrupted afterwards.
      * @param {yfiles.algorithms.ListCell} cell A list cell which is not part of any list.
      */
      addFirstCell(cell:yfiles.algorithms.ListCell):void;
      /**
      * Same as {@link yfiles.algorithms.YList#addLast}.
      * @return {boolean} <code>true</code>
      * @see Specified by {@link yfiles.algorithms.ICollection#addObject}.
      */
      addObject(o:Object):boolean;
      /**
      * Appends all elements provided by the given collection to this list.
      * @return {boolean} Whether there have been elements appended.
      * @see Specified by {@link yfiles.algorithms.ICollection#addAll}.
      */
      addAll(collection:yfiles.algorithms.ICollection):boolean;
      /**
      * Appends all elements provided by the given cursor to this list.
      * The cursor will be moved from its given position to the end.
      * Be aware that a statement like <code>aList.append(aList.cursor())</code> results
      * in an infinite recursion.
      */
      addAllFromCursor(c:yfiles.algorithms.ICursor):void;
      /**
      * Inserts the given object into this list with respect to a given reference list
      * cell.
      * The (newly created) list cell that stores the object is inserted right before
      * the reference list cell <code>refCell</code>.
      * If <code>refCell == null</code>, the given object is appended to the list.
      * <b>Precondition:</b> <code>refCell</code> must be part of this list.
      * @param {Object} o The object to be inserted.
      * @param {yfiles.algorithms.ListCell} refCell The list cell used to reference the position.
      * @return {yfiles.algorithms.ListCell} The newly created ListCell object that stores object <code>o</code>.
      */
      insertBefore(o:Object,refCell:yfiles.algorithms.ListCell):yfiles.algorithms.ListCell;
      /**
      * Inserts a formerly removed ListCell object into this list with respect to a
      * given reference list cell.
      * The ListCell object is inserted right before the reference list cell <code>refCell</code>.
      * <b>Attention:</b> If the ListCell object is still part of any list, then that
      * list will be corrupted afterwards.
      * <b>Precondition:</b> <code>refCell</code> must be part of this list.
      * @param {yfiles.algorithms.ListCell} cellToInsert A list cell which is not part of any list.
      * @param {yfiles.algorithms.ListCell} refCell The list cell used to reference the position.
      */
      insertCellBefore(cellToInsert:yfiles.algorithms.ListCell,refCell:yfiles.algorithms.ListCell):void;
      /**
      * Inserts a formerly removed ListCell object into this list with respect to a
      * given reference list cell.
      * The ListCell object is inserted right after the reference list cell <code>refCell</code>.
      * <b>Attention:</b> If the ListCell object is still part of any list, then that
      * list will be corrupted afterwards.
      * <b>Precondition:</b> <code>refCell</code> must be part of this list.
      * @param {yfiles.algorithms.ListCell} cellToInsert A list cell which is not part of any list.
      * @param {yfiles.algorithms.ListCell} refCell The list cell used to reference the position.
      */
      insertCellAfter(cellToInsert:yfiles.algorithms.ListCell,refCell:yfiles.algorithms.ListCell):void;
      /**
      * Inserts the given object into this list with respect to a given reference list
      * cell.
      * The (newly created) list cell that stores the object is inserted right after
      * the reference list cell <code>refCell</code>.
      * If <code>refCell == null</code>, the given object is inserted at the head of
      * the list.
      * <b>Precondition:</b> <code>refCell</code> must be part of this list.
      * @param {Object} o The object to be inserted.
      * @param {yfiles.algorithms.ListCell} refCell The list cell used to reference the position.
      * @return {yfiles.algorithms.ListCell} The newly created ListCell object that stores object <code>o</code>.
      */
      insertAfter(o:Object,refCell:yfiles.algorithms.ListCell):yfiles.algorithms.ListCell;
      /**
      * The number of elements in this list.
      * @see Specified by {@link yfiles.algorithms.ICollection#count}.
      */
      count:number;
      /**
      * Checks whether this list contains elements.
      * @see Specified by {@link yfiles.algorithms.ICollection#empty}.
      */
      empty:boolean;
      /**
      * Removes all elements from this list.
      * @see Specified by {@link yfiles.algorithms.ICollection#clear}.
      */
      clear():void;
      /**
      * The first element of this list.
      * <b>Precondition:</b> <code>!isEmpty()</code>.
      */
      first:Object;
      /**
      * Removes the first element from this list and returns it.
      */
      pop():Object;
      /**
      * Equivalent to {@link yfiles.algorithms.YList#addFirst}.
      */
      push(o:Object):yfiles.algorithms.ListCell;
      /**
      * Equivalent to {@link yfiles.algorithms.YList#first}.
      */
      peek():Object;
      /**
      * The last element of this list.
      * <b>Precondition:</b> <code>!isEmpty()</code>.
      */
      last:Object;
      /**
      * Removes the last element from this list and returns it.
      */
      popLast():Object;
      /**
      * Returns the i-th element of this list.
      * <b>Precondition:</b> <code>i</code> is a valid index, i.e., <code>i &gt;= 0 &amp;&amp; i &lt; size()</code>.
      */
      elementAt(i:number):Object;
      /**
      * Returns the zero-based index of the given element in this list.
      * If the given element is not in the list, -1 is returned.
      * @see Specified by {@link yfiles.algorithms.IList#indexOf}.
      */
      indexOf(obj:Object):number;
      /**
      * The first cell of this list.
      * <b>Precondition:</b> <code>!isEmpty()</code>.
      */
      firstCell:yfiles.algorithms.ListCell;
      /**
      * The last cell of this list.
      * <b>Precondition:</b> <code>!isEmpty()</code>.
      */
      lastCell:yfiles.algorithms.ListCell;
      /**
      * Returns the successor cell of the given list cell.
      */
      succCell(c:yfiles.algorithms.ListCell):yfiles.algorithms.ListCell;
      /**
      * Returns the predecessor cell of the given list cell.
      */
      predCell(c:yfiles.algorithms.ListCell):yfiles.algorithms.ListCell;
      /**
      * Returns the cyclic successor cell of the given list cell.
      * The first cell is returned as the cyclic successor of the last list cell.
      */
      cyclicSucc(c:yfiles.algorithms.ListCell):yfiles.algorithms.ListCell;
      /**
      * Returns the cyclic predecessor cell of the given list cell.
      * The last cell is returned as the cyclic predecessor of the first list cell.
      */
      cyclicPred(c:yfiles.algorithms.ListCell):yfiles.algorithms.ListCell;
      /**
      * Returns the element stored in the given list cell.
      */
      getInfo(c:yfiles.algorithms.ListCell):Object;
      /**
      * Updates the element stored in the given list cell with the given object.
      */
      setInfo(c:yfiles.algorithms.ListCell,value:Object):void;
      /**
      * Removes the given object from this list.
      * Only the first element for which equality to <code>o</code> holds gets removed.
      * <b>Complexity:</b> O(size())
      * @see Specified by {@link yfiles.algorithms.ICollection#remove}.
      */
      remove(o:Object):boolean;
      /**
      * Removes the given collection of objects from this list.
      * @return {boolean} Whether there have been elements removed.
      * @see Specified by {@link yfiles.algorithms.ICollection#removeAll}.
      */
      removeAll(collection:yfiles.algorithms.ICollection):boolean;
      /**
      * Retains only those elements in this list which are contained in the given collection.
      * <b>Complexity:</b> 
      * This operation has running time O(max(m, n)), were m and n are the sizes of
      * this list and the given collection, respectively.
      * @return {boolean} Whether there have been elements removed.
      * @see Specified by {@link yfiles.algorithms.ICollection#retainAll}.
      */
      retainAll(collection:yfiles.algorithms.ICollection):boolean;
      /**
      * Removes the given list cell, and hence the element stored in it, from this
      * list.
      * <b>Complexity:</b> O(1)
      * <b>Precondition:</b> The given list cell is part of this list.
      * @return {Object} The element that is stored in the removed cell.
      */
      removeCell(c:yfiles.algorithms.ListCell):Object;
      /**
      * Removes the element pointed to by the given YCursor object.
      * <b>Precondition:</b> 
      * The given cursor has been created by a call to this list's {@link yfiles.algorithms.YList#cursor}
      * method and the element pointed to by it is contained in this list.
      * @return {Object} The removed element.
      */
      removeItemPointedToByCursor(c:yfiles.algorithms.ICursor):Object;
      /**
      * Returns a cursor for this list.
      * All cursor operations are supported.
      * This cursor implementation is not fail-fast and continues to work
      * if this list is modified during the traversal as long as the current
      * ListCell the cursor points at is this in this list or has been removed
      * from this list
      * but has not been added to another instance since then.
      */
      cursor():yfiles.algorithms.ICursor;
      /**
      * Returns an iterator for that list.
      * The remove operation is supported on the iterator. This iterator instance
      * is fail-fast.
      * @see Specified by {@link yfiles.algorithms.ICollection#iterator}.
      */
      iterator():yfiles.algorithms.IIterator;
      /**
      * Returns a list iterator that can be used to iterate over all items of this list
      * in correct order.
      * @return {yfiles.algorithms.IListIterator} a list iterator that iterates over the items of this list.
      * @see Specified by {@link yfiles.algorithms.IList#listIterator}.
      */
      listIterator():yfiles.algorithms.IListIterator;
      /**
      * Whether or not this list contains the given element.
      * Equality of elements is defined by the {@link Object#equals} method.
      * @see Specified by {@link yfiles.algorithms.ICollection#contains}.
      */
      contains(o:Object):boolean;
      /**
      * Whether or not this list contains all the elements in the given collection.
      * Equality of elements is defined by the {@link Object#equals} method.
      * @see Specified by {@link yfiles.algorithms.ICollection#containsAll}.
      */
      containsAll(collection:yfiles.algorithms.ICollection):boolean;
      /**
      * Returns the {@link yfiles.algorithms.ListCell} where object <code>o</code> is stored.
      * This operation returns <code>null</code>, if no such cell exists.
      * Equality of elements is defined by the {@link Object#equals} method.
      * The first element in the list that matches that criteria is returned.
      * @return {yfiles.algorithms.ListCell} 
      * the ListCell that contains the element or <code>null</code> if no
      * such ListCell was found
      */
      findCell(o:Object):yfiles.algorithms.ListCell;
      /**
      * Returns a string representation of this List.
      */
      toString():string;
      /**
      * Returns an array representation of this list.
      * @see Specified by {@link yfiles.algorithms.ICollection#toArray}.
      */
      toArray():Object[];
      /**
      * Returns an array containing all list elements in the correct order.
      * The runtime type of the returned array is that of the given array.
      * If the list does not fit in the specified array, a new array is allocated with
      * the runtime type of the specified array and the size of this list.
      * If the list fits in the specified array with room to spare (i.e., the array
      * has more elements than the list), the element in the array immediately following
      * the end of the collection is set to <code>null</code>.
      * This is useful in determining the length of the list <i>only</i> if the caller
      * knows that the list does not contain any <code>null</code> elements.
      * @param {Object} a 
      * The array into which the elements of the list are to be stored, if it is big
      * enough.
      * Otherwise, a new array of the same runtime type is allocated for this purpose.
      * @return {Object} An array containing the elements of the list.
      * @see Specified by {@link yfiles.algorithms.ICollection#toGivenArray}.
      */
      toGivenArray(a:Object):Object;
      /**
      * Reverses the sequence of elements in this list.
      */
      reverse():void;
      /**
      * Sorts the elements in this list according to the given comparator.
      * NOTE: The elements will be assigned to different list cells by this method.
      * <b>Complexity:</b> O(size() * log(size()))
      */
      sortWithComparer(comp:yfiles.objectcollections.IComparer):void;
      /**
      * Sorts the elements in this list into ascending order, according to their natural
      * ordering.
      * All elements must implement the {@link yfiles.lang.IObjectComparable} interface.
      * Furthermore, all elements in this list must be mutually comparable (that is,
      * <code>e1.compareTo(e2)</code> must not throw a ClassCastException for any elements
      * <code>e1</code> and <code>e2</code> in this list).
      * NOTE: The elements will be assigned to different list cells by this method.
      * <b>Complexity:</b> O(size() * log(size()))
      */
      sort():void;
      /**
      * Transfers the contents of the given list to the end of this list.
      * The given list will be empty after this operation.
      * Note that this operation transfers the list cells of the given list to this
      * list.
      * No new list cells are created by this operation.
      * <b>Complexity:</b> O(1)
      */
      splice(list:yfiles.algorithms.YList):void;
      /**
      * Adds all items of the given collection at the specified index.
      * <p>
      * All subsequent items are shifted to the right by the number of items added.
      * </p>
      * @param {number} index the index at which to insert the items.
      * @param {yfiles.algorithms.ICollection} c the collection whose items will be added.
      * @return {boolean} <code>true</code> if this list has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.IList#addAllAt}.
      */
      addAllAt(index:number,c:yfiles.algorithms.ICollection):boolean;
      /**
      * Gets the cell at the given index.
      * @param {number} index the zero-based index of the cell in this list.
      * @return {yfiles.algorithms.ListCell} The cell.
      * @throws {yfiles.system.IndexOutOfRangeException} 
      * if the index is negative or greater or equal than the {@link yfiles.algorithms.YList#count}
      */
      getCell(index:number):yfiles.algorithms.ListCell;
      /**
      * Returns the index of the last occurrence of the specified item in this list,
      * or -1 if the list does not contain the object.
      * @param {Object} o the item whose last index is being returned.
      * @return {number} the index of last occurrence of the specified item, or -1.
      * @see Specified by {@link yfiles.algorithms.IList#lastIndexOf}.
      */
      lastIndexOf(o:Object):number;
      /**
      * Replaces the item at the specified index with the given item.
      * @param {number} index the index at which to replace the item.
      * @param {Object} item the item which should be set at the specified index.
      * @return {Object} the item that was previously at the specified index.
      * @see Specified by {@link yfiles.algorithms.IList#setAtListIndex}.
      */
      setAtListIndex(index:number,element:Object):Object;
      /**
      * Removes the object at the specified index.
      * <p>
      * All subsequent list items are shifted to the left by one step.
      * </p>
      * @param {number} index the index of the item to be removed.
      * @return {Object} the object previously at the specified position
      * @see Specified by {@link yfiles.algorithms.IList#removeAtIndex}.
      */
      removeAtIndex(index:number):Object;
      /**
      * Returns a list iterator that can be used to iterate over all items of this list
      * in correct order.
      * The iteration starts at the specified index.
      * @param {number} index the index at which to start the iteration.
      * @return {yfiles.algorithms.IListIterator} 
      * a list iterator that iterates over the items of this list, starting at the
      * specified index.
      * @see Specified by {@link yfiles.algorithms.IList#listIteratorFrom}.
      */
      listIteratorFrom(index:number):yfiles.algorithms.IListIterator;
      /**
      * Returns the item at the specified index.
      * @param {number} index the index of the item that is retrieved.
      * @return {Object} the item at the specified index.
      * @see Specified by {@link yfiles.algorithms.IList#getAtListIndex}.
      */
      getAtListIndex(index:number):Object;
      /**
      * Adds the given object to the collection at the specified index.
      * <p>
      * All subsequent items are shifted to the right one step.
      * </p>
      * @param {number} index the index at which to insert the item
      * @param {Object} item the item to insert
      * @see Specified by {@link yfiles.algorithms.IList#addAt}.
      */
      addAt(index:number,element:Object):void;
      /**
      * Returns a list that contains the specified range of items in this list.
      * @param {number} fromIndex the index of the item that is the first element of the returned list.
      * @param {number} toIndex 
      * the end index the returned list. The item at this index is not included
      * in the returned list.
      * @return {yfiles.algorithms.IList} a list that contains the items of this list in the specified range.
      * @see Specified by {@link yfiles.algorithms.IList#subList}.
      */
      subList(fromIndex:number,toIndex:number):yfiles.algorithms.IList;
      equals(other:Object):boolean;
      hashCode():number;
      getObjectEnumerator():yfiles.objectcollections.IEnumerator;
      copyTo(array:Object,index:number):void;
      syncRoot:Object;
      isSynchronized:boolean;
      getEnumerator():yfiles.collections.IEnumerator<Object>;
      add(item:Object):void;
      copyToArrayAt(array:Object[],arrayIndex:number):void;
      insertAt(index:number,value:Object):void;
      get(index:number):Object;
      set(index:number,value:Object):void;
      isFixedSize:boolean;
      insert(index:number,item:Object):void;
      removeAt(index:number):void;
      getItem(index:number):Object;
      setItemAt(index:number,value:Object):void;
    }
    export module YList{
      /**
      * Cursor implementation for class YList.
      */
      export interface ListCursorImpl extends Object,yfiles.algorithms.ICursor{
        /**
        * <code>true</code> if the current cursor position is valid.
        * @see Specified by {@link yfiles.algorithms.ICursor#ok}.
        */
        ok:boolean;
        /**
        * Moves this cursor one position forward.
        * @see Specified by {@link yfiles.algorithms.ICursor#next}.
        */
        next():void;
        /**
        * Moves this cursor one position backward (optional).
        * @see Specified by {@link yfiles.algorithms.ICursor#prev}.
        */
        prev():void;
        /**
        * Moves this cursor to the first valid cursor position (optional).
        * @see Specified by {@link yfiles.algorithms.ICursor#toFirst}.
        */
        toFirst():void;
        /**
        * Moves this cursor to the last valid cursor position (optional).
        * @see Specified by {@link yfiles.algorithms.ICursor#toLast}.
        */
        toLast():void;
        /**
        * The number of elements that can be accessed with this cursor.
        * @see Specified by {@link yfiles.algorithms.ICursor#size}.
        */
        size:number;
        /**
        * The object currently pointed on.
        * @see Specified by {@link yfiles.algorithms.ICursor#current}.
        */
        current:Object;
      }
    }
    var YList:{
      $class:yfiles.lang.Class;
      /**
      * Creates an empty doubly linked list.
      */
      new ():yfiles.algorithms.YList;
      /**
      * Creates a list that is initialized with the elements provided by the given
      * Collection object.
      */
      FromCollection:{
        new (c:yfiles.algorithms.ICollection):yfiles.algorithms.YList;
      };
      /**
      * Creates a list that is initialized with the elements provided by the given
      * iterator object.
      */
      FromIterator:{
        new (it:yfiles.algorithms.IIterator):yfiles.algorithms.YList;
      };
      /**
      * Creates a list that is initialized with the elements provided by the given
      * enumerator object.
      */
      FromEnumerator:{
        new (e:yfiles.objectcollections.IEnumerator):yfiles.algorithms.YList;
      };
      /**
      * Creates a list that is initialized with the elements provided by the given
      * YCursor object.
      */
      FromCursor:{
        new (c:yfiles.algorithms.ICursor):yfiles.algorithms.YList;
      };
      /**
      * Creates a list that is initialized with those elements from the given YCursor
      * object for which the given data provider returns <code>true</code> upon
      * calling its {@link yfiles.algorithms.IDataProvider#getBool  getBool} method.
      * @param {yfiles.algorithms.ICursor} c A cursor providing objects that should be added to this list.
      * @param {yfiles.algorithms.IDataProvider} predicate 
      * A data provider that acts as a inclusion predicate for each object accessible
      * by the given cursor.
      */
      FromCursorFiltered:{
        new (c:yfiles.algorithms.ICursor,predicate:yfiles.algorithms.IDataProvider):yfiles.algorithms.YList;
      };
      /**
      * Creates a list that is initialized with the elements provided by the given
      * array of objects.
      */
      FromArray:{
        new (a:Object[]):yfiles.algorithms.YList;
      };
      /**
      * Creates a list that is initialized with the elements stored in the given
      * collection.
      */
      newInstanceFromCollection(c:yfiles.objectcollections.ICollection):yfiles.algorithms.YList;
      /**
      * Creates a list that is initialized with the elements stored in the given
      * collection.
      */
      newInstance<T>(c:yfiles.collections.ICollection<T>):yfiles.algorithms.YList;
      ListCursorImpl:{
        $class:yfiles.lang.Class;
        new (_enclosing:yfiles.algorithms.YList):yfiles.algorithms.YList;
      };
    };
    /**
    * This class is an abstract empty implementation of the NodeMap interface.
    * Subclasses
    */
    export interface NodeMapAdapter extends Object,yfiles.algorithms.INodeMap{
      /**
      * Associates the given value to with the given node.
      * @see Specified by {@link yfiles.algorithms.INodeMap#set}.
      */
      set(key:Object,value:Object):void;
      /**
      * Returns the value bound to the given node.
      * @param {Object} key 
      * @return {Object} <code>null</code>
      * @see Specified by {@link yfiles.algorithms.INodeMap#get}.
      */
      get(key:Object):Object;
      /**
      * Associates the given boolean value to with the given node.
      * @see Specified by {@link yfiles.algorithms.INodeMap#setBool}.
      */
      setBool(key:Object,value:boolean):void;
      /**
      * Returns the boolean value bound to the given node.
      * <b>Precondition:</b> 
      * The value must have been associated to the given node by
      * a call to <code>setBool</code>.
      * @param {Object} key 
      * @return {boolean} <code>false</code>
      * @see Specified by {@link yfiles.algorithms.INodeMap#getBool}.
      */
      getBool(key:Object):boolean;
      /**
      * Associates the given double value to with the given node.
      * @see Specified by {@link yfiles.algorithms.INodeMap#setDouble}.
      */
      setDouble(key:Object,value:number):void;
      /**
      * Returns the double value bound to the given node.
      * <b>Precondition:</b> 
      * The value must have been associated to the given node by
      * a call to <code>setDouble</code>.
      * @return {number} <code>0.0d</code>
      * @see Specified by {@link yfiles.algorithms.INodeMap#getDouble}.
      */
      getDouble(key:Object):number;
      /**
      * Associates the given integer value to with the given node.
      * @see Specified by {@link yfiles.algorithms.INodeMap#setInt}.
      */
      setInt(key:Object,value:number):void;
      /**
      * Returns the integer value bound to the given node.
      * <b>Precondition:</b> 
      * The value must have been associated to the given node by
      * a call to <code>setInt</code>.
      * @return {number} <code>0</code>
      * @see Specified by {@link yfiles.algorithms.INodeMap#getInt}.
      */
      getInt(key:Object):number;
    }
    var NodeMapAdapter:{
      $class:yfiles.lang.Class;
    };
    /**
    * This class can be used to wrap a given DataProvider with another one.
    * It is intended to work with DataProviders providing Objects only.
    * Whenever data is not found in the decorating DataProvider (known as the wrapper).
    * The underlying data provider will be queried.
    */
    export interface WrappedObjectDataProvider extends Object,yfiles.algorithms.IDataProvider{
      /**
      * A DataMap that can be used to read and write values.
      */
      dataMapView:yfiles.algorithms.IDataMap;
      /**
      * Performs the wrapping, the given DataProvider will be unregistered
      * from the graph and replaced with this instance.
      * @param {yfiles.algorithms.Graph} g the graph which will be registered with the data providers
      * @param {Object} dataProviderKey the key used for registering
      */
      wrap(g:yfiles.algorithms.Graph,dataProviderKey:Object):void;
      /**
      * Undoes a previous wrap() operation.
      */
      unwrap():void;
      /**
      * Returns an object value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#get}.
      */
      get(dataHolder:Object):Object;
      /**
      * Returns a boolean value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#getBool}.
      */
      getBool(dataHolder:Object):boolean;
      /**
      * Returns a double value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#getDouble}.
      */
      getDouble(dataHolder:Object):number;
      /**
      * Returns an integer value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#getInt}.
      */
      getInt(dataHolder:Object):number;
      /**
      * The underlying wrapped DataProvider.
      */
      wrappedProvider:yfiles.algorithms.IDataProvider;
      /**
      * The wrapping DataProvider instance.
      * This can safely be cast to
      * a NodeMap or an EdgeMap respectively if the appropriate static factory
      * methods have been used for the construction of <code>this</code>.
      */
      wrappingProvider:yfiles.algorithms.IDataProvider;
      /**
      * Disposes previously allocated data structures.
      * First a call to
      * <code>unwrap()</code> is made. Then the wrappers are disposed from the
      * graph if they are instances of NodeMaps or EdgeMaps respectively.
      */
      dispose():void;
    }
    var WrappedObjectDataProvider:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of WrappedDataProvider.
      * This instance
      * will delegate queries to the wrapper first. Unsatisfied requests
      * will be delegated to the original second provider.
      * @param {yfiles.algorithms.IDataProvider} wrapper The DataProvider instance which will be queried first
      * @param {yfiles.algorithms.IDataProvider} provider the data provider which will be wrapped by the first one
      */
      new (wrapper:yfiles.algorithms.IDataProvider,provider:yfiles.algorithms.IDataProvider):yfiles.algorithms.WrappedObjectDataProvider;
      /**
      * Creates a new instance of WrappedDataProvider.
      * This instance
      * will delegate queries to the wrapper first. Unsatisfied requests
      * will be delegated to the original provider. This method wraps the
      * currently registered DataProvider with <code>this</code>. This can be undone
      * by calling <code>unwrap()</code>
      * @param {yfiles.algorithms.IDataProvider} wrapper the wrapping data provider
      * @param {yfiles.algorithms.Graph} graph the graph which will be registered with the data providers
      * @param {Object} dataProviderKey the key used for registering
      */
      ForGraph:{
        new (wrapper:yfiles.algorithms.IDataProvider,graph:yfiles.algorithms.Graph,dataProviderKey:Object):yfiles.algorithms.WrappedObjectDataProvider;
      };
      /**
      * Creates a new instance of WrappedDataProvider.
      * This instance
      * will delegate queries to a newly created EdgeMap wrapper first. Unsatisfied requests
      * will be delegated to the original provider. This method wraps the
      * currently registered DataProvider with the returned DataProvider instance.
      * This can be undone
      * by calling <code>unwrap()</code>
      * @param {yfiles.algorithms.Graph} graph the graph which will be registered with the data providers
      * @param {Object} dataProviderKey the key used for registering and wrapping
      */
      wrapUsingEdgeMap(graph:yfiles.algorithms.Graph,dataProviderKey:Object):yfiles.algorithms.WrappedObjectDataProvider;
      /**
      * Creates a new instance of WrappedDataProvider.
      * This instance
      * will delegate queries to a newly created NodeMap wrapper first. Unsatisfied requests
      * will be delegated to the original provider. This method wraps the
      * currently registered DataProvider with the returned DataProvider instance.
      * This can be undone
      * by calling <code>unwrap()</code>
      * @param {yfiles.algorithms.Graph} graph the graph which will be registered with the data providers
      * @param {Object} dataProviderKey the key used for registering and wrapping
      */
      wrapUsingNodeMap(graph:yfiles.algorithms.Graph,dataProviderKey:Object):yfiles.algorithms.WrappedObjectDataProvider;
    };
    /**
    * Generates pseudo-random numbers and the such.
    */
    export interface YRandom extends yfiles.algorithms.Random{
      /**
      * Returns a pseudo-random, uniformly distributed <code>int</code> value
      * between 0 (inclusive) and the specified value (exclusive), drawn from
      * this random number generator's sequence.
      * @see Overrides {@link yfiles.algorithms.Random#nextIntInRange}
      */
      nextIntInRange(n:number):number;
      /**
      * Returns an array of <code>n</code> unique random integers that
      * lie within the range <code>min</code> (inclusive) and
      * <code>max</code> (exclusive).
      * If <code>max - min &lt; n</code>
      * then <code>null</code> is returned.
      */
      getUniqueArray(n:number,min:number,max:number):number[];
      /**
      * Returns an array of <code>n</code> randomly chosen boolean values
      * of which <code>trueCount</code> of them are <code>true</code>.
      * If the requested numbers of true values is bigger than the number
      * of requested boolean values, an Exception is raised.
      */
      getBoolArray(n:number,trueCount:number):boolean[];
      /**
      * Returns an int array of length <code>bucketCount</code> for
      * which the values of all fields are non-negative and sum up
      * to <code>ballCount</code>.
      * The values are put
      * in the array randomly.
      */
      getIntArray(bucketCount:number,ballCount:number):number[];
      /**
      * Returns a double with a random value between <code>minValue</code>
      * (inclusive) and <code>maxValue</code> (exclusive).
      * <b>Precondition:</b> <code>maxValue &gt; minValue</code>
      */
      nextDoubleBetweenMinAndMax(minValue:number,maxValue:number):number;
      /**
      * Returns an int with a random value between <code>minValue</code>
      * (inclusive) and <code>maxValue</code> (exclusive).
      * <b>Precondition:</b> <code>maxValue &gt; minValue</code>
      */
      nextIntBetweenMinAndMax(minValue:number,maxValue:number):number;
      /**
      * Permutes the positions of the elements within the given array.
      */
      permutate(a:Object[]):void;
    }
    var YRandom:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of this class.
      */
      new ():yfiles.algorithms.YRandom;
      /**
      * Creates a new instance of this class with a given
      * initial random seed.
      */
      WithSeed:{
        new (seed:number):yfiles.algorithms.YRandom;
      };
    };
    /**
    * Implements a priority queue for nodes based on AVL Trees.
    * The priority values may be non-negative.
    */
    export interface TreeIntNodePQ extends Object,yfiles.algorithms.IIntNodePQ{
      /**
      * Specifies whether or not this queue is empty.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#empty}.
      */
      empty:boolean;
      /**
      * Returns whether or not the given node is contained within this queue.
      * <b>Complexity:</b> O(log(n)).
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#contains}.
      */
      contains(n:yfiles.algorithms.Node):boolean;
      /**
      * Inserts a node into the queue.
      * <b>Complexity:</b> O(log(n)).
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#add}.
      */
      add(n:yfiles.algorithms.Node,value:number):void;
      /**
      * Removes a node from the queue.
      * <b>Complexity:</b> O(log(n)).
      */
      remove(n:yfiles.algorithms.Node):void;
      /**
      * The node with the minimal value in the queue.
      * <b>Complexity:</b> O(log(n)).
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#min}.
      */
      min:yfiles.algorithms.Node;
      /**
      * Removes the node with the minimal value from the queue.
      * <b>Complexity:</b> O(log(n)).
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#removeMin}.
      */
      removeMin():yfiles.algorithms.Node;
      /**
      * Decreases the value of a node in the queue to a certain value.
      * <b>Complexity:</b> O(log(n)).
      * @param {yfiles.algorithms.Node} n a node in the priority queue.
      * @param {number} value the new priority value of the node.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#decreasePriority}.
      */
      decreasePriority(n:yfiles.algorithms.Node,value:number):void;
      /**
      * Removes all entities from the queue.
      * <b>Complexity:</b> O(1).
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#clear}.
      */
      clear():void;
      /**
      * Returns the current priority of the given node.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#getPriority}.
      */
      getPriority(v:yfiles.algorithms.Node):number;
      /**
      * Disposes this queue.
      * It is important to call this method after the queue
      * is not needed anymore, to free hold resources.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#dispose}.
      */
      dispose():void;
    }
    var TreeIntNodePQ:{
      $class:yfiles.lang.Class;
      /**
      * Returns an empty Priority-Queue.
      * @param {yfiles.algorithms.Graph} _graph the graph which contains the nodes
      */
      new (_graph:yfiles.algorithms.Graph):yfiles.algorithms.TreeIntNodePQ;
      /**
      * Returns a new Priority-Queue initialized with all nodes of the graph.
      * @param {yfiles.algorithms.Graph} _graph the graph which contains the nodes
      * @param {yfiles.algorithms.IDataProvider} _initValues the initial priority-values of the nodes.
      */
      WithInitValues:{
        new (_graph:yfiles.algorithms.Graph,_initValues:yfiles.algorithms.IDataProvider):yfiles.algorithms.TreeIntNodePQ;
      };
      /**
      * Returns an empty Priority-Queue.
      * This constructor takes a <code>NodeMap</code> as argument
      * which is used to store the priority values.
      * @param {yfiles.algorithms.INodeMap} _valueMap here the priority values are stored
      */
      FromNodeMap:{
        new (_valueMap:yfiles.algorithms.INodeMap):yfiles.algorithms.TreeIntNodePQ;
      };
    };
    /**
    * This class represents an ordered 2-Tuple that is consistent with
    * <code>equals()</code> and <code>hashCode()</code>.
    * Therefore it can
    * safely be used within HashTables, HashSets, HashMaps and the like.
    * Using the static <code>create</code> methods, it is possible to
    * build 3,4,5-Tuples recursively out of multiple 2-Tuples.
    */
    export interface Tuple extends Object{
      /**
      * The first element of the Tuple.
      */
      o1:Object;
      /**
      * The second element of the Tuple.
      */
      o2:Object;
      /**
      * Determines if the given Tuple equals another Tuple.
      * Returns true iff both elements are equal
      * (both null or equals() returns <code>true</code>.
      * @param {Object} o the element to compare this tuple with
      * @return {boolean} true iff o equals this
      */
      equals(o:Object):boolean;
      /**
      * Generates a hashCode using the two tuple elements.
      * @return {number} a hashCode built using the hashCodes of the two elements.
      */
      hashCode():number;
      toString():string;
    }
    var Tuple:{
      $class:yfiles.lang.Class;
      /**
      * Constructs a 2-Tuple using the two given Objects.
      * @param {Object} o1 The first element (may be <code>null</code>)
      * @param {Object} o2 The second element (may be <code>null</code>)
      */
      new (o1:Object,o2:Object):yfiles.algorithms.Tuple;
      /**
      * Factory method to create a 2-Tuple.
      */
      create(o1:Object,o2:Object):Object;
      /**
      * Factory method to create a 3-Tuple.
      */
      createTriple(o1:Object,o2:Object,o3:Object):Object;
      /**
      * Factory method to create a 4-Tuple.
      */
      createQuadruple(o1:Object,o2:Object,o3:Object,o4:Object):Object;
      /**
      * Factory method to create a 5-Tuple.
      */
      createQuintuple(o1:Object,o2:Object,o3:Object,o4:Object,o5:Object):Object;
    };
    /**
    * A factory class that creates instances of the classes implementing
    * {@link yfiles.algorithms.ICollection}.
    */
    export interface CollectionFactory extends Object{
    }
    var CollectionFactory:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new {@link yfiles.algorithms.IList}.
      * @return {yfiles.algorithms.IList} 
      * a new instance of {@link yfiles.algorithms.IList}.
      */
      createArrayList():yfiles.algorithms.IList;
      /**
      * Creates a new {@link yfiles.algorithms.IList} with the contents of the specified
      * collection.
      * @return {yfiles.algorithms.IList} 
      * a new instance of {@link yfiles.algorithms.IList}.
      */
      createArrayListFromCollection(c:yfiles.algorithms.ICollection):yfiles.algorithms.IList;
      /**
      * Creates a new {@link yfiles.algorithms.IMap}.
      * @return {yfiles.algorithms.IMap} 
      * a new instance of {@link yfiles.algorithms.IMap}.
      */
      createHashMap():yfiles.algorithms.IMap;
      /**
      * Creates a new {@link yfiles.algorithms.ISet}.
      * @return {yfiles.algorithms.ISet} 
      * a new instance of {@link yfiles.algorithms.ISet}.
      */
      createHashSet():yfiles.algorithms.ISet;
      /**
      * Creates a new {@link yfiles.algorithms.ISet} with the contents of the specified
      * collection.
      * @return {yfiles.algorithms.ISet} 
      * a new instance of {@link yfiles.algorithms.ISet}.
      */
      createHashSetFromCollection(c:yfiles.algorithms.ICollection):yfiles.algorithms.ISet;
      /**
      * Creates a new {@link yfiles.algorithms.ISet}.
      * @return {yfiles.algorithms.ISet} 
      * a new instance of {@link yfiles.algorithms.ISet}.
      */
      createTreeSet():yfiles.algorithms.ISet;
      /**
      * Creates a new {@link yfiles.algorithms.ISet} with the contents of the specified
      * collection.
      * @return {yfiles.algorithms.ISet} 
      * a new instance of {@link yfiles.algorithms.ISet}.
      */
      createTreeSetFromCollection(c:yfiles.algorithms.ICollection):yfiles.algorithms.ISet;
    };
    /**
    * Represents a two-dimensional rectangle of size <code>(width x height)</code>,
    * located at the point <code>(x, y)</code>.
    */
    export interface Rectangle2D extends Object,yfiles.algorithms.ICloneable{
      /**
      * The outer bounds of this rectangle in double coordinates.
      */
      frame:yfiles.algorithms.Rectangle2D;
      /**
      * Sets the outer bounds of this rectangle based on the end points of one of its diagonals.
      * @param {number} x1 the x-coordinate of the first end point of a diagonal.
      * @param {number} y1 the y-coordinate of the first end point of a diagonal.
      * @param {number} x2 the x-coordinate of the other end point of a diagonal.
      * @param {number} y2 the y-coordinate of the other end point of a diagonal.
      */
      setFrameFromDiagonalCoordinates(x1:number,y1:number,x2:number,y2:number):void;
      /**
      * Sets the outer bounds of this rectangle based on the end points of one of its diagonals.
      * @param {yfiles.algorithms.Point2D} p1 the first end point of a diagonal.
      * @param {yfiles.algorithms.Point2D} p2 the other end point of a diagonal.
      */
      setFrameFromDiagonal(p1:yfiles.algorithms.Point2D,p2:yfiles.algorithms.Point2D):void;
      /**
      * Sets the outer bounds of this rectangle based on the specified new center and corner.
      * @param {number} centerX the x-coordinate of the new center of this rectangle.
      * @param {number} centerY the y-coordinate of the new center of this rectangle.
      * @param {number} cornerX the x-coordinate of any new corner of this rectangle.
      * @param {number} cornerY the y-coordinate of any new corner of this rectangle.
      */
      setFrameFromCenterCoordinates(centerX:number,centerY:number,cornerX:number,cornerY:number):void;
      /**
      * Sets the outer bounds of this rectangle based on the specified new center and corner.
      * @param {yfiles.algorithms.Point2D} center the new center of this rectangle.
      * @param {yfiles.algorithms.Point2D} corner any new corner of this rectangle.
      */
      setFrameFromCenter(center:yfiles.algorithms.Point2D,corner:yfiles.algorithms.Point2D):void;
      /**
      * Sets the outer bounds of this rectangle based on the specified location and size.
      * @param {number} x the new x-coordinate of the upper left corner.
      * @param {number} y the new y-coordinate of the upper left corner.
      * @param {number} width the new width.
      * @param {number} height the new height.
      */
      setFrame(x:number,y:number,width:number,height:number):void;
      /**
      * The location and size of this rectangle to be similar to the specified rectangle.
      */
      rect:yfiles.algorithms.Rectangle2D;
      /**
      * Sets the location and size of this rectangle to the specified values.
      * @param {number} x the new x-coordinate of the upper left corner.
      * @param {number} y the new y-coordinate of the upper left corner.
      * @param {number} width the new width.
      * @param {number} height the new height.
      */
      setRect(x:number,y:number,width:number,height:number):void;
      /**
      * Calculates the intersection of this rectangle with the given rectangle and returns the result as new rectangle.
      * @param {yfiles.algorithms.Rectangle2D} r a rectangle to intersect with this rectangle.
      * @return {yfiles.algorithms.Rectangle2D} a new rectangle that represents the calculated intersection.
      */
      createIntersection(r:yfiles.algorithms.Rectangle2D):yfiles.algorithms.Rectangle2D;
      /**
      * Calculates the union of this rectangle with the given rectangle and returns the result as new rectangle.
      * @param {yfiles.algorithms.Rectangle2D} r a rectangle to union with this rectangle.
      * @return {yfiles.algorithms.Rectangle2D} a new rectangle that represents the calculated union.
      */
      createUnion(r:yfiles.algorithms.Rectangle2D):yfiles.algorithms.Rectangle2D;
      /**
      * Checks if the line segment specified by the given coordinates intersects this rectangle.
      * @param {number} x1 the x-coordinate of the first end point of the line.
      * @param {number} y1 the y-coordinate of the first end point of the line.
      * @param {number} x2 the x-coordinate of the other end point of the line.
      * @param {number} y2 the y-coordinate of the other end point of the line.
      * @return {boolean} <code>true</code> if the specified line intersects this rectangle; <code>false</code> otherwise.
      */
      intersectsLine(x1:number,y1:number,x2:number,y2:number):boolean;
      /**
      * Checks if the point specified by the given coordinates is contained in this rectangle.
      * @param {number} x the x-coordinate of the point.
      * @param {number} y the y-coordinate of the point.
      * @return {boolean} <code>true</code> if the specified point is contained in this rectangle; <code>false</code> otherwise.
      */
      containsPoint(x:number,y:number):boolean;
      /**
      * Checks whether this rectangle and the second specified rectangle intersect.
      * @param {number} x the x coordinate of the second rectangle.
      * @param {number} y the y coordinate of the second rectangle.
      * @param {number} width the width coordinate of the second rectangle.
      * @param {number} height the height coordinate of the second rectangle.
      * @return {boolean} <code>true</code> if both rectangles intersect
      */
      intersectsRectangleCoordinates(x:number,y:number,width:number,height:number):boolean;
      /**
      * Checks whether this rectangle completely contains the second specified rectangle.
      * @param {number} x the x coordinate of the second rectangle.
      * @param {number} y the y coordinate of the second rectangle.
      * @param {number} width the width coordinate of the second rectangle.
      * @param {number} height the height coordinate of the second rectangle.
      * @return {boolean} <code>true</code> if this rectangle contains the second one
      */
      containsRectangle(x:number,y:number,width:number,height:number):boolean;
      /**
      * Adds a point, specified by its coordinates, to this rectangle.
      * The rectangle will be grown if necessary. Note that for points that would lie on the right or bottom border of the rectangle,
      * {@link yfiles.algorithms.Rectangle2D#containsPoint} will still return <code>false</code> for the added point.
      * @param {number} px the x coordinate of the point to add
      * @param {number} py the y coordinate of the point to add
      */
      addCoordinates(px:number,py:number):void;
      /**
      * Adds a rectangle to this rectangle.
      * The rectangle will be grown to the union of both rectangles
      * @param {yfiles.algorithms.Rectangle2D} r the rectangle to add
      */
      add(r:yfiles.algorithms.Rectangle2D):void;
      hashCode():number;
      /**
      * Returns whether this rectangle and <code>obj</code> are equal.
      * Two rectangles are considered equal if the have the same location and size.
      * @param {Object} obj The object to test for equality
      * @return {boolean} <code>true</code> if both objects are equal.
      */
      equals(obj:Object):boolean;
      /**
      * Checks whether this rectangle completely contains the second specified rectangle.
      * @param {yfiles.algorithms.Rectangle2D} rect the rectangle to check for containment
      * @return {boolean} <code>true</code> if this rectangle contains the second one
      */
      containsRectangle2D(rect:yfiles.algorithms.Rectangle2D):boolean;
      /**
      * Checks whether this rectangle and the second specified rectangle intersect.
      * @param {yfiles.algorithms.Rectangle2D} rect the rectangle to check for intersection
      * @return {boolean} <code>true</code> if both rectangles intersect
      */
      intersectsRectangle(rect:yfiles.algorithms.Rectangle2D):boolean;
      /**
      * The x coordinate of the upper left corner.
      */
      x:number;
      /**
      * The y coordinate of the upper left corner.
      */
      y:number;
      /**
      * The width of this rectangle.
      */
      width:number;
      /**
      * The height of this rectangle.
      */
      height:number;
      /**
      * Specifies whether this instance is empty, i.e.
      * covers no area.
      */
      empty:boolean;
      /**
      * The smallest x coordinate of this rectangle.
      */
      minX:number;
      /**
      * The smallest y coordinate of this rectangle.
      */
      minY:number;
      /**
      * The largest x coordinate of this rectangle.
      */
      maxX:number;
      /**
      * The largest y coordinate of this rectangle.
      */
      maxY:number;
      /**
      * The x coordinate of the center point of this rectangle.
      */
      centerX:number;
      /**
      * The y coordinate of the center point of this rectangle.
      */
      centerY:number;
      toString():string;
      /**
      * Creates a new instance of this class that has the same values as this objects.
      * @return {Object} a new instance of this class that has the same values as this objects.
      * @see Specified by {@link yfiles.algorithms.ICloneable#clone}.
      */
      clone():Object;
    }
    export module Rectangle2D{
      /**
      * Concrete implementation of {@link yfiles.algorithms.Rectangle2D}.
      */
      export interface Double extends yfiles.algorithms.Rectangle2D{
        /**
        * Sets the location and size of this rectangle to the specified values.
        * @param {number} x the new x-coordinate of the upper left corner.
        * @param {number} y the new y-coordinate of the upper left corner.
        * @param {number} width the new width.
        * @param {number} height the new height.
        */
        setRect(x:number,y:number,width:number,height:number):void;
        /**
        * Sets the outer bounds of this rectangle based on the specified location and size.
        * @param {number} x the new x-coordinate of the upper left corner.
        * @param {number} y the new y-coordinate of the upper left corner.
        * @param {number} width the new width.
        * @param {number} height the new height.
        */
        setFrame(x:number,y:number,width:number,height:number):void;
        /**
        * The outer bounds of this rectangle in double coordinates.
        */
        frame:yfiles.algorithms.Rectangle2D;
        /**
        * Checks whether this rectangle and the second specified rectangle intersect.
        * @param {number} x the x coordinate of the second rectangle.
        * @param {number} y the y coordinate of the second rectangle.
        * @param {number} width the width coordinate of the second rectangle.
        * @param {number} height the height coordinate of the second rectangle.
        * @return {boolean} <code>true</code> if both rectangles intersect
        */
        intersectsRectangleCoordinates(x:number,y:number,width:number,height:number):boolean;
        /**
        * Calculates the intersection of this rectangle with the given rectangle and returns the result as new rectangle.
        * @param {yfiles.algorithms.Rectangle2D} r a rectangle to intersect with this rectangle.
        * @return {yfiles.algorithms.Rectangle2D} a new rectangle that represents the calculated intersection.
        */
        createIntersection(r:yfiles.algorithms.Rectangle2D):yfiles.algorithms.Rectangle2D;
        /**
        * Calculates the union of this rectangle with the given rectangle and returns the result as new rectangle.
        * @param {yfiles.algorithms.Rectangle2D} r a rectangle to union with this rectangle.
        * @return {yfiles.algorithms.Rectangle2D} a new rectangle that represents the calculated union.
        */
        createUnion(r:yfiles.algorithms.Rectangle2D):yfiles.algorithms.Rectangle2D;
        /**
        * The x coordinate of the upper left corner.
        */
        x:number;
        /**
        * The y coordinate of the upper left corner.
        */
        y:number;
        /**
        * The width of this rectangle.
        */
        width:number;
        /**
        * The height of this rectangle.
        */
        height:number;
        /**
        * Specifies whether this instance is empty, i.e.
        * covers no area.
        */
        empty:boolean;
        /**
        * The largest x coordinate of this rectangle.
        */
        maxX:number;
        /**
        * The largest y coordinate of this rectangle.
        */
        maxY:number;
        /**
        * The x coordinate of the center point of this rectangle.
        */
        centerX:number;
        /**
        * The y coordinate of the center point of this rectangle.
        */
        centerY:number;
        /**
        * The bounds of this instance in double precision.
        */
        bounds2D:yfiles.algorithms.Rectangle2D;
        /**
        * Creates and returns a copy of this object.
        * The precise meaning of "copy" may depend on the class of the object.
        * @see Specified by {@link yfiles.algorithms.ICloneable#clone}.
        */
        clone():Object;
        /**
        * @see Overrides {@link yfiles.algorithms.Rectangle2D#equals}
        */
        equals(obj:Object):boolean;
      }
    }
    var Rectangle2D:{
      $class:yfiles.lang.Class;
      Double:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new rectangle of the specified size at the specified location.
        * @param {number} x the x-coordinate of the upper left corner of the created rectangle.
        * @param {number} y the y-coordinate of the upper left corner of the created rectangle.
        * @param {number} width the width of the created rectangle.
        * @param {number} height the height of the created rectangle.
        */
        FromValues:{
          new (x:number,y:number,width:number,height:number):yfiles.algorithms.Rectangle2D;
        };
        /**
        * Creates a new rectangle of size <code>(0 x 0)</code> at the location <code>(0, 0)</code>.
        */
        new ():yfiles.algorithms.Rectangle2D;
      };
      /**
      * Cannot create instances of this abstract class.
      */
      new ():yfiles.algorithms.Rectangle2D;
      /**
      * Calculates the intersection of the first and second specified rectangle and sets the resulting location and size to
      * the third rectangle.
      * @param {yfiles.algorithms.Rectangle2D} src1 the first rectangle to intersect.
      * @param {yfiles.algorithms.Rectangle2D} src2 the second rectangle to intersect.
      * @param {yfiles.algorithms.Rectangle2D} dst the rectangle to which the result is set.
      */
      intersect(src1:yfiles.algorithms.Rectangle2D,src2:yfiles.algorithms.Rectangle2D,dst:yfiles.algorithms.Rectangle2D):void;
      /**
      * Calculates the union of the first and second specified rectangle and sets the resulting location and size to the
      * third rectangle.
      * @param {yfiles.algorithms.Rectangle2D} src1 the first rectangle to union.
      * @param {yfiles.algorithms.Rectangle2D} src2 the second rectangle to union.
      * @param {yfiles.algorithms.Rectangle2D} dst the rectangle to which the result is set.
      */
      union(src1:yfiles.algorithms.Rectangle2D,src2:yfiles.algorithms.Rectangle2D,dst:yfiles.algorithms.Rectangle2D):void;
    };
    /**
    * Double-precision immutable insets representation.
    */
    export interface Insets extends Object,yfiles.algorithms.ICloneable{
      /**
      * The inset from the top.
      */
      top:number;
      /**
      * The inset from the left.
      */
      left:number;
      /**
      * The inset from the bottom.
      */
      bottom:number;
      /**
      * The inset from the right.
      */
      right:number;
      hashCode():number;
      /**
      * Returns whether this insets object and <code>o</code> are equal.
      * Two insets are considered equal if the have the same values for each side.
      * @param {Object} o The object to test for equality
      * @return {boolean} <code>true</code> if both objects are equal.
      */
      equals(o:Object):boolean;
      /**
      * Creates and returns a copy of this object.
      * The precise meaning of "copy" may depend on the class of the object.
      * @see Specified by {@link yfiles.algorithms.ICloneable#clone}.
      */
      clone():Object;
      toString():string;
      /**
      * Assigns the given values to this instance.
      * @param {number} top The new top inset value
      * @param {number} left The new left inset value
      * @param {number} bottom The new bottom inset value
      * @param {number} right The new right inset value
      */
      set(top:number,left:number,bottom:number,right:number):void;
    }
    var Insets:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with the given values.
      * @param {number} top The new top inset value
      * @param {number} left The new left inset value
      * @param {number} bottom The new bottom inset value
      * @param {number} right The new right inset value
      */
      new (top:number,left:number,bottom:number,right:number):yfiles.algorithms.Insets;
    };
    /**
    * Represents a two-dimensional point located at <code>(x, y)</code>.
    */
    export interface Point2D extends Object,yfiles.algorithms.ICloneable{
      /**
      * Sets the location of this point to the given coordinates.
      * @param {number} x the new x coordinate
      * @param {number} y the new y coordinate
      */
      setLocation(x:number,y:number):void;
      /**
      * The location of this point to the same values as for the given point.
      */
      location:yfiles.algorithms.Point2D;
      toString():string;
      /**
      * Calculates the squared distance between this points and another one, given as its coordinates.
      * @param {number} px The x coordinate of the second point.
      * @param {number} py The y coordinate of the second point.
      * @return {number} the squared distance between this points and another one, given as its coordinates.
      */
      distanceSqToCoordinates(px:number,py:number):number;
      /**
      * Calculates the squared distance between this points and another one.
      * @param {yfiles.algorithms.Point2D} p The second point.
      * @return {number} the squared distance between this points and another one.
      */
      distanceSq(p:yfiles.algorithms.Point2D):number;
      /**
      * Calculates the distance between this points and another one, given as its coordinates.
      * @param {number} px The x coordinate of the second point.
      * @param {number} py The y coordinate of the second point.
      * @return {number} the distance between this points and another one, given as its coordinates.
      */
      distanceToCoordinates(px:number,py:number):number;
      /**
      * Calculates the distance between this points and another one.
      * @param {yfiles.algorithms.Point2D} p The second point.
      * @return {number} the distance between this points and another one.
      */
      distance(p:yfiles.algorithms.Point2D):number;
      hashCode():number;
      /**
      * Returns whether this point and <code>obj</code> are equal.
      * Two points are considered equal if the have the same location.
      * @param {Object} obj The object to test for equality
      * @return {boolean} <code>true</code> if both objects are equal.
      */
      equals(obj:Object):boolean;
      /**
      * The x coordinate of this point.
      */
      x:number;
      /**
      * The y coordinate of this point.
      */
      y:number;
      /**
      * Creates a new instance of this class that has the same values as this objects.
      * @return {Object} a new instance of this class that has the same values as this objects.
      * @see Specified by {@link yfiles.algorithms.ICloneable#clone}.
      */
      clone():Object;
    }
    export module Point2D{
      /**
      * Concrete implementation of {@link yfiles.algorithms.Point2D}.
      */
      export interface Double extends yfiles.algorithms.Point2D{
        /**
        * The x coordinate of this point.
        */
        x:number;
        /**
        * The y coordinate of this point.
        */
        y:number;
        /**
        * Creates and returns a copy of this object.
        * The precise meaning of "copy" may depend on the class of the object.
        * @see Specified by {@link yfiles.algorithms.ICloneable#clone}.
        */
        clone():Object;
        /**
        * Sets the location of this point to the given coordinates.
        * @param {number} x the new x coordinate
        * @param {number} y the new y coordinate
        */
        setLocation(x:number,y:number):void;
      }
    }
    var Point2D:{
      $class:yfiles.lang.Class;
      Double:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance at the given location.
        * @param {number} x The x coordinate of the new point
        * @param {number} y The x coordinate of the new point
        */
        FromValues:{
          new (x:number,y:number):yfiles.algorithms.Point2D;
        };
        /**
        * Creates a new instance that is located at <code>(0, 0)</code>.
        */
        new ():yfiles.algorithms.Point2D;
      };
      /**
      * Calculates the squared distance between two points, given as their coordinates.
      * @param {number} x1 The x coordinate of the first point.
      * @param {number} y1 The y coordinate of the first point.
      * @param {number} x2 The x coordinate of the second point.
      * @param {number} y2 The y coordinate of the second point.
      * @return {number} the squared distance between two points, given as their coordinates.
      */
      distanceSqBetween(x1:number,y1:number,x2:number,y2:number):number;
      /**
      * Calculates the distance between two points, given as their coordinates.
      * @param {number} x1 The x coordinate of the first point.
      * @param {number} y1 The y coordinate of the first point.
      * @param {number} x2 The x coordinate of the second point.
      * @param {number} y2 The y coordinate of the second point.
      * @return {number} the distance between two points, given as their coordinates.
      */
      distanceBetween(x1:number,y1:number,x2:number,y2:number):number;
    };
    /**
    * Represents a two-dimensional rectangle of size <code>(width x height)</code>,
    * located at the point <code>(x, y)</code>.
    */
    export interface Rectangle extends yfiles.algorithms.Rectangle2D{
      /**
      * Sets the upper left corner of this rectangle to the given values.
      * @param {number} x the x coordinate of the new location
      * @param {number} y the y coordinate of the new location
      */
      setLocation(x:number,y:number):void;
      /**
      * Sets the location and size of this rectangle to the specified values.
      * @param {number} x the new x-coordinate of the upper left corner.
      * @param {number} y the new y-coordinate of the upper left corner.
      * @param {number} width the new width.
      * @param {number} height the new height.
      */
      setRect(x:number,y:number,width:number,height:number):void;
      /**
      * Sets the location and size of this rectangle to the same values as in the given rectangle.
      * @param {yfiles.algorithms.Rectangle} r the rectangle where all values are taken from.
      */
      setBounds(r:yfiles.algorithms.Rectangle):void;
      /**
      * Sets the location and size of this rectangle to the specified values.
      * @param {number} x the new x-coordinate of the upper left corner.
      * @param {number} y the new y-coordinate of the upper left corner.
      * @param {number} width the new width.
      * @param {number} height the new height.
      */
      setBoundsCoordinates(x:number,y:number,width:number,height:number):void;
      /**
      * Enlarge this instance by the given amounts.
      * The rectangle will be resized by <code>dx</code> units on both the left and right side and <code>dy</code> units on both
      * the top and bottom side. For negative values of <code>dx</code> or <code>dy</code>, the rectangle will shrink accordingly.
      * @param {number} dx the enlargement in horizontal direction.
      * @param {number} dy the enlargement in vertical direction.
      */
      grow(dx:number,dy:number):void;
      /**
      * Moves the rectangle by the given amount in x resp.
      * y direction.
      * @param {number} mx The movement in x direction
      * @param {number} my The movement in y direction
      */
      translate(mx:number,my:number):void;
      /**
      * Adds a point, specified by its coordinates, to this rectangle.
      * The rectangle will be grown if necessary. Note that for points that would lie on the right or bottom border of the rectangle,
      * {@link yfiles.algorithms.Rectangle#containsIntCoordinates} will still return <code>false</code> for the added point.
      * @param {number} px the x coordinate of the point to add
      * @param {number} py the y coordinate of the point to add
      */
      addIntCoordinates(px:number,py:number):void;
      /**
      * Adds a rectangle to this rectangle.
      * The rectangle will be grown to the union of both rectangles
      * @param {yfiles.algorithms.Rectangle} r the rectangle to add
      */
      addRectangle(r:yfiles.algorithms.Rectangle):void;
      /**
      * Checks if the point specified by the given coordinates is contained in this rectangle.
      * @param {number} px the x-coordinate of the point.
      * @param {number} py the y-coordinate of the point.
      * @return {boolean} <code>true</code> if the specified point is contained in this rectangle; <code>false</code> otherwise.
      */
      containsIntCoordinates(px:number,py:number):boolean;
      /**
      * Checks whether this rectangle completely contains the second specified rectangle.
      * @param {number} rx the x coordinate of the second rectangle.
      * @param {number} ry the y coordinate of the second rectangle.
      * @param {number} rw the width coordinate of the second rectangle.
      * @param {number} rh the height coordinate of the second rectangle.
      * @return {boolean} <code>true</code> if this rectangle contains the second one
      */
      containsIntRectangle(rx:number,ry:number,rw:number,rh:number):boolean;
      /**
      * Checks whether this rectangle completely contains the second specified rectangle.
      * @param {yfiles.algorithms.Rectangle} r the rectangle to check for containment
      * @return {boolean} <code>true</code> if this rectangle contains the second one
      */
      contains(r:yfiles.algorithms.Rectangle):boolean;
      /**
      * Calculates the intersection of this rectangle with the given rectangle and returns the result as new rectangle.
      * @param {yfiles.algorithms.Rectangle2D} r a rectangle to intersect with this rectangle.
      * @return {yfiles.algorithms.Rectangle2D} a new rectangle that represents the calculated intersection.
      */
      createIntersection(r:yfiles.algorithms.Rectangle2D):yfiles.algorithms.Rectangle2D;
      /**
      * Calculates the intersection of this rectangle with the given rectangle and returns the result as new {@link yfiles.algorithms.Rectangle}.
      * @param {yfiles.algorithms.Rectangle} r a rectangle to intersect with this rectangle.
      * @return {yfiles.algorithms.Rectangle} a new rectangle that represents the calculated intersection.
      */
      intersection(r:yfiles.algorithms.Rectangle):yfiles.algorithms.Rectangle;
      /**
      * Checks whether this rectangle and the second specified rectangle intersect.
      * @param {yfiles.algorithms.Rectangle} r the second rectangle.
      * @return {boolean} <code>true</code> if both rectangles intersect
      */
      intersects(r:yfiles.algorithms.Rectangle):boolean;
      /**
      * Calculates the union of this rectangle with the given rectangle and returns the result as new rectangle.
      * @param {yfiles.algorithms.Rectangle2D} r a rectangle to union with this rectangle.
      * @return {yfiles.algorithms.Rectangle2D} a new rectangle that represents the calculated union.
      */
      createUnion(r:yfiles.algorithms.Rectangle2D):yfiles.algorithms.Rectangle2D;
      /**
      * Calculates the union of this rectangle with the given rectangle and returns the result as new {@link yfiles.algorithms.Rectangle}.
      * @param {yfiles.algorithms.Rectangle} r a rectangle to union with this rectangle.
      * @return {yfiles.algorithms.Rectangle} a new rectangle that represents the calculated union.
      */
      union(r:yfiles.algorithms.Rectangle):yfiles.algorithms.Rectangle;
      /**
      * @see Overrides {@link yfiles.algorithms.Rectangle2D#equals}
      */
      equals(obj:Object):boolean;
      /**
      * The x coordinate of the upper left corner.
      */
      x:number;
      /**
      * The y coordinate of the upper left corner.
      */
      y:number;
      /**
      * The height of this rectangle.
      */
      height:number;
      /**
      * The width of this rectangle.
      */
      width:number;
      /**
      * Specifies whether this instance is empty, i.e.
      * covers no area.
      */
      empty:boolean;
      /**
      * The bounds of this rectangle as a new{@link yfiles.algorithms.Rectangle} instance.
      */
      bounds:yfiles.algorithms.Rectangle;
      /**
      * The bounds of this rectangle as a new{@link yfiles.algorithms.Rectangle2D} instance.
      */
      bounds2D:yfiles.algorithms.Rectangle2D;
      /**
      * Creates and returns a copy of this object.
      * The precise meaning of "copy" may depend on the class of the object.
      * @see Specified by {@link yfiles.algorithms.ICloneable#clone}.
      */
      clone():Object;
    }
    var Rectangle:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with the given location and dimensions.
      * @param {number} x the x coordinate of the upper left corner of the new rectangle
      * @param {number} y the y coordinate of the upper left corner of the new rectangle
      * @param {number} height the height of the new rectangle
      * @param {number} width the width of the new rectangle
      */
      FromValues:{
        new (x:number,y:number,width:number,height:number):yfiles.algorithms.Rectangle;
      };
      /**
      * Creates a new instance located at the coordinate system origin with the given dimensions.
      * @param {number} height the height of the new rectangle
      * @param {number} width the width of the new rectangle
      */
      FromWidthAndHeight:{
        new (width:number,height:number):yfiles.algorithms.Rectangle;
      };
      /**
      * Creates a new instance with the same values as in the given rectangle.
      * @param {yfiles.algorithms.Rectangle} r The rectangle whose values are used for the initialization
      */
      FromRectangle:{
        new (r:yfiles.algorithms.Rectangle):yfiles.algorithms.Rectangle;
      };
      /**
      * Creates a new empty instance located at the coordinate system origin.
      */
      new ():yfiles.algorithms.Rectangle;
    };
    /**
    * A class implements the Cloneable interface to indicate to the {@link yfiles.algorithms.ICloneable#clone} method that it is legal for that method to make a field-for-field copy of instances of that class.
    */
    export interface ICloneable extends Object{
      /**
      * Creates and returns a copy of this object.
      * The precise meaning of "copy" may depend on the class of the object.
      * @see Specified by {@link yfiles.algorithms.ICloneable#clone}.
      */
      clone():Object;
    }
    var ICloneable:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Iterates over a list of items either forwards or backwards.
    * <p>
    * Also allows to insert items into the list at the current
    * position.
    * </p>
    * <p>
    * The cursor can be regarded as being located between two list items. There
    * is no current, but only a next and a previous item.
    * </p>
    */
    export interface IListIterator extends Object,yfiles.algorithms.IIterator{
      /**
      * Adds an item to the list next to the current cursor position.
      * @param {Object} o the item to be added.
      * @see Specified by {@link yfiles.algorithms.IListIterator#add}.
      */
      add(o:Object):void;
      /**
      * Checks if there is an item before the current cursor position.
      * @see Specified by {@link yfiles.algorithms.IListIterator#hasPrevious}.
      */
      hasPrevious:boolean;
      /**
      * Gets the index of the next element.
      * @return {number} 
      * the index of the next element, or the size of the list if there is
      * no next item.
      * @see Specified by {@link yfiles.algorithms.IListIterator#nextIndex}.
      */
      nextIndex():number;
      /**
      * Get the element before the current cursor position.
      * @return {Object} the element before the current cursor position.
      * @see Specified by {@link yfiles.algorithms.IListIterator#previous}.
      */
      previous():Object;
      /**
      * Gets the index of the previous element.
      * @return {number} 
      * the index of the previous element, or -1 if there is
      * no previous item.
      * @see Specified by {@link yfiles.algorithms.IListIterator#previousIndex}.
      */
      previousIndex():number;
      /**
      * Assigns the specified object to the index of the element that was last
      * returned by <code>next()</code> or <code>previous()</code>.
      * The item
      * previously at this position is replaced.
      * @param {Object} o the item which to set at the index of the last item.
      * @see Specified by {@link yfiles.algorithms.IListIterator#set}.
      */
      set(o:Object):void;
    }
    var IListIterator:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * An interface for objects that store associations between <i>keys</i> and <i>values</i>.
    * <p>
    * Maps are also known as <i>dictionaries</i> or <i>associative arrays</i> and map each element in the {@link yfiles.algorithms.IMap#keySet} collection
    * to exactly one element in the {@link yfiles.algorithms.IMap#values} collection (which may be  <code>null</code>). Each key-value pair is represented by
    * an instance of {@link yfiles.algorithms.IMapEntry}. The set of all key-value pairs can be accessed through the {@link yfiles.algorithms.IMap#entrySet} collection.
    * </p>
    * <p>
    * This interface does not impose restrictions on the <i>order</i> of the entries and on the
    * type of either keys or values. Concrete implementations may thus allow or disallow <code>null</code> keys or impose a specific order of the entries.
    * </p>
    * <p>
    * Note that the behavior is undefined if you use mutable objects as keys and change them in a way that affects equality comparisons
    * with other keys as long as the object is used as key in the map.
    * </p>
    */
    export interface IMap extends Object{
      /**
      * Returns the number of entries in this map.
      * @return {number} The number of entries in this map.
      * @see Specified by {@link yfiles.algorithms.IMap#size}.
      */
      size():number;
      /**
      * <code>true</code> iff this map does not contain any entries.
      * @see Specified by {@link yfiles.algorithms.IMap#empty}.
      */
      empty:boolean;
      /**
      * Returns <code>true</code> if the given object is currently mapped to a (possibly <code>null</code>) value.
      * @param {Object} key The object whose use as a key is checked.
      * @return {boolean} <code>true</code> if <code>key</code> is currently mapped to a value.
      * @see Specified by {@link yfiles.algorithms.IMap#containsKey}.
      */
      containsKey(key:Object):boolean;
      /**
      * Returns <code>true</code> if the given object is currently associated to at least one key.
      * @param {Object} value The object whose use as a key is checked.
      * @return {boolean} <code>true</code> if <code>value</code> is currently associated to at least one key.
      * @see Specified by {@link yfiles.algorithms.IMap#containsValue}.
      */
      containsValue(value:Object):boolean;
      /**
      * Retrieves the value that <code>key</code> maps to.
      * If no mapping for <code>key</code> exists, this method returns <code>null</code>. A <code>null</code> return value
      * may also occur if <code>key</code> has been explicitly mapped to <code>null</code>. To check whether a mapping for the key exists
      * at all, use the {@link yfiles.algorithms.IMap#containsKey} method instead.
      * @param {Object} key The key object for which the mapped value is requested.
      * @return {Object} The value to which the specified key is mapped, or <code>null</code> if no such mapping exists.
      * @see Specified by {@link yfiles.algorithms.IMap#get}.
      */
      get(key:Object):Object;
      /**
      * Maps <code>key</code> to <code>value</code>.
      * An existing mapping for <code>key</code> will be replaced. Implementations may impose additional restrictions
      * on the type or value of <code>key</code>.
      * @param {Object} key The key that maps to <code>value</code>.
      * @param {Object} value The value that is associated to <code>key</code>.
      * @return {Object} The previous value associated with <code>key</code>, or <code>null</code> if no previous mapping existed.
      * @see Specified by {@link yfiles.algorithms.IMap#put}.
      */
      put(key:Object,value:Object):Object;
      /**
      * Removes the mapping from <code>key</code> to its associated value.
      * <code>key</code> need not be present as an actual key in this map, in which case the map is not modified.
      * @param {Object} key The key whose mapping should be removed.
      * @return {Object} The previous value associated with <code>key</code>, or <code>null</code> if no previous mapping existed.
      * @see Specified by {@link yfiles.algorithms.IMap#remove}.
      */
      remove(key:Object):Object;
      /**
      * Inserts all mappings in <code>t</code> into this map.
      * @param {yfiles.algorithms.IMap} t The map whose mappings should be copied.
      * @see Specified by {@link yfiles.algorithms.IMap#putAll}.
      */
      putAll(t:yfiles.algorithms.IMap):void;
      /**
      * Clears all mappings from this instance.
      * @see Specified by {@link yfiles.algorithms.IMap#clear}.
      */
      clear():void;
      /**
      * The {@link yfiles.algorithms.ISet} of all keys in this map.
      * <p>
      * This is a live view on the map keys in the sense that
      * changes in the map are automatically reflected in this collection and vice-versa.
      * </p>
      * <p>
      * Note that modifications on the map instance while iterating over the set are not supported (i.e. the behavior is undefined)
      * </p>
      * @return {yfiles.algorithms.ISet} The set of keys in this instance.
      * @see Specified by {@link yfiles.algorithms.IMap#keySet}.
      */
      keySet():yfiles.algorithms.ISet;
      /**
      * The {@link yfiles.algorithms.ICollection} of all values in this map.
      * <p>
      * This is a live view on the map values in the sense that
      * changes in the map are automatically reflected in this collection and vice-versa. This collection may contain duplicate entries
      * if a value is associated with more than one key.
      * </p>
      * <p>
      * Note that modifications on the map instance while iterating over the set are not supported (i.e. the behavior is undefined)
      * </p>
      * @return {yfiles.algorithms.ICollection} The collection of values in this instance.
      * @see Specified by {@link yfiles.algorithms.IMap#values}.
      */
      values():yfiles.algorithms.ICollection;
      /**
      * The {@link yfiles.algorithms.ISet} of all key-value mappings in this map.
      * <p>
      * The entries are of type {@link yfiles.algorithms.IMapEntry}. This is a live view on the map entries in the sense that
      * changes in the map are automatically reflected in this collection and vice-versa.
      * </p>
      * <p>
      * Note that modifications on the map instance while iterating over the set are not supported (i.e. the behavior is undefined)
      * </p>
      * @return {yfiles.algorithms.ISet} The set of key-value mappings in this instance.
      * @see Specified by {@link yfiles.algorithms.IMap#entrySet}.
      */
      entrySet():yfiles.algorithms.ISet;
      /**
      * Returns whether <code>o</code> is equal to this instance.
      * <code>o</code> and this instance are considered equal when <code>o</code>
      * is also a <code>Map</code> and both {@link yfiles.algorithms.IMap#entrySet}s are equal.
      * @param {Object} o The object that is compared for equality with this instance
      * @return {boolean} <code>true</code> when both objects are equal.
      * @see Specified by {@link yfiles.algorithms.IMap#equals}.
      */
      equals(o:Object):boolean;
      /**
      * Returns the hash code for this map instance.
      * @return {number} The hash code for this map instance.
      * @see Specified by {@link yfiles.algorithms.IMap#hashCode}.
      */
      hashCode():number;
    }
    var IMap:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * The representation of a key-value mapping in a {@link yfiles.algorithms.IMap}.
    * Instances of this interface are returned in the {@link yfiles.algorithms.IMap#entrySet} set. These instances may be invalidated
    * if the underlying map is modified. Therefore, it is only safe to use these objects during an iteration that does not modify the
    * map.
    */
    export interface IMapEntry extends Object{
      /**
      * Checks for equality between this object and <code>o</code>.
      * @param {Object} o The object that is checked for equality.
      * @return {boolean} <code>true</code> iff <code>o</code> and this instance are equal.
      * @see Specified by {@link yfiles.algorithms.IMapEntry#equals}.
      */
      equals(o:Object):boolean;
      /**
      * The key stored in this entry.
      * If the mapping has been removed on the underlying map instance, the behavior is undefined.
      * @see Specified by {@link yfiles.algorithms.IMapEntry#key}.
      */
      key:Object;
      /**
      * The value stored in this entry.
      * If the mapping has been removed on the underlying map instance, the behavior is undefined.
      * @see Specified by {@link yfiles.algorithms.IMapEntry#value}.
      */
      value:Object;
      /**
      * Returns the hash code for this instance.
      * @return {number} The hash code for this instance.
      * @see Specified by {@link yfiles.algorithms.IMapEntry#hashCode}.
      */
      hashCode():number;
      /**
      * Changes the value associated with this entry.
      * This is a live operation on the underlying map. If the mapping for the <code>key</code> has been removed
      * on the underlying map instance, the behavior is undefined.
      * @param {Object} value The value that should be associated to the <code>key</code> of this entry.
      * @return {Object} The value previously associated to the <code>key</code> of this entry.
      * @see Specified by {@link yfiles.algorithms.IMapEntry#setValue}.
      */
      setValue(value:Object):Object;
    }
    var IMapEntry:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * The basic interface in the hierarchy of collection classes.
    * <p>
    * A collection contains a number of items. These may or may not be in a
    * specific order. The collection may or may not contain duplicate items.
    * </p>
    * <p>
    * A collection allows adding and removing single as well as whole
    * collections of items.
    * </p>
    */
    export interface ICollection extends Object,yfiles.collections.ICollection<Object>{
      /**
      * Adds the given item to this collection.
      * @param {Object} o the object to add to the collection
      * @return {boolean} <code>true</code> if this collection has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.ICollection#addObject}.
      */
      addObject(o:Object):boolean;
      /**
      * Adds all items of the given collection to this collection.
      * @param {yfiles.algorithms.ICollection} c the collection which items should be added to this collection.
      * @return {boolean} <code>true</code> if this collection has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.ICollection#addAll}.
      */
      addAll(c:yfiles.algorithms.ICollection):boolean;
      /**
      * Removes all items in this collection.
      * @see Specified by {@link yfiles.algorithms.ICollection#clear}.
      */
      clear():void;
      /**
      * Checks if this collection contains the given item.
      * @param {Object} o the item to check.
      * @return {boolean} <code>true</code> if this collection contains the given item.
      * @see Specified by {@link yfiles.algorithms.ICollection#contains}.
      */
      contains(o:Object):boolean;
      /**
      * Checks if this collection contains all the items of the given collection.
      * @param {yfiles.algorithms.ICollection} c the collection that contains the items to check.
      * @return {boolean} <code>true</code> if this collection contains all the items of the given collection.
      * @see Specified by {@link yfiles.algorithms.ICollection#containsAll}.
      */
      containsAll(c:yfiles.algorithms.ICollection):boolean;
      /**
      * Checks if this collection is equal to the given object.
      * @param {Object} o the object to check equality with.
      * @return {boolean} <code>true</code> if this collection is equal to the given object.
      * @see Specified by {@link yfiles.algorithms.ICollection#equals}.
      */
      equals(o:Object):boolean;
      /**
      * Gets the hash code of this collection.
      * @return {number} the hash code of this collection.
      * @see Specified by {@link yfiles.algorithms.ICollection#hashCode}.
      */
      hashCode():number;
      /**
      * Checks if this collection is empty.
      * @see Specified by {@link yfiles.algorithms.ICollection#empty}.
      */
      empty:boolean;
      /**
      * Gets an iterator for the items of this collection.
      * @return {yfiles.algorithms.IIterator} an iterator for the items of this collection.
      * @see Specified by {@link yfiles.algorithms.ICollection#iterator}.
      */
      iterator():yfiles.algorithms.IIterator;
      /**
      * Removes the given item from this collection.
      * @param {Object} o the item to remove from the collection.
      * @return {boolean} <code>true</code> if this collection has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.ICollection#remove}.
      */
      remove(o:Object):boolean;
      /**
      * Removes all items of the given collection from this collection.
      * @param {yfiles.algorithms.ICollection} c the collection which items should be removed from this collection.
      * @return {boolean} <code>true</code> if this collection has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.ICollection#removeAll}.
      */
      removeAll(c:yfiles.algorithms.ICollection):boolean;
      /**
      * Keeps all the items in this collection that are contained in the given collection.
      * items that are not part of the given collection are removed.
      * @param {yfiles.algorithms.ICollection} c The collection that contains the items that should be retained.
      * @return {boolean} <code>true</code> if this collection has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.ICollection#retainAll}.
      */
      retainAll(c:yfiles.algorithms.ICollection):boolean;
      /**
      * The number of elements in this collection.
      * @see Specified by {@link yfiles.algorithms.ICollection#count}.
      */
      count:number;
      /**
      * Creates an array containing the items of this collection.
      * @return {Object[]} a new array with the items of this collection.
      * @see Specified by {@link yfiles.algorithms.ICollection#toArray}.
      */
      toArray():Object[];
      /**
      * Copies the content of this collection to an array.
      * If an array is given and it is large enough, the given array is
      * used to copy the content to. Otherwise, a new array is created.
      * If the given array is larger than this collection, the first array element after the content is set to null.
      * @param {Object} a an optional array to use.
      * @return {Object} an array with the same content as this collection.
      * @see Specified by {@link yfiles.algorithms.ICollection#toGivenArray}.
      */
      toGivenArray(a:Object):Object;
    }
    var ICollection:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * An iterator over the items of a collection.
    * <p>
    * Iterators allow to iterate over the items of a collection one-by-one as
    * well as remove the item last iterated over from the list.
    * </p>
    */
    export interface IIterator extends Object{
      /**
      * Checks if there is another item in the collection.
      * @see Specified by {@link yfiles.algorithms.IIterator#hasNext}.
      */
      hasNext:boolean;
      /**
      * Gets the next item in the collection.
      * @return {Object} the next item in the collection.
      * @see Specified by {@link yfiles.algorithms.IIterator#next}.
      */
      next():Object;
      /**
      * Returns from the collection the last element returned by <code>next()</code>.
      * @see Specified by {@link yfiles.algorithms.IIterator#remove}.
      */
      remove():void;
    }
    var IIterator:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * An ordered collection of items.
    * <p>
    * Items can be appended as well as inserted at a specific index. Also, items
    * can be retrieved or removed from the list at a certain position using an
    * integer index.
    * </p>
    * <p>
    * A list, unlike a set, can contain the same item more than once at distinct
    * positions.
    * </p>
    */
    export interface IList extends Object,yfiles.algorithms.ICollection,yfiles.collections.IList<Object>{
      /**
      * Appends the given item at the end of the list.
      * @param {Object} o the object to add
      * @return {boolean} <code>true</code> if this list has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.IList#addObject}.
      */
      addObject(o:Object):boolean;
      /**
      * Appends all items of the given collection at the end of this list.
      * @param {yfiles.algorithms.ICollection} c the collection which items should be added.
      * @return {boolean} <code>true</code> if this list has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.IList#addAll}.
      */
      addAll(c:yfiles.algorithms.ICollection):boolean;
      /**
      * Adds the given object to the collection at the specified index.
      * <p>
      * All subsequent items are shifted to the right one step.
      * </p>
      * @param {number} index the index at which to insert the item
      * @param {Object} item the item to insert
      * @see Specified by {@link yfiles.algorithms.IList#addAt}.
      */
      addAt(index:number,item:Object):void;
      /**
      * Adds all items of the given collection at the specified index.
      * <p>
      * All subsequent items are shifted to the right by the number of items added.
      * </p>
      * @param {number} index the index at which to insert the items.
      * @param {yfiles.algorithms.ICollection} c the collection whose items will be added.
      * @return {boolean} <code>true</code> if this list has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.IList#addAllAt}.
      */
      addAllAt(index:number,c:yfiles.algorithms.ICollection):boolean;
      /**
      * Returns the item at the specified index.
      * @param {number} index the index of the item that is retrieved.
      * @return {Object} the item at the specified index.
      * @see Specified by {@link yfiles.algorithms.IList#getAtListIndex}.
      */
      getAtListIndex(index:number):Object;
      /**
      * Returns the index of first occurrence of the specified item in this list,
      * or -1 if the list does not contain the object.
      * @param {Object} o the item whose index is being returned.
      * @return {number} the index of the specified item, or -1.
      * @see Specified by {@link yfiles.algorithms.IList#indexOf}.
      */
      indexOf(o:Object):number;
      /**
      * Returns the index of the last occurrence of the specified item in this list,
      * or -1 if the list does not contain the object.
      * @param {Object} o the item whose last index is being returned.
      * @return {number} the index of last occurrence of the specified item, or -1.
      * @see Specified by {@link yfiles.algorithms.IList#lastIndexOf}.
      */
      lastIndexOf(o:Object):number;
      /**
      * Returns a list iterator that can be used to iterate over all items of this list
      * in correct order.
      * @return {yfiles.algorithms.IListIterator} a list iterator that iterates over the items of this list.
      * @see Specified by {@link yfiles.algorithms.IList#listIterator}.
      */
      listIterator():yfiles.algorithms.IListIterator;
      /**
      * Returns a list iterator that can be used to iterate over all items of this list
      * in correct order.
      * The iteration starts at the specified index.
      * @param {number} index the index at which to start the iteration.
      * @return {yfiles.algorithms.IListIterator} 
      * a list iterator that iterates over the items of this list, starting at the
      * specified index.
      * @see Specified by {@link yfiles.algorithms.IList#listIteratorFrom}.
      */
      listIteratorFrom(index:number):yfiles.algorithms.IListIterator;
      /**
      * Removes the first occurrence of the given item from this list.
      * @param {Object} o the item to remove.
      * @return {boolean} <code>true</code> if this collection has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.IList#remove}.
      */
      remove(o:Object):boolean;
      /**
      * Removes all items of the given collection from this list.
      * @param {yfiles.algorithms.ICollection} c the collection which items should be removed from this collection.
      * @return {boolean} <code>true</code> if this collection has been modified due to the call of this method.
      * @see Specified by {@link yfiles.algorithms.IList#removeAll}.
      */
      removeAll(c:yfiles.algorithms.ICollection):boolean;
      /**
      * Removes the object at the specified index.
      * <p>
      * All subsequent list items are shifted to the left by one step.
      * </p>
      * @param {number} index the index of the item to be removed.
      * @return {Object} the object previously at the specified position
      * @see Specified by {@link yfiles.algorithms.IList#removeAtIndex}.
      */
      removeAtIndex(index:number):Object;
      /**
      * Replaces the item at the specified index with the given item.
      * @param {number} index the index at which to replace the item.
      * @param {Object} item the item which should be set at the specified index.
      * @return {Object} the item that was previously at the specified index.
      * @see Specified by {@link yfiles.algorithms.IList#setAtListIndex}.
      */
      setAtListIndex(index:number,item:Object):Object;
      /**
      * Returns a list that contains the specified range of items in this list.
      * @param {number} fromIndex the index of the item that is the first element of the returned list.
      * @param {number} toIndex 
      * the end index the returned list. The item at this index is not included
      * in the returned list.
      * @return {yfiles.algorithms.IList} a list that contains the items of this list in the specified range.
      * @see Specified by {@link yfiles.algorithms.IList#subList}.
      */
      subList(fromIndex:number,toIndex:number):yfiles.algorithms.IList;
      /**
      * Clears this collection and makes it empty.
      * @see Specified by {@link yfiles.algorithms.IList#clear}.
      */
      clear():void;
      /**
      * Determines whether the provided object is part of this collection.
      * @param {Object} o The instance to check.
      * @see Specified by {@link yfiles.algorithms.IList#contains}.
      */
      contains(o:Object):boolean;
      /**
      * Yields the number of items in this collection.
      * @see Specified by {@link yfiles.algorithms.IList#count}.
      */
      count:number;
      isFixedSize:boolean;
    }
    var IList:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * A factory class that creates instances of the classes implementing
    * {@link yfiles.algorithms.IMap}.
    */
    export interface MapFactory extends Object{
    }
    var MapFactory:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new {@link yfiles.algorithms.HashMap}.
      * @return {yfiles.algorithms.IMap} 
      * a new instance of {@link yfiles.algorithms.HashMap}.
      */
      createHashMap():yfiles.algorithms.IMap;
      /**
      * Creates a new {@link yfiles.algorithms.HashMap} with the contents of the specified
      * {@link yfiles.algorithms.IMap}.
      * @return {yfiles.algorithms.IMap} 
      * a new instance of {@link yfiles.algorithms.HashMap}.
      */
      createHashMapFromMap(m:yfiles.algorithms.IMap):yfiles.algorithms.IMap;
      /**
      * Creates a new {@link yfiles.algorithms.TreeMap}.
      * @return {yfiles.algorithms.IMap} 
      * a new instance of {@link yfiles.algorithms.TreeMap}.
      */
      createTreeMap():yfiles.algorithms.IMap;
      /**
      * Creates a new {@link yfiles.algorithms.TreeMap} with the contents of the specified
      * {@link yfiles.algorithms.IMap}.
      * @return {yfiles.algorithms.IMap} 
      * a new instance of {@link yfiles.algorithms.TreeMap}.
      */
      createTreeMapFromMap(m:yfiles.algorithms.IMap):yfiles.algorithms.IMap;
      /**
      * Creates a new {@link yfiles.algorithms.TreeMap} with the specified
      * {@link yfiles.objectcollections.IComparer}.
      * @return {yfiles.algorithms.IMap} 
      * a new instance of {@link yfiles.algorithms.TreeMap}.
      */
      createTreeMapWithComparator(comparator:yfiles.objectcollections.IComparer):yfiles.algorithms.IMap;
    };
    /**
    * This class provides methods to generate pseudo-random numbers.
    */
    export interface Random extends Object{
      /**
      * Returns a pseudo-random uniformly distributed integer value of
      * the number of bits specified by the argument <code>bits</code>.
      * @param {number} bits The number of bits of the returned value.
      * @return {number} A random integer.
      */
      next(bits:number):number;
      /**
      * Returns the next pseudo-random uniformly distributed boolean value.
      * @return {boolean} A random boolean value.
      */
      nextBoolean():boolean;
      /**
      * Returns the next pseudo-random uniformly distributed random number between 0.0
      * inclusively and 1.0 exclusively.
      * @return {number} A random number between 0.0 and 1.0.
      * @see {@link yfiles.algorithms.Random#nextFloat}
      */
      nextDouble():number;
      /**
      * Returns the next pseudo-random uniformly distributed random number between 0.0
      * inclusively and 1.0 exclusively.
      * @return {number} A random number between 0.0 and 1.0.
      * @see {@link yfiles.algorithms.Random#nextDouble}
      */
      nextFloat():number;
      /**
      * Returns the next pseudo-random normally distributed
      * number with mean 0.0 and a standard deviation value
      * of <code>1.0</code>.
      * Implements G. E. P. Box, M. E. Muller, and G. Marsaglia's polar method
      * found in <i>The Art of Computer Programming, Volume 2: Seminumerical
      * Algorithms</i>, by Donald E. Knuth (section 3.4.1).
      * @return {number} A random, normally distributed number.
      * @see {@link yfiles.algorithms.Random#nextDouble}
      */
      nextGaussian():number;
      /**
      * Returns the next pseudo-random uniformly distributed integer.
      * @return {number} A random integer.
      * @see {@link yfiles.algorithms.Random#nextIntInRange}
      * @see {@link yfiles.algorithms.Random#nextLong}
      */
      nextInt():number;
      /**
      * Returns the next pseudo-random uniformly distributed integer
      * between 0 (inclusively) and <code>n</code> (exclusively).
      * @param {number} n The upper limit of the returned random integer.
      * @return {number} A random integer between 0 and <code>n</code>
      */
      nextIntInRange(n:number):number;
      nextIntImpl():number;
      nextIntInRangeImpl(max:number):number;
      /**
      * Returns the next pseudo-random uniformly distributed integer.
      * @return {number} A random integer.
      * @see {@link yfiles.algorithms.Random#nextInt}
      * @see {@link yfiles.algorithms.Random#nextIntInRange}
      */
      nextLong():number;
      /**
      * The seed of this random number generator.
      */
      seed:number;
    }
    var Random:{
      $class:yfiles.lang.Class;
      /**
      * Constructs a random generator with a seed based on the current time of day.
      * @see {@link yfiles.algorithms.Random#seed}
      */
      new ():yfiles.algorithms.Random;
      /**
      * Construct a random generator with the given <code>seed</code>.
      * @param {number} seed 
      * The seed of this random number generator.
      * @see {@link yfiles.algorithms.Random#seed}
      */
      WithSeed:{
        new (seed:number):yfiles.algorithms.Random;
      };
    };
    /**
    * An interface for collections that contain no duplicates.
    * <p>
    * For each pair of elements <code>e1</code> and <code>e2</code> in a set, <code>e1.equals(e2)</code> is always <code>false</code>.
    * In addition, the {@link yfiles.algorithms.ICollection#addObject} and {@link yfiles.algorithms.ICollection#addAll} methods do not insert objects that are already
    * present in the set (again, according to the <code>equals</code> method of the entries).
    * </p>
    * <p>
    * This interface does not impose restrictions on the <i>order</i> or the type of the entries.
    * Concrete implementations may thus allow or disallow <code>null</code> entries or impose a specific order of the entries.
    * </p>
    * <p>
    * Note that the behavior is undefined if you use mutable objects as entries and change them in a way that affects equality comparisons
    * with other entries as long as the object is stored in the set.
    * </p>
    */
    export interface ISet extends Object,yfiles.algorithms.ICollection{
    }
    var ISet:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This class provides convenience and transformation services for Node- and EdgeMaps.
    */
    export interface Maps extends Object{
    }
    export module Maps{
      /**
      * Implementation of a resettable high performance map for values of type <code>Object</code>.
      * A high performance map is a facade to another map which will allow to reset
      * all bound values to a default value in constant time.
      */
      export interface HighPerformanceObjectMap extends Object,yfiles.algorithms.INodeMap,yfiles.algorithms.IEdgeMap{
        /**
        * Resets all values to the given default value in constant time.
        * @param {Object} defaultValue the new default value
        */
        resetAll(defaultValue:Object):void;
        /**
        * Returns the value bound to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#get}.
        */
        get(dataHolder:Object):Object;
        /**
        * Associates the given value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#set}.
        */
        set(dataHolder:Object,value:Object):void;
        /**
        * Returns the boolean value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setBool  setBool}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getBool}.
        */
        getBool(dataHolder:Object):boolean;
        /**
        * Returns the double value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setDouble  setDouble}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getDouble}.
        */
        getDouble(dataHolder:Object):number;
        /**
        * Returns the integer value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setInt  setInt}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getInt}.
        */
        getInt(dataHolder:Object):number;
        /**
        * Associates the given boolean value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setBool}.
        */
        setBool(dataHolder:Object,value:boolean):void;
        /**
        * Associates the given double value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setDouble}.
        */
        setDouble(dataHolder:Object,value:number):void;
        /**
        * Associates the given integer value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setInt}.
        */
        setInt(dataHolder:Object,value:number):void;
      }
      /**
      * Implementation of a resettable high performance map for values of simple type <code>double</code>.
      * A high performance map is a facade to another map which will allow to reset
      * all bound values to a default value in constant time.
      */
      export interface HighPerformanceDoubleMap extends Object,yfiles.algorithms.INodeMap,yfiles.algorithms.IEdgeMap{
        /**
        * Resets all values to the given default value in constant time.
        * @param {number} defaultValue the new default value
        */
        resetAll(defaultValue:number):void;
        /**
        * Returns the value bound to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#get}.
        */
        get(dataHolder:Object):Object;
        /**
        * Associates the given value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#set}.
        */
        set(dataHolder:Object,value:Object):void;
        /**
        * Returns the boolean value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setBool  setBool}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getBool}.
        */
        getBool(dataHolder:Object):boolean;
        /**
        * Returns the double value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setDouble  setDouble}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getDouble}.
        */
        getDouble(dataHolder:Object):number;
        /**
        * Returns the integer value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setInt  setInt}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getInt}.
        */
        getInt(dataHolder:Object):number;
        /**
        * Associates the given boolean value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setBool}.
        */
        setBool(dataHolder:Object,value:boolean):void;
        /**
        * Associates the given double value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setDouble}.
        */
        setDouble(dataHolder:Object,value:number):void;
        /**
        * Associates the given integer value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setInt}.
        */
        setInt(dataHolder:Object,value:number):void;
      }
      /**
      * Implementation of a resettable high performance map for values of simple type <code>int</code>.
      * A high performance map is a facade to another map which will allow to reset
      * all bound values to a default value in constant time.
      */
      export interface HighPerformanceIntMap extends Object,yfiles.algorithms.INodeMap,yfiles.algorithms.IEdgeMap{
        /**
        * Resets all values to the given default value in constant time.
        * @param {number} defaultValue the new default value
        */
        resetAll(defaultValue:number):void;
        /**
        * Returns the value bound to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#get}.
        */
        get(dataHolder:Object):Object;
        /**
        * Associates the given value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#set}.
        */
        set(dataHolder:Object,value:Object):void;
        /**
        * Returns the boolean value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setBool  setBool}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getBool}.
        */
        getBool(dataHolder:Object):boolean;
        /**
        * Returns the double value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setDouble  setDouble}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getDouble}.
        */
        getDouble(dataHolder:Object):number;
        /**
        * Returns the integer value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setInt  setInt}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getInt}.
        */
        getInt(dataHolder:Object):number;
        /**
        * Associates the given boolean value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setBool}.
        */
        setBool(dataHolder:Object,value:boolean):void;
        /**
        * Associates the given double value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setDouble}.
        */
        setDouble(dataHolder:Object,value:number):void;
        /**
        * Associates the given integer value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setInt}.
        */
        setInt(dataHolder:Object,value:number):void;
      }
      /**
      * Implementation of a resettable high performance map for values of simple type <code>boolean</code>.
      * A high performance map is a facade to another map which will allow to reset
      * all bound values to a default value in constant time.
      */
      export interface HighPerformanceBoolMap extends Object,yfiles.algorithms.INodeMap,yfiles.algorithms.IEdgeMap{
        /**
        * Resets all values to the given default value in constant time.
        * @param {boolean} defaultValue the new default value
        */
        resetAll(defaultValue:boolean):void;
        /**
        * Returns the value bound to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#get}.
        */
        get(dataHolder:Object):Object;
        /**
        * Associates the given value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#set}.
        */
        set(dataHolder:Object,value:Object):void;
        /**
        * Returns the boolean value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setBool  setBool}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getBool}.
        */
        getBool(dataHolder:Object):boolean;
        /**
        * Returns the double value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setDouble  setDouble}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getDouble}.
        */
        getDouble(dataHolder:Object):number;
        /**
        * Returns the integer value bound to the given node.
        * <b>Precondition:</b> 
        * The value must have been associated to the given node by
        * a call to {@link yfiles.algorithms.INodeMap#setInt  setInt}.
        * @see Specified by {@link yfiles.algorithms.INodeMap#getInt}.
        */
        getInt(dataHolder:Object):number;
        /**
        * Associates the given boolean value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setBool}.
        */
        setBool(dataHolder:Object,value:boolean):void;
        /**
        * Associates the given double value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setDouble}.
        */
        setDouble(dataHolder:Object,value:number):void;
        /**
        * Associates the given integer value to the given node.
        * @see Specified by {@link yfiles.algorithms.INodeMap#setInt}.
        */
        setInt(dataHolder:Object,value:number):void;
      }
    }
    var Maps:{
      $class:yfiles.lang.Class;
      /**
      * Returns a NodeMap view  of a double array defined for nodes.
      * The double value <code>data[node.index()]</code> will be accessed
      * by the NodeMap upon the method calls <code>getDouble(node)</code>
      * and <code>setDouble(node,value)</code>.
      * <b>Warning!</b> The indices of the accessed nodes must not change during
      * the use of this NodeMap.
      * @param {number[]} data array data for each node of a static graph
      * @return {yfiles.algorithms.INodeMap} a NodeMap view of the given array
      */
      createIndexNodeMapDouble(data:number[]):yfiles.algorithms.INodeMap;
      /**
      * Returns a NodeMap view  of an int array defined for nodes.
      * The int value <code>data[node.index()]</code> will be accessed
      * by the NodeMap upon the method calls <code>getInt(node)</code>
      * and <code>setInt(node,value)</code>.
      * <b>Warning!</b> The indices of the accessed nodes must not change during
      * the use of this NodeMap.
      * @param {number[]} data array data for each node of a static graph
      * @return {yfiles.algorithms.INodeMap} a NodeMap view of the given array
      */
      createIndexNodeMapInt(data:number[]):yfiles.algorithms.INodeMap;
      /**
      * Returns a NodeMap view  of a boolean array defined for nodes.
      * The boolean value <code>data[node.index()]</code> will be accessed
      * by the NodeMap upon the method calls <code>getBool(node)</code>
      * and <code>setBool(node,value)</code>.
      * @param {boolean[]} data array data for each node of a static graph
      * @return {yfiles.algorithms.INodeMap} a NodeMap view of the given array
      */
      createIndexNodeMapBoolean(data:boolean[]):yfiles.algorithms.INodeMap;
      /**
      * Returns a NodeMap view  of an Object array defined for nodes.
      * The Object value <code>data[node.index()]</code> will be accessed
      * by the NodeMap upon the method calls <code>get(node)</code>
      * and <code>set(node,value)</code>.
      * <b>Warning!</b> The indices of the accessed nodes must not change during
      * the use of this NodeMap.
      * @param {Object[]} data array data for each node of a static graph
      * @return {yfiles.algorithms.INodeMap} a NodeMap view of the given array
      */
      createIndexNodeMap(data:Object[]):yfiles.algorithms.INodeMap;
      /**
      * Returns a NodeMap view  of a double, int, boolean and Object
      * array defined for nodes.
      * The double value <code>doubleData[node.index()]</code> will be accessed
      * by the NodeMap upon the method calls <code>getDouble(node)</code> and
      * <code>setDouble(node,value)</code>.
      * The int value <code>intData[node.index()]</code> will be accessed
      * by the NodeMap upon the method calls <code>getInt(node)</code> and
      * <code>setInt(node,value)</code>.
      * The boolean value <code>boolData[node.index()]</code> will be accessed
      * by the NodeMap upon the method calls <code>getBool(node)</code> and
      * <code>setBool(node,value)</code>.
      * The Object value <code>objectData[node.index()]</code> will be accessed
      * by the NodeMap upon the method calls <code>get(node)</code> and
      * <code>set(node,value)</code>.
      * <b>Warning!</b> The indices of the accessed nodes must not change during
      * the use of this NodeMap.
      * @param {number[]} doubleData double data for each node of a static graph
      * @param {number[]} intData int data for each node of a static graph
      * @param {boolean[]} boolData boolean data for each node of a static graph
      * @param {Object[]} objectData Object data for each node of a static graph
      * @return {yfiles.algorithms.INodeMap} a NodeMap view of the given arrays
      */
      createIndexNodeMapFromArrays(doubleData:number[],intData:number[],boolData:boolean[],objectData:Object[]):yfiles.algorithms.INodeMap;
      /**
      * Returns a EdgeMap view  of a double array defined for edges.
      * The double value <code>data[edge.index()]</code> will be accessed
      * by the EdgeMap upon the method calls <code>getDouble(edge)</code>
      * and <code>setDouble(edge,value)</code>.
      * <b>Warning!</b> The indices of the accessed edges must not change during
      * the use of this EdgeMap.
      * @param {number[]} data array data for each edge of a static graph
      * @return {yfiles.algorithms.IEdgeMap} a EdgeMap view of the given array
      */
      createIndexEdgeMapDouble(data:number[]):yfiles.algorithms.IEdgeMap;
      /**
      * Returns a EdgeMap view  of an int array defined for edges.
      * The int value <code>data[edge.index()]</code> will be accessed
      * by the EdgeMap upon the method calls <code>getInt(edge)</code>
      * and <code>setInt(edge,value)</code>.
      * <b>Warning!</b> The indices of the accessed edges must not change during
      * the use of this EdgeMap.
      * @param {number[]} data array data for each edge of a static graph
      * @return {yfiles.algorithms.IEdgeMap} a EdgeMap view of the given array
      */
      createIndexEdgeMapInt(data:number[]):yfiles.algorithms.IEdgeMap;
      /**
      * Returns a EdgeMap view  of a boolean array defined for edges.
      * The boolean value <code>data[edge.index()]</code> will be accessed
      * by the EdgeMap upon the method calls <code>getBool(edge)</code>
      * and <code>setBool(edge,value)</code>.
      * <b>Warning!</b> The indices of the accessed edges must not change during
      * the use of this EdgeMap.
      * @param {boolean[]} data array data for each edge of a static graph
      * @return {yfiles.algorithms.IEdgeMap} a EdgeMap view of the given array
      */
      createIndexEdgeMapBoolean(data:boolean[]):yfiles.algorithms.IEdgeMap;
      /**
      * Returns a EdgeMap view  of an Object array defined for edges.
      * The Object value <code>data[edge.index()]</code> will be accessed
      * by the EdgeMap upon the method calls <code>get(edge)</code>
      * and <code>set(edge,value)</code>.
      * <b>Warning!</b> The indices of the accessed edges must not change during
      * the use of this EdgeMap.
      * @param {Object[]} data array data for each edge of a static graph
      * @return {yfiles.algorithms.IEdgeMap} a EdgeMap view of the given array
      */
      createIndexEdgeMap(data:Object[]):yfiles.algorithms.IEdgeMap;
      /**
      * Returns a EdgeMap view  of a double, int, boolean and Object
      * array defined for edges.
      * The double value <code>doubleData[edge.index()]</code> will be accessed
      * by the EdgeMap upon the method calls <code>getDouble(edge)</code> and
      * <code>setDouble(edge,value)</code>.
      * The int value <code>intData[edge.index()]</code> will be accessed
      * by the EdgeMap upon the method calls <code>getInt(edge)</code> and
      * <code>setInt(edge,value)</code>.
      * The boolean value <code>boolData[edge.index()]</code> will be accessed
      * by the EdgeMap upon the method calls <code>getBool(edge)</code> and
      * <code>setBool(edge,value)</code>.
      * The Object value <code>objectData[edge.index()]</code> will be accessed
      * by the EdgeMap upon the method calls <code>get(edge)</code> and
      * <code>set(edge,value)</code>.
      * <b>Warning!</b> The indices of the accessed edges must not change during
      * the use of this EdgeMap.
      * @param {number[]} doubleData double data for each edge of a static graph
      * @param {number[]} intData int data for each edge of a static graph
      * @param {boolean[]} boolData boolean data for each edge of a static graph
      * @param {Object[]} objectData Object data for each edge of a static graph
      * @return {yfiles.algorithms.IEdgeMap} a EdgeMap view of the given arrays
      */
      createIndexEdgeMapFromArrays(doubleData:number[],intData:number[],boolData:boolean[],objectData:Object[]):yfiles.algorithms.IEdgeMap;
      /**
      * Creates a NodeMap that is based on hashing.
      * The preconditions specified in java.util.HashMap
      * apply for the keys and values of this map.
      */
      createHashedNodeMap():yfiles.algorithms.INodeMap;
      /**
      * Create a NodeMap view of the given map.
      * Accessing basic value types is solved by
      * storing the corresponding wrapper types
      * Double, Integer and Boolean within the given Map.
      */
      createNodeMap(map:yfiles.algorithms.IMap):yfiles.algorithms.INodeMap;
      /**
      * Creates an EdgeMap that is based on hashing.
      * The preconditions specified in java.util.HashMap
      * apply for the keys and values of this map.
      */
      createHashedEdgeMap():yfiles.algorithms.IEdgeMap;
      /**
      * Create an EdgeMap view of the given map.
      * Accessing basic value types is solved by
      * storing the corresponding wrapper types
      * Double, Integer and Boolean within the given Map.
      */
      createEdgeMap(map:yfiles.algorithms.IMap):yfiles.algorithms.IEdgeMap;
      /**
      * Creates a DataMap that is based on hashing.
      * The preconditions specified in java.util.HashMap
      * apply for the keys and values of this map.
      */
      createHashedDataMap():yfiles.algorithms.IDataMap;
      /**
      * Create a DataMap view of the given map.
      * Accessing basic value types is solved by
      * storing the corresponding wrapper types
      * Double, Integer and Boolean within the given Map.
      */
      createDataMap(map:yfiles.algorithms.IMap):yfiles.algorithms.IDataMap;
      HighPerformanceObjectMap:{
        $class:yfiles.lang.Class;
        new (backingMap:yfiles.algorithms.IDataMap,defaultValue:Object):yfiles.algorithms.Maps;
        FromBackingProviderAndAcceptor:{
          new (backingProvider:yfiles.algorithms.IDataProvider,backingAcceptor:yfiles.algorithms.IDataAcceptor,defaultValue:Object):yfiles.algorithms.Maps;
        };
      };
      HighPerformanceDoubleMap:{
        $class:yfiles.lang.Class;
        new (backingMap:yfiles.algorithms.IDataMap,defaultValue:number):yfiles.algorithms.Maps;
        FromBackingProviderAndAcceptor:{
          new (backingProvider:yfiles.algorithms.IDataProvider,backingAcceptor:yfiles.algorithms.IDataAcceptor,defaultValue:number):yfiles.algorithms.Maps;
        };
      };
      HighPerformanceIntMap:{
        $class:yfiles.lang.Class;
        new (backingMap:yfiles.algorithms.IDataMap,defaultValue:number):yfiles.algorithms.Maps;
        FromBackingProviderAndAcceptor:{
          new (backingProvider:yfiles.algorithms.IDataProvider,backingAcceptor:yfiles.algorithms.IDataAcceptor,defaultValue:number):yfiles.algorithms.Maps;
        };
      };
      HighPerformanceBoolMap:{
        $class:yfiles.lang.Class;
        new (backingMap:yfiles.algorithms.IDataMap,defaultValue:boolean):yfiles.algorithms.Maps;
        FromBackingProviderAndAcceptor:{
          new (backingProvider:yfiles.algorithms.IDataProvider,backingAcceptor:yfiles.algorithms.IDataAcceptor,defaultValue:boolean):yfiles.algorithms.Maps;
        };
      };
    };
    /**
    * Exception thrown when a graph-structural precondition is violated.
    * Some graph algorithms make only sense on specially structured graphs, like,
    * e.g., trees, DAGs (short for directed acyclic graph), or planar graphs.
    * Methods that detect graph-structural mismatch will throw this exception then.
    */
    export interface InvalidGraphStructureException extends yfiles.system.ArgumentException{
    }
    var InvalidGraphStructureException:{
      $class:yfiles.lang.Class;
      /**
      * Constructs a WrongGraphStructure exception with the specified message.
      */
      new (msg:string):yfiles.algorithms.InvalidGraphStructureException;
    };
    /**
    * Represents a so-called "cell" or "link" of the doubly linked list implementation
    * {@link yfiles.algorithms.YList}.
    * It may be used to perform fast access and remove operations on that type of list.
    */
    export interface ListCell extends Object{
      /**
      * Returns the successor cell of this cell.
      * If there is no successor, then <code>null</code> is returned.
      */
      succ():yfiles.algorithms.ListCell;
      /**
      * Returns the predecessor cell of this cell.
      * If there is no predecessor, then <code>null</code> is returned.
      */
      pred():yfiles.algorithms.ListCell;
      /**
      * The element stored in this cell.
      */
      info:Object;
    }
    var ListCell:{
      $class:yfiles.lang.Class;
    };
    /**
    * A cursor interface for iterating over nodes.
    */
    export interface INodeCursor extends Object,yfiles.algorithms.ICursor{
      /**
      * The node at the current location of the cursor.
      * This method is the typed variant of {@link yfiles.algorithms.ICursor#current}.
      * @see Specified by {@link yfiles.algorithms.INodeCursor#node}.
      */
      node:yfiles.algorithms.Node;
      /**
      * Moves the cursor to the cyclic next element of the underlying sequence.
      * This is the next element if available, else it is the first element.
      * @see Specified by {@link yfiles.algorithms.INodeCursor#cyclicNext}.
      */
      cyclicNext():void;
      /**
      * Moves the cursor to the cyclic previous element of the underlying sequence.
      * This is the previous element if available, else it is the last element.
      * @see Specified by {@link yfiles.algorithms.INodeCursor#cyclicPrev}.
      */
      cyclicPrev():void;
    }
    var INodeCursor:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This class provides methods for calculating independent sets.
    */
    export interface IndependentSets extends Object{
    }
    var IndependentSets:{
      $class:yfiles.lang.Class;
      /**
      * Partitions the vertex set of the given conflict graph into independent sets.
      * <b>Precondition:</b> The input graph is simple, i.e. it contains neither multi-edges nor selfloops.
      * @param {yfiles.algorithms.Graph} conflictGraph the input graph.
      * @return {yfiles.algorithms.NodeList[]} a NodeList array where each entry contains an independent set of nodes.
      * @see {@link yfiles.algorithms.IndependentSets#getIndependentSet}
      */
      getIndependentSets(conflictGraph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList[];
      /**
      * Calculates an independent set for a given conflict graph (each pair of nodes of the independent set is non-adjacent
      * in the conflict graph).
      * We use a greedy heuristic which tries to find a large independent set.
      * <b>Precondition:</b> The input graph is simple, i.e. it contains neither multi-edges nor selfloops.
      * @param {yfiles.algorithms.Graph} conflictGraph the input graph.
      * @return {yfiles.algorithms.NodeList} a NodeList containing an independent set of nodes
      */
      getIndependentSet(conflictGraph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList;
    };
    /**
    * Generic Interface for classes that provide an ordering
    * for the nodes of a graph.
    */
    export interface INodeSequencer extends Object{
      /**
      * Returns a cursor that grants access to <b>all</b> nodes of the given
      * graph in some order.
      * @see Specified by {@link yfiles.algorithms.INodeSequencer#nodes}.
      */
      nodes(graph:yfiles.algorithms.Graph):yfiles.algorithms.INodeCursor;
    }
    var INodeSequencer:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Provides access to data associated with a node.
    * A node map can be considered as a map that allows
    * only nodes as keys. Node keys of a node map must belong
    * to the same graph.
    * There are data access methods defined for the most common typed
    * values as well.
    * The node values are initialized with Java(TM) default values
    * (null, 0, 0.0, false) upon initialization.
    */
    export interface INodeMap extends Object,yfiles.algorithms.IDataProvider,yfiles.algorithms.IDataAcceptor,yfiles.algorithms.IDataMap{
      /**
      * Associates the given value to the given node.
      * @see Specified by {@link yfiles.algorithms.INodeMap#set}.
      */
      set(node:Object,value:Object):void;
      /**
      * Returns the value bound to the given node.
      * @see Specified by {@link yfiles.algorithms.INodeMap#get}.
      */
      get(node:Object):Object;
      /**
      * Associates the given boolean value to the given node.
      * @see Specified by {@link yfiles.algorithms.INodeMap#setBool}.
      */
      setBool(node:Object,value:boolean):void;
      /**
      * Returns the boolean value bound to the given node.
      * <b>Precondition:</b> 
      * The value must have been associated to the given node by
      * a call to {@link yfiles.algorithms.INodeMap#setBool  setBool}.
      * @see Specified by {@link yfiles.algorithms.INodeMap#getBool}.
      */
      getBool(key:Object):boolean;
      /**
      * Associates the given double value to the given node.
      * @see Specified by {@link yfiles.algorithms.INodeMap#setDouble}.
      */
      setDouble(node:Object,value:number):void;
      /**
      * Returns the double value bound to the given node.
      * <b>Precondition:</b> 
      * The value must have been associated to the given node by
      * a call to {@link yfiles.algorithms.INodeMap#setDouble  setDouble}.
      * @see Specified by {@link yfiles.algorithms.INodeMap#getDouble}.
      */
      getDouble(node:Object):number;
      /**
      * Associates the given integer value to the given node.
      * @see Specified by {@link yfiles.algorithms.INodeMap#setInt}.
      */
      setInt(node:Object,value:number):void;
      /**
      * Returns the integer value bound to the given node.
      * <b>Precondition:</b> 
      * The value must have been associated to the given node by
      * a call to {@link yfiles.algorithms.INodeMap#setInt  setInt}.
      * @see Specified by {@link yfiles.algorithms.INodeMap#getInt}.
      */
      getInt(node:Object):number;
    }
    var INodeMap:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Provides graph algorithms that order the nodes of a graph
    * by a specific criterion.
    */
    export interface NodeOrders extends Object{
    }
    var NodeOrders:{
      $class:yfiles.lang.Class;
      /**
      * Assigns a topological order to the nodes of an acyclic graph.
      * If the given graph is not acyclic then this method returns <code>false</code>
      * leaving the contents of result <code>topOrder</code> unspecified.
      * A topological node order of an acyclic graph has the property that for
      * each node <code>v</code> all of its successors have a higher rank in the order
      * than <code>v</code> itself.
      * <b>Precondition:</b> order.length == graph.N()
      * <b>Complexity:</b> O(graph.N()+graph.E())
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {number[]} order 
      * result value that holds for each node <code>v</code> the
      * zero-based index within the calculated order,
      * i.e <code>topOrder[v.index()] == 5</code>
      * means that <code>v</code> is the 6-th node within the order.
      */
      topologicalWithOrder(graph:yfiles.algorithms.Graph,order:number[]):boolean;
      /**
      * Returns a topological node order of an acyclic graph.
      * <b>Precondition:</b> GraphChecker.isAcyclic(graph)
      * <b>Complexity:</b> O(graph.N()+graph.E())
      */
      topological(graph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList;
      /**
      * This method calculates a node order that is identical with
      * the order of node completion events in a depth first search.
      * This order is a reversed topological order in case the input graph
      * is acyclic.
      * <b>Complexity:</b> O(graph.N()+graph.E())
      * @see {@link yfiles.algorithms.NodeOrders#topologicalWithOrder}
      */
      dfsCompletionWithOrder(graph:yfiles.algorithms.Graph,order:number[]):void;
      /**
      * Like {@link yfiles.algorithms.NodeOrders#dfsCompletionWithOrder} but the result is returned
      * as a NodeList.
      */
      dfsCompletion(graph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList;
      /**
      * Assigns an ST-order to the nodes of a biconnected graph.
      * An ST order <code>(v_1,v_2,....,v_n)</code> for a biconnected graph
      * is a node order which guarantees that
      * <ul>
      * <li>the first node <code>S</code> and the last node <code>T</code>
      * are connected by an edge.</li>
      * <li>For each node <code>v_i</code> in the order that
      * are not <code>S</code> or <code>T</code> there are
      * neighbors <code>v_j</code> and <code>v_k</code> with
      * <code>j &lt; i</code> and <code>k &gt; i</code>.</li>
      * </ul>
      * <b>Precondition:</b> tOrder.length == graph.N()
      * <b>Precondition:</b> GraphChecker.isBiconnected(graph)
      * <b>Complexity:</b> O(graph.N()+graph.E())
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {number[]} stOrder 
      * result value that holds for each node <code>v</code> the
      * zero-based index within the calculated order,
      * i.e <code>stOrder[v.index()] == 5</code>
      * means that <code>v</code> is the 6-th node within the order.
      */
      stWithOrder(graph:yfiles.algorithms.Graph,stOrder:number[]):void;
      /**
      * Similar to {@link yfiles.algorithms.NodeOrders#stWithOrder}.
      * Additionally, the edge between the first node <code>S</code> and
      * the last node <code>T</code> of the returned ordering can be specified.
      * @param {yfiles.algorithms.Edge} stEdge an edge that connects the first node of the ordering with the last node of the ordering.
      */
      stWithOrderAndEdge(graph:yfiles.algorithms.Graph,stOrder:number[],stEdge:yfiles.algorithms.Edge):void;
      /**
      * Like {@link yfiles.algorithms.NodeOrders#stWithOrder} but the result is returned as
      * a NodeList.
      */
      st(graph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList;
      /**
      * Converts an array-based result yield by a method of this class
      * to a NodeList that contains all nodes of the order in the
      * correct sequence.
      */
      toNodeList(graph:yfiles.algorithms.Graph,order:number[]):yfiles.algorithms.NodeList;
      /**
      * Copies an array-based result yield by a method of this class
      * to a NodeMap that will provide values of basic type <code>int</code>.
      */
      toNodeMapWithOrder(graph:yfiles.algorithms.Graph,order:number[],result:yfiles.algorithms.INodeMap):void;
      /**
      * Copies a list-based result yield by a method of this class
      * to a NodeMap.
      * The resulting NodeMap will provide for each node
      * the index of the node within the given order. The index is of basic type
      * <code>int</code>.
      */
      toNodeMap(order:yfiles.algorithms.NodeList,result:yfiles.algorithms.INodeMap):void;
    };
    /**
    * Provides sophisticated algorithms for solving classical network flow problems
    * like MinCostFlow or MaxFlow.
    */
    export interface NetworkFlows extends Object{
    }
    var NetworkFlows:{
      $class:yfiles.lang.Class;
      /**
      * Solves a minimum cost flow problem with a capacity scaling algorithm.
      * (see Ahuja,Magnanti,Orlin: Network flows, Prentice Hall, 1993, pp.360-362).
      * This algorithm is a variant of the successive shortest path algorithm.
      * (see Ahuja,Magnanti,Orlin: Network flows, Prentice Hall, 1993, pp.320-324).
      * It has the pseudo-polynomial running time O(m*log U*(m+n log n)) where n is the
      * number of nodes in the network, m the number of edges and U the maximal edge
      * capacity.
      * Edges may have infinite capacity, which is denoted by
      * the value <code>Integer.MAX_VALUE</code>.
      * There are no restriction for the costs, especially they
      * can be negative.
      * Solves a min-cost flow optimization problem.
      * @param {yfiles.algorithms.Graph} graph the network.
      * @param {yfiles.algorithms.IDataProvider} lCapDP 
      * the lower bound on the arc flow.
      * May be <code>null</code>.
      * @param {yfiles.algorithms.IDataProvider} uCapDP 
      * the capacity of the arcs.
      * Infinite capacity is denoted by
      * <code>Integer.MAX_VALUE</code>
      * @param {yfiles.algorithms.IDataProvider} cost0DP the costs of the arcs.
      * @param {yfiles.algorithms.IDataProvider} supplyDP 
      * the supply/demand of the nodes.
      * Supply is denoted by a positive value, demand by a
      * negative value.
      * @param {yfiles.algorithms.IEdgeMap} flowEM here the resulting flow is stored.
      * @param {yfiles.algorithms.INodeMap} dualsNM 
      * here the resulting dual values are stored.
      * Dual values are also referred as potentials.
      * May be <code>null</code>.
      * @return {number} the cost of the flow.
      */
      minCostFlowWithLowerBound(graph:yfiles.algorithms.Graph,lCapDP:yfiles.algorithms.IDataProvider,uCapDP:yfiles.algorithms.IDataProvider,cost0DP:yfiles.algorithms.IDataProvider,supplyDP:yfiles.algorithms.IDataProvider,flowEM:yfiles.algorithms.IEdgeMap,dualsNM:yfiles.algorithms.INodeMap):number;
      /**
      * Solves a min-cost flow optimization problem.
      * @param {yfiles.algorithms.Graph} graph the network.
      * @param {yfiles.algorithms.IDataProvider} uCapDP 
      * the capacity of the arcs.
      * Infinite capacity is denoted by
      * <code>Integer.MAX_VALUE</code>
      * @param {yfiles.algorithms.IDataProvider} cost0DP the costs of the arcs.
      * @param {yfiles.algorithms.IDataProvider} supplyDP 
      * the supply/demand of the nodes.
      * Supply is denoted by a positive value, demand by a
      * negative value.
      * @param {yfiles.algorithms.IEdgeMap} flowEM here the resulting flow is stored.
      * @param {yfiles.algorithms.INodeMap} dualsNM 
      * here the resulting dual values are stored.
      * Dual values are also referred as potentials.
      * @return {number} the cost of the flow.
      */
      minCostFlow(graph:yfiles.algorithms.Graph,uCapDP:yfiles.algorithms.IDataProvider,cost0DP:yfiles.algorithms.IDataProvider,supplyDP:yfiles.algorithms.IDataProvider,flowEM:yfiles.algorithms.IEdgeMap,dualsNM:yfiles.algorithms.INodeMap):number;
      /**
      * Solves a min-cost max-flow optimization problem.
      * @param {yfiles.algorithms.Graph} graph the network.
      * @param {yfiles.algorithms.Node} s source of the network.
      * @param {yfiles.algorithms.Node} t sink of the network.
      * @param {yfiles.algorithms.IDataProvider} uCapDP 
      * the capacity of the arcs.
      * Infinite capacity is denoted by
      * <code>Integer.MAX_VALUE</code>
      * @param {yfiles.algorithms.IDataProvider} cost0DP the costs of the arcs.
      * @param {yfiles.algorithms.IEdgeMap} flowEM here the resulting flow is stored.
      * @param {yfiles.algorithms.INodeMap} dualsNM 
      * here the resulting dual values are stored.
      * Dual values are also referred as potentials.
      * @return {number} the cost of the flow.
      */
      minCostFlowBetweenSourceAndSink(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,t:yfiles.algorithms.Node,uCapDP:yfiles.algorithms.IDataProvider,cost0DP:yfiles.algorithms.IDataProvider,flowEM:yfiles.algorithms.IEdgeMap,dualsNM:yfiles.algorithms.INodeMap):number;
      /**
      * Solves a maximum flow problem using the preflow-push method.
      * (see Mehlhorn, Naeher: LEDA: a platform for combinatorial and geometric computing,
      * Cambridge University Press, 2000, pp. 443-488)
      * The worst case running time is O(mdeg * n^2 * m^(1/2)), where n is the number of
      * nodes in the network, m the number of edges and mdeg the maximal degree of any node.
      * Edges may have infinite capacity, which is denoted by
      * the value <code>Integer.MAX_VALUE</code>.
      * @param {yfiles.algorithms.Graph} graph the network.
      * @param {yfiles.algorithms.Node} source the source of the network.
      * @param {yfiles.algorithms.Node} sink the sink of the network.
      * @param {yfiles.algorithms.IDataProvider} eCapDP 
      * the capacity of the arcs.
      * Infinite capacity is denoted by
      * <code>Integer.MAX_VALUE</code>
      * @param {yfiles.algorithms.IEdgeMap} flowEM here the resulting flow is stored.
      * @return {number} the maximum flow value.
      */
      calcMaxFlow(graph:yfiles.algorithms.Graph,source:yfiles.algorithms.Node,sink:yfiles.algorithms.Node,eCapDP:yfiles.algorithms.IDataProvider,flowEM:yfiles.algorithms.IEdgeMap):number;
      /**
      * Like {@link yfiles.algorithms.NetworkFlows#calcMaxFlow} this method
      * solves a maximum flow problem.
      * Additionally, this method marks all nodes
      * that belong to the minimum cut set that is associated with the
      * source of the network.
      * @param {yfiles.algorithms.INodeMap} sourceCutNM 
      * return value. This map will provide a boolean value for each node
      * that indicates whether or not a node belongs to the cut set associated
      * with the source of the network.
      * @return {number} 
      * the maximum flow value which also corresponds to the capacity
      * of all edges that cross from the cut set associated with the network source
      * to the cut set associated with the network sink.
      */
      calcMaxFlowMinCut(graph:yfiles.algorithms.Graph,source:yfiles.algorithms.Node,sink:yfiles.algorithms.Node,eCapDP:yfiles.algorithms.IDataProvider,flowEM:yfiles.algorithms.IEdgeMap,sourceCutNM:yfiles.algorithms.INodeMap):number;
    };
    /**
    * Specialized list implementation for instances of type {@link yfiles.algorithms.Node}.
    */
    export interface NodeList extends yfiles.algorithms.YList{
      /**
      * Returns a node cursor for this node list.
      * @return {yfiles.algorithms.INodeCursor} A node cursor granting access to the nodes within this list.
      */
      nodes():yfiles.algorithms.INodeCursor;
      /**
      * Returns the first node in this list, or <code>null</code> when the list is
      * empty.
      * @return {yfiles.algorithms.Node} The first node in the list.
      */
      firstNode():yfiles.algorithms.Node;
      /**
      * Returns the last node in this list, or <code>null</code> when the list is empty.
      * @return {yfiles.algorithms.Node} The last node in the list.
      */
      lastNode():yfiles.algorithms.Node;
      /**
      * Removes the first node from this list and returns it.
      * @return {yfiles.algorithms.Node} The first node from the list.
      */
      popNode():yfiles.algorithms.Node;
      /**
      * Returns a node array containing all elements of this list in the canonical
      * order.
      */
      toNodeArray():yfiles.algorithms.Node[];
      getEnumerator():yfiles.collections.IEnumerator<yfiles.algorithms.Node>;
    }
    var NodeList:{
      $class:yfiles.lang.Class;
      /**
      * Creates an empty node list.
      */
      new ():yfiles.algorithms.NodeList;
      /**
      * Creates a list that is initialized with the nodes provided by the given NodeCursor
      * object.
      */
      WithNodes:{
        new (c:yfiles.algorithms.INodeCursor):yfiles.algorithms.NodeList;
      };
      /**
      * Creates a list that is initialized with those nodes from the given NodeCursor
      * object for which the given data provider returns <code>true</code> upon
      * calling its {@link yfiles.algorithms.IDataProvider#getBool  getBool} method.
      * @param {yfiles.algorithms.INodeCursor} nc A node cursor providing nodes that should be added to this list.
      * @param {yfiles.algorithms.IDataProvider} predicate 
      * A data provider that acts as a inclusion predicate for each node accessible
      * by the given node cursor.
      */
      WithFilteredNodes:{
        new (nc:yfiles.algorithms.INodeCursor,predicate:yfiles.algorithms.IDataProvider):yfiles.algorithms.NodeList;
      };
      /**
      * Creates a list that is initialized with the elements provided by the given
      * Iterator object.
      */
      WithIterator:{
        new (it:yfiles.algorithms.IIterator):yfiles.algorithms.NodeList;
      };
      /**
      * Creates a list that is initialized with the nodes provided by the given array
      * of nodes.
      */
      WithNodeArray:{
        new (a:yfiles.algorithms.Node[]):yfiles.algorithms.NodeList;
      };
      /**
      * Creates a list that is initialized with a single node provided.
      */
      WithNode:{
        new (v:yfiles.algorithms.Node):yfiles.algorithms.NodeList;
      };
      /**
      * Creates a list that is initialized with the entries of the given list.
      * @param {yfiles.algorithms.NodeList} list the values are added to the new list
      */
      WithNodeList:{
        new (list:yfiles.algorithms.NodeList):yfiles.algorithms.NodeList;
      };
    };
    /**
    * Represents a so-called node in the directed graph data type {@link yfiles.algorithms.Graph}.
    * Most notably, a node provides access to its adjacent edges (represented by instances
    * of class {@link yfiles.algorithms.Edge}).
    * These can be distinguished into the sets of incoming and outgoing edges.
    * Iteration over all three sets of edges is provided by means of bidirectional
    * cursors that present a read-only view of the respective set ({@link yfiles.algorithms.Node#getEdgeCursor},
    * {@link yfiles.algorithms.Node#getInEdgeCursor}, {@link yfiles.algorithms.Node#getOutEdgeCursor}).
    * Also supported is iteration over all nodes at opposite ends of either incoming
    * edges or outgoing edges ({@link yfiles.algorithms.Node#getPredecessorCursor}, {@link yfiles.algorithms.Node#getSuccessorCursor}).
    * The number of overall edges at a node is called its degree ({@link yfiles.algorithms.Node#degree}),
    * which is the sum of incoming and outgoing edges ({@link yfiles.algorithms.Node#inDegree},
    * {@link yfiles.algorithms.Node#outDegree}).
    * <b>Important:</b>
    * Class Graph is the single authority for any structural changes to the graph data
    * type.
    * Specifically, this means that there is no way to create or delete a node or an
    * edge without using an actual Graph instance.
    */
    export interface Node extends yfiles.algorithms.GraphObject{
      /**
      * Creates a copy of this node that will be inserted into the given graph.
      * @param {yfiles.algorithms.Graph} g The graph that the created node will belong to.
      * @return {yfiles.algorithms.Node} The newly created Node object.
      */
      createCopy(g:yfiles.algorithms.Graph):yfiles.algorithms.Node;
      /**
      * The overall number of incoming and outgoing edges at this node.
      * Note that self-loops are counted twice.
      * @see {@link yfiles.algorithms.Edge}
      * @see {@link yfiles.algorithms.Node#inDegree}
      * @see {@link yfiles.algorithms.Node#outDegree}
      */
      degree:number;
      /**
      * The number of incoming edges at this node.
      * @see {@link yfiles.algorithms.Node#degree}
      * @see {@link yfiles.algorithms.Node#outDegree}
      */
      inDegree:number;
      /**
      * The number of outgoing edges at this node.
      * @see {@link yfiles.algorithms.Node#degree}
      * @see {@link yfiles.algorithms.Node#inDegree}
      */
      outDegree:number;
      /**
      * The index of this node within its graph G.
      * Node indices represent the ordering of standard node iteration on G.
      * The value of an index is <code> &gt;= 0</code> and <code> &lt; G.nodeCount()</code>.
      * Note that indices are subject to change whenever the sequence of nodes in a
      * graph is modified by either removing, hiding, reinserting, or unhiding a node,
      * or by explicitly changing its position in the sequence.
      * <b>Precondition:</b> This node must belong to some graph.
      * @see {@link yfiles.algorithms.Graph#removeNode}
      * @see {@link yfiles.algorithms.Graph#hideNode}
      * @see {@link yfiles.algorithms.Graph#reInsertNode}
      * @see {@link yfiles.algorithms.Graph#unhideNode}
      * @see {@link yfiles.algorithms.Graph#moveToFirstNode}
      * @see {@link yfiles.algorithms.Graph#moveToLastNode}
      */
      index:number;
      /**
      * The graph this node belongs to.
      * If the node does not belong to a graph, because it was removed or hidden from
      * it, this method returns <code>null</code>.
      */
      graph:yfiles.algorithms.Graph;
      /**
      * The first outgoing edge at this node, or <code>null</code> if it does
      * not exist.
      * @see {@link yfiles.algorithms.Node#firstInEdge}
      * @see {@link yfiles.algorithms.Node#lastOutEdge}
      */
      firstOutEdge:yfiles.algorithms.Edge;
      /**
      * The first incoming edge at this node, or <code>null</code> if it does
      * not exist.
      * @see {@link yfiles.algorithms.Node#firstOutEdge}
      * @see {@link yfiles.algorithms.Node#lastInEdge}
      */
      firstInEdge:yfiles.algorithms.Edge;
      /**
      * The last outgoing edge at this node, or <code>null</code> if it does
      * not exist.
      * @see {@link yfiles.algorithms.Node#firstOutEdge}
      * @see {@link yfiles.algorithms.Node#lastInEdge}
      */
      lastOutEdge:yfiles.algorithms.Edge;
      /**
      * The last incoming edge at this node, or <code>null</code> if it does
      * not exist.
      * @see {@link yfiles.algorithms.Node#firstInEdge}
      * @see {@link yfiles.algorithms.Node#lastOutEdge}
      */
      lastInEdge:yfiles.algorithms.Edge;
      /**
      * Returns an edge cursor for all incoming and outgoing edges at this node.
      * @see {@link yfiles.algorithms.Node#getInEdgeCursor}
      * @see {@link yfiles.algorithms.Node#getOutEdgeCursor}
      */
      getEdgeCursor():yfiles.algorithms.IEdgeCursor;
      /**
      * Returns an edge cursor for all incoming edges at this node.
      * @see {@link yfiles.algorithms.Node#getEdgeCursor}
      * @see {@link yfiles.algorithms.Node#getOutEdgeCursor}
      */
      getInEdgeCursor():yfiles.algorithms.IEdgeCursor;
      /**
      * Returns an edge cursor for incoming edges at this node.
      * The cursor starts at the given edge, and the cyclic sequence order is the same
      * as returned by {@link yfiles.algorithms.Node#getInEdgeCursor}.
      * <b>Precondition:</b> <code>startEdge</code> is an incoming edge at this node.
      * @param {yfiles.algorithms.Edge} startEdge The first edge being accessed by the returned cursor.
      * @see {@link yfiles.algorithms.Node#getOutEdgeCursorFromStartEdge}
      */
      getInEdgeCursorFromStartEdge(startEdge:yfiles.algorithms.Edge):yfiles.algorithms.IEdgeCursor;
      /**
      * Returns an edge cursor for all outgoing edges at this node.
      * @see {@link yfiles.algorithms.Node#getEdgeCursor}
      * @see {@link yfiles.algorithms.Node#getInEdgeCursor}
      */
      getOutEdgeCursor():yfiles.algorithms.IEdgeCursor;
      /**
      * Returns an edge cursor for outgoing edges at this node.
      * The cursor starts at the given edge, and the cyclic sequence order is the same
      * as returned by {@link yfiles.algorithms.Node#getOutEdgeCursor}.
      * <b>Precondition:</b> <code>startEdge</code> is an outgoing edge at this node.
      * @param {yfiles.algorithms.Edge} startEdge The first edge being accessed by the returned cursor.
      * @see {@link yfiles.algorithms.Node#getInEdgeCursorFromStartEdge}
      */
      getOutEdgeCursorFromStartEdge(startEdge:yfiles.algorithms.Edge):yfiles.algorithms.IEdgeCursor;
      /**
      * Returns a node cursor for all neighbor nodes of this node.
      * Neighbor nodes are those at the opposite ends of both incoming and outgoing
      * edges.
      * @see {@link yfiles.algorithms.Node#getPredecessorCursor}
      * @see {@link yfiles.algorithms.Node#getSuccessorCursor}
      */
      getNeighborCursor():yfiles.algorithms.INodeCursor;
      /**
      * Returns a node cursor for all predecessor nodes of this node.
      * Predecessor nodes are those at the opposite ends of incoming edges.
      * @see {@link yfiles.algorithms.Node#getSuccessorCursor}
      */
      getPredecessorCursor():yfiles.algorithms.INodeCursor;
      /**
      * Returns a node cursor for all successor nodes of this node.
      * Successor nodes are those at the opposite ends of outgoing edges.
      * @see {@link yfiles.algorithms.Node#getPredecessorCursor}
      */
      getSuccessorCursor():yfiles.algorithms.INodeCursor;
      /**
      * Returns an outgoing edge that connects this node with the given node, if such
      * an edge exists.
      * Otherwise <code>null</code> is returned.
      * @see {@link yfiles.algorithms.Node#getEdge}
      * @see {@link yfiles.algorithms.Node#getEdgeFrom}
      */
      getEdgeTo(target:yfiles.algorithms.Node):yfiles.algorithms.Edge;
      /**
      * Returns an incoming edge that connects the given node with this node, if such
      * an edge exists.
      * Otherwise <code>null</code> is returned.
      * @see {@link yfiles.algorithms.Node#getEdge}
      * @see {@link yfiles.algorithms.Node#getEdgeTo}
      */
      getEdgeFrom(source:yfiles.algorithms.Node):yfiles.algorithms.Edge;
      /**
      * Returns an edge that connects this node with the given node, if such an edge
      * exists.
      * Otherwise <code>null</code> is returned.
      * Note that the first matching edge is returned, and that outgoing edges are
      * tested prior to incoming edges.
      * @see {@link yfiles.algorithms.Node#getEdgeFrom}
      * @see {@link yfiles.algorithms.Node#getEdgeTo}
      */
      getEdge(opposite:yfiles.algorithms.Node):yfiles.algorithms.Edge;
      /**
      * Sorts incoming edges at this node according to the given comparator.
      * @see {@link yfiles.algorithms.Node#sortOutEdges}
      */
      sortInEdges(c:yfiles.objectcollections.IComparer):void;
      /**
      * Sorts outgoing edges at this node according to the given comparator.
      * @see {@link yfiles.algorithms.Node#sortInEdges}
      */
      sortOutEdges(c:yfiles.objectcollections.IComparer):void;
      /**
      * Returns a String representation of this node.
      */
      toString():string;
      /**
      * Yields a dynamic {@link yfiles.collections.IEnumerable}
      * for {@link yfiles.algorithms.Edge}s that can be used to iterate over outgoing edges at this instance.
      * This is a live enumerable and will thus reflect the current state of the node's adjacency.
      * Note that changes to the graph structure during the traversal should be carried out with great care.
      * Note that self-loop edges are reported, too.
      */
      outEdges:yfiles.collections.IEnumerable<yfiles.algorithms.Edge>;
      /**
      * Yields a dynamic {@link yfiles.collections.IEnumerable}
      * for {@link yfiles.algorithms.Edge}s that can be used to iterate over ingoing edges at this instance.
      * This is a live enumerable and will thus reflect the current state of the node's adjacency.
      * Note that changes to the graph structure during the traversal should be carried out with great care.
      * Note that self-loop edges are reported, too.
      */
      inEdges:yfiles.collections.IEnumerable<yfiles.algorithms.Edge>;
      /**
      * Yields a dynamic {@link yfiles.collections.IEnumerable}
      * for {@link yfiles.algorithms.Edge}s that can be used to iterate over the adjacent edges at this instance.
      * This is a live enumerable and will thus reflect the current state of the node's adjacency.
      * Note that changes to the graph structure during the traversal should be carried out with great care.
      * Note that self-loop edges are reported twice (as in edge and as out edge).
      */
      edges:yfiles.collections.IEnumerable<yfiles.algorithms.Edge>;
      /**
      * Yields a dynamic {@link yfiles.collections.IEnumerable}
      * for {@link yfiles.algorithms.Node}s that can be used to iterate over the opposite sides of adjacent outgoing edges at this instance.
      * This is a live enumerable and will thus reflect the current state of the node's adjacency.
      * Note that changes to the graph structure during the traversal should be carried out with great care.
      * Note that for self-loop edges this node itself will be reported as a successor.
      */
      successors:yfiles.collections.IEnumerable<yfiles.algorithms.Node>;
      /**
      * Yields a dynamic {@link yfiles.collections.IEnumerable}
      * for {@link yfiles.algorithms.Node}s that can be used to iterate over the opposite sides of adjacent incoming edges at this instance.
      * This is a live enumerable and will thus reflect the current state of the node's adjacency.
      * Note that changes to the graph structure during the traversal should be carried out with great care.
      * Note that for self-loop edges this node itself will be reported as a predecessor.
      */
      predecessors:yfiles.collections.IEnumerable<yfiles.algorithms.Node>;
      /**
      * Yields a dynamic {@link yfiles.collections.IEnumerable}
      * for {@link yfiles.algorithms.Node}s that can be used to iterate over the opposite sides of adjacent adjacent edges at this instance.
      * This is a live enumerable and will thus reflect the current state of the node's adjacency.
      * Note that changes to the graph structure during the traversal should be carried out with great care.
      * Note that for self-loop edges this node itself will be reported as a neighbor, twice.
      */
      neighbors:yfiles.collections.IEnumerable<yfiles.algorithms.Node>;
    }
    var Node:{
      $class:yfiles.lang.Class;
      /**
      * Instantiates a new Node object that will be part of the given graph.
      * @param {yfiles.algorithms.Graph} g The graph that the created node will belong to.
      */
      new (g:yfiles.algorithms.Graph):yfiles.algorithms.Node;
    };
    /**
    * This class provides methods for automatically partitioning nodes of a graph into groups.
    */
    export interface Groups extends Object{
    }
    var Groups:{
      $class:yfiles.lang.Class;
      /**
      * Partitions the graph into groups using edge betweenness centrality (see {@link yfiles.algorithms.Centrality#edgeBetweenness}.
      * In each iteration the edge with the highest
      * betweenness centrality is removed from the graph. The method stops, if there are no more edges to remove. The
      * clustering with the best quality reached during the process will be returned.
      * <b>Complexity:</b> 
      * O(graph.E())*O(edgeBetweenness) (Note: is practical faster because edge betweenness is computed for
      * subgraphs during the process and this algorithm terminates after <code>maxGroupCount</code> groups have been
      * determined.)
      * <b>Precondition:</b> <code>minGroupCount &lt;= maxGroupCount</code>
      * <b>Precondition:</b> <code>minGroupCount &lt;= graph.N()</code>
      * <b>Precondition:</b> <code>maxGroupCount &gt; 0</code>
      * @param {yfiles.algorithms.Graph} graph the input graph.
      * @param {yfiles.algorithms.INodeMap} clusterIDs used as return value. This map gets a cluster ID of integer type for every node.
      * @param {boolean} directed whether or not to consider the edges of the graph as directed.
      * @param {number} minGroupCount the minimum number of groups to be returned.
      * @param {number} maxGroupCount 
      * the maximum number of groups to be returned. The smaller this value is chosen the faster the
      * overall computation time. Note that the upper bound on the number of groups is
      * <code>graph.N()</code>. Note, that the number of returned groups is never less than the number
      * of connected components of the graph.
      * @param {yfiles.algorithms.IDataProvider} edgeCosts 
      * if <code>null</code> the edges of the graph are considered to have equal cost. Otherwise
      * it must provide a non-negative <code>double</code> value (its cost) for every edge.
      * @return {number} the number of different groups found.
      */
      edgeBetweennessClusteringWithCost(graph:yfiles.algorithms.Graph,clusterIDs:yfiles.algorithms.INodeMap,directed:boolean,minGroupCount:number,maxGroupCount:number,edgeCosts:yfiles.algorithms.IDataProvider):number;
      /**
      * Partitions the graph into groups using <em>Edge Betweenness Clustering</em> proposed by Girvan and Newman.
      * In each
      * iteration the edge with the highest betweenness centrality is removed from the graph. The method stops, if there
      * are no more edges to remove or if the requested maximum number of groups is found. The clustering with the best
      * quality reached during the process is returned.
      * The algorithm includes several heuristic speed-up techniques available through the quality/time ratio.  For the
      * highest quality setting, it is used almost unmodified. The fast betweenness approximation of Brandes und Pich
      * (<em>Centrality Estimation in Large Networks</em>) is employed for values around 0.5. Typically, this results in a
      * tiny decrease in quality but a large speed-up and is the recommended setting. To achieve the lowest running time, a
      * local betweenness calculation is used (Gregory: <em>Local Betweenness for Finding Communities in Networks</em>).
      * <b>Complexity:</b> 
      * O(graph.E())*O(edgeBetweenness) (Note: is practical faster because edge betweenness is computed for
      * subgraphs during the process and this algorithm terminates after <code>maxGroupCount</code> groups have been
      * determined.)
      * <b>Precondition:</b> <code>minGroupCount &lt;= maxGroupCount</code>
      * <b>Precondition:</b> <code>minGroupCount &lt;= graph.N()</code>
      * <b>Precondition:</b> <code>maxGroupCount &gt; 0</code>
      * @param {yfiles.algorithms.Graph} graph the input graph.
      * @param {yfiles.algorithms.INodeMap} clusterIDs used as return value. This map gets a cluster ID of integer type for every node.
      * @param {number} qualityTimeRatio 
      * a value between 0.0 (low quality, fast) and 1.0 (high quality, slow). The recommended value
      * is 0.5.
      * @param {number} minGroupCount the minimum number of groups to be returned.
      * @param {number} maxGroupCount 
      * the maximum number of groups to be returned. The smaller this value is chosen the faster
      * the overall computation time. Note, that the upper bound on the number of groups is
      * <code>graph.N()</code> and that the number of returned groups is never less than the number
      * of connected components of the graph.
      * @param {boolean} refine whether the algorithm refines or discards the current grouping.
      * @return {number} the number of different groups found
      */
      edgeBetweennessClustering(graph:yfiles.algorithms.Graph,clusterIDs:yfiles.algorithms.INodeMap,qualityTimeRatio:number,minGroupCount:number,maxGroupCount:number,refine:boolean):number;
      /**
      * This method partitions the graph by analyzing its biconnected component structure.
      * Nodes will be grouped in a way
      * that the nodes within each group are biconnected. Nodes that belong to multiple biconnected components will be
      * assigned to exactly one of these components.
      * <p>
      * <b>Note:</b>
      * Biconnected components are defined for undirected graphs only.
      * As a consequence, this algorithm ignores selfloops and isolated nodes with
      * only selfloop edges or no edges at all are not assigned to any group,
      * i.e. the <code>groupID</code> for such a node will be <code>null</code>.
      * </p>
      * <b>Complexity:</b> O(graph.E()+graph.N())
      * @param {yfiles.algorithms.Graph} graph the input graph.
      * @param {yfiles.algorithms.INodeMap} groupIDs used as return value. This map gets a cluster ID of integer type for every node.
      * @return {number} the number of different groups found.
      */
      biconnectedComponentGrouping(graph:yfiles.algorithms.Graph,groupIDs:yfiles.algorithms.INodeMap):number;
    };
    /**
    * Very simple default implementation of a Copy Factory that creates {@link yfiles.algorithms.Graph} instances
    * and simply delegates to the {@link yfiles.algorithms.Graph#createNode} and
    * {@link yfiles.algorithms.Graph#createEdgeBetween} method.
    */
    export interface GraphCopyFactory extends Object,yfiles.algorithms.GraphCopier.ICopyFactory{
      /**
      * This implementation does nothing.
      * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#preCopyGraphData}.
      */
      preCopyGraphData(hint:yfiles.algorithms.Graph,newGraph:yfiles.algorithms.Graph):void;
      /**
      * This implementation does nothing.
      * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#postCopyGraphData}.
      */
      postCopyGraphData(originalGraph:yfiles.algorithms.Graph,newGraph:yfiles.algorithms.Graph,nodeMap:yfiles.algorithms.IMap,edgeMap:yfiles.algorithms.IMap):void;
      /**
      * Copies the <code>originalNode</code> from the source graph to the new <code>targetGraph</code>.
      * @param {yfiles.algorithms.Graph} targetGraph the graph to create the new node in
      * @param {yfiles.algorithms.Node} originalNode the original node from the source graph
      * @return {yfiles.algorithms.Node} the newly created node
      * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#copyNode}.
      */
      copyNode(targetGraph:yfiles.algorithms.Graph,originalNode:yfiles.algorithms.Node):yfiles.algorithms.Node;
      /**
      * Copies the <code>originalEdge</code> from the source graph to the new <code>targetGraph</code>
      * using the specified new source and target node in the target graph.
      * @param {yfiles.algorithms.Graph} targetGraph the graph to create the new node in
      * @param {yfiles.algorithms.Node} newSource the source node in the target graph to use for the newly created edge
      * @param {yfiles.algorithms.Node} newTarget the target node in the target graph to use for the newly created edge
      * @param {yfiles.algorithms.Edge} originalEdge the original edge from the source graph
      * @return {yfiles.algorithms.Edge} the newly created edge
      * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#copyEdge}.
      */
      copyEdge(targetGraph:yfiles.algorithms.Graph,source:yfiles.algorithms.Node,target:yfiles.algorithms.Node,originalEdge:yfiles.algorithms.Edge):yfiles.algorithms.Edge;
      /**
      * Creates a new {@link yfiles.algorithms.Graph}.
      * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#createGraph}.
      */
      createGraph():yfiles.algorithms.Graph;
    }
    var GraphCopyFactory:{
      $class:yfiles.lang.Class;
    };
    /**
    * Provides algorithms for determining certain connectivity components within a graph.
    * Also provides convenience method for working with these components.
    */
    export interface GraphConnectivity extends Object{
    }
    var GraphConnectivity:{
      $class:yfiles.lang.Class;
      /**
      * Returns the connected components of a given graph.
      * A graph <code>G</code> is called connected if there is an
      * undirected path between each pair of nodes belonging to <code>G</code>.
      * The connected components of <code>G</code> are connected
      * subgraphs that <code>G</code> consists of.
      * <b>Complexity:</b> O(graph.N() + graph.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @return {yfiles.algorithms.NodeList[]} 
      * an array of NodeLists each of which contains the nodes that belong to
      * a common connected component of the graph.
      */
      connectedComponents(graph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList[];
      /**
      * Returns the connected components of a given graph.
      * A graph <code>G</code> is called connected if there is an
      * undirected path between each pair of nodes belonging to <code>G</code>.
      * The connected components of <code>G</code> are connected
      * subgraphs that <code>G</code> consists of.
      * <b>Complexity:</b> O(graph.N() + graph.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.INodeMap} compNum 
      * return value that will hold the zero-based number
      * of the connected component that it belongs to. The component number of
      * Node <code>v</code> is <code>compNum.getInt()</code>.
      * @return {number} the number of connected components of this graph.
      */
      connectedComponentsWithIndex(graph:yfiles.algorithms.Graph,compNum:yfiles.algorithms.INodeMap):number;
      /**
      * Makes a graph connected by adding additional edges to the graph.
      * The number of edges that will be added is equal to one less the number of
      * separate components of the original graph.
      * <b>Complexity:</b> O(graph.N() + graph.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @return {yfiles.algorithms.EdgeList} an edge list containing the edges added to this graph.
      */
      makeConnected(graph:yfiles.algorithms.Graph):yfiles.algorithms.EdgeList;
      /**
      * Transforms the return values of {@link yfiles.algorithms.GraphConnectivity#connectedComponentsWithIndex} to
      * an array of type NodeList, like it is returned by
      * {@link yfiles.algorithms.GraphConnectivity#connectedComponents}.
      */
      toNodeListArray(graph:yfiles.algorithms.Graph,compNum:yfiles.algorithms.INodeMap,maxCompNum:number):yfiles.algorithms.NodeList[];
      /**
      * Checks whether or not the given graph is connected.
      */
      isConnected(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Calculates the biconnected components of a given undirected graph.
      * The result is returned as an array of EdgeList objects each containing all
      * edges that belong to the same biconnected component of
      * the graph.
      * <p>
      * <b>Note:</b> Selfloops do not belong to any biconnected component.
      * Therefore no selfloops are included in the returned edge lists.
      * </p>
      * <b>Precondition:</b> GraphChecker.isConnected(graph)
      * <b>Complexity:</b> O(graph.N() + graph.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      */
      biconnectedComponents(graph:yfiles.algorithms.Graph):yfiles.algorithms.EdgeList[];
      /**
      * Calculates the biconnected components of a given undirected graph.
      * The main result is returned in the form of an EdgeMap that provides
      * for each edge a zero-based index of the biconnected component it belongs to.
      * <p>
      * <b>Note:</b> Selfloops do not belong to any biconnected component.
      * Therefore the component index for selfloops is always <code>-1</code>.
      * </p>
      * <b>Precondition:</b> GraphChecker.isConnected(graph)
      * <b>Precondition:</b> compNum defined for each edge in the graph.
      * <b>Complexity:</b> O(graph.N() + graph.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.IEdgeMap} compNum 
      * return value that provides for each edge a zero-based index
      * of the biconnected component it belongs to or
      * <code>-1</code> for selfloops.
      * @return {number} the number of biconnected components found
      */
      biconnectedComponentsWithIndex(graph:yfiles.algorithms.Graph,compNum:yfiles.algorithms.IEdgeMap):number;
      /**
      * Calculates the biconnected components of a given undirected graph.
      * Additionally, this method calculates the articulation points of the input
      * graph. Articulation points are returned in the form of a NodeMap that
      * provides for each node a boolean value indicating whether or not it is an
      * articulation point.
      * <p>
      * <b>Note:</b> Selfloops do not belong to any biconnected component.
      * Therefore the component index for selfloops is always <code>-1</code>.
      * </p>
      * <b>Precondition:</b> aPoint defined for each node in the graph
      * @param {yfiles.algorithms.INodeMap} aPoint 
      * return value that provides for each node  a boolean value
      * indicating whether or not it is an articulation point.
      */
      biconnectedComponentsWithIndexAndArticulationPoint(graph:yfiles.algorithms.Graph,compNum:yfiles.algorithms.IEdgeMap,aPoint:yfiles.algorithms.INodeMap):number;
      /**
      * Transforms the return values of {@link yfiles.algorithms.GraphConnectivity#biconnectedComponentsWithIndex} to
      * an array of {@link yfiles.algorithms.EdgeList}s, like it is returned by
      * {@link yfiles.algorithms.GraphConnectivity#biconnectedComponents}.
      */
      toEdgeListArray(graph:yfiles.algorithms.Graph,compNum:yfiles.algorithms.IEdgeMap,maxCompNum:number):yfiles.algorithms.EdgeList[];
      /**
      * Makes the given graph biconnected by inserting a minimum number of edges
      * in the graph.
      * The given graph is considered to be undirected.
      * <b>Precondition:</b> GraphChecker.isConnected(graph)
      * <b>Complexity:</b> O(graph.N() + graph.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @return {yfiles.algorithms.EdgeList} an edge list containing the edges added to this graph.
      */
      makeBiconnected(graph:yfiles.algorithms.Graph):yfiles.algorithms.EdgeList;
      /**
      * Checks whether or not the given graph is biconnected.
      */
      isBiconnected(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Determines the set of nodes that can be reached in the given graph when starting
      * from a given node.
      * <b>Precondition:</b> reached.length = graph.N()
      * @param {yfiles.algorithms.Graph} graph the graph the search is performed on
      * @param {yfiles.algorithms.Node} start the node the search is started from
      * @param {boolean} directed 
      * traverses edges only from source to target if <code>true</code>. Otherwise
      * traverses edges in both directions.
      * @param {boolean[]} reached 
      * the return value. a boolean array that has value <code>true</code> at field
      * <code>v.index()</code> iff node v can be reached by the dfs search.
      */
      reachable(graph:yfiles.algorithms.Graph,start:yfiles.algorithms.Node,directed:boolean,reached:boolean[]):void;
      /**
      * Similar to {@link yfiles.algorithms.GraphConnectivity#reachable}.
      * Additionally
      * it is possible to specify a set of forbidden edges that will not be traversed
      * when performing the search.
      * <b>Precondition:</b> forbiddenEdges.length = graph.E()
      * @param {yfiles.algorithms.Graph} graph the graph DFS is performed on
      * @param {yfiles.algorithms.Node} start the node DFS is started from
      * @param {boolean} directed 
      * traverses edges only from source to target if <code>true</code>. Otherwise
      * traverses edges in both directions.
      * @param {boolean[]} forbidden 
      * marks edges that may not be traversed by DFS. An edge <code>e</code>
      * is marked as forbidden if <code>forbidden[e.index()] == true</code>.
      * @param {boolean[]} reached 
      * the return value. a boolean array that has value <code>true</code> at field
      * <code>v.index()</code> iff node v can be reached by the dfs search.
      */
      reachableWithForbidden(graph:yfiles.algorithms.Graph,start:yfiles.algorithms.Node,directed:boolean,forbidden:boolean[],reached:boolean[]):void;
      /**
      * Determines the direct or indirect successors of a given set of nodes.
      * A direct successor
      * of a node is the target node of an outgoing edge connected to a node.
      * An indirect successor of a node is a direct successor to another successor of a node.
      * @param {yfiles.algorithms.Graph} graph the graph to act upon
      * @param {yfiles.algorithms.NodeList} startNodes contains the node the search is started from
      * @param {number} maxDistance 
      * limits the distance between a start node and a returned node. For all returned
      * nodes there must be a path to a start node that has a length equal or smaller than maxDistance.
      * Setting maxDistance to <code>1</code> will only yield the direct successors of all start nodes. On the other hand,
      * setting maxDistance to <code>graph.N()</code> or larger, will yield all successors of all start nodes.
      * @return {yfiles.algorithms.NodeList} 
      * a NodeList that contains all direct and indirect successors of a node. The order
      * of the returned nodes follows is determined by a breadth first search.
      * No start node will be part of the resulting set.
      */
      getSuccessors(graph:yfiles.algorithms.Graph,startNodes:yfiles.algorithms.NodeList,maxDistance:number):yfiles.algorithms.NodeList;
      /**
      * Determines the direct or indirect predecessors of a given set of nodes.
      * A direct predecessor
      * of a node is the source node of an ingoing edge connected to a node.
      * An indirect predecessor of a node is a direct predecessor to another predecessor of a node.
      * @param {yfiles.algorithms.Graph} graph the graph to act upon
      * @param {yfiles.algorithms.NodeList} startNodes contains the node the search is started from
      * @param {number} maxDistance 
      * limits the distance between a start node and a returned node. For all returned
      * nodes there must be a path to a start node that has a length equal or smaller than maxDistance.
      * Setting maxDistance to <code>1</code> will only yield the direct predecessors of all start nodes. On the other hand,
      * setting maxDistance to <code>graph.N()</code> or larger, will yield all predecessors of all start nodes.
      * @return {yfiles.algorithms.NodeList} 
      * a NodeList that contains all direct and indirect predecessors of a node. The order
      * of the returned nodes follows is determined by a breadth first search.
      * No start node will be part of the resulting set.
      */
      getPredecessors(graph:yfiles.algorithms.Graph,startNodes:yfiles.algorithms.NodeList,maxDistance:number):yfiles.algorithms.NodeList;
      /**
      * Determines the direct or indirect neighbors of a given set of nodes.
      * A direct neighbor
      * of a node is directly connected by an edge to that node.
      * An indirect neighbor of a node is directly connected to another direct or indirect neighbor of a node.
      * @param {yfiles.algorithms.Graph} graph the graph to act upon
      * @param {yfiles.algorithms.NodeList} startNodes contains the node the search is started from
      * @param {number} maxDistance 
      * limits the distance between a start node and a returned node. For all returned
      * nodes there must be a path to a start node that has a length equal or smaller than maxDistance.
      * Setting maxDistance to <code>1</code> will only yield the direct neighbors of all start nodes. On the other hand,
      * setting maxDistance to <code>graph.N()</code> or larger, will yield all neighbors of all start nodes.
      * @return {yfiles.algorithms.NodeList} 
      * a NodeList that contains all direct and indirect neighbors of a node.
      * The order of the returned nodes follows is determined by a breadth first search.
      * No start node will be part of the resulting set.
      */
      getNeighbors(graph:yfiles.algorithms.Graph,startNodes:yfiles.algorithms.NodeList,maxDistance:number):yfiles.algorithms.NodeList;
      /**
      * Returns the connected components of a given graph.
      * A graph <code>G</code> is called strongly connected if there is an
      * directed path between each pair of nodes belonging to <code>G</code>.
      * The strongly connected components of <code>G</code> are strongly connected
      * subgraphs that <code>G</code> consists of.
      * <b>Complexity:</b> O(graph.N() + graph.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @return {yfiles.algorithms.NodeList[]} 
      * an array of NodeLists each of which contains the nodes that belong to
      * a common connected component of the graph.
      */
      stronglyConnectedComponents(graph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList[];
      /**
      * Returns the connected components of a given graph.
      * A graph <code>G</code> is called strongly connected if there is an
      * directed path between each pair of nodes belonging to <code>G</code>.
      * The strongly connected components of <code>G</code> are strongly connected
      * subgraphs that <code>G</code> consists of.
      * <b>Complexity:</b> O(graph.N() + graph.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.INodeMap} compNum 
      * return value that will hold the zero-based number
      * of the strongly connected component that it belongs to. The component number of
      * Node <code>v</code> is <code>compNum.getInt()</code>.
      * @return {number} the number of strongly connected components of this graph.
      */
      stronglyConnectedComponentsWithIndex(graph:yfiles.algorithms.Graph,compNum:yfiles.algorithms.INodeMap):number;
      /**
      * Checks whether or not the given graph is strongly connected.
      */
      isStronglyConnected(graph:yfiles.algorithms.Graph):boolean;
    };
    /**
    * Common base type for both {@link yfiles.algorithms.Node} and {@link yfiles.algorithms.Edge}.
    * This type does not add public functionality to its base type.
    */
    export interface GraphObject extends Object{
    }
    var GraphObject:{
      $class:yfiles.lang.Class;
    };
    /**
    * An event which indicates that a graph structure change occurred.
    * This low-level event is generated by a graph when its structure changes.
    * The event is passed to every {@link yfiles.algorithms.IGraphListener} object that registered to
    * receive such events using the graph's
    * {@link yfiles.algorithms.Graph#addGraphListener  addGraphListener} method.
    * The object that implements the GraphListener interface gets this GraphEvent when
    * the event occurs.
    * Each GraphEvent has a type that signals what kind of change occurred in the graph
    * and a data object that is the object (either node or edge) that was involved
    * in the structural change of the graph, e.g., the node that has been created or
    * the edge that has been reversed.
    */
    export interface GraphEvent extends Object{
      /**
      * The type of this GraphEvent.
      * It can be either of the type constants defined in this class.
      */
      type:yfiles.algorithms.GraphEventType;
      /**
      * The data object associated with this graph event.
      * For a "Node"-associated event, it returns an object of type y.base.Node.
      * For an "Edge"-associated event, it returns an object of type y.base.Edge.
      * To check the type of event, see the method getType()
      */
      data:Object;
      /**
      * The graph that is the emitter of this event.
      */
      graph:yfiles.algorithms.Graph;
      /**
      * Returns a String representation of this GraphEvent object's type.
      */
      toString():string;
    }
    var GraphEvent:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new GraphEvent instance with given type and data.
      */
      new (source:yfiles.algorithms.Graph,type:yfiles.algorithms.GraphEventType,data:Object):yfiles.algorithms.GraphEvent;
    };
    /**
    * A general interface for iterating over a collection of objects.
    * It can be regarded as a read-only view of such a collection.
    * A YCursor acts like a movable pointer on the elements of a collection.
    * The pointer can be moved forward and backward and the element currently pointed
    * on can be accessed.
    * The removal of elements can only be performed on the provider of the cursor,
    * not on the cursor itself.
    * (That's why the cursor presents a read-only view.)
    * Implementations of this interface do not need to support operations marked "optional."
    */
    export interface ICursor extends Object{
      /**
      * <code>true</code> if the current cursor position is valid.
      * @see Specified by {@link yfiles.algorithms.ICursor#ok}.
      */
      ok:boolean;
      /**
      * Moves this cursor one position forward.
      * @see Specified by {@link yfiles.algorithms.ICursor#next}.
      */
      next():void;
      /**
      * Moves this cursor one position backward (optional).
      * @see Specified by {@link yfiles.algorithms.ICursor#prev}.
      */
      prev():void;
      /**
      * Moves this cursor to the first valid cursor position (optional).
      * @see Specified by {@link yfiles.algorithms.ICursor#toFirst}.
      */
      toFirst():void;
      /**
      * Moves this cursor to the last valid cursor position (optional).
      * @see Specified by {@link yfiles.algorithms.ICursor#toLast}.
      */
      toLast():void;
      /**
      * The object currently pointed on.
      * @see Specified by {@link yfiles.algorithms.ICursor#current}.
      */
      current:Object;
      /**
      * The number of elements that can be accessed with this cursor.
      * @see Specified by {@link yfiles.algorithms.ICursor#size}.
      */
      size:number;
    }
    var ICursor:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * An interface that describes the structural information of a graph and the data
    * that is associated with its nodes and edges.
    */
    export interface IGraphInterface extends Object{
      /**
      * Returns an iterator that provides access to all nodes residing in the graph.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#nodeObjects}.
      */
      nodeObjects():yfiles.algorithms.IIterator;
      /**
      * Returns an iterator that provides access to all edges residing in the graph.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#edgeObjects}.
      */
      edgeObjects():yfiles.algorithms.IIterator;
      /**
      * Returns the source node associated with the given edge.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#getSource}.
      */
      getSource(edgeObject:Object):Object;
      /**
      * Returns the target node associated with the given edge.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#getTarget}.
      */
      getTarget(edgeObject:Object):Object;
      /**
      * Returns the data provider that is registered with the graph using the given
      * look-up key.
      * The look-up domain of a returned data provider normally consists of either
      * the nodes of the graph, or its edges, or both.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#getDataProvider}.
      */
      getDataProvider(dataKey:Object):yfiles.algorithms.IDataProvider;
      /**
      * An array of all data provider look-up keys that are registered with
      * the graph.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#dataProviderKeys}.
      */
      dataProviderKeys:Object[];
    }
    var IGraphInterface:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Provides access to data associated with an edge.
    * An edge map can be considered as a map that allows
    * only edges as keys. Edge keys of an edge map must belong
    * to the same graph.
    * There are data access methods defined for the most common typed
    * values as well.
    * The edge values are initialized with Java(TM) default values
    * (null, 0, 0.0, false) upon initialization.
    */
    export interface IEdgeMap extends Object,yfiles.algorithms.IDataProvider,yfiles.algorithms.IDataAcceptor,yfiles.algorithms.IDataMap{
      /**
      * Associates the given value to the given edge.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#set}.
      */
      set(edge:Object,value:Object):void;
      /**
      * Returns the value bound to the given edge.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#get}.
      */
      get(edge:Object):Object;
      /**
      * Associates the given boolean value to the given edge.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#setBool}.
      */
      setBool(edge:Object,value:boolean):void;
      /**
      * Returns the boolean value bound to the given edge.
      * <b>Precondition:</b> 
      * The value must have been associated to the given edge by
      * a call to {@link yfiles.algorithms.IEdgeMap#setBool  setBool}.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#getBool}.
      */
      getBool(edge:Object):boolean;
      /**
      * Associates the given double value to the given edge.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#setDouble}.
      */
      setDouble(edge:Object,value:number):void;
      /**
      * Returns the double value bound to the given edge.
      * <b>Precondition:</b> 
      * The value must have been associated to the given edge by
      * a call to {@link yfiles.algorithms.IEdgeMap#setDouble  setDouble}.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#getDouble}.
      */
      getDouble(edge:Object):number;
      /**
      * Associates the given integer value to the given edge.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#setInt}.
      */
      setInt(edge:Object,value:number):void;
      /**
      * Returns the integer value bound to the given edge.
      * <b>Precondition:</b> 
      * The value must have been associated to the given edge by
      * a call to {@link yfiles.algorithms.IEdgeMap#setInt  setInt}.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#getInt}.
      */
      getInt(edge:Object):number;
    }
    var IEdgeMap:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * The listener interface for receiving graph events.
    * A class that is interested in processing a graph event implements this interface.
    * The object created with that class is then registered with a graph.
    * When the graph structure changes, the listener object's
    * {@link yfiles.algorithms.IGraphListener#onGraphEvent  onGraphEvent} method is invoked.
    * The listener object's onGraphEvent method is also invoked on so-called PRE and
    * POST events emitted by the graph.
    * These events signal that a (possibly empty) sequence of graph events is about
    * to be emitted (PRE event) or that the sequence is completed (POST event).
    * For example, if a node is about to be removed from a graph, then the following
    * sequence of graph events can be observed:
    * <ul>
    * <li>
    * a PRE event
    * </li>
    * <li>
    * a (possibly empty) sequence of edge removal events
    * </li>
    * <li>
    * the actual node removal event
    * </li>
    * <li>
    * a POST event
    * </li>
    * </ul>
    * The POST event concludes the logically coherent sequence of structural graph
    * changes that has been opened by the PRE event.
    * PRE and POST events must constitute a well-formed bracket-structure, e.g.,
    * ( ( () ) () ).
    */
    export interface IGraphListener extends Object{
      /**
      * Invoked when the structure of the graph has changed.
      * The code written for this method performs the operations that need to occur
      * when the graph changes.
      * @see Specified by {@link yfiles.algorithms.IGraphListener#onGraphEvent}.
      */
      onGraphEvent(e:yfiles.algorithms.GraphEvent):void;
    }
    var IGraphListener:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Interface that combines the {@link yfiles.algorithms.IDataProvider} and {@link yfiles.algorithms.IDataAcceptor}
    * interfaces.
    * This interface does not declare any additional methods.
    */
    export interface IDataMap extends Object,yfiles.algorithms.IDataProvider,yfiles.algorithms.IDataAcceptor{
    }
    var IDataMap:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * A general interface for setting data.
    * A data acceptor associates data with data holders.
    * It constitutes a write-only view on particular data.
    */
    export interface IDataAcceptor extends Object{
      /**
      * Sets an object value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataAcceptor#set}.
      */
      set(dataHolder:Object,value:Object):void;
      /**
      * Sets an integer value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataAcceptor#setInt}.
      */
      setInt(dataHolder:Object,value:number):void;
      /**
      * Sets a double value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataAcceptor#setDouble}.
      */
      setDouble(dataHolder:Object,value:number):void;
      /**
      * Sets a boolean value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataAcceptor#setBool}.
      */
      setBool(dataHolder:Object,value:boolean):void;
    }
    var IDataAcceptor:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * A cursor interface for iterating over edges.
    */
    export interface IEdgeCursor extends Object,yfiles.algorithms.ICursor{
      /**
      * The edge at the current location of the cursor.
      * This method is the typed variant of {@link yfiles.algorithms.ICursor#current}.
      * @see Specified by {@link yfiles.algorithms.IEdgeCursor#edge}.
      */
      edge:yfiles.algorithms.Edge;
      /**
      * Moves the cursor to the cyclic next element of the underlying sequence.
      * This is the next element if available, else it is the first element.
      * @see Specified by {@link yfiles.algorithms.IEdgeCursor#cyclicNext}.
      */
      cyclicNext():void;
      /**
      * Moves the cursor to the cyclic previous element of the underlying sequence.
      * This is the previous element if available, else it is the last element.
      * @see Specified by {@link yfiles.algorithms.IEdgeCursor#cyclicPrev}.
      */
      cyclicPrev():void;
    }
    var IEdgeCursor:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * A general interface for data provision.
    * A data provider grants access to data associated
    * with one or more data holders. It constitutes a read-only
    * view on particular data.
    */
    export interface IDataProvider extends Object{
      /**
      * Returns an object value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#get}.
      */
      get(dataHolder:Object):Object;
      /**
      * Returns an integer value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#getInt}.
      */
      getInt(dataHolder:Object):number;
      /**
      * Returns a double value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#getDouble}.
      */
      getDouble(dataHolder:Object):number;
      /**
      * Returns a boolean value associated with the given data holder.
      * This method may throw an UnsupportedOperationException.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#getBool}.
      */
      getBool(dataHolder:Object):boolean;
    }
    var IDataProvider:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Responsible for finding paths within a graph that have
    * certain properties.
    */
    export interface Paths extends Object{
    }
    var Paths:{
      $class:yfiles.lang.Class;
      /**
      * Returns an edge list that contains the edges of a path
      * from the given start node to the given end node,
      * if such a path exists.
      * The edges are returned in the
      * order they appear in the found path.
      * If the returned path is empty then no path between the
      * given nodes was found.
      * <b>Precondition:</b> startNode != endNode
      * <b>Complexity:</b> O(graph.N() + graph.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.Node} startNode the first node of the path
      * @param {yfiles.algorithms.Node} endNode the last node of the path
      * @param {boolean} directed whether to search for a directed or undirected path
      */
      findPath(graph:yfiles.algorithms.Graph,startNode:yfiles.algorithms.Node,endNode:yfiles.algorithms.Node,directed:boolean):yfiles.algorithms.EdgeList;
      /**
      * Returns an edge list that contains the edges of a
      * undirected simple path within the given graph.
      * The edges are returned in the order they appear in the found path.
      * A heuristic is used to find a path that is long.
      * It is not guaranteed though that the returned path is
      * actually the longest path within the given graph, since that is
      * a well known hard to solve problem.
      * <b>Complexity:</b> O(graph.N() + graph.E())
      * <b>Precondition:</b> GraphChecker.isSimple(graph);
      */
      findLongPath(graph:yfiles.algorithms.Graph):yfiles.algorithms.EdgeList;
      /**
      * Calculates the longest path from one vertex to all other vertices
      * in a given acyclic graph.
      * <b>Precondition:</b> GraphCheckers.isAcyclic(g)
      * @param {yfiles.algorithms.Graph} g a directed acyclic graph.
      * @param {yfiles.algorithms.Node} startNode the node, for which the distances are calculated.
      * @param {yfiles.algorithms.IEdgeMap} dist the distances for the edges.
      * @param {yfiles.algorithms.INodeMap} maxDist here the result will be stored.
      * @param {yfiles.algorithms.IEdgeMap} predicate only edges for which predicate is true are considered.
      */
      findLongestPaths(g:yfiles.algorithms.Graph,startNode:yfiles.algorithms.Node,dist:yfiles.algorithms.IEdgeMap,maxDist:yfiles.algorithms.INodeMap,predicate:yfiles.algorithms.IEdgeMap):void;
      /**
      * Returns the longest directed path within the given acyclic graph.
      * <b>Precondition:</b> GraphChecker.isAcyclic(g)
      * @param {yfiles.algorithms.Graph} g a directed acyclic graph
      * @return {yfiles.algorithms.EdgeList} 
      * an edge list representing the longest directed path within
      * the given graph
      */
      findLongestPath(g:yfiles.algorithms.Graph):yfiles.algorithms.EdgeList;
      /**
      * Returns the longest directed path within a given acyclic weighted
      * graph.
      * All edges of the graph have an  integral length associated
      * with them. The longest path is defined as one of all
      * directed paths within the graph for which the edge lengths
      * of all contained edges sum up to a maximum.
      * <b>Precondition:</b> GraphChecker.isAcyclic(g)
      * <b>Precondition:</b> edgeLength.getInt(e) > 0 for all edges e of g
      * @param {yfiles.algorithms.Graph} g a directed acyclic graph
      * @param {yfiles.algorithms.IDataProvider} edgeLength 
      * a data provider that must provide the length of each
      * edge as an int value
      * @return {yfiles.algorithms.EdgeList} 
      * an edge list representing the longest directed path within
      * the given graph
      */
      findLongestPathWithEdgeLength(g:yfiles.algorithms.Graph,edgeLength:yfiles.algorithms.IDataProvider):yfiles.algorithms.EdgeList;
      /**
      * Constructs a node path from a given edge path.
      * The returned node path
      * has length <code>path.size()+1</code>, if the given path is not empty.
      * Otherwise the returned path will be empty. The i-th node in the
      * returned path will be either source or target node of the i-th edge
      * in the given path.
      */
      constructNodePath(path:yfiles.algorithms.EdgeList):yfiles.algorithms.NodeList;
      /**
      * Returns whether or not there is a directed path from one node to another node
      * in an acyclic graph.
      * <b>Precondition:</b> GraphChecker.isAcyclic(g)
      * @param {yfiles.algorithms.Graph} g the acyclic graph which contains the two nodes.
      * @param {yfiles.algorithms.NodeList} topSort a topological sorting of the nodes of the graph.
      * @param {yfiles.algorithms.IEdgeMap} predicate only edges for which predicate is true are considered.
      */
      findPathFiltered(g:yfiles.algorithms.Graph,topSort:yfiles.algorithms.NodeList,startNode:yfiles.algorithms.Node,endNode:yfiles.algorithms.Node,predicate:yfiles.algorithms.IEdgeMap):boolean;
      /**
      * Marks all edges that belong to a directed path from <code>start</code> to <code>end</code> node.
      * <b>Complexity:</b> O(g.N()+g.E())
      * @param {yfiles.algorithms.Graph} g the input graph
      * @param {yfiles.algorithms.Node} start the start node
      * @param {yfiles.algorithms.Node} end the end node
      * @param {yfiles.algorithms.IEdgeMap} pathEdges 
      * the result. For each edge a boolean value will indicate whether or not
      * it belongs to a path connecting the two nodes.
      */
      findAllPathsToEdgeMap(g:yfiles.algorithms.Graph,start:yfiles.algorithms.Node,end:yfiles.algorithms.Node,pathEdges:yfiles.algorithms.IEdgeMap):void;
      /**
      * Returns all chains present in the given graph.
      * A chain in a graph is
      * a paths of maximal length, where each internal node on the path has degree 2.
      * The internal nodes on directed chains all have in-degree 1 and out-degree 1.
      * <b>Complexity:</b> O(g.N()+g.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @return {yfiles.algorithms.EdgeList[]} 
      * an array of EdgeList objects, each of which has at least length 2.
      * An edge list contains the edges that make up a chain. Method
      * {@link yfiles.algorithms.Paths#constructNodePath} can be used to convert an edge path
      * to a node path.
      */
      findAllChains(graph:yfiles.algorithms.Graph,directed:boolean):yfiles.algorithms.EdgeList[];
      /**
      * Returns all simple directed or undirected paths that connect <code>start</code> with <code>end</code> node.
      * One should note that the number of different paths connecting two nodes can be exponential
      * in number of nodes and edges of a given graph. This said, even for small graphs the runtime and memory
      * consumption of the algorithm can be excessive. To significantly lower memory consumption use
      * {@link yfiles.algorithms.Paths#findAllPathsCursor} instead.
      * <b>Complexity:</b> O(2^(g.N()+g.E()))
      * <b>Precondition:</b> graph, startNode, and endNode may not be <code>null</code>.
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.Node} startNode the start node
      * @param {yfiles.algorithms.Node} endNode the end node
      * @param {boolean} directed whether or not to consider the edges in the graph to be directed or not.
      * @return {yfiles.algorithms.EdgeList[]} an array of EdgeLists each representing a path between start and end node.
      */
      findAllPaths(graph:yfiles.algorithms.Graph,startNode:yfiles.algorithms.Node,endNode:yfiles.algorithms.Node,directed:boolean):yfiles.algorithms.EdgeList[];
      /**
      * A variant of {@link yfiles.algorithms.Paths#findAllPaths}
      * that returns its result not as a list but as a special cursor that calculates
      * the next path in the sequence only when needed.
      * The returned cursor only supports the operation {@link yfiles.algorithms.ICursor#ok},
      * {@link yfiles.algorithms.ICursor#current}, {@link yfiles.algorithms.ICursor#size} and {@link yfiles.algorithms.ICursor#next}.
      */
      findAllPathsCursor(graph:yfiles.algorithms.Graph,startNode:yfiles.algorithms.Node,endNode:yfiles.algorithms.Node,directed:boolean):yfiles.algorithms.ICursor;
      /**
      * A variant of {@link yfiles.algorithms.Paths#findAllPaths}
      * that additionally allows to specify a filter for the paths to be returned.
      * @param {function(yfiles.algorithms.EdgeList):boolean} filter a filter that tests for each found EdgeList if it should make it to the result list.
      */
      findAllPathsFiltered(graph:yfiles.algorithms.Graph,startNode:yfiles.algorithms.Node,endNode:yfiles.algorithms.Node,directed:boolean,filter:(obj:yfiles.algorithms.EdgeList)=>boolean):yfiles.algorithms.EdgeList[];
    };
    /**
    * This class provides access to some Comparator instances
    * that are commonly used in yFiles.
    */
    export interface Comparators extends Object{
    }
    export module Comparators{
      /**
      * Tag interface to mark comparator or comparable implementations that do not
      * define a total order but only a partial order. Implementations tagged with this
      * interface use a special sorting algorithm that does not throw <code>IllegalArgumentException</code>
      * if the specified comparator used for sorting does not define a total order.
      * @see {@link yfiles.algorithms.Comparators#sort}
      * @see {@link yfiles.algorithms.Comparators#sortListWithComparer}
      * @see {@link yfiles.algorithms.Comparators#sortArrayPartWithComparer}
      */
      export interface IPartialOrder extends Object{
      }
    }
    var Comparators:{
      $class:yfiles.lang.Class;
      /**
      * Returns a comparator that compares objects of type
      * {@link yfiles.algorithms.Edge}.
      * Two edges are compared by comparing their
      * source nodes. Each source node <code>e.source()</code> in turn
      * is compared by the int value provided by the given data provider:
      * <code>dp.getInt(e.source())</code>.
      * @param {yfiles.algorithms.IDataProvider} dp 
      * a data provider that must return an int value for
      * the source node of each edge being compared.
      * @return {yfiles.objectcollections.IComparer} a comparator that compares edges.
      */
      createIntDataSourceComparator(dp:yfiles.algorithms.IDataProvider):yfiles.objectcollections.IComparer;
      /**
      * Returns a comparator that compares objects of type
      * {@link yfiles.algorithms.Edge}.
      * Two edges are compared by comparing their
      * target nodes. Each target node <code>e.target()</code> in turn
      * is compared by the int value provided by the given data provider:
      * <code>dp.getInt(e.target())</code>.
      * @param {yfiles.algorithms.IDataProvider} dp 
      * a data provider that must return an int value for
      * the target node of each edge being compared.
      * @return {yfiles.objectcollections.IComparer} a comparator that compares edges.
      */
      createIntDataTargetComparator(dp:yfiles.algorithms.IDataProvider):yfiles.objectcollections.IComparer;
      /**
      * Returns a comparator that compares objects of type
      * {@link yfiles.algorithms.Edge}.
      * Two edges are compared by comparing their
      * source nodes. Each source node <code>e.source()</code> in turn
      * is compared by the double value provided by the given data provider:
      * <code>dp.getDouble(e.source())</code>.
      * @param {yfiles.algorithms.IDataProvider} dp 
      * a data provider that must return a double value for
      * the source node of each edge being compared.
      * @return {yfiles.objectcollections.IComparer} a comparator that compares edges.
      */
      createDoubleDataSourceComparator(dp:yfiles.algorithms.IDataProvider):yfiles.objectcollections.IComparer;
      /**
      * Returns a comparator that compares objects of type
      * {@link yfiles.algorithms.Edge}.
      * Two edges are compared by comparing their
      * target nodes. Each target node <code>e.target()</code> in turn
      * is compared by the double value provided by the given data provider:
      * <code>dp.getDouble(e.target())</code>.
      * @param {yfiles.algorithms.IDataProvider} dp 
      * a data provider that must return a double value for
      * the target node of each edge being compared.
      * @return {yfiles.objectcollections.IComparer} a comparator that compares edges.
      */
      createDoubleDataTargetComparator(dp:yfiles.algorithms.IDataProvider):yfiles.objectcollections.IComparer;
      /**
      * Returns a comparator that compares objects of arbitrary type.
      * Two objects are compared by comparing the int value the given
      * data provider returns for each of these objects.
      * @param {yfiles.algorithms.IDataProvider} dp 
      * a data provider that must return an int value for
      * each object that is being compared by this comparator.
      * @return {yfiles.objectcollections.IComparer} a comparator that compares arbitrary objects.
      */
      createIntDataComparator(dp:yfiles.algorithms.IDataProvider):yfiles.objectcollections.IComparer;
      /**
      * Returns a comparator that compares objects of arbitrary type.
      * Two objects are compared by comparing the double value the given
      * data provider returns for each of these objects.
      * @param {yfiles.algorithms.IDataProvider} dp 
      * a data provider that must return a double value for
      * each object that is being compared by this comparator.
      * @return {yfiles.objectcollections.IComparer} a comparator that compares arbitrary objects.
      */
      createDoubleDataComparator(dp:yfiles.algorithms.IDataProvider):yfiles.objectcollections.IComparer;
      /**
      * Returns a comparator that compares to Objects of type
      * Comparable.
      */
      createComparableComparator():yfiles.objectcollections.IComparer;
      /**
      * Returns a comparator that compares objects of arbitrary type.
      * Two objects are compared by comparing the <code>Comparable</code> instances
      * the given data provider returns for each of these objects.
      * @param {yfiles.algorithms.IDataProvider} dp 
      * a data provider that must return a Comparable for
      * each object that is being compared by this comparator.
      * @return {yfiles.objectcollections.IComparer} a comparator that compares arbitrary objects.
      */
      createComparableDataComparator(dp:yfiles.algorithms.IDataProvider):yfiles.objectcollections.IComparer;
      /**
      * Compares the specified integral numbers.
      * Returns a negative integer, zero, or a positive integer as the first
      * argument is less than, equal to, or greater than the second.
      * @param {number} i1 the first number to compare.
      * @param {number} i2 the second number to compare.
      * @return {number} 
      * a negative integer, zero, or a positive integer as the first
      * argument is less than, equal to, or greater than the second.
      * @see {@link yfiles.objectcollections.IComparer#compare}
      */
      compareInts(i1:number,i2:number):number;
      /**
      * Compares the specified integral numbers.
      * Returns a negative integer, zero, or a positive integer as the first
      * argument is less than, equal to, or greater than the second.
      * @param {number} l1 the first number to compare.
      * @param {number} l2 the second number to compare.
      * @return {number} 
      * a negative integer, zero, or a positive integer as the first
      * argument is less than, equal to, or greater than the second.
      * @see {@link yfiles.objectcollections.IComparer#compare}
      */
      compareLongs(l1:number,l2:number):number;
      /**
      * Compares the specified floating point numbers.
      * Returns a negative integer, zero, or a positive integer as the first
      * argument is less than, equal to, or greater than the second.
      * <p>
      * <b>Warning:</b> This method does <b>not</b> handle <code>NaN</code>!
      * If you need <code>NaN</code>-safe comparison, use
      * {@link yfiles.system.PrimitiveExtensions#compareNumbers} instead.
      * </p>
      * @param {number} f1 the first number to compare.
      * @param {number} f2 the second number to compare.
      * @return {number} 
      * a negative integer, zero, or a positive integer as the first
      * argument is less than, equal to, or greater than the second.
      * @see {@link yfiles.objectcollections.IComparer#compare}
      */
      compareFloats(f1:number,f2:number):number;
      /**
      * Compares the specified floating point numbers.
      * Returns a negative integer, zero, or a positive integer as the first
      * argument is less than, equal to, or greater than the second.
      * <p>
      * <b>Warning:</b> This method does <b>not</b> handle <code>NaN</code>!
      * If you need <code>NaN</code>-safe comparison, use
      * {@link yfiles.system.PrimitiveExtensions#compareNumbers} instead.
      * </p>
      * @param {number} d1 the first number to compare.
      * @param {number} d2 the second number to compare.
      * @return {number} 
      * a negative integer, zero, or a positive integer as the first
      * argument is less than, equal to, or greater than the second.
      * @see {@link yfiles.objectcollections.IComparer#compare}
      */
      compareDoubles(d1:number,d2:number):number;
      /**
      * Sorts the specified list of objects according to the order induced by
      * the specified comparator.
      * <p>
      * This sort is guaranteed to be <em>stable</em>:
      * Equal elements will not be reordered as a result of the sort.
      * </p><p>
      * Implementation note:
      * If the comparator is marked with the
      * {@link yfiles.algorithms.Comparators.IPartialOrder}
      * interface,
      * this implementation does not throw <code>IllegalArgumentException</code>
      * if the specified comparator used for sorting does not define a total order.
      * </p>
      * @param {yfiles.algorithms.IList} data the list to be sorted.
      * @param {yfiles.objectcollections.IComparer} c 
      * the comparator to determine the order of the list.
      * A <code>null</code> value indicates that the elements'
      * {@link yfiles.lang.IObjectComparable  natural ordering} should be used.
      * @see {@link yfiles.algorithms.Comparators.IPartialOrder}
      */
      sortListWithComparer(data:yfiles.algorithms.IList,c:yfiles.objectcollections.IComparer):void;
      /**
      * Sorts the specified array of objects according to the order induced by
      * the specified comparator.
      * <p>
      * This sort is guaranteed to be <em>stable</em>:
      * Equal elements will not be reordered as a result of the sort.
      * </p><p>
      * Implementation note:
      * If the comparator is marked with the
      * {@link yfiles.algorithms.Comparators.IPartialOrder}
      * interface,
      * this implementation does not throw <code>IllegalArgumentException</code> if the
      * specified comparator used for sorting does not define a total order.
      * </p>
      * @param {Object} data the array to be sorted.
      * @param {yfiles.objectcollections.IComparer} c 
      * the comparator to determine the order of the array.
      * A <code>null</code> value indicates that the elements'
      * {@link yfiles.lang.IObjectComparable  natural ordering} should be used.
      * @see {@link yfiles.algorithms.Comparators.IPartialOrder}
      */
      sort(data:Object,c:yfiles.objectcollections.IComparer):void;
      /**
      * Sorts the specified array of objects according to the order induced by
      * the specified comparator.
      * <p>
      * This sort is guaranteed to be <em>stable</em>:
      * Equal elements will not be reordered as a result of the sort.
      * </p><p>
      * Implementation note:
      * If the comparator is marked with the
      * {@link yfiles.algorithms.Comparators.IPartialOrder}
      * interface,
      * this implementation does not throw <code>IllegalArgumentException</code>
      * if the specified comparator used for sorting does not define a total order.
      * </p>
      * @param {Object} data the array to be sorted.
      * @param {number} fromIndex the index of the first element (inclusive) to be sorted.
      * @param {number} toIndex the index of the last element (exclusive) to be sorted.
      * @param {yfiles.objectcollections.IComparer} c 
      * the comparator to determine the order of the array.
      * A <code>null</code> value indicates that the elements'
      * {@link yfiles.lang.IObjectComparable  natural ordering} should be used.
      * @throws {yfiles.system.ArgumentException} if <code>fromIndex &gt; toIndex</code>.
      * @throws {yfiles.system.IndexOutOfRangeException} 
      * if <code>fromIndex &lt; 0</code> or
      * <code>toIndex &gt; a.length</code>.
      * @see {@link yfiles.algorithms.Comparators.IPartialOrder}
      */
      sortArrayPartWithComparer(data:Object,fromIndex:number,toIndex:number,c:yfiles.objectcollections.IComparer):void;
    };
    /**
    * Provides utility methods for working with {@link yfiles.algorithms.ICursor  cursors}
    * and {@link yfiles.algorithms.IIterator  iterators}.
    */
    export interface Cursors extends Object{
    }
    var Cursors:{
      $class:yfiles.lang.Class;
      /**
      * Creates or fills an array with the values provided by the cursor.
      * @param {yfiles.algorithms.ICursor} cursor the cursor
      * @param {Object[]} dest 
      * the array to fill with the values or <code>null</code> if the
      * method should create the array itself
      * @return {Object[]} dest or a newly created array filled with the values from cursor
      */
      toArray(cursor:yfiles.algorithms.ICursor,dest:Object[]):Object[];
      /**
      * Creates a YCursor view of the given collection.
      * Note that the returned cursor does not support the
      * {@link yfiles.algorithms.ICursor#prev  prev} and {@link yfiles.algorithms.ICursor#toLast  toLast}
      * operations.
      * @param {yfiles.algorithms.ICollection} c The collection.
      * @return {yfiles.algorithms.ICursor} The cursor view of the given collection.
      * @see {@link yfiles.algorithms.Cursors#createEdgeCursor}
      * @see {@link yfiles.algorithms.Cursors#createNodeCursor}
      */
      createCursorFromCollection(c:yfiles.algorithms.ICollection):yfiles.algorithms.ICursor;
      /**
      * Creates a cursor view of the given collection.
      * Creates an ICursor view of the given collection.
      * Note that the returned cursor does not support the
      * {@link yfiles.algorithms.ICursor#prev prev}
      * and
      * {@link yfiles.algorithms.ICursor#toLast toLast}
      * operations.
      * @param {yfiles.collections.ICollection.<T>} c 
      * The collection.
      * @return {yfiles.algorithms.ICursor} 
      * The cursor view of the given collection.
      */
      createCursor<T>(c:yfiles.collections.ICollection<T>):yfiles.algorithms.ICursor;
      /**
      * Creates a cursor view of the given collection.
      * <p>
      * Note that the returned cursor does not support the operations
      * {@link yfiles.algorithms.ICursor#prev  prev},
      * {@link yfiles.algorithms.ICursor#toLast  toLast}, and
      * {@link yfiles.algorithms.IEdgeCursor#cyclicPrev}.
      * </p>
      * @param {yfiles.algorithms.ICollection} c The collection.
      * @return {yfiles.algorithms.IEdgeCursor} 
      * an {@link yfiles.algorithms.IEdgeCursor} view of the given collection.
      * @see {@link yfiles.algorithms.Cursors#createNodeCursor}
      */
      createEdgeCursor(c:yfiles.algorithms.ICollection):yfiles.algorithms.IEdgeCursor;
      /**
      * Creates a cursor view of the given collection.
      * <p>
      * Note that the returned cursor does not support the operations
      * {@link yfiles.algorithms.ICursor#prev  prev},
      * {@link yfiles.algorithms.ICursor#toLast  toLast}, and
      * {@link yfiles.algorithms.INodeCursor#cyclicPrev}.
      * </p>
      * @param {yfiles.algorithms.ICollection} c The collection.
      * @return {yfiles.algorithms.INodeCursor} 
      * an {@link yfiles.algorithms.INodeCursor} view of the given collection.
      * @see {@link yfiles.algorithms.Cursors#createEdgeCursor}
      */
      createNodeCursor(c:yfiles.algorithms.ICollection):yfiles.algorithms.INodeCursor;
      /**
      * Creates a first-to-last <code>Iterator</code> view of the given cursor.
      * <p>
      * Note that the returned iterator does not support the
      * {@link yfiles.algorithms.IIterator#remove  remove} operation.
      * </p>
      * @param {yfiles.algorithms.ICursor} cursor The cursor.
      * @return {yfiles.algorithms.IIterator} The iterator view of the given cursor.
      */
      createIterator(cursor:yfiles.algorithms.ICursor):yfiles.algorithms.IIterator;
      /**
      * Creates a last-to-first <code>Iterator</code> view of the given cursor.
      * <p>
      * Note that the returned iterator does not support the
      * {@link yfiles.algorithms.IIterator#remove  remove} operation.
      * </p>
      * @param {yfiles.algorithms.ICursor} cursor The cursor.
      * @return {yfiles.algorithms.IIterator} The iterator view of the given cursor.
      */
      createReverseIterator(cursor:yfiles.algorithms.ICursor):yfiles.algorithms.IIterator;
      /**
      * Creates a new cursor that provides a logical view
      * on the concatenation of the two given cursors.
      * @param {yfiles.algorithms.ICursor} c1 - first concatenation argument
      * @param {yfiles.algorithms.ICursor} c2 - second concatenation argument
      */
      concatenate(c1:yfiles.algorithms.ICursor,c2:yfiles.algorithms.ICursor):yfiles.algorithms.ICursor;
    };
    /**
    * This class provides convenience and transformation services for DataProviders.
    */
    export interface DataProviders extends Object{
    }
    export module DataProviders{
      /**
      * This helper class can be used to overlay DataProviders registered at a graph
      * with another DataProvider.
      */
      export interface DataProviderOverlayManager extends Object{
        /**
        * Adds the given DataProvider under the given key to the graph.
        * Stores the previously set
        * DataProvider instance so it can be restored at a later time using method {{@link yfiles.algorithms.DataProviders.DataProviderOverlayManager#restoreOriginalDataProviders}.
        */
        addDataProvider(dataProviderKey:Object,newDataProvider:yfiles.algorithms.IDataProvider):void;
        /**
        * Restores all DataProvider bindings that have been changed using {{@link yfiles.algorithms.DataProviders.DataProviderOverlayManager#addDataProvider}.
        * Calling this method resets the state its state.
        */
        restoreOriginalDataProviders():void;
      }
    }
    var DataProviders:{
      $class:yfiles.lang.Class;
      /**
      * Returns a DataProvider view  of a double array defined for edges.
      * The double value <code>data[edge.index()]</code> will be returned
      * by the data provider upon the method call <code>getDouble(edge)</code>.
      * @param {number[]} data array data for each edge of a static graph
      * @return {yfiles.algorithms.IDataProvider} a data provider view of the given array
      */
      createEdgeDataProviderDouble(data:number[]):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider view  of an int array defined for edges.
      * The int value <code>data[edge.index()]</code> will be returned
      * by the data provider upon the method call <code>getInt(edge)</code>.
      * @param {number[]} data array data for each edge of a static graph
      * @return {yfiles.algorithms.IDataProvider} a data provider view of the given array
      */
      createEdgeDataProviderInt(data:number[]):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider view  of a boolean array defined for edges.
      * The boolean value <code>data[edge.index()]</code> will be returned
      * by the data provider upon the method call <code>getBool(edge)</code>.
      * @param {boolean[]} data array data for each edge of a static graph
      * @return {yfiles.algorithms.IDataProvider} a data provider view of the given array
      */
      createEdgeDataProviderBoolean(data:boolean[]):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider view  of an Object array defined for edges.
      * The Object value <code>data[edge.index()]</code> will be returned
      * by the data provider upon the method call <code>get(edge)</code>.
      * @param {Object[]} data array data for each edge of a static graph
      * @return {yfiles.algorithms.IDataProvider} a data provider view of the given array
      */
      createEdgeDataProvider(data:Object[]):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider view  of a double, int, boolean and Object
      * array defined for edges.
      * The double value <code>doubleData[edge.index()]</code> will be returned
      * by the data provider upon the method call <code>getDouble(edge)</code>.
      * The int value <code>intData[edge.index()]</code> will be returned
      * by the data provider upon the method call <code>getInt(edge)</code>.
      * The boolean value <code>boolData[edge.index()]</code> will be returned
      * by the data provider upon the method call <code>getBool(edge)</code>.
      * The Object value <code>objectData[edge.index()]</code> will be returned
      * by the data provider upon the method call <code>get(edge)</code>.
      * @param {number[]} doubleData double data for each edge of a static graph
      * @param {number[]} intData int data for each edge of a static graph
      * @param {boolean[]} boolData boolean data for each edge of a static graph
      * @param {Object[]} objectData Object data for each edge of a static graph
      * @return {yfiles.algorithms.IDataProvider} a data provider view of the given arrays
      */
      createEdgeDataProviderForArrays(doubleData:number[],intData:number[],boolData:boolean[],objectData:Object[]):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider view  of a double array defined for nodes.
      * The double value <code>data[node.index()]</code> will be returned
      * by the data provider upon the method call <code>getDouble(node)</code>.
      * @param {number[]} data array data for each node of a static graph
      * @return {yfiles.algorithms.IDataProvider} a data provider view of the given array
      */
      createNodeDataProviderDouble(data:number[]):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider view  of an int array defined for nodes.
      * The int value <code>data[node.index()]</code> will be returned
      * by the data provider upon the method call <code>getInt(node)</code>.
      * @param {number[]} data array data for each node of a static graph
      * @return {yfiles.algorithms.IDataProvider} a data provider view of the given array
      */
      createNodeDataProviderInt(data:number[]):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider view  of a boolean array defined for nodes.
      * The boolean value <code>data[node.index()]</code> will be returned
      * by the data provider upon the method call <code>getBool(node)</code>.
      * @param {boolean[]} data array data for each node of a static graph
      * @return {yfiles.algorithms.IDataProvider} a data provider view of the given array
      */
      createNodeDataProviderBoolean(data:boolean[]):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider view  of an Object array defined for nodes.
      * The Object value <code>data[node.index()]</code> will be returned
      * by the data provider upon the method call <code>get(node)</code>.
      * @param {Object[]} data array data for each node of a static graph
      * @return {yfiles.algorithms.IDataProvider} a data provider view of the given array
      */
      createNodeDataProvider(data:Object[]):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider view  of a double, int, boolean and Object
      * array defined for nodes.
      * The double value <code>doubleData[node.index()]</code> will be returned
      * by the data provider upon the method call <code>getDouble(node)</code>.
      * The int value <code>intData[node.index()]</code> will be returned
      * by the data provider upon the method call <code>getInt(node)</code>.
      * The boolean value <code>boolData[node.index()]</code> will be returned
      * by the data provider upon the method call <code>getBool(node)</code>.
      * The Object value <code>objectData[node.index()]</code> will be returned
      * by the data provider upon the method call <code>get(node)</code>.
      * @param {number[]} doubleData double data for each node of a static graph
      * @param {number[]} intData int data for each node of a static graph
      * @param {boolean[]} boolData boolean data for each node of a static graph
      * @param {Object[]} objectData Object data for each node of a static graph
      * @return {yfiles.algorithms.IDataProvider} a data provider view of the given arrays
      */
      createNodeDataProviderWithArrays(doubleData:number[],intData:number[],boolData:boolean[],objectData:Object[]):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider that returns the given value for each
      * key.
      * @param {Object} data constant Object data returned by the created data provider.
      * @return {yfiles.algorithms.IDataProvider} a data provider view of a single value.
      */
      createConstantDataProvider(data:Object):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider for edges that return the data provider values
      * bound to their source nodes.
      */
      createSourceDataProvider(nodeData:yfiles.algorithms.IDataProvider):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider for edges that return the data provider values
      * bound to their target nodes.
      */
      createTargetDataProvider(nodeData:yfiles.algorithms.IDataProvider):yfiles.algorithms.IDataProvider;
      /**
      * Returns a DataProvider that returns the negated boolean values
      * provided by another data provider.
      */
      createNegatedDataProvider(data:yfiles.algorithms.IDataProvider):yfiles.algorithms.IDataProvider;
      DataProviderOverlayManager:{
        $class:yfiles.lang.Class;
        /**
        * Creates a data provider overlay for the given graph instance.
        */
        new (graph:yfiles.algorithms.Graph):yfiles.algorithms.DataProviders;
      };
    };
    /**
    * An abstract adapter class for accepting data.
    * The data accepting methods
    * in this class throw a {@link yfiles.system.NotSupportedException} and
    * {@link yfiles.algorithms.DataAcceptorAdapter#defined} always returns <code>false</code>.
    * <p>
    * This class exists as a convenience for creating data acceptor objects.
    * </p><p>
    * Extend this class to access either typed or untyped data for a
    * certain lookup domain.
    * </p>
    */
    export interface DataAcceptorAdapter extends Object,yfiles.algorithms.IDataAcceptor{
      /**
      * Subclasses may override this
      * method to set object values associated with a data holder.
      * @throws {yfiles.system.NotSupportedException} unless overwritten.
      * @see Specified by {@link yfiles.algorithms.IDataAcceptor#set}.
      */
      set(dataHolder:Object,value:Object):void;
      /**
      * Subclasses may override this
      * method to set integer values associated with a data holder.
      * @throws {yfiles.system.NotSupportedException} unless overwritten.
      * @see Specified by {@link yfiles.algorithms.IDataAcceptor#setInt}.
      */
      setInt(dataHolder:Object,value:number):void;
      /**
      * Subclasses may override this
      * method to set double values associated with a data holder.
      * @throws {yfiles.system.NotSupportedException} unless overwritten.
      * @see Specified by {@link yfiles.algorithms.IDataAcceptor#setDouble}.
      */
      setDouble(dataHolder:Object,value:number):void;
      /**
      * Subclasses may override this
      * method to set boolean values associated with a data holder.
      * @throws {yfiles.system.NotSupportedException} unless overwritten.
      * @see Specified by {@link yfiles.algorithms.IDataAcceptor#setBool}.
      */
      setBool(dataHolder:Object,value:boolean):void;
      /**
      * Returns <code>false</code> for all data holders.
      * Subclasses
      * should override this method to make clear for which data holders
      * there is a value accessible via this data provider.
      * @return {boolean} <code>false</code>.
      */
      defined(dataHolder:Object):boolean;
    }
    var DataAcceptorAdapter:{
      $class:yfiles.lang.Class;
    };
    /**
    * An abstract adapter class for providing data.
    * The data provision methods
    * in this class throw a {@link yfiles.system.NotSupportedException} and
    * {@link yfiles.algorithms.DataProviderAdapter#defined} always returns <code>false</code>.
    * <p>
    * This class exists as a convenience for creating data provider objects.
    * </p><p>
    * Extend this class to provide either typed or untyped data for a
    * certain lookup domain.
    * </p>
    */
    export interface DataProviderAdapter extends Object,yfiles.algorithms.IDataProvider{
      /**
      * Subclasses may override this
      * method to provide access to object values.
      * @throws {yfiles.system.NotSupportedException} unless overwritten.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#get}.
      */
      get(dataHolder:Object):Object;
      /**
      * Subclasses may override this
      * method to provide access to integer values.
      * @throws {yfiles.system.NotSupportedException} unless overwritten.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#getInt}.
      */
      getInt(dataHolder:Object):number;
      /**
      * Subclasses may override this
      * method to provide access to double values.
      * @throws {yfiles.system.NotSupportedException} unless overwritten.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#getDouble}.
      */
      getDouble(dataHolder:Object):number;
      /**
      * Subclasses may override this
      * method to provide access to boolean values.
      * @throws {yfiles.system.NotSupportedException} unless overwritten.
      * @see Specified by {@link yfiles.algorithms.IDataProvider#getBool}.
      */
      getBool(dataHolder:Object):boolean;
      /**
      * Returns <code>false</code> for all data holders.
      * Subclasses
      * should override this method to make clear for which data holders
      * there is a value accessible via this data provider.
      * @return {boolean} <code>false</code>.
      */
      defined(dataHolder:Object):boolean;
    }
    var DataProviderAdapter:{
      $class:yfiles.lang.Class;
    };
    /**
    * Implements a priority queue for nodes based on a
    * array with bucket lists.
    * The priority values must be less than a maximal-value
    * which must be provided to the constructor.
    * Certain operations have time-complexity dependent on this value.
    * The priority values of the nodes must be non-negative.
    * While the priority queue is used, the graph must not change.
    */
    export interface ArrayIntNodePQ extends Object,yfiles.algorithms.IIntNodePQ{
      /**
      * Removes all entries from the queue.
      * <b>Complexity:</b> <code>O(maxSize)</code>
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#clear}.
      */
      clear():void;
      /**
      * Specifies whether or not this queue is empty.
      * <b>Complexity:</b> <code>O(1)</code>
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#empty}.
      */
      empty:boolean;
      /**
      * Returns whether or not the given node is contained within this queue.
      * <b>Complexity:</b> <code>O(1)</code>
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#contains}.
      */
      contains(n:yfiles.algorithms.Node):boolean;
      /**
      * Inserts a node into the queue.
      * <b>Complexity:</b> <code>O(1)</code>
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#add}.
      */
      add(n:yfiles.algorithms.Node,value:number):void;
      /**
      * Removes a node from the priority queue.
      * Time complexity in worst-case O(maxSize).
      * <b>Complexity:</b> 
      * Amortized time complexity is O(maxSize), given
      * that the sequence of minimal keys is non-decreasing
      */
      remove(n:yfiles.algorithms.Node):void;
      /**
      * The node with the minimal value in the queue.
      * <b>Complexity:</b> <code>O(1)</code>
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#min}.
      */
      min:yfiles.algorithms.Node;
      /**
      * Decreases the value of a node in the queue to a certain value.
      * <b>Complexity:</b> <code>O(1)</code>
      * @param {yfiles.algorithms.Node} n a node in the priority queue.
      * @param {number} value the new priority value of the node.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#decreasePriority}.
      */
      decreasePriority(n:yfiles.algorithms.Node,value:number):void;
      /**
      * Increases the value of a node in the queue to a certain value.
      * <b>Complexity:</b> O(1).
      * @param {yfiles.algorithms.Node} n a node in the priority queue.
      * @param {number} value the new priority value of the node.
      */
      increasePriority(n:yfiles.algorithms.Node,value:number):void;
      /**
      * Changes the value of a node in the queue to a certain value.
      * <b>Complexity:</b> O(1).
      * @param {yfiles.algorithms.Node} n a node in the priority queue.
      * @param {number} value the new priority value of the node.
      */
      changePriority(n:yfiles.algorithms.Node,value:number):void;
      /**
      * Removes the node with the minimal value from the queue.
      * Time complexity like {@link yfiles.algorithms.ArrayIntNodePQ#remove}.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#removeMin}.
      */
      removeMin():yfiles.algorithms.Node;
      /**
      * Returns the current priority of the given node.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#getPriority}.
      */
      getPriority(v:yfiles.algorithms.Node):number;
      /**
      * Disposes this queue.
      * It is important to call this method after the queue
      * is not needed anymore, to free bound resources.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#dispose}.
      */
      dispose():void;
      /**
      * Returns the list for a given slot.
      * If there is no list yet, create one.
      */
      getList(value:number):yfiles.algorithms.YList;
    }
    var ArrayIntNodePQ:{
      $class:yfiles.lang.Class;
      /**
      * Returns an empty Priority-Queue.
      * @param {yfiles.algorithms.Graph} _graph the graph which contains the nodes
      * @param {number} maxSize the maximum value of a node in the priority queue
      */
      new (_graph:yfiles.algorithms.Graph,maxSize:number):yfiles.algorithms.ArrayIntNodePQ;
      /**
      * Returns a new Priority-Queue initialized with all nodes of the graph.
      * @param {yfiles.algorithms.Graph} _graph the graph which contains the nodes
      * @param {yfiles.algorithms.IDataProvider} _initValues the initial priority values of the nodes.
      */
      WithInitValues:{
        new (_graph:yfiles.algorithms.Graph,_initValues:yfiles.algorithms.IDataProvider):yfiles.algorithms.ArrayIntNodePQ;
      };
      /**
      * Returns an empty Priority-Queue.
      * This constructor takes a <code>NodeMap</code> as argument
      * which is used to store the priority values.
      * @param {yfiles.algorithms.Graph} _graph the graph which contains the nodes
      * @param {yfiles.algorithms.INodeMap} _valueMap here the priority values are stored
      * @param {number} maxSize the maximum value of a node in the priority queue
      */
      WithValueMapAndMaxSize:{
        new (_graph:yfiles.algorithms.Graph,_valueMap:yfiles.algorithms.INodeMap,maxSize:number):yfiles.algorithms.ArrayIntNodePQ;
      };
    };
    /**
    * Provides algorithms to compute reachability information for directed, acyclic
    * graphs.
    * The following algorithms are available:
    * <ul>
    * <li>transitive closure</li>
    * <li>transitive reduction</li>
    * </ul>
    */
    export interface Transitivity extends Object{
    }
    var Transitivity:{
      $class:yfiles.lang.Class;
      /**
      * Calculates the transitive closure for a directed acyclic graph.
      * The reflexive, transitive closure is defined as follows:
      * Let <code>G = (V,E)</code> be an directed acyclic graph.
      * The directed acyclic graph <code>G* = (V,E*)</code> is the <em>reflexive,
      * transitive closure</em> of <code>G</code>,
      * if <code>(v,w) in E*</code> iff there is a path from <code>v</code> to
      * <code>w</code> in <code>G</code>.
      * <b>REMARK:</b>
      * Note, that this implementation produces the transitive closure and
      * not the reflexive, transitive closure of the specified graph, since
      * no self-loops are added to the specified graph.
      * <b>Precondition:</b> <code>GraphChecker.isAcyclic(graph)</code>
      * @param {yfiles.algorithms.Graph} graph input graph to which this method will add transitive edges if necessary.
      */
      transitiveClosure(graph:yfiles.algorithms.Graph):void;
      /**
      * Like {@link yfiles.algorithms.Transitivity#transitiveClosure}, additionally this method returns the edges
      * that have been added to the graph.
      * <b>Precondition:</b> <code>GraphChecker.isAcyclic(graph)</code>
      * @param {yfiles.algorithms.Graph} graph input graph to which this method will add transitive edges if necessary.
      * @param {yfiles.algorithms.EdgeList} addedEdges contains edges that have been added to the graph by this method.
      */
      transitiveClosureWithAddedEdges(graph:yfiles.algorithms.Graph,addedEdges:yfiles.algorithms.EdgeList):void;
      /**
      * Calculates the transitive reduction for a directed acyclic graph.
      * The transitive edges
      * in the graph will be removed by this method.
      * The transitive reduction is defined as follows:
      * Let <code>G = (V,E)</code> be an directed acyclic graph.
      * The directed acyclic graph <code>G* = (V,E*)</code> is the <em>transitive
      * reduction</em> of <code>G</code>,
      * if <code>(v,w) in E*</code> iff there is no path from <code>v</code> to
      * <code>w</code> in <code>G</code> of length 2 or more.
      * <b>WARNING:</b>
      * This implementation is costly in terms of memory, since a
      * (<code>n</code> x <code>n</code>)-Matrix is allocated to store reach
      * data.
      * <b>Complexity:</b> 
      * <b><code>O(n^3)</code></b>, where <code>n</code> is
      * the node count of the specified graph
      * <b>Precondition:</b> <code>GraphChecker.isAcyclic(graph)</code>
      */
      transitiveReduction(graph:yfiles.algorithms.Graph):void;
      /**
      * Like {@link yfiles.algorithms.Transitivity#transitiveReduction} this method calculates the transitive reduction
      * of a graph.
      * The transitive edges will not be removed from the graph. Instead they will be returned
      * in an EdgeList.
      * <b>Complexity:</b> 
      * <b><code>O(n^3)</code></b>, where <code>n</code> is
      * the node count of the specified graph
      * <b>Precondition:</b> <code>GraphChecker.isAcyclic(graph)</code>
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.EdgeList} transitiveEdges 
      * returns the result. It will contain all transitive
      * edges of the given graph. Removal of these edges will yield the transitive
      * reduction of the graph.
      */
      transitiveReductionWithTransitiveEdges(graph:yfiles.algorithms.Graph,transitiveEdges:yfiles.algorithms.EdgeList):void;
    };
    /**
    * Provides diverse algorithms and services for tree-structured graphs or subgraphs.
    */
    export interface Trees extends Object{
    }
    var Trees:{
      $class:yfiles.lang.Class;
      /**
      * Returns an array of EdgeList objects each containing edges that belong to a
      * maximal directed subtree of the given graph.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {yfiles.algorithms.EdgeList[]} 
      * an array of {@link yfiles.algorithms.EdgeList} objects each containing edges that belong to a maximal directed subtree.
      * @see {@link yfiles.algorithms.Trees#getTreeNodes}
      */
      getTreeEdges(graph:yfiles.algorithms.Graph):yfiles.algorithms.EdgeList[];
      /**
      * Same as {@link yfiles.algorithms.Trees#getTreeEdges} but more efficient if
      * the treeNodes where calculated before by {@link yfiles.algorithms.Trees#getTreeNodes}.
      * Furthermore, the method can also be applied to the result obtained by {@link yfiles.algorithms.Trees#getUndirectedTreeNodes}.
      * In this case the subtrees are considered to be undirected.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @param {yfiles.algorithms.NodeList[]} treeNodes 
      * An array of {@link yfiles.algorithms.NodeList}s formerly calculated by {@link yfiles.algorithms.Trees#getTreeNodes}.
      * @return {yfiles.algorithms.EdgeList[]} 
      * an array of {@link yfiles.algorithms.EdgeList} objects each containing edges that belong to a maximal subtree.
      */
      getTreeEdgesForNodes(graph:yfiles.algorithms.Graph,treeNodes:yfiles.algorithms.NodeList[]):yfiles.algorithms.EdgeList[];
      /**
      * Returns an array of NodeList objects each containing nodes
      * that belong to a maximal directed subtree
      * of the given graph.
      * For each list of tree nodes the first node
      * element is the root of a tree. On each such root all
      * outgoing edges connect to nodes in the subtree and each
      * root's indegree is at least two.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {yfiles.algorithms.NodeList[]} 
      * an array of {@link yfiles.algorithms.NodeList} objects each containing nodes that belong to a maximal directed subtree.
      */
      getTreeNodes(graph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList[];
      /**
      * Returns an array of NodeList objects each containing nodes
      * that belong to a maximal undirected subtree
      * of the given graph.
      * For each list of tree nodes the first node
      * is the only node of the subtree that may be incident to non-tree edges.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {yfiles.algorithms.NodeList[]} 
      * an array of {@link yfiles.algorithms.NodeList} objects each containing nodes that belong to a maximal undirected subtree.
      */
      getUndirectedTreeNodes(graph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList[];
      /**
      * Checks whether the given graph is a directed rooted tree where each
      * node has a maximum of <code>n</code> children.
      * @param {yfiles.algorithms.Graph} g the given graph.
      * @param {number} n the allowed maximum of children.
      * @return {boolean} 
      * <code>true</code> if the given graph is a directed rooted tree where each
      * node has a maximum of <code>n</code> children. Otherwise, the method returns <code>false</code>.
      */
      isNaryTree(g:yfiles.algorithms.Graph,n:number):boolean;
      /**
      * Checks whether the given graph is a directed rooted tree.
      * Note:  <code>isRootedTree(graph) =&gt; isTree(graph)</code>.
      * @param {yfiles.algorithms.Graph} g the given graph.
      * @return {boolean} 
      * <code>true</code> if the given graph is a directed rooted tree.
      * Otherwise, the method returns <code>false</code>.
      */
      isRootedTree(g:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given graph is an undirected tree.
      * Note: <code>isRootedTree(graph) =&gt; isTree(graph)</code>.
      * @param {yfiles.algorithms.Graph} g the given graph.
      * @return {boolean} 
      * <code>true</code> if the given graph is an undirected tree.
      * Otherwise, the method returns <code>false</code>.
      */
      isTree(g:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether the given graph is a forest, that is,
      * a graph whose connected components are directed rooted trees.
      * @param {yfiles.algorithms.Graph} g the given graph.
      * @return {boolean} <code>true</code> if the given graph is a forest. Otherwise, the method returns <code>false</code>.
      */
      isForest(g:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether the given graph is a forest.
      * If <code>directedRootedTree == true</code> each component has to be a directed rooted tree.
      * Otherwise, each component has to be an undirected tree.
      * Note: <code>isForest(graph, true) =&gt; isForest(graph, false)</code>.
      * @param {yfiles.algorithms.Graph} g the given graph.
      * @param {boolean} directedRootedTree whether to check for directed rooted trees.
      * @return {boolean} <code>true</code> if the given graph is a forest. Otherwise, the method returns <code>false</code>.
      */
      isForestWithDirection(g:yfiles.algorithms.Graph,directedRootedTree:boolean):boolean;
      /**
      * Returns all leaf nodes of the given tree.
      * A leaf node is a node with <code>outdegree == 0</code> if the input is a directed rooted tree,
      * and a node with <code>degree == 1</code>, otherwise.
      * @param {yfiles.algorithms.Graph} tree the given tree.
      * @param {boolean} directedRootedTree whether or not to consider the tree as directed rooted tree.
      * @return {yfiles.algorithms.NodeList} a NodeList that contains all leaf nodes of the given tree.
      */
      getLeafNodes(tree:yfiles.algorithms.Graph,directedRootedTree:boolean):yfiles.algorithms.NodeList;
      /**
      * Returns the center node of an undirected tree.
      * The center node has the property of inducing a minimum depth
      * tree when being used as the root of that tree.
      * <b>Precondition:</b> <code>!tree.isEmpty()</code>
      * <b>Precondition:</b> <code>isTree(tree)</code>
      * @param {yfiles.algorithms.Graph} tree the given undirected tree.
      * @return {yfiles.algorithms.Node} the center node of the given undirected tree.
      */
      getCenterRoot(tree:yfiles.algorithms.Graph):yfiles.algorithms.Node;
      /**
      * Returns a possible root for the given (undirected) tree.
      * More precisely, if the input is a directed rooted tree or reversed directed rooted tree it returns the
      * corresponding root node.
      * Otherwise, if the input is a tree, the method returns a maximum weight center node as defined in
      * {@link yfiles.algorithms.Trees#getWeightedCenterNode}.
      * If the input is not a tree, the node with indegree == 0 (or outdegree == 0) is returned.
      * <b>Precondition:</b> 
      * <code>isTree(tree)</code>
      * or there is exactly one node with indegree == 0
      * or there is exactly one node with outdegree == 0
      * <b>Precondition:</b> <code>!tree.isEmpty()</code>
      * @param {yfiles.algorithms.Graph} tree the given tree.
      * @return {yfiles.algorithms.Node} a possible root for the given tree.
      */
      getRoot(tree:yfiles.algorithms.Graph):yfiles.algorithms.Node;
      /**
      * Reverses some edges of the given tree such that it is
      * a directed rooted tree afterwards.
      * A list of all reversed edges will be returned by this method.
      * <b>Precondition:</b> The given graph must be a tree.
      * <b>Precondition:</b> <code>!graph.isEmpty()</code>
      * @param {yfiles.algorithms.Graph} tree the given tree.
      * @return {yfiles.algorithms.EdgeList} 
      * an {@link yfiles.algorithms.EdgeList} that contains the reversed edges.
      */
      directTree(tree:yfiles.algorithms.Graph):yfiles.algorithms.EdgeList;
      /**
      * Finds a node which is used by the greatest number of all (undirected) paths interconnecting
      * all nodes with each other.
      * <b>Precondition:</b> The given graph must be a tree (may be undirected).
      * <b>Precondition:</b> <code>!graph.isEmpty()</code>
      * @param {yfiles.algorithms.Graph} tree the given tree.
      * @return {yfiles.algorithms.Node} a node which is used by the greatest number of all undirected paths.
      */
      getWeightedCenterNode(tree:yfiles.algorithms.Graph):yfiles.algorithms.Node;
      /**
      * Finds a node which is used by the greatest number of all (undirected) paths interconnecting
      * all nodes with each other.
      * The number of paths per node are stored in the given
      * NodeMap.
      * <b>Precondition:</b> The given graph must be a tree (may be undirected).
      * <b>Precondition:</b> <code>!graph.isEmpty()</code>
      * @param {yfiles.algorithms.Graph} tree the given tree.
      * @param {yfiles.algorithms.INodeMap} intWeight 
      * a {@link yfiles.algorithms.INodeMap} that is used to store the number of paths per node.
      * @return {yfiles.algorithms.Node} a node which is used by the greatest number of all undirected paths.
      */
      getWeightedCenterNodeWithWeight(tree:yfiles.algorithms.Graph,intWeight:yfiles.algorithms.INodeMap):yfiles.algorithms.Node;
      /**
      * Reverses some edges of the given tree such that it is
      * a directed rooted tree with the given node as root element.
      * A list of all reversed edges will be returned by this method.
      * <b>Precondition:</b> The given graph must be a tree.
      * <b>Precondition:</b> The given node must be part of the given graph
      * @param {yfiles.algorithms.Graph} tree the given tree.
      * @param {yfiles.algorithms.Node} root the given root element.
      * @return {yfiles.algorithms.EdgeList} 
      * an {@link yfiles.algorithms.EdgeList} that contains the reversed edges.
      */
      directTreeWithRoot(tree:yfiles.algorithms.Graph,root:yfiles.algorithms.Node):yfiles.algorithms.EdgeList;
      /**
      * Collects all nodes of the subtree starting with root.
      * @deprecated For internal use only. Might be changed or removed in the future.
      * @param {yfiles.algorithms.Node} root 
      * @param {yfiles.algorithms.NodeList} nodes the resulting node list
      */
      collectSubtree(root:yfiles.algorithms.Node,nodes:yfiles.algorithms.NodeList):void;
      /**
      * Returns the nearest common ancestor of a subset of nodes within a directed rooted tree.
      * It is not part of the
      * given subset.
      * <b>Precondition:</b> isTree(tree)
      * <b>Complexity:</b> O(tree.N())
      * @param {yfiles.algorithms.Graph} tree the given directed rooted tree.
      * @param {yfiles.algorithms.Node} root the root of the tree.
      * @param {boolean} rootedDownward 
      * whether the tree is directed from the root to the leaves (<code>true</code>) or from the
      * leaves to the root (<code>false</code>).
      * @param {yfiles.algorithms.NodeList} nodes the subset of nodes.
      * @return {yfiles.algorithms.Node} the nearest common ancestor of the given subset of nodes.
      */
      getNearestCommonAncestor(tree:yfiles.algorithms.Graph,root:yfiles.algorithms.Node,rootedDownward:boolean,nodes:yfiles.algorithms.NodeList):yfiles.algorithms.Node;
      /**
      * Returns for a rooted directed tree the depths of each of its subtrees.
      * @param {yfiles.algorithms.Graph} tree a rooted directed tree graph.
      * @param {yfiles.algorithms.INodeMap} subtreeDepthMap 
      * node map that will hold for each node the depth of the subtree rooted at it. The resulting
      * depth values can be retrieved using the map method {@link yfiles.algorithms.INodeMap#getInt}.
      */
      getSubTreeDepths(tree:yfiles.algorithms.Graph,subtreeDepthMap:yfiles.algorithms.INodeMap):void;
      /**
      * Returns for a rooted directed tree the size (number of nodes) of each of its subtrees.
      * @param {yfiles.algorithms.Graph} tree a rooted directed tree graph
      * @param {yfiles.algorithms.INodeMap} subtreeSizeMap 
      * node map that will hold for each node the size of the subtree rooted at it. The resulting
      * size values can be retrieved using the map method {@link yfiles.algorithms.INodeMap#getInt}.
      */
      getSubTreeSizes(tree:yfiles.algorithms.Graph,subtreeSizeMap:yfiles.algorithms.INodeMap):void;
    };
    /**
    * This class represents a priority queue for nodes where
    * the priority values are of type Object
    * The implementation is based on binary heaps.
    * In case the priority values are of type double then using {@link yfiles.algorithms.BHeapDoubleNodePQ}
    * is slightly more efficient than using this generic NodePQ.
    */
    export interface BHeapNodePQ extends Object,yfiles.algorithms.INodePQ{
      /**
      * Adds the given node with with given priority to this queue.
      * <b>Precondition:</b> !contains(v)
      * <b>Complexity:</b> O(log(size()))
      * @see Specified by {@link yfiles.algorithms.INodePQ#add}.
      */
      add(v:yfiles.algorithms.Node,priority:Object):void;
      /**
      * Decreases the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Precondition:</b> 
      * c.compare(priority,getPriority(v)) &lt; 0, where
      * c is the corresponding comparator for the priorities in this
      * queue.
      * <b>Complexity:</b> O(log(size()))
      * @see Specified by {@link yfiles.algorithms.INodePQ#decreasePriority}.
      */
      decreasePriority(v:yfiles.algorithms.Node,priority:Object):void;
      increasePriority(v:yfiles.algorithms.Node,priority:Object):void;
      /**
      * Changes the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Complexity:</b> O(log(size()))
      */
      changePriority(v:yfiles.algorithms.Node,priority:Object):void;
      /**
      * Removes the node with smallest priority from this queue.
      * <b>Precondition:</b> !isEmpty()
      * <b>Complexity:</b> O(log(size()))
      * @return {yfiles.algorithms.Node} the removed node with smallest priority
      * @see Specified by {@link yfiles.algorithms.INodePQ#removeMin}.
      */
      removeMin():yfiles.algorithms.Node;
      /**
      * He node with smallest priority in this queue.
      * <b>Precondition:</b> !isEmpty()
      * @see Specified by {@link yfiles.algorithms.INodePQ#min}.
      */
      min:yfiles.algorithms.Node;
      /**
      * The minimum priority value in this queue.
      */
      minPriority:Object;
      /**
      * Removes the given node from this queue.
      * <b>Precondition:</b> contains(v)
      * <b>Complexity:</b> O(log(size()))
      */
      remove(v:yfiles.algorithms.Node):void;
      /**
      * Makes this queue the empty queue.
      * in this queue.
      * <b>Complexity:</b> O(graph.N())
      * @see Specified by {@link yfiles.algorithms.INodePQ#clear}.
      */
      clear():void;
      /**
      * Returns whether or not the given node is contained
      * in this queue.
      * <b>Complexity:</b> O(1)
      * @see Specified by {@link yfiles.algorithms.INodePQ#contains}.
      */
      contains(v:yfiles.algorithms.Node):boolean;
      /**
      * Specifies whether or not this queue is empty.
      * <b>Complexity:</b> O(1)
      * @see Specified by {@link yfiles.algorithms.INodePQ#empty}.
      */
      empty:boolean;
      /**
      * Returns the number of nodes currently in this queue.
      * <b>Complexity:</b> O(1)
      * @see Specified by {@link yfiles.algorithms.INodePQ#size}.
      */
      size():number;
      /**
      * Returns the current priority of the given node.
      * <b>Precondition:</b> contains(v)
      * @see Specified by {@link yfiles.algorithms.INodePQ#getPriority}.
      */
      getPriority(v:yfiles.algorithms.Node):Object;
    }
    var BHeapNodePQ:{
      $class:yfiles.lang.Class;
      /**
      * Creates an empty NodePQ for nodes contained
      * in the given graph.
      * The given comparator
      * must be able to compare all nodes residing in this
      * queue by their priority.
      * Neither the node set nor the indices of the nodes
      * of the given graph may change while this queue is being used.
      */
      new (graph:yfiles.algorithms.Graph,c:yfiles.objectcollections.IComparer):yfiles.algorithms.BHeapNodePQ;
      /**
      * Creates an empty NodePQ for nodes contained
      * in the given graph.
      * The given comparator
      * must be able to compare all nodes residing in this
      * queue by their priority.
      * By providing a NodeMap that can handle dynamic
      * changes of its definition range this queue will
      * be enabled to function even when the node set of
      * the given graph changes.
      */
      FromMap:{
        new (graph:yfiles.algorithms.Graph,c:yfiles.objectcollections.IComparer,dynamicMap:yfiles.algorithms.INodeMap):yfiles.algorithms.BHeapNodePQ;
      };
    };
    /**
    * This class implements a priority queue for nodes whose priority
    * values are of type double.
    * The implementation is based on binary heaps.
    */
    export interface BHeapDoubleNodePQ extends Object,yfiles.algorithms.IDoubleNodePQ{
      /**
      * Adds the given node with with given priority to this queue.
      * <b>Precondition:</b> !contains(v)
      * <b>Complexity:</b> O(log(size()))
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#add}.
      */
      add(v:yfiles.algorithms.Node,value:number):void;
      /**
      * Decreases the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Precondition:</b> 
      * c.compare(p,getPriority(v)) &lt; 0, where
      * c is the corresponding comparator for the priorities in this
      * queue.
      * <b>Complexity:</b> O(log(size()))
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#decreasePriority}.
      */
      decreasePriority(v:yfiles.algorithms.Node,priority:number):void;
      increasePriority(v:yfiles.algorithms.Node,priority:number):void;
      /**
      * Changes the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Complexity:</b> O(log(size()))
      */
      changePriority(v:yfiles.algorithms.Node,p:number):void;
      /**
      * Removes the node with smallest priority from this queue.
      * <b>Precondition:</b> !isEmpty()
      * <b>Complexity:</b> O(log(size()))
      * @return {yfiles.algorithms.Node} the removed node with smallest priority
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#removeMin}.
      */
      removeMin():yfiles.algorithms.Node;
      /**
      * He node with smallest priority in this queue.
      * <b>Precondition:</b> !isEmpty()
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#min}.
      */
      min:yfiles.algorithms.Node;
      /**
      * The minimum priority value in this queue.
      */
      minPriority:number;
      /**
      * Returns whether or not the given node is contained
      * in this queue.
      * <b>Complexity:</b> O(1)
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#contains}.
      */
      contains(v:yfiles.algorithms.Node):boolean;
      /**
      * Specifies whether or not this queue is empty.
      * <b>Complexity:</b> O(1)
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#empty}.
      */
      empty:boolean;
      /**
      * Returns the number of nodes currently in this queue.
      * <b>Complexity:</b> O(1)
      */
      size():number;
      /**
      * Returns the current priority of the given node.
      * <b>Precondition:</b> contains(v)
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#getPriority}.
      */
      getPriority(v:yfiles.algorithms.Node):number;
      /**
      * Removes the given node from this queue.
      * <b>Precondition:</b> contains(v)
      * <b>Complexity:</b> O(log(size()))
      */
      remove(v:yfiles.algorithms.Node):void;
      /**
      * Makes this queue the empty queue.
      * in this queue.
      * <b>Complexity:</b> O(graph.N())
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#clear}.
      */
      clear():void;
      /**
      * Does nothing.
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#dispose}.
      */
      dispose():void;
    }
    var BHeapDoubleNodePQ:{
      $class:yfiles.lang.Class;
      /**
      * Creates an empty NodePQ for nodes contained
      * in the given graph.
      * Neither the node set nor the indices of the nodes
      * of the given graph may change while this queue is being used.
      */
      new (graph:yfiles.algorithms.Graph):yfiles.algorithms.BHeapDoubleNodePQ;
    };
    /**
    * This class implements a priority queue for nodes whose priority
    * values are of type int.
    * <p>
    * The implementation is based on binary heaps.
    * </p>
    */
    export interface BHeapIntNodePQ extends Object,yfiles.algorithms.IIntNodePQ{
      /**
      * Adds the given node with with given priority to this queue.
      * <b>Precondition:</b> !contains(v)
      * <b>Complexity:</b> O(log(size()))
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#add}.
      */
      add(v:yfiles.algorithms.Node,priority:number):void;
      /**
      * Decreases the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Precondition:</b> priority &lt; getPriority(v)
      * <b>Complexity:</b> O(log(size()))
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#decreasePriority}.
      */
      decreasePriority(v:yfiles.algorithms.Node,priority:number):void;
      /**
      * Increases the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Precondition:</b> priority > getPriority(v)
      * <b>Complexity:</b> O(log(size()))
      */
      increasePriority(v:yfiles.algorithms.Node,priority:number):void;
      /**
      * Changes the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Complexity:</b> O(log(size()))
      */
      changePriority(v:yfiles.algorithms.Node,p:number):void;
      /**
      * Removes the node with smallest priority from this queue.
      * <b>Precondition:</b> !isEmpty()
      * <b>Complexity:</b> O(log(size()))
      * @return {yfiles.algorithms.Node} the removed node with smallest priority
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#removeMin}.
      */
      removeMin():yfiles.algorithms.Node;
      /**
      * He node with smallest priority in this queue.
      * <b>Precondition:</b> !isEmpty()
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#min}.
      */
      min:yfiles.algorithms.Node;
      /**
      * The minimum priority value in this queue.
      */
      minPriority:number;
      /**
      * Returns whether or not the given node is contained
      * in this queue.
      * <b>Complexity:</b> O(1)
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#contains}.
      */
      contains(v:yfiles.algorithms.Node):boolean;
      /**
      * Specifies whether or not this queue is empty.
      * <b>Complexity:</b> O(1)
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#empty}.
      */
      empty:boolean;
      /**
      * Returns the number of nodes currently in this queue.
      * <b>Complexity:</b> O(1)
      */
      size():number;
      /**
      * Returns the current priority of the given node.
      * <b>Precondition:</b> contains(v)
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#getPriority}.
      */
      getPriority(v:yfiles.algorithms.Node):number;
      /**
      * Removes the given node from this queue.
      * <b>Precondition:</b> contains(v)
      * <b>Complexity:</b> O(log(size()))
      */
      remove(v:yfiles.algorithms.Node):void;
      /**
      * Makes this queue the empty queue.
      * in this queue.
      * <b>Complexity:</b> O(graph.N())
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#clear}.
      */
      clear():void;
      /**
      * Does nothing.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#dispose}.
      */
      dispose():void;
    }
    var BHeapIntNodePQ:{
      $class:yfiles.lang.Class;
      /**
      * Creates an empty NodePQ for nodes contained
      * in the given graph.
      * Neither the node set nor the indices of the nodes
      * of the given graph may change while this queue is being used.
      */
      new (graph:yfiles.algorithms.Graph):yfiles.algorithms.BHeapIntNodePQ;
    };
    /**
    * This class provides methods for efficiently sorting graph elements in graph
    * structures.
    */
    export interface Sorting extends Object{
    }
    var Sorting:{
      $class:yfiles.lang.Class;
      /**
      * Sort nodes by degree in ascending order.
      */
      sortNodesByDegree(graph:yfiles.algorithms.Graph):yfiles.algorithms.Node[];
      /**
      * Sort nodes by an integer key associated to each node through the given data provider.
      * The nodes are sorted in ascending order.
      */
      sortNodesByIntKey(graph:yfiles.algorithms.Graph,keys:yfiles.algorithms.IDataProvider):yfiles.algorithms.Node[];
    };
    /**
    * Provides (minimum) spanning tree algorithms for graphs.
    * A spanning tree of an undirected connected graph is a subset of its edges
    * that form a tree connecting all edges of the graph.
    * If the edges of a graph have a cost or a weight associated with
    * them then it is possible to calculate a minimum spanning tree of that graph,
    * i.e. a spanning tree whose edges have minimum overall cost of all spanning
    * trees of that graph.
    */
    export interface SpanningTrees extends Object{
    }
    var SpanningTrees:{
      $class:yfiles.lang.Class;
      /**
      * Calculates a minimum spanning tree for the given graph using our
      * favorite algorithm for that problem.
      * <b>Precondition:</b> GraphComponents.isConnected(graph)
      * <b>Precondition:</b> cost.length == graph.E();
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.IDataProvider} cost 
      * a data provider that must return a double value  for each
      * edge in the graph.
      * @return {yfiles.algorithms.EdgeList} 
      * a list that contains the edges that make up the minimum spanning
      * tree.
      */
      minimum(graph:yfiles.algorithms.Graph,cost:yfiles.algorithms.IDataProvider):yfiles.algorithms.EdgeList;
      /**
      * Calculates a minimum spanning tree for the given graph.
      * The implementation
      * is based on an algorithm originally published in
      * J.B. Kruskal. On the shortest spanning subtree of a graph and the
      * traveling salesman problem. <i>Proceedings of the American Mathematical
      * Society</i>, pages 48-50, 1956.
      * <b>Precondition:</b> GraphComponents.isConnected(graph)
      * <b>Precondition:</b> cost.length == graph.E();
      * <b>Complexity:</b> graph.E()+graph.N()*log(graph.N())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.IDataProvider} cost 
      * a data provider that must return a double value  for each
      * edge in the graph.
      * @return {yfiles.algorithms.EdgeList} 
      * a list that contains the edges that make up the minimum spanning
      * tree.
      */
      kruskal(graph:yfiles.algorithms.Graph,cost:yfiles.algorithms.IDataProvider):yfiles.algorithms.EdgeList;
      /**
      * Calculates a minimum spanning tree for the given graph.
      * The implementation
      * is based on an algorithm originally published in
      * R.C. Prim. Shortest connection networks and some generalizations.
      * <i>Bell System Technical Journal</i>, 36:1389-1401, 1957.
      * <b>Precondition:</b> GraphComponents.isConnected(graph)
      * <b>Precondition:</b> cost.length == graph.E();
      * <b>Complexity:</b> graph.E()*log(graph.N())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.IDataProvider} cost 
      * a data provider that must return a double value  for each
      * edge in the graph.
      * @return {yfiles.algorithms.EdgeList} 
      * a list that contains the edges that make up the minimum spanning
      * tree.
      */
      prim(graph:yfiles.algorithms.Graph,cost:yfiles.algorithms.IDataProvider):yfiles.algorithms.EdgeList;
      /**
      * Calculates a spanning tree for the given graph.
      * Each edge has
      * assumed uniform cost of 1.0.
      * <b>Precondition:</b> GraphComponents.isConnected(graph)
      * <b>Complexity:</b> O(graph.E()+graph.N())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @return {yfiles.algorithms.EdgeList} 
      * a list that contains the edges that make up the minimum spanning
      * tree.
      */
      uniform(graph:yfiles.algorithms.Graph):yfiles.algorithms.EdgeList;
      /**
      * Returns the overall cost of a previously calculated minimum
      * spanning tree.
      * @param {yfiles.algorithms.EdgeList} treeEdges edges that make up a minimum spanning tree.
      * @param {yfiles.algorithms.IDataProvider} edgeCost 
      * a data provider that returns the double valued
      * cost of each of the tree edges.
      * @return {number} the overall cost of the tree edges.
      */
      cost(treeEdges:yfiles.algorithms.EdgeList,edgeCost:yfiles.algorithms.IDataProvider):number;
    };
    /**
    * Provides diverse algorithms and helper methods for solving the shortest path problem
    * on weighted graphs.
    */
    export interface ShortestPaths extends Object{
    }
    var ShortestPaths:{
      $class:yfiles.lang.Class;
      /**
      * This method solves the single-source shortest path problem for arbitrary graphs
      * where each edge has a <b>uniform cost of 1.0</b>.
      * This method yields the shortest distance from a given node <code>s</code> to all other nodes.
      * <b>Precondition:</b> dist.length == graph.N()
      * <b>Complexity:</b> O(graph.N()+graph.E())
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {yfiles.algorithms.Node} s the start node for the shortest path search
      * @param {boolean} directed 
      * whether or not to consider the graph as directed. If the graph is
      * to be considered undirected then each edge can be traversed in both directions and
      * the returned shortest paths can thus be undirected.
      * @param {number[]} dist 
      * return value that will hold the shortest distance from node <code>s</code> to
      * all other nodes. The distance from <code>s</code> to <code>v</code> is
      * <code>dist[v.index()]</code>. If there is no path from <code>s</code> to <code>v</code>
      * then <code>dist[v.index()] == Double.POSITIVE_INFINITY</code>.
      */
      uniform(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,dist:number[]):void;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#uniform} but additionally this method
      * yields the path edges of each calculated shortest path.
      * <b>Precondition:</b> pred.length == graph.N()
      * @param {yfiles.algorithms.Edge[]} pred 
      * return value that holds for each node <code>t</code> the shortest
      * path edge <code>pred[t.index()]</code> which is the last edge on the shortest
      * path from <code>s</code> to <code>t</code>. If <code>t == s</code> or if there
      * is no shortest path from <code>s</code> to <code>t</code> then
      * <code>pred[t.index()] == null</code>.
      * @see {@link yfiles.algorithms.ShortestPaths#constructNodePathFromArray}
      * @see {@link yfiles.algorithms.ShortestPaths#constructEdgePathFromArray}
      */
      uniformToArray(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,dist:number[],pred:yfiles.algorithms.Edge[]):void;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#uniformToArray} but uses NodeMaps instead of
      * arrays.
      * @param {yfiles.algorithms.INodeMap} dist return value. the map will provide a double value for each node.
      * @param {yfiles.algorithms.INodeMap} pred return value. the map will provide an Edge for each node.
      */
      uniformToMap(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,dist:yfiles.algorithms.INodeMap,pred:yfiles.algorithms.INodeMap):void;
      /**
      * This method solves the single-source shortest path problem for <b>acyclic</b> directed graphs.
      * Associated with each edge is an arbitrary double value that represents the cost of that edge.
      * This method yields the shortest distance from a given node <code>s</code> to all other nodes.
      * <b>Precondition:</b> GraphChecker.isAcyclic(graph)
      * <b>Precondition:</b> cost.length == graph.E()
      * <b>Precondition:</b> dist.length == graph.N()
      * <b>Complexity:</b> O(graph.N()+graph.E())
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {yfiles.algorithms.Node} s the start node for the shortest path search
      * @param {number[]} cost 
      * holds the costs for traversing each edge. Edge <code>e</code>
      * has cost <code>cost[e.index()]</code>.
      * @param {number[]} dist 
      * return value that will hold the shortest distance from node <code>s</code> to
      * all other nodes. The distance from <code>s</code> to <code>v</code> is
      * <code>dist[v.index()]</code>. If there is no path from <code>s</code> to <code>v</code>
      * then <code>dist[v.index()] == Double.POSITIVE_INFINITY</code>.
      * @return {boolean} <code>false</code> if the input graph was not acyclic.
      */
      acyclic(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,cost:number[],dist:number[]):boolean;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#acyclic} but additionally this method
      * yields the path edges of each calculated shortest path.
      * <b>Precondition:</b> pred.length == graph.N()
      * @param {yfiles.algorithms.Edge[]} pred 
      * return value that holds for each node <code>t</code> the shortest
      * path edge <code>pred[t.index()]</code> which is the last edge on the shortest
      * path from <code>s</code> to <code>t</code>. If <code>t == s</code> or if there
      * is no shortest path from <code>s</code> to <code>t</code> then
      * <code>pred[t.index()] == null</code>.
      * @see {@link yfiles.algorithms.ShortestPaths#constructNodePathFromArray}
      * @see {@link yfiles.algorithms.ShortestPaths#constructEdgePathFromArray}
      */
      acyclicToArray(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,cost:number[],dist:number[],pred:yfiles.algorithms.Edge[]):boolean;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#acyclicToArray}
      * but uses NodeMaps and DataProviders instead of arrays.
      * @param {yfiles.algorithms.IDataProvider} cost must provide a double value for each edge.
      * @param {yfiles.algorithms.INodeMap} dist return value. the map will provide a double value for each node.
      * @param {yfiles.algorithms.INodeMap} pred return value. the map will provide an Edge for each node.
      */
      acyclicToMap(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,cost:yfiles.algorithms.IDataProvider,dist:yfiles.algorithms.INodeMap,pred:yfiles.algorithms.INodeMap):boolean;
      /**
      * This method solves the single-source shortest path problem for arbitrary graphs.
      * Associated with each edge is a <b>non-negative</b> double value that represents
      * the cost of that edge.
      * This method yields the shortest distance from a given node <code>s</code> to all other nodes.
      * <b>Precondition:</b> For each edge e: cost[e.index()] >= 0
      * <b>Precondition:</b> cost.length == graph.E()
      * <b>Precondition:</b> dist.length == graph.N()
      * <b>Complexity:</b> O(graph.E()+graph.N()*log(graph.N())
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {yfiles.algorithms.Node} s the start node for the shortest path search
      * @param {boolean} directed 
      * whether or not to consider the graph as directed. If the graph is
      * to be considered undirected then each edge can be traversed in both directions and
      * the returned shortest paths can thus be undirected.
      * @param {number[]} cost 
      * holds the costs for traversing each edge. Edge <code>e</code>
      * has cost <code>cost[e.index()]</code>.
      * @param {number[]} dist 
      * return value that will hold the shortest distance from node <code>s</code> to
      * all other nodes. The distance from <code>s</code> to <code>v</code> is
      * <code>dist[v.index()]</code>. If there is no path from <code>s</code> to <code>v</code>
      * then <code>dist[v.index()] == Double.POSITIVE_INFINITY</code>.
      */
      dijkstra(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,cost:number[],dist:number[]):void;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#dijkstra} but additionally this method
      * yields the path edges of each calculated shortest path.
      * <b>Precondition:</b> pred.length == graph.N()
      * @param {yfiles.algorithms.Edge[]} pred 
      * return value that holds for each node <code>t</code> the shortest
      * path edge <code>pred[t.index()]</code> which is the last edge on the shortest
      * path from <code>s</code> to <code>t</code>. If <code>t == s</code> or if there
      * is no shortest path from <code>s</code> to <code>t</code> then
      * <code>pred[t.index()] == null</code>.
      * @see {@link yfiles.algorithms.ShortestPaths#constructNodePathFromArray}
      * @see {@link yfiles.algorithms.ShortestPaths#constructEdgePathFromArray}
      */
      dijkstraToArray(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,cost:number[],dist:number[],pred:yfiles.algorithms.Edge[]):void;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#dijkstraToArray}
      * but uses NodeMaps and DataProviders instead of arrays.
      * @param {yfiles.algorithms.IDataProvider} cost must provide a double value for each edge.
      * @param {yfiles.algorithms.INodeMap} dist return value. the map will provide a double value for each node.
      * @param {yfiles.algorithms.INodeMap} pred return value. the map will provide an Edge for each node.
      */
      dijkstraWithCostToMap(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,cost:yfiles.algorithms.IDataProvider,dist:yfiles.algorithms.INodeMap,pred:yfiles.algorithms.INodeMap):void;
      /**
      * This method solves the single-source single-sink shortest path problem
      * for arbitrary graphs.
      * Associated with each edge is a <b>non-negative</b> double value that represents
      * the cost of that edge.
      * This method returns the shortest distance from node <code>s</code> to node <code>t</code>.
      * It also returns information to construct the actual path between these to nodes.
      * <b>Precondition:</b> For each edge e: cost[e.index()] >= 0
      * <b>Precondition:</b> cost.length == graph.E()
      * <b>Precondition:</b> pred.length == graph.N()
      * <b>Complexity:</b> O(graph.E()+graph.N()*log(graph.N())
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {yfiles.algorithms.Node} s the source node for the shortest path search
      * @param {yfiles.algorithms.Node} t the sink   node for the shortest path search
      * @param {boolean} directed 
      * whether or not to consider the graph as directed. If the graph is
      * to be considered undirected then each edge can be traversed in both directions and
      * the returned shortest paths can thus be undirected.
      * @param {number[]} cost 
      * holds the costs for traversing each edge. Edge <code>e</code>
      * has cost <code>cost[e.index()]</code>.
      * @param {yfiles.algorithms.Edge[]} pred 
      * return value that holds for each node <code>v</code> on the
      * the shortest the path from <code>s</code> to <code>t</code> an edge
      * <code>pred[v.index()]</code> which is the last edge on
      * the shortest path from <code>s</code> to <code>v</code>. If <code>v == s</code> or if there
      * is no shortest path from <code>s</code> to <code>v</code> then
      * <code>pred[v.index()] == null</code>.
      * @return {number} 
      * the distance between <code>s</code> and <code>t</code> if a path between these two
      * nodes exist and <code>Double.POSITIVE_INFINITY</code> otherwise.
      * @see {@link yfiles.algorithms.ShortestPaths#constructNodePathFromArray}
      * @see {@link yfiles.algorithms.ShortestPaths#constructEdgePathFromArray}
      */
      singleSourceSingleSinkToArray(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,t:yfiles.algorithms.Node,directed:boolean,cost:number[],pred:yfiles.algorithms.Edge[]):number;
      /**
      * Similar to {@link yfiles.algorithms.ShortestPaths#singleSourceSingleSinkToArray}
      * but instead of returning the shortest distance between the source and sink
      * the actual shortest edge path between these nodes will be returned.
      * If the returned path is empty then there is no path between the nodes.
      * @return {yfiles.algorithms.EdgeList} a shortest path between source and sink
      */
      singleSourceSingleSink(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,t:yfiles.algorithms.Node,directed:boolean,cost:number[]):yfiles.algorithms.EdgeList;
      /**
      * Similar to {@link yfiles.algorithms.ShortestPaths#singleSourceSingleSinkToMap}
      * but instead of returning the shortest distance between the source and sink
      * the actual shortest edge path between these nodes will be returned.
      * If the returned path is empty then there is no path between the nodes.
      * @return {yfiles.algorithms.EdgeList} a shortest path between source and sink
      */
      singleSourceSingleSinkWithCost(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,t:yfiles.algorithms.Node,directed:boolean,cost:yfiles.algorithms.IDataProvider):yfiles.algorithms.EdgeList;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#singleSourceSingleSinkToArray}
      * but uses NodeMaps and DataProviders instead of arrays.
      * @param {yfiles.algorithms.IDataProvider} cost must provide a double value for each edge.
      * @param {yfiles.algorithms.INodeMap} pred return value. the map will provide an Edge for each node.
      */
      singleSourceSingleSinkToMap(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,t:yfiles.algorithms.Node,directed:boolean,cost:yfiles.algorithms.IDataProvider,pred:yfiles.algorithms.INodeMap):number;
      /**
      * This method solves the single-source shortest path problem for arbitrary graphs.
      * Associated with each edge is an arbitrary double value that represents
      * the cost of that edge. In case the given weighted graph contains no <b>negative cost cycles</b>
      * this method will yield the shortest distance from a given node <code>s</code> to all other nodes.
      * If, on the other hand, the given graph contains negative-cost cycles this method will yield
      * no reasonable result which will be indicated by the return value <code>false</code>.
      * <b>Precondition:</b> cost.length == graph.E()
      * <b>Precondition:</b> dist.length == graph.N()
      * <b>Complexity:</b> 
      * O(graph.E()*min(D,graph.N())) where D is the maximal
      * number of edges in any shortest path.
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {yfiles.algorithms.Node} s the start node for the shortest path search
      * @param {boolean} directed 
      * whether or not to consider the graph as directed. If the graph is
      * to be considered undirected then each edge can be traversed in both directions and
      * the returned shortest paths can thus be undirected.
      * @param {number[]} cost 
      * holds the costs for traversing each edge. Edge <code>e</code>
      * has cost <code>cost[e.index()]</code>.
      * @param {number[]} dist 
      * return value that will hold the shortest distance from node <code>s</code> to
      * all other nodes. The distance from <code>s</code> to <code>v</code> is
      * <code>dist[v.index()]</code>. If there is no path from <code>s</code> to <code>v</code>
      * then <code>dist[v.index()] == Double.POSITIVE_INFINITY</code>.
      * @return {boolean} 
      * <code>false</code> if this weighted graph contains a negative cost cycle,
      * <code>true</code> otherwise.
      */
      bellmanFord(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,cost:number[],dist:number[]):boolean;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#bellmanFord} but additionally this method
      * yields the path edges of each calculated shortest path.
      * <b>Precondition:</b> pred.length == graph.N()
      * @param {yfiles.algorithms.Edge[]} pred 
      * return value that holds for each node <code>t</code> the shortest
      * path edge <code>pred[t.index()]</code> which is the last edge on the shortest
      * path from <code>s</code> to <code>t</code>. If <code>t == s</code> or if there
      * is no shortest path from <code>s</code> to <code>t</code> then
      * <code>pred[t.index()] == null</code>.
      * @see {@link yfiles.algorithms.ShortestPaths#constructNodePathFromArray}
      * @see {@link yfiles.algorithms.ShortestPaths#constructEdgePathFromArray}
      */
      bellmanFordToArray(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,cost:number[],dist:number[],pred:yfiles.algorithms.Edge[]):boolean;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#bellmanFordToArray}
      * but uses NodeMaps and DataProviders instead of arrays.
      * @param {yfiles.algorithms.IDataProvider} cost must provide a double value for each edge.
      * @param {yfiles.algorithms.INodeMap} dist return value. the map will provide a double value for each node.
      * @param {yfiles.algorithms.INodeMap} pred return value. the map will provide an Edge for each node.
      */
      bellmanFordToMap(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,cost:yfiles.algorithms.IDataProvider,dist:yfiles.algorithms.INodeMap,pred:yfiles.algorithms.INodeMap):boolean;
      /**
      * This method solves the single-source shortest path problem for arbitrary graphs.
      * Depending on the structure of the given graph and the values of the given edge costs it
      * delegates its job to the algorithm with the theoretically best running time.
      * Please note that theory does not necessarily reflect practice.
      * <b>Precondition:</b> cost.length == graph.E()
      * <b>Precondition:</b> dist.length == graph.N()
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {yfiles.algorithms.Node} s the start node for the shortest path search
      * @param {boolean} directed 
      * whether or not to consider the graph as directed. If the graph is
      * to be considered undirected then each edge can be traversed in both directions and
      * the returned shortest paths can thus be undirected.
      * @param {number[]} cost 
      * holds the costs for traversing each edge. Edge <code>e</code>
      * has cost <code>cost[e.index()]</code>.
      * @param {number[]} dist 
      * return value that will hold the shortest distance from node <code>s</code> to
      * all other nodes. The distance from <code>s</code> to <code>v</code> is
      * <code>dist[v.index()]</code>. If there is no path from <code>s</code> to <code>v</code>
      * then <code>dist[v.index()] == Double.POSITIVE_INFINITY</code>.
      * @return {boolean} 
      * <code>false</code> if this weighted graph contains a negative cost cycle,
      * <code>true</code> otherwise.
      */
      singleSource(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,cost:number[],dist:number[]):boolean;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#singleSource} but additionally this method
      * yields the path edges of each calculated shortest path.
      * <b>Precondition:</b> pred.length == graph.N()
      * @param {yfiles.algorithms.Edge[]} pred 
      * return value that holds for each node <code>t</code> the shortest
      * path edge <code>pred[t.index()]</code> which is the last edge on the shortest
      * path from <code>s</code> to <code>t</code>. If <code>t == s</code> or if there
      * is no shortest path from <code>s</code> to <code>t</code> then
      * <code>pred[t.index()] == null</code>.
      * @see {@link yfiles.algorithms.ShortestPaths#constructNodePathFromArray}
      * @see {@link yfiles.algorithms.ShortestPaths#constructEdgePathFromArray}
      */
      singleSourceToArray(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,cost:number[],dist:number[],pred:yfiles.algorithms.Edge[]):boolean;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#singleSourceToArray}
      * but uses NodeMaps and DataProviders instead of arrays.
      * @param {yfiles.algorithms.IDataProvider} cost must provide a double value for each edge.
      * @param {yfiles.algorithms.INodeMap} dist return value. the map will provide a double value for each node.
      * @param {yfiles.algorithms.INodeMap} pred return value. the map will provide an Edge for each node.
      */
      singleSourceToMap(graph:yfiles.algorithms.Graph,s:yfiles.algorithms.Node,directed:boolean,cost:yfiles.algorithms.IDataProvider,dist:yfiles.algorithms.INodeMap,pred:yfiles.algorithms.INodeMap):boolean;
      /**
      * This method solves the all-pairs shortest path problem for graphs with arbitrary
      * edge costs.
      * If the given graph contains a negative cost cycle, then <code>false</code> is
      * returned and the values returned in <code>dist</code> are left unspecified.
      * <b>Precondition:</b> cost.length == graph.E();
      * <b>Precondition:</b> dimension of dist: [graph.N()][graph.N()]]
      * <b>Complexity:</b> O(graph.N())*O(singleSource)
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {boolean} directed 
      * whether or not to consider the graph as directed. If the graph is
      * to be considered undirected then each edge can be traversed in both directions and
      * the returned shortest paths can thus be undirected.
      * @param {number[]} cost 
      * holds the costs for traversing each edge. Edge <code>e</code>
      * has cost <code>cost[e.index()]</code>.
      * @param {number[][]} dist 
      * return value that will hold the shortest path distances from all pairs of
      * nodes <code>s</code> and <code>t</code> in the graph.
      * The distance from <code>s</code> to <code>t</code> is
      * <code>dist[s.index()][t.index()]</code>. If there is no path from <code>s</code> to <code>t</code>
      * then <code>dist[s.index()][t.index()] == Double.POSITIVE_INFINITY</code>.
      * @return {boolean} whether or not the given graph contains a negative cost cycle.
      */
      allPairs(graph:yfiles.algorithms.Graph,directed:boolean,cost:number[],dist:number[][]):boolean;
      /**
      * Marks all edges that belong to a shortest path from <code>start</code> to <code>end</code> node.
      * This method assumes that each edge of the input graph has a <b>cost of 1.0</b>.
      * <b>Complexity:</b> O(g.N()+g.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.Node} start the start node
      * @param {yfiles.algorithms.Node} end the end node
      * @param {boolean} directed 
      * whether or not to consider the graph as directed. If the graph is
      * to be considered undirected then each edge can be traversed in both directions and
      * the returned shortest paths can thus be undirected.
      * @param {yfiles.algorithms.IEdgeMap} pathMap 
      * the result. For each edge a boolean value will indicate whether or not
      * it belongs to a shortest path connecting the two nodes.
      */
      findShortestUniformPaths(graph:yfiles.algorithms.Graph,start:yfiles.algorithms.Node,end:yfiles.algorithms.Node,directed:boolean,pathMap:yfiles.algorithms.IEdgeMap):void;
      /**
      * This method finds the <code>k</code> shortest paths
      * connecting a pair of nodes in a directed graph with non-negative edge costs.
      * The result will be returned as a list of EdgeList objects.
      * Note that the returned paths are not required to be simple, i.e. they may contain
      * a node or an edge multiple times.
      * <b>Precondition:</b> For each edge e: costDP.getDouble(e) >= 0
      * <b>Complexity:</b> O(graph.E() + graph.N()*log(graph.N()) + k)
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {yfiles.algorithms.IDataProvider} costDP 
      * a data provider that provides a double-valued cost for each edge
      * of the input graph.
      * @param {yfiles.algorithms.Node} start start node of the shortest paths
      * @param {yfiles.algorithms.Node} end the end node of the shortest paths
      * @param {number} k 
      * @return {yfiles.algorithms.YList} 
      * a list of EdgeList objects each of which representing a path from
      * <code>start</code> to <code>end</code> node. The i-th path in the
      * list contains the i-th shortest path between <code>start</code> and <code>end</code>
      * node. Note that the returned list may contain less than <code>k</code> paths in case
      * there are fewer directed paths between start and end node.
      */
      kShortestPaths(graph:yfiles.algorithms.Graph,costDP:yfiles.algorithms.IDataProvider,start:yfiles.algorithms.Node,end:yfiles.algorithms.Node,k:number):yfiles.algorithms.YList;
      /**
      * A variant of {@link yfiles.algorithms.ShortestPaths#kShortestPaths}
      * that returns its result not as a list but as a special cursor that calculates
      * the next path in the sequence only when needed.
      * The returned cursor only supports the operation {@link yfiles.algorithms.ICursor#ok},
      * {@link yfiles.algorithms.ICursor#current} and {@link yfiles.algorithms.ICursor#next}.
      */
      kShortestPathsCursor(graph:yfiles.algorithms.Graph,costDP:yfiles.algorithms.IDataProvider,start:yfiles.algorithms.Node,end:yfiles.algorithms.Node,k:number):yfiles.algorithms.ICursor;
      /**
      * Convenience method that returns an array containing
      * uniform edge costs of <code>1.0</code> for each edge
      * of the given graph.
      * @return {number[]} 
      * an array <code>cost[]</code> that contains uniform
      * edge costs of 1.0 for each edge <code>e: cost[e.index()] == 1.0</code>.
      */
      uniformCost(graph:yfiles.algorithms.Graph):number[];
      /**
      * Convenience method that constructs an explicit node path from the
      * result yielded by one of the shortest paths methods defined in this class.
      * @param {yfiles.algorithms.Node} s 
      * the start node of the shortest path. This must be the
      * same start node that was specified when <code>pred</code> was calculated.
      * @param {yfiles.algorithms.Node} t the end node of the path
      * @param {yfiles.algorithms.Edge[]} pred 
      * the shortest path edge result array returned by one of the
      * shortest path edge methods defined in this class.
      * @return {yfiles.algorithms.NodeList} 
      * a node list that holds the nodes on the shortest path
      * from <code>s</code> to <code>t</code> in the correct order. If there
      * is no path from <code>s</code> to <code>t</code> then an empty
      * list is returned.
      */
      constructNodePathFromArray(s:yfiles.algorithms.Node,t:yfiles.algorithms.Node,pred:yfiles.algorithms.Edge[]):yfiles.algorithms.NodeList;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#constructNodePathFromArray} with the difference that
      * the path edges are given by a DataProvider.
      * @param {yfiles.algorithms.IDataProvider} pred 
      * the shortest path edge result DataProvider returned by one of the
      * shortest path edge methods defined in this class.
      */
      constructNodePathFromMap(s:yfiles.algorithms.Node,t:yfiles.algorithms.Node,pred:yfiles.algorithms.IDataProvider):yfiles.algorithms.NodeList;
      /**
      * Convenience method that constructs an explicit edge path from the
      * result yielded by one of the shortest paths methods defined in this class.
      * @param {yfiles.algorithms.Node} s 
      * the start node of the shortest path. This must be the
      * same start node that was specified when <code>pred</code> was calculated.
      * @param {yfiles.algorithms.Node} t the end node of the path
      * @param {yfiles.algorithms.Edge[]} pred 
      * the shortest path edge result array returned by one of the
      * shortest path edge methods defined in this class.
      * @return {yfiles.algorithms.EdgeList} 
      * an edge list that holds the edges on the shortest path
      * from <code>s</code> to <code>t</code> in the correct order. If there
      * is no path from <code>s</code> to <code>t</code> then an empty
      * list is returned.
      */
      constructEdgePathFromArray(s:yfiles.algorithms.Node,t:yfiles.algorithms.Node,pred:yfiles.algorithms.Edge[]):yfiles.algorithms.EdgeList;
      /**
      * Like {@link yfiles.algorithms.ShortestPaths#constructEdgePathFromArray} with the difference that
      * the path edges are given by a DataProvider.
      * @param {yfiles.algorithms.IDataProvider} pred 
      * the shortest path edge result DataProvider returned by one of the
      * shortest path edge methods defined in this class.
      */
      constructEdgePathToMap(s:yfiles.algorithms.Node,t:yfiles.algorithms.Node,pred:yfiles.algorithms.IDataProvider):yfiles.algorithms.EdgeList;
      /**
      * Finds all nodes and edges that belong to a shortest path from <code>start</code> to a set of target nodes in the graph not
      * farther away than a given distance.
      * This method assumes that each edge of the input graph has a <b>cost of 1.0</b>.
      * <b>Complexity:</b> O(g.N()+g.E())
      * <b>Complexity:</b> O(graph.N()+graph.E())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.Node} start the start node
      * @param {yfiles.algorithms.IDataProvider} targetMap 
      * a boolean data provider that marks the target nodes. If the data provider is <code>null</code>
      * all nodes in the graph are assumed to be target nodes.
      * @param {boolean} directed whether or not to work on directed edges
      * @param {number} maxLength 
      * the maximum edge length of the shortest paths. Shortest paths
      * that are longer than this value will not be considered.
      * @param {yfiles.algorithms.EdgeList} pathEdges 
      * a return value. If this parameter is not null, this algorithm first clears the list and then adds
      * all edges that belong to the detected shortest paths.
      * @param {yfiles.algorithms.NodeList} pathNodes 
      * a return value. If this parameter is not null, this algorithm first clears the list and then adds
      * all nodes that belong to the detected shortest paths.
      */
      findShortestUniformPathsFromMap(graph:yfiles.algorithms.Graph,start:yfiles.algorithms.Node,targetMap:yfiles.algorithms.IDataProvider,directed:boolean,maxLength:number,pathEdges:yfiles.algorithms.EdgeList,pathNodes:yfiles.algorithms.NodeList):void;
      /**
      * Returns two edge-disjoint paths from in a nonnegatively-weighted directed graph, so that both paths connect
      * <code>s</code> and <code>t</code> and have minimum total length.
      * @param {yfiles.algorithms.Graph} graph the graph being acted upon
      * @param {yfiles.algorithms.Node} source source node of the shortest pair
      * @param {yfiles.algorithms.Node} target end node of the shortest pair
      * @param {boolean} directed whether or not to interpret the edges as directed or undirected
      * @param {yfiles.algorithms.IDataProvider} costDP 
      * a data provider that provides a double-valued cost for each edge
      * of the input graph.
      * @return {yfiles.algorithms.EdgeList[]} 
      * a two-dimensional EdgeList array that holds the resulting edge-disjoint paths, or <code>null</code> if no such
      * edge-disjoint paths exist.
      */
      shortestPair(graph:yfiles.algorithms.Graph,source:yfiles.algorithms.Node,target:yfiles.algorithms.Node,directed:boolean,costDP:yfiles.algorithms.IDataProvider):yfiles.algorithms.EdgeList[];
    };
    /**
    * Provides algorithms for solving the rank assignment problem.
    * Let G=(V,E) be a directed acyclic graph. Let length(e) denote
    * the minimal length and weight(e) the weight of an
    * edge e.
    * The rank assignment problem is to find values x(v) for all
    * v in V, such that x(v) - x(w) >= length(v,w) for all (v,w) in E,
    * and that the sum weight(v,w)*(x(v)-x(w)) over all (v,w) in E
    * is minimal.
    */
    export interface RankAssignments extends Object{
    }
    var RankAssignments:{
      $class:yfiles.lang.Class;
      /**
      * Solves the rank assignment problem using the simplex method.
      * This method assigns a minimal rank to the nodes in a acyclic graph.
      * Although its time complexity has not been proven polynomial, in practice
      * it takes few iterations and runs quickly.
      * The algorithm is based on:
      * E.R. Gansner et al, <i>A Technique for Drawing Directed Graphs</i>,
      * IEEE Transactions on Software Engineering, Vol.19, No.3,
      * March 1993,
      * <b>Precondition:</b> GraphChecker.isAcyclic(graph)
      * <b>Precondition:</b> minLength.getInt(e) defined for each edge in graph.
      * @param {yfiles.algorithms.Graph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the ranking is stored.
      * @param {yfiles.algorithms.IDataProvider} w here the weight of an edge is stored.
      * @param {yfiles.algorithms.IDataProvider} minLength here the minimal length of an edge is stored.
      * @return {number} the number of layers
      */
      simplex(g:yfiles.algorithms.Graph,layer:yfiles.algorithms.INodeMap,w:yfiles.algorithms.IDataProvider,minLength:yfiles.algorithms.IDataProvider):number;
      /**
      * Solves the rank assignment problem using the simplex method.
      * This method assigns a minimal rank to the nodes in a acyclic graph.
      * Although its time complexity has not been proven polynomial, in practice
      * it takes few iterations and runs quickly.
      * The algorithm is based on:
      * E.R. Gansner et al, <i>A Technique for Drawing Directed Graphs</i>,
      * IEEE Transactions on Software Engineering, Vol.19, No.3,
      * March 1993,
      * <p>
      * Note: if the algorithm exceeds the maximal duration, the result may not be optimal.
      * </p>
      * <b>Precondition:</b> GraphChecker.isAcyclic(graph)
      * <b>Precondition:</b> minLength.getInt(e) defined for each edge in graph.
      * @param {yfiles.algorithms.Graph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the ranking is stored.
      * @param {yfiles.algorithms.IDataProvider} w here the weight of an edge is stored.
      * @param {yfiles.algorithms.IDataProvider} minLength here the minimal length of an edge is stored.
      * @param {number} maximalDuration a preferred time limit for the algorithm in milliseconds.
      * @return {number} the number of layers
      */
      simplexWithMaximalDuration(g:yfiles.algorithms.Graph,layer:yfiles.algorithms.INodeMap,w:yfiles.algorithms.IDataProvider,minLength:yfiles.algorithms.IDataProvider,maximalDuration:number):number;
      /**
      * Similar to {@link yfiles.algorithms.RankAssignments#simplex}.
      * Additionally
      * it is possible to provide a valid initial tree solution for the problem.
      * @param {yfiles.algorithms.Graph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the ranking is stored.
      * @param {yfiles.algorithms.IDataProvider} w here the weight of an edge is stored.
      * @param {yfiles.algorithms.IDataProvider} minLength here the minimal length of an edge is stored.
      * @param {boolean} validRanking 
      * if <code>true</code>, the argument
      * <code>layer</code> contains a valid ranking.
      * @param {yfiles.algorithms.IEdgeMap} tree may contain a valid tree solution.
      * @param {yfiles.algorithms.Node} _root the root of the tree solution.
      * @return {number} the number of layers
      */
      simplexWithRankingValidity(g:yfiles.algorithms.Graph,layer:yfiles.algorithms.INodeMap,w:yfiles.algorithms.IDataProvider,minLength:yfiles.algorithms.IDataProvider,tree:yfiles.algorithms.IEdgeMap,_root:yfiles.algorithms.Node,validRanking:boolean):number;
      /**
      * Similar to {@link yfiles.algorithms.RankAssignments#simplex}.
      * Additionally
      * it is possible to provide a valid initial tree solution for the problem.
      * <p>
      * Note: if the algorithm exceeds the maximal duration, the result may not be optimal.
      * </p>
      * @param {yfiles.algorithms.Graph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the ranking is stored.
      * @param {yfiles.algorithms.IDataProvider} w here the weight of an edge is stored.
      * @param {yfiles.algorithms.IDataProvider} minLength here the minimal length of an edge is stored.
      * @param {boolean} validRanking 
      * if <code>true</code>, the argument
      * <code>layer</code> contains a valid ranking.
      * @param {yfiles.algorithms.IEdgeMap} tree may contain a valid tree solution.
      * @param {yfiles.algorithms.Node} _root the root of the tree solution.
      * @param {number} maximalDuration a preferred time limit for the algorithm in milliseconds.
      * @return {number} the number of layers
      */
      simplexWithRankingValidityAndMaximalDuration(g:yfiles.algorithms.Graph,layer:yfiles.algorithms.INodeMap,w:yfiles.algorithms.IDataProvider,minLength:yfiles.algorithms.IDataProvider,tree:yfiles.algorithms.IEdgeMap,_root:yfiles.algorithms.Node,validRanking:boolean,maximalDuration:number):number;
      /**
      * This method quickly calculates a tight tree
      * using a highly optimized version of Gansner's algorithm .
      * @param {yfiles.algorithms.Graph} g 
      * the graph, where all the edges have directions, such that
      * rank[source] &lt; rank[target] and rank[target] - rank[source] &gt;= minlength[edge]
      * @param {yfiles.algorithms.INodeMap} rank the initial ranking
      * @param {yfiles.algorithms.IEdgeMap} minLength 
      * the minimal (tight) lengths for each edge. Values must be
      * non-negative.
      * @return {number} the number of layers.
      */
      simple(g:yfiles.algorithms.Graph,rank:yfiles.algorithms.INodeMap,minLength:yfiles.algorithms.IEdgeMap):number;
      /**
      * This method quickly calculates a tight tree
      * using a highly optimized version of Gansner's algorithm .
      * <p>
      * Note: if the algorithm exceeds the maximal duration, the result may be invalid (not a valid ranking).
      * </p>
      * @param {yfiles.algorithms.Graph} g 
      * the graph, where all the edges have directions, such that
      * rank[source] &lt; rank[target] and rank[target] - rank[source] &gt;= minlength[edge]
      * @param {yfiles.algorithms.INodeMap} rank the initial ranking
      * @param {yfiles.algorithms.IEdgeMap} minLength 
      * the minimal (tight) lengths for each edge. Values must be
      * non-negative.
      * @param {number} maximalDuration a preferred time limit for the algorithm in milliseconds.
      * @return {number} the number of layers.
      */
      simpleWithMaximumDuration(g:yfiles.algorithms.Graph,rank:yfiles.algorithms.INodeMap,minLength:yfiles.algorithms.IEdgeMap,maximalDuration:number):number;
      /**
      * This method quickly calculates a tight tree
      * using a highly optimized version of Gansner's algorithm .
      * @param {yfiles.algorithms.Graph} g 
      * the graph, where all the edges have directions, such that
      * rank[source] &lt; rank[target] and rank[target] - rank[source] &gt;= minlength[edge]
      * @param {number[]} rank the initial ranking
      * @param {number[]} minLength 
      * the minimal (tight) lengths for each edge. Values must be
      * non-negative.
      * @return {number} the number of layers.
      */
      simpleFromArray(g:yfiles.algorithms.Graph,rank:number[],minLength:number[]):number;
      /**
      * This method quickly calculates a tight tree
      * using a highly optimized version of Gansner's algorithm .
      * <p>
      * Note: if the algorithm exceeds the maximal duration, the result may be invalid (not a valid ranking).
      * </p>
      * @param {yfiles.algorithms.Graph} g 
      * the graph, where all the edges have directions, such that
      * rank[source] &lt; rank[target] and rank[target] - rank[source] &gt;= minlength[edge]
      * @param {number[]} rank the initial ranking
      * @param {number[]} minLength 
      * the minimal (tight) lengths for each edge. Values must be
      * non-negative.
      * @param {number} maximalDuration a preferred time limit for the algorithm in milliseconds.
      * @return {number} the number of layers.
      */
      simpleFromArrayWithMaximalDuration(g:yfiles.algorithms.Graph,rank:number[],minLength:number[],maximalDuration:number):number;
    };
    /**
    * A utility class that can be used to copy a graph's structure and possibly associated data to another instance.
    * This
    * class relies on implementations of {@link yfiles.algorithms.GraphCopier.ICopyFactory} that can either be any of the default
    * implementations or any other implementation that can be associated with a {@link yfiles.algorithms.Graph}'s
    * {@link yfiles.algorithms.Graph#graphCopyFactory  copy factory property}.
    * @see {@link yfiles.algorithms.GraphCopier.ICopyFactory}
    * @see {@link yfiles.algorithms.GraphCopier#copy}
    */
    export interface GraphCopier extends Object{
      /**
      * Determines if the contents of node maps are copied automatically.
      * <p>
      * The default is <code>false</code>.
      * </p><p>
      * Copying will be done by reference on {@link Object} basis. To store these objects, new
      * {@link yfiles.algorithms.INodeMap}s are created for the target graph.
      * </p><p>
      * In order to access these {@link yfiles.algorithms.INodeMap}s it is necessary to store the number of {@link yfiles.algorithms.INodeMap}s in
      * the target graph before creating the {@link yfiles.algorithms.INodeMap}s as they will be appended. After copying the graph a
      * {@link yfiles.algorithms.INodeMap} can be found using this number as offset and add the index of the map in the original graph.
      * </p><p>
      * Note: To be able to control and access {@link yfiles.algorithms.INodeMap}s more easily, it is recommended to use
      * {@link yfiles.algorithms.IDataProvider}s instead and have them copied.
      * </p>
      * @see {@link yfiles.algorithms.GraphCopier.NodeMapCopyFactory}
      * @see {@link yfiles.algorithms.Graph#registeredNodeMaps}
      * @see {@link yfiles.algorithms.GraphCopier#dataProviderContentCopying}
      */
      nodeMapCopying:boolean;
      /**
      * Determines if the contents of edge maps are copied automatically.
      * <p>
      * The default is <code>false</code>.
      * </p><p>
      * Copying will be done by reference on {@link Object} basis. To store these objects, new
      * {@link yfiles.algorithms.IEdgeMap}s are created for the target graph.
      * </p><p>
      * In order to access these {@link yfiles.algorithms.IEdgeMap}s it is necessary to store the number of {@link yfiles.algorithms.IEdgeMap}s in
      * the target graph before creating the {@link yfiles.algorithms.IEdgeMap}s as they will be appended. After copying the graph an
      * {@link yfiles.algorithms.IEdgeMap} can be found using this number as offset and add the index of the map in the original graph.
      * </p><p>
      * Note: To be able to control and access {@link yfiles.algorithms.IEdgeMap}s more easily, it is recommended to use
      * {@link yfiles.algorithms.IDataProvider}s instead and have them copied.
      * </p>
      * @see {@link yfiles.algorithms.GraphCopier.EdgeMapCopyFactory}
      * @see {@link yfiles.algorithms.Graph#registeredEdgeMaps}
      * @see {@link yfiles.algorithms.GraphCopier#dataProviderContentCopying}
      */
      edgeMapCopying:boolean;
      /**
      * Determines if the contents of data providers are copied automatically.
      * <p>
      * The default is <code>false</code>.
      * </p><p>
      * Copying will be done by reference on {@link Object} basis.
      * The backing store for the content will be {@link yfiles.algorithms.HashMap} based.
      * </p>
      * @see {@link yfiles.algorithms.GraphCopier.ItemDataProviderCopyFactory}
      */
      dataProviderContentCopying:boolean;
      /**
      * Copies the contents of the source graph to the target graph and returns the newly created nodes in the target
      * graph.
      * @param {yfiles.algorithms.Graph} sourceGraph the graph to copy the contents from
      * @param {yfiles.algorithms.Graph} targetGraph the target graph to copy the contents to, it will not be cleared prior to the copying
      * @return {yfiles.algorithms.NodeList} the list of Nodes that have been copied to the target graph.
      * @see {@link yfiles.algorithms.GraphCopier#copySubgraphNodes}
      */
      copyFromSourceToTargetGraph(sourceGraph:yfiles.algorithms.Graph,targetGraph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList;
      /**
      * Copies the contents of the source graph to a newly created target graph and returns the new graph.
      * @param {yfiles.algorithms.Graph} sourceGraph the graph to copy the contents from
      * @return {yfiles.algorithms.Graph} the newly created graph
      * @see {@link yfiles.algorithms.GraphCopier.ICopyFactory#createGraph}
      */
      copy(sourceGraph:yfiles.algorithms.Graph):yfiles.algorithms.Graph;
      /**
      * Copies the subgraph contained in graph induced by the source nodes to a newly created graph.
      * @param {yfiles.algorithms.Graph} sourceGraph the graph to copy
      * @param {yfiles.algorithms.INodeCursor} sourceNodes the nodes in the sourceGraph to copy to the new graph
      * @return {yfiles.algorithms.Graph} the newly created graph
      * @see {@link yfiles.algorithms.GraphCopier.ICopyFactory#createGraph}
      */
      copyWithSourceGraphAndSourceNodes(sourceGraph:yfiles.algorithms.Graph,sourceNodes:yfiles.algorithms.INodeCursor):yfiles.algorithms.Graph;
      /**
      * The factory that is used for copy operations.
      * @throws {yfiles.system.ArgumentNullException} if <code>copyFactory</code> is <code>null</code>
      */
      copyFactory:yfiles.algorithms.GraphCopier.ICopyFactory;
      /**
      * Callback that uses the given factory to create a new graph.
      * This method simply delegates to {@link yfiles.algorithms.GraphCopier.ICopyFactory#createGraph} and can be overwritten to change the behavior.
      * @param {yfiles.algorithms.GraphCopier.ICopyFactory} factory the factory to use for the creation
      * @param {yfiles.algorithms.Graph} sourceGraph the graph that will be
      * @return {yfiles.algorithms.Graph} the newly created graph
      */
      createGraph(factory:yfiles.algorithms.GraphCopier.ICopyFactory,sourceGraph:yfiles.algorithms.Graph):yfiles.algorithms.Graph;
      /**
      * Copies the subgraph contained in sourceGraph induced by the source nodes to the targetGraph.
      * targetGraph is not
      * cleared prior to the copy operation.
      * @param {yfiles.algorithms.Graph} sourceGraph the graph to copy
      * @param {yfiles.algorithms.INodeCursor} sourceNodes the nodes in the sourceGraph to copy to the new graph
      * @param {yfiles.algorithms.Graph} targetGraph the graph to copy the sourceGraph's contents to
      * @return {yfiles.algorithms.NodeList} the list of the new nodes in targetGraph
      */
      copySubgraphNodes(sourceGraph:yfiles.algorithms.Graph,sourceNodes:yfiles.algorithms.INodeCursor,targetGraph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList;
      /**
      * Copies the subgraph contained in sourceGraph induced by the source nodes and the provided source edges to the targetGraph.
      * targetGraph is not cleared prior to the copy operation.
      * @param {yfiles.algorithms.Graph} sourceGraph the graph to copy
      * @param {yfiles.algorithms.INodeCursor} sourceNodes the nodes in the sourceGraph to copy to the new graph
      * @param {yfiles.algorithms.Graph} targetGraph the graph to copy the sourceGraph's contents to
      * @param {yfiles.algorithms.IEdgeCursor} sourceEdges the edges in the sourceGraph to copy to the new graph
      * @return {yfiles.algorithms.NodeList} the list of the new nodes in targetGraph
      */
      copySubgraph(sourceGraph:yfiles.algorithms.Graph,sourceNodes:yfiles.algorithms.INodeCursor,sourceEdges:yfiles.algorithms.IEdgeCursor,targetGraph:yfiles.algorithms.Graph):yfiles.algorithms.NodeList;
      /**
      * Callback that uses the given factory to perform the copy operation.
      * This method simply delegates to {@link yfiles.algorithms.GraphCopier.ICopyFactory#preCopyGraphData} and can be overwritten to change
      * the behavior.
      * @param {yfiles.algorithms.GraphCopier.ICopyFactory} copyFactory the factory delegate the operation to
      */
      preCopyGraphData(copyFactory:yfiles.algorithms.GraphCopier.ICopyFactory,sourceGraph:yfiles.algorithms.Graph,targetGraph:yfiles.algorithms.Graph):void;
      /**
      * Callback that uses the given factory to perform the copy operation.
      * This method simply delegates to {@link yfiles.algorithms.GraphCopier.ICopyFactory#postCopyGraphData} and can
      * be overwritten to change the behavior.
      * @param {yfiles.algorithms.GraphCopier.ICopyFactory} copyFactory the factory delegate the operation to
      */
      postCopyGraphData(copyFactory:yfiles.algorithms.GraphCopier.ICopyFactory,sourceGraph:yfiles.algorithms.Graph,targetGraph:yfiles.algorithms.Graph,nodeMap:yfiles.algorithms.IMap,edgeMap:yfiles.algorithms.IMap):void;
      /**
      * Callback that creates the Map that will hold the mapping from the edges in the old source graph to the newly
      * created edges in the target graph.
      * @return {yfiles.algorithms.IMap} A map that can be used to store the mapping.
      */
      createEdgeMap():yfiles.algorithms.IMap;
      /**
      * Callback that uses the given factory to perform the copy operation.
      * This method simply delegates to {@link yfiles.algorithms.GraphCopier.ICopyFactory#copyEdge} and can be
      * overwritten to change the behavior.
      * @param {yfiles.algorithms.GraphCopier.ICopyFactory} copyFactory the factory delegate the operation to
      */
      copyEdge(copyFactory:yfiles.algorithms.GraphCopier.ICopyFactory,targetGraph:yfiles.algorithms.Graph,newSource:yfiles.algorithms.Node,newTarget:yfiles.algorithms.Node,edge:yfiles.algorithms.Edge):yfiles.algorithms.Edge;
      /**
      * Determines the set of edge candidates from the source graph that should be copied.
      * Note that if any of the source
      * or target node is not present in the target graph the edge will not be copied. This implementation simply returns
      * {@link yfiles.algorithms.Graph#getEdgeCursor}
      * @param {yfiles.algorithms.Graph} sourceGraph the graph to determine the edges to copy
      * @return {yfiles.algorithms.IEdgeCursor} the edges to copy
      */
      getSourceEdges(sourceGraph:yfiles.algorithms.Graph):yfiles.algorithms.IEdgeCursor;
      /**
      * Callback that uses the given factory to perform the copy operation.
      * This method simply delegates to {@link yfiles.algorithms.GraphCopier.ICopyFactory#copyNode}
      * and can be overwritten to change the behavior.
      * @param {yfiles.algorithms.GraphCopier.ICopyFactory} copyFactory the factory delegate the operation to
      */
      copyNode(copyFactory:yfiles.algorithms.GraphCopier.ICopyFactory,targetGraph:yfiles.algorithms.Graph,node:yfiles.algorithms.Node):yfiles.algorithms.Node;
      /**
      * Callback that creates the Map that will hold the mapping from the nodes in the old source graph to the newly
      * created nodes in the target graph.
      * @return {yfiles.algorithms.IMap} A map that can be used to store the mapping.
      */
      createNodeMap():yfiles.algorithms.IMap;
      /**
      * Determines the set of node candidates from the source graph that should be copied if
      * no other nodes are specified by the user.
      * This implementation simply returns
      * {@link yfiles.algorithms.Graph#getNodeCursor}
      * @param {yfiles.algorithms.Graph} sourceGraph the graph to determine the nodes to copy
      * @return {yfiles.algorithms.INodeCursor} the nodes to copy
      */
      getSourceNodes(sourceGraph:yfiles.algorithms.Graph):yfiles.algorithms.INodeCursor;
    }
    export module GraphCopier{
      /**
      * An abstract base implementation of a delegating {@link yfiles.algorithms.GraphCopier.ICopyFactory} that
      * copies data for items being copied.
      * The actual copying will be performed
      * by the wrapped delegate. Instances of this class should be used to wrap
      * existing copy factories.
      * Subclasses should override any or all of the
      * {@link yfiles.algorithms.GraphCopier.GraphDataCopyFactory#copyNodeData},
      * {@link yfiles.algorithms.GraphCopier.GraphDataCopyFactory#copyEdgeData},
      * {@link yfiles.algorithms.GraphCopier.GraphDataCopyFactory#preCopyData}, and
      * {@link yfiles.algorithms.GraphCopier.GraphDataCopyFactory#postCopyData}
      * methods.
      */
      export interface GraphDataCopyFactory extends Object,yfiles.algorithms.GraphCopier.ICopyFactory{
        /**
        * Calls {@link yfiles.algorithms.GraphCopier.GraphDataCopyFactory#preCopyData} and then the delegate.
        * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#preCopyGraphData}.
        */
        preCopyGraphData(srcGraph:yfiles.algorithms.Graph,newGraph:yfiles.algorithms.Graph):void;
        /**
        * Calls the delegate and then {@link yfiles.algorithms.GraphCopier.GraphDataCopyFactory#postCopyData}.
        * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#postCopyGraphData}.
        */
        postCopyGraphData(srcGraph:yfiles.algorithms.Graph,newGraph:yfiles.algorithms.Graph,nodeMap:yfiles.algorithms.IMap,edgeMap:yfiles.algorithms.IMap):void;
        /**
        * Delegates the copying of the data to {@link yfiles.algorithms.GraphCopier.GraphDataCopyFactory#copyNodeData}.
        * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#copyNode}.
        */
        copyNode(graph:yfiles.algorithms.Graph,hint:yfiles.algorithms.Node):yfiles.algorithms.Node;
        /**
        * Creates a new graph instance that will be the target graph of the copy operation.
        * This method is called if no target graph is specified by the user.
        * @return {yfiles.algorithms.Graph} the graph to use as the target graph
        * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#createGraph}.
        */
        createGraph():yfiles.algorithms.Graph;
        /**
        * Empty stub to be overwritten by subclass implementations.
        */
        preCopyData(src:yfiles.algorithms.Graph,dst:yfiles.algorithms.Graph):void;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.IMap} nodeMap a Map that maps old node instances to their new copies
        * @param {yfiles.algorithms.IMap} edgeMap a Map that maps old edge instances to their new copies
        */
        postCopyData(src:yfiles.algorithms.Graph,dst:yfiles.algorithms.Graph,nodeMap:yfiles.algorithms.IMap,edgeMap:yfiles.algorithms.IMap):void;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.Node} src the old entity
        * @param {yfiles.algorithms.Node} dst the new entity
        */
        copyNodeData(src:yfiles.algorithms.Node,dst:yfiles.algorithms.Node):void;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.Edge} src the old entity
        * @param {yfiles.algorithms.Edge} dst the new entity
        */
        copyEdgeData(src:yfiles.algorithms.Edge,dst:yfiles.algorithms.Edge):void;
        /**
        * Delegates the copying of the data to {@link yfiles.algorithms.GraphCopier.GraphDataCopyFactory#copyEdgeData}.
        * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#copyEdge}.
        */
        copyEdge(graph:yfiles.algorithms.Graph,source:yfiles.algorithms.Node,target:yfiles.algorithms.Node,hint:yfiles.algorithms.Edge):yfiles.algorithms.Edge;
      }
      /**
      * Abstract helper class that provides helper methods to copy {@link yfiles.algorithms.IDataProvider} contents.
      */
      export interface DataProviderCopyFactory extends yfiles.algorithms.GraphCopier.GraphDataCopyFactory{
        /**
        * The DataProvider key.
        */
        dpKey:Object;
        /**
        * Calls {@link yfiles.algorithms.GraphCopier.DataProviderCopyFactory#createMap} and registers that map on the
        * target graph if there is no {@link yfiles.algorithms.IDataMap} registered on the
        * target graph yet.
        * @see Overrides {@link yfiles.algorithms.GraphCopier.GraphDataCopyFactory#preCopyData}
        */
        preCopyData(src:yfiles.algorithms.Graph,dst:yfiles.algorithms.Graph):void;
        /**
        * Factory callback to create the backing storage.
        */
        createMap(dst:yfiles.algorithms.Graph):yfiles.algorithms.IDataMap;
        /**
        * Helper method that retrieves the map for the given graph instance.
        * @param {yfiles.algorithms.Graph} graph Graph instance for which the map is retrieved
        * @return {yfiles.algorithms.IDataMap} the map for the given graph instance
        */
        getMap(graph:yfiles.algorithms.Graph):yfiles.algorithms.IDataMap;
      }
      /**
      * Helper class implementation of {@link yfiles.algorithms.GraphCopier.ICopyFactory} that
      * can be used to copy the contents of a {@link yfiles.algorithms.IDataProvider} registered with
      * the source graph onto the target graph storing the values in newly created
      * {@link yfiles.algorithms.Graph#createNodeMap  node map}.
      * @see {@link yfiles.algorithms.GraphCopier.NodeDataProviderCopyFactory#copyNodeDataToNode}
      */
      export interface NodeDataProviderCopyFactory extends yfiles.algorithms.GraphCopier.DataProviderCopyFactory{
        /**
        * Factory callback to create the backing storage.
        */
        createMap(dst:yfiles.algorithms.Graph):yfiles.algorithms.IDataMap;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.Node} src the old entity
        * @param {yfiles.algorithms.Node} dst the new entity
        */
        copyNodeData(src:yfiles.algorithms.Node,dst:yfiles.algorithms.Node):void;
        /**
        * Callback method that performs the actual copying of the data.
        * This implementation simply returns the reference.
        */
        copyNodeDataToNode(dpKey:Object,src:yfiles.algorithms.Node,dst:yfiles.algorithms.Node,value:Object):Object;
      }
      /**
      * A helper wrapping implementation of the {@link yfiles.algorithms.GraphCopier.ICopyFactory} interface that copies the contents
      * of the node maps from the source to the target graph.
      * @see {@link yfiles.algorithms.GraphCopier.NodeMapCopyFactory#copy}
      */
      export interface NodeMapCopyFactory extends yfiles.algorithms.GraphCopier.GraphDataCopyFactory{
        /**
        * Empty stub to be overwritten by subclass implementations.
        */
        preCopyData(src:yfiles.algorithms.Graph,dst:yfiles.algorithms.Graph):void;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.Node} src the old entity
        * @param {yfiles.algorithms.Node} dst the new entity
        */
        copyNodeData(src:yfiles.algorithms.Node,dst:yfiles.algorithms.Node):void;
        /**
        * Callback method that performs the actual copying of the data.
        * This implementation simply returns the reference.
        */
        copy(src:yfiles.algorithms.Node,dst:yfiles.algorithms.Node,value:Object):Object;
      }
      /**
      * A helper wrapping implementation of the {@link yfiles.algorithms.GraphCopier.ICopyFactory} interface that copies the contents
      * of the edge maps from the source to the target graph.
      * @see {@link yfiles.algorithms.GraphCopier.EdgeMapCopyFactory#copy}
      */
      export interface EdgeMapCopyFactory extends yfiles.algorithms.GraphCopier.GraphDataCopyFactory{
        /**
        * Empty stub to be overwritten by subclass implementations.
        */
        preCopyData(src:yfiles.algorithms.Graph,dst:yfiles.algorithms.Graph):void;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.Edge} src the old entity
        * @param {yfiles.algorithms.Edge} dst the new entity
        */
        copyEdgeData(src:yfiles.algorithms.Edge,dst:yfiles.algorithms.Edge):void;
        /**
        * Callback method that performs the actual copying of the data.
        * This implementation simply returns the reference.
        */
        copy(src:yfiles.algorithms.Edge,dst:yfiles.algorithms.Edge,value:Object):Object;
      }
      /**
      * Helper class implementation of {@link yfiles.algorithms.GraphCopier.ICopyFactory} that
      * can be used to copy the contents of a {@link yfiles.algorithms.IDataProvider} registered with
      * the source graph onto the target graph storing the values in newly created
      * {@link yfiles.algorithms.HashMap} based {@link yfiles.algorithms.IDataMap}s.
      * @see {@link yfiles.algorithms.GraphCopier.ItemDataProviderCopyFactory#copyNodeDataToNode}
      * @see {@link yfiles.algorithms.GraphCopier.ItemDataProviderCopyFactory#copyEdgeDataToNode}
      */
      export interface ItemDataProviderCopyFactory extends yfiles.algorithms.GraphCopier.DataProviderCopyFactory{
        /**
        * Factory callback to create the backing storage.
        */
        createMap(dst:yfiles.algorithms.Graph):yfiles.algorithms.IDataMap;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.Node} src the old entity
        * @param {yfiles.algorithms.Node} dst the new entity
        */
        copyNodeData(src:yfiles.algorithms.Node,dst:yfiles.algorithms.Node):void;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.Edge} src the old entity
        * @param {yfiles.algorithms.Edge} dst the new entity
        */
        copyEdgeData(src:yfiles.algorithms.Edge,dst:yfiles.algorithms.Edge):void;
        /**
        * Callback method that performs the actual copying of the data.
        * This implementation simply returns the reference.
        */
        copyNodeDataToNode(dpKey:Object,src:yfiles.algorithms.Node,dst:yfiles.algorithms.Node,value:Object):Object;
        /**
        * Callback method that performs the actual copying of the data.
        * This implementation simply returns the reference.
        */
        copyEdgeDataToNode(dpKey:Object,src:yfiles.algorithms.Edge,dst:yfiles.algorithms.Edge,value:Object):Object;
      }
      /**
      * Helper class implementation of {@link yfiles.algorithms.GraphCopier.ICopyFactory} that
      * can be used to copy the contents of a {@link yfiles.algorithms.IDataProvider} registered with
      * the source graph onto the target graph storing the values in newly a
      * created {@link yfiles.algorithms.Graph#createEdgeMap  edge map}.
      * @see {@link yfiles.algorithms.GraphCopier.EdgeDataProviderCopyFactory#copy}
      */
      export interface EdgeDataProviderCopyFactory extends yfiles.algorithms.GraphCopier.DataProviderCopyFactory{
        /**
        * Factory callback to create the backing storage.
        */
        createMap(dst:yfiles.algorithms.Graph):yfiles.algorithms.IDataMap;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.Edge} src the old entity
        * @param {yfiles.algorithms.Edge} dst the new entity
        */
        copyEdgeData(src:yfiles.algorithms.Edge,dst:yfiles.algorithms.Edge):void;
        /**
        * Callback method that performs the actual copying of the data.
        * This implementation simply returns the reference.
        */
        copy(dpKey:Object,src:yfiles.algorithms.Edge,dst:yfiles.algorithms.Edge,value:Object):Object;
      }
      /**
      * The copy factory interface used by {@link yfiles.algorithms.GraphCopier} to delegate the actual work to.
      */
      export interface ICopyFactory extends Object{
        /**
        * Copies the <code>originalNode</code> from the source graph to the new <code>targetGraph</code>.
        * @param {yfiles.algorithms.Graph} targetGraph the graph to create the new node in
        * @param {yfiles.algorithms.Node} originalNode the original node from the source graph
        * @return {yfiles.algorithms.Node} the newly created node
        * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#copyNode}.
        */
        copyNode(targetGraph:yfiles.algorithms.Graph,originalNode:yfiles.algorithms.Node):yfiles.algorithms.Node;
        /**
        * Copies the <code>originalEdge</code> from the source graph to the new <code>targetGraph</code>
        * using the specified new source and target node in the target graph.
        * @param {yfiles.algorithms.Graph} targetGraph the graph to create the new node in
        * @param {yfiles.algorithms.Node} newSource the source node in the target graph to use for the newly created edge
        * @param {yfiles.algorithms.Node} newTarget the target node in the target graph to use for the newly created edge
        * @param {yfiles.algorithms.Edge} originalEdge the original edge from the source graph
        * @return {yfiles.algorithms.Edge} the newly created edge
        * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#copyEdge}.
        */
        copyEdge(targetGraph:yfiles.algorithms.Graph,newSource:yfiles.algorithms.Node,newTarget:yfiles.algorithms.Node,originalEdge:yfiles.algorithms.Edge):yfiles.algorithms.Edge;
        /**
        * Creates a new graph instance that will be the target graph of the copy operation.
        * This method is called if no target graph is specified by the user.
        * @return {yfiles.algorithms.Graph} the graph to use as the target graph
        * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#createGraph}.
        */
        createGraph():yfiles.algorithms.Graph;
        /**
        * Callback that will be called before the copy operation takes place.
        * At that point in time no entities have been copied to the new graph.
        * @param {yfiles.algorithms.Graph} sourceGraph the graph that will be used to copy the entities from.
        * @param {yfiles.algorithms.Graph} targetGraph the graph that will be used to copy the entities to.
        * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#preCopyGraphData}.
        */
        preCopyGraphData(sourceGraph:yfiles.algorithms.Graph,targetGraph:yfiles.algorithms.Graph):void;
        /**
        * Callback that will be called after the copy operation has completed.
        * At that point in time all entities have been copied to the new graph.
        * @param {yfiles.algorithms.Graph} sourceGraph the graph that was used to copy the entities from.
        * @param {yfiles.algorithms.Graph} targetGraph the graph that was used to copy the entities to.
        * @param {yfiles.algorithms.IMap} nodeMap 
        * a map that contains a mapping between the nodes in the source graph
        * to their corresponding nodes in the new graph.
        * @param {yfiles.algorithms.IMap} edgeMap 
        * a map that contains a mapping between the edges in the source graph
        * to their corresponding edges in the new graph.
        * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#postCopyGraphData}.
        */
        postCopyGraphData(sourceGraph:yfiles.algorithms.Graph,targetGraph:yfiles.algorithms.Graph,nodeMap:yfiles.algorithms.IMap,edgeMap:yfiles.algorithms.IMap):void;
      }
    }
    var GraphCopier:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance that uses a {@link yfiles.algorithms.GraphCopyFactory} as the default factory.
      */
      new ():yfiles.algorithms.GraphCopier;
      GraphDataCopyFactory:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance that delegates the actual copying process of the elements to the provided factory.
        * @param {yfiles.algorithms.GraphCopier.ICopyFactory} delegatingFactory 
        */
        new (delegatingFactory:yfiles.algorithms.GraphCopier.ICopyFactory):yfiles.algorithms.GraphCopier;
      };
      DataProviderCopyFactory:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new delegating instance that copies the data for the given data provider key.
        * @param {yfiles.algorithms.GraphCopier.ICopyFactory} delegatingFactory the factory to delegate to.
        * @param {Object} dpKey the data provider key
        */
        new (delegatingFactory:yfiles.algorithms.GraphCopier.ICopyFactory,dpKey:Object):yfiles.algorithms.GraphCopier;
      };
      NodeDataProviderCopyFactory:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance using the delegate for the given data provider key.
        */
        new (delegatingFactory:yfiles.algorithms.GraphCopier.ICopyFactory,dpKey:Object):yfiles.algorithms.GraphCopier;
      };
      NodeMapCopyFactory:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance that copies the node map contents.
        * @param {yfiles.algorithms.GraphCopier.ICopyFactory} delegatingFactory the factory to delegate the copying of the entities to.
        */
        new (delegatingFactory:yfiles.algorithms.GraphCopier.ICopyFactory):yfiles.algorithms.GraphCopier;
      };
      EdgeMapCopyFactory:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance that copies the node map contents.
        * @param {yfiles.algorithms.GraphCopier.ICopyFactory} delegatingFactory the factory to delegate the copying of the entities to.
        */
        new (delegatingFactory:yfiles.algorithms.GraphCopier.ICopyFactory):yfiles.algorithms.GraphCopier;
      };
      ItemDataProviderCopyFactory:{
        $class:yfiles.lang.Class;
        new (delegatingFactory:yfiles.algorithms.GraphCopier.ICopyFactory,dpKey:Object):yfiles.algorithms.GraphCopier;
      };
      EdgeDataProviderCopyFactory:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance using the delegate for the given data provider key.
        */
        new (delegatingFactory:yfiles.algorithms.GraphCopier.ICopyFactory,dpKey:Object):yfiles.algorithms.GraphCopier;
      };
      /**
      * Creates a new instance that uses the specified factory to perform the actual copy operations.
      * @param {yfiles.algorithms.GraphCopier.ICopyFactory} copyFactory the factory to use, must be non-<code>null</code>.
      * @throws {yfiles.system.ArgumentNullException} if <code>copyFactory</code> is <code>null</code>
      */
      WithFactory:{
        new (copyFactory:yfiles.algorithms.GraphCopier.ICopyFactory):yfiles.algorithms.GraphCopier;
      };
    };
    /**
    * Provides functionality to hide and unhide nodes and edges of a graph temporarily for algorithmic operations.
    * <p>
    * This class can be used to temporarily hide away certain elements
    * of a graph and to unhide that parts at a later time again.
    * Instances of this class keep track of graph elements that were
    * hidden from a graph in order to make them visible again
    * at a later time.
    * </p>
    * <p>
    * Note that this class should not be used to hide elements from a Graph2D for pure hiding purposes.
    * Since this class will by default prevent the graph instance from firing events, other code
    * might cease to work correctly. Use this class for short term removal of nodes and edges, only.
    * </p>
    */
    export interface GraphHider extends Object{
      /**
      * holds the list of the hidden edges in stack order.
      */
      hiddenEdgesF:yfiles.algorithms.EdgeList;
      /**
      * holds the list of the hidden nodes in stack order.
      */
      hiddenNodesF:yfiles.algorithms.NodeList;
      /**
      * Specifies whether or not this hider should fire graph events.
      * By default the hider does not fire graph events.
      */
      fireGraphEvents:boolean;
      /**
      * Hides all nodes and edges from this graph.
      * The hidden elements will be stored so that they can be unhidden
      * again at a later time.
      */
      hideAll():void;
      /**
      * Hides all edges from this graph.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      hideEdges():void;
      /**
      * Hides all self-loop edges from this graph.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      hideSelfLoops():void;
      /**
      * Hides all self-loops and multiple edges from the graph.
      * The overall effect of this method is that the minimum number of
      * edges are hidden from the graph such that it contains no
      * self-loops and no multiple edges anymore.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      simplifyGraph():void;
      /**
      * Hides multiple edges from the graph.
      * If there are multiple edges connecting two nodes then
      * all but one (representative) of these edges will be hidden.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      hideMultipleEdges():void;
      /**
      * Unhides all formerly hidden elements in the graph.
      */
      unhideAll():void;
      /**
      * Unhides all formerly hidden nodes in the graph.
      * Note that this
      * method does not unhide hidden edges.
      */
      unhideNodes():void;
      /**
      * Unhides all formerly hidden edges in the graph.
      * <b>Precondition:</b> 
      * Both source or target node of all
      * such edges must be contained in the graph.
      */
      unhideEdges():void;
      /**
      * Hides the given node and all it's adjacent edges from the graph.
      * The hidden elements will be stored so that they can be unhidden
      * again at a later time.
      */
      hideNode(v:yfiles.algorithms.Node):void;
      /**
      * Hides the given edge from the graph.
      * The hidden edge will be stored so that they can be unhidden
      * again at a later time.
      */
      hide(e:yfiles.algorithms.Edge):void;
      /**
      * Hides the given list of edges from the graph.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      hideEdgeList(el:yfiles.algorithms.EdgeList):void;
      /**
      * Hides the given list of nodes from the graph.
      * The hidden nodes and adjacent edges will be stored
      * so that they can be unhidden
      * again at a later time.
      */
      hideNodeList(nl:yfiles.algorithms.NodeList):void;
      /**
      * Hides the given edges from the graph.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      hideEdgeCursor(ec:yfiles.algorithms.IEdgeCursor):void;
      /**
      * Hides the given nodes from the graph.
      * The hidden nodes and adjacent edges will be stored
      * so that they can be unhidden
      * again at a later time.
      */
      hideNodeCursor(nc:yfiles.algorithms.INodeCursor):void;
      /**
      * Hides the given elements from the graph.
      * The hidden nodes and adjacent edges will be stored
      * so that they can be unhidden
      * again at a later time.
      */
      hideItemCursor(cursor:yfiles.algorithms.ICursor):void;
      /**
      * The <code>Graph</code> for which this <code>GraphHider</code> was
      * created.
      */
      graph:yfiles.algorithms.Graph;
      /**
      * This method will be called whenever
      * the hider is requested to unhide the given edge
      * from the graph.
      */
      unhideOneEdge(e:yfiles.algorithms.Edge):void;
      /**
      * Unhides the given edge.
      * Also updates {@link yfiles.algorithms.GraphHider#hiddenEdgesF}.
      * <p>
      * Note that unhiding an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed)
      * causes an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.
      * </p>
      * <b>Complexity:</b> O(hiddenEdges.size())
      * @param {yfiles.algorithms.Edge} e the edge that will be unhidden
      */
      unhideEdge(e:yfiles.algorithms.Edge):void;
      /**
      * Unhides the given edges.
      * Also updates {@link yfiles.algorithms.GraphHider#hiddenEdgesF}.
      * <p>
      * Note that unhiding an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed)
      * causes an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.
      * </p>
      * <b>Complexity:</b> O(hiddenEdges.size())
      * @param {yfiles.algorithms.EdgeList} edges the edges that will be unhidden
      */
      unhideEdgeList(edges:yfiles.algorithms.EdgeList):void;
      /**
      * Unhides the given nodes and if requested its adjacent edges.
      * Also updates {@link yfiles.algorithms.GraphHider#hiddenNodesF} and {@link yfiles.algorithms.GraphHider#hiddenEdgesF}.
      * <b>Complexity:</b> O(hiddenNodes.size()+hiddenEdges.size())
      * @param {yfiles.algorithms.NodeList} nodes the nodes that will be unhidden
      * @param {boolean} unhideAdjacentEdges 
      * whether of not to unhide previously hidden edges connected at the given nodes whose other end point
      * is not hidden, i.e. it is part of the graph.
      */
      unhideNodeList(nodes:yfiles.algorithms.NodeList,unhideAdjacentEdges:boolean):void;
      /**
      * Unhides the given node and if requested its adjacent edges.
      * Also updates {@link yfiles.algorithms.GraphHider#hiddenNodesF} and {@link yfiles.algorithms.GraphHider#hiddenEdgesF}.
      * <b>Complexity:</b> O(hiddenNodes.size()+hiddenEdges.size())
      * @param {yfiles.algorithms.Node} v the node that will be unhidden
      * @param {boolean} unhideAdjacentEdges 
      * whether of not to unhide previously hidden edges connected at <code>v</code> whose other end point
      * is not hidden, i.e. it is part of the graph.
      */
      unhideNode(v:yfiles.algorithms.Node,unhideAdjacentEdges:boolean):void;
      /**
      * This method will be called whenever
      * the hider is requested to unhide the given node
      * from the graph.
      */
      unhideOneNode(v:yfiles.algorithms.Node):void;
      /**
      * The nodes that are currently hidden.
      * @return {yfiles.algorithms.INodeCursor} a NodeList containing the currently hidden nodes
      */
      hiddenNodes():yfiles.algorithms.INodeCursor;
      /**
      * The edges that are currently hidden.
      * @return {yfiles.algorithms.IEdgeCursor} an EdgeList containing the currently hidden edges
      */
      hiddenEdges():yfiles.algorithms.IEdgeCursor;
    }
    var GraphHider:{
      $class:yfiles.lang.Class;
      /**
      * Instantiates a new GraphHider for the given graph.
      * All non-static hiding and unhiding methods will refer
      * to the given graph.
      */
      new (g:yfiles.algorithms.Graph):yfiles.algorithms.GraphHider;
      /**
      * Unhides the subgraph induced by the given edges in the given graph.
      * The induced subgraph defined by the given edges consists
      * of the given edges and all nodes that are either source
      * or target of at least one of the given edges.
      * Parts of the subgraph that are already contained in the given
      * graph will not be unhidden and pose no problem to this method.
      */
      unhideSubgraph(graph:yfiles.algorithms.Graph,ec:yfiles.algorithms.IEdgeCursor):void;
      /**
      * Hides the subgraph induced by the given edges from the given graph.
      * The induced subgraph defined by the given edges consists
      * of the given edges and all nodes that are solely connected
      * to the rest of the graph by the given edges.
      */
      hideSubgraph(graph:yfiles.algorithms.Graph,ec:yfiles.algorithms.IEdgeCursor):void;
    };
    /**
    * This class implements a priority queue for objects whose priority
    * values are of type double.
    * The implementation is based on binary heaps.
    */
    export interface DoubleObjectPQ extends Object{
      /**
      * Adds the given object with given priority to this queue.
      * <b>Precondition:</b> !contains(o)
      * <b>Complexity:</b> O(log(size()))
      */
      add(o:Object,priority:number):void;
      /**
      * Decreases the priority value of the given object.
      * <b>Precondition:</b> contains(o)
      * <b>Precondition:</b> priority &lt; getPriority(o)
      * <b>Complexity:</b> O(log(size()))
      */
      decreasePriority(o:Object,priority:number):void;
      /**
      * Increases the priority value of the given object.
      * <b>Precondition:</b> contains(o)
      * <b>Precondition:</b> priority > getPriority(o)
      * <b>Complexity:</b> O(log(size()))
      */
      increasePriority(o:Object,priority:number):void;
      /**
      * Changes the priority value of the given object.
      * <b>Precondition:</b> contains(o)
      * <b>Complexity:</b> O(log(size()))
      */
      changePriority(o:Object,priority:number):void;
      /**
      * Removes the object with smallest priority from this queue.
      * <b>Precondition:</b> !isEmpty()
      * <b>Complexity:</b> O(log(size()))
      * @return {Object} the removed object with smallest priority
      */
      removeMin():Object;
      /**
      * The object with smallest priority in this queue.
      * <b>Precondition:</b> !isEmpty()
      */
      min:Object;
      /**
      * The minimum priority value in this queue.
      */
      minPriority:number;
      /**
      * Returns whether or not the given object is contained.
      * in this queue.
      * <b>Complexity:</b> O(1)
      */
      contains(o:Object):boolean;
      /**
      * Specifies whether or not this queue is empty.
      * <b>Complexity:</b> O(1)
      */
      empty:boolean;
      /**
      * Returns the number of nodes currently in this queue.
      * <b>Complexity:</b> O(1)
      */
      size():number;
      /**
      * Returns the current priority of the given object.
      * <b>Precondition:</b> contains(o)
      */
      getPriority(o:Object):number;
      /**
      * Removes the given object from this queue.
      * <b>Precondition:</b> contains(o)
      * <b>Complexity:</b> O(log(size()))
      */
      remove(o:Object):void;
      /**
      * Makes this queue the empty queue.
      * <b>Complexity:</b> O(size())
      */
      clear():void;
      /**
      * Does nothing.
      */
      dispose():void;
    }
    var DoubleObjectPQ:{
      $class:yfiles.lang.Class;
      /**
      * Creates an empty ObjectPQ using the given {@link yfiles.algorithms.IDataProvider} and
      * {@link yfiles.algorithms.IDataAcceptor} to store and retrieve Object support information.
      * The contents of the provider should be modified through the use of the
      * acceptor, i.e. they should be based on the same initially empty backing store.
      * Additionally this backing store should not be modified externally as long as
      * this PQ is still in use.
      */
      new (initialSize:number,provider:yfiles.algorithms.IDataProvider,acceptor:yfiles.algorithms.IDataAcceptor):yfiles.algorithms.DoubleObjectPQ;
    };
    /**
    * This class is an empty abstract implementation of the EdgeMap interface.
    */
    export interface EdgeMapAdapter extends Object,yfiles.algorithms.IEdgeMap{
      /**
      * Associates the given value to with the given edge.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#set}.
      */
      set(edge:Object,value:Object):void;
      /**
      * Returns the value bound to the given edge.
      * @return {Object} <code>null</code>
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#get}.
      */
      get(edge:Object):Object;
      /**
      * Associates the given boolean value to with the given edge.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#setBool}.
      */
      setBool(edge:Object,value:boolean):void;
      /**
      * Returns the boolean value bound to the given edge.
      * <b>Precondition:</b> 
      * The value must have been associated to the given edge by
      * a call to <code>setBool</code>.
      * @return {boolean} <code>false</code>
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#getBool}.
      */
      getBool(edge:Object):boolean;
      /**
      * Associates the given double value to with the given edge.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#setDouble}.
      */
      setDouble(edge:Object,value:number):void;
      /**
      * Returns the double value bound to the given edge.
      * <b>Precondition:</b> 
      * The value must have been associated to the given edge by
      * a call to <code>setDouble</code>.
      * @return {number} <code>0.0d</code>
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#getDouble}.
      */
      getDouble(edge:Object):number;
      /**
      * Associates the given integer value to with the given edge.
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#setInt}.
      */
      setInt(edge:Object,value:number):void;
      /**
      * Returns the integer value bound to the given edge.
      * <b>Precondition:</b> 
      * The value must have been associated to the given edge by
      * a call to <code>setInt</code>.
      * @return {number} <code>0</code>
      * @see Specified by {@link yfiles.algorithms.IEdgeMap#getInt}.
      */
      getInt(edge:Object):number;
    }
    var EdgeMapAdapter:{
      $class:yfiles.lang.Class;
    };
    /**
    * Defines an interface for specialized priority queues that contains
    * nodes which are prioritized by associated double values.
    */
    export interface IDoubleNodePQ extends Object{
      /**
      * Specifies whether or not this queue is empty.
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#empty}.
      */
      empty:boolean;
      /**
      * Returns whether or not the given node is contained within this queue.
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#contains}.
      */
      contains(n:yfiles.algorithms.Node):boolean;
      /**
      * Adds a node with the given priority to the queue.
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#add}.
      */
      add(n:yfiles.algorithms.Node,priority:number):void;
      /**
      * Removes the node with the minimal priority from the queue.
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#removeMin}.
      */
      removeMin():yfiles.algorithms.Node;
      /**
      * He node with smallest priority in this queue.
      * <b>Precondition:</b> !isEmpty()
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#min}.
      */
      min:yfiles.algorithms.Node;
      /**
      * Decreases the priority of a node in the queue to a given value.
      * @param {yfiles.algorithms.Node} n a node in the priority queue.
      * @param {number} priority the new priority of the node.
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#decreasePriority}.
      */
      decreasePriority(n:yfiles.algorithms.Node,priority:number):void;
      /**
      * Removes all entries from the queue.
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#clear}.
      */
      clear():void;
      /**
      * Returns the current priority of the given node.
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#getPriority}.
      */
      getPriority(n:yfiles.algorithms.Node):number;
      /**
      * Disposes this queue.
      * It is important to call this method after the queue
      * is not needed anymore, to free bound resources.
      * @see Specified by {@link yfiles.algorithms.IDoubleNodePQ#dispose}.
      */
      dispose():void;
    }
    var IDoubleNodePQ:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Provides functionality to hide and unhide partitions of nodes and their adjacent edges of a graph temporarily for algorithmic operations.
    * <p>
    * This class can be used to temporarily hide away certain elements
    * of a graph and to unhide that parts at a later time again.
    * Instances of this class keep track of graph elements that were
    * hidden from a graph in order to make them visible again
    * at a later time.
    * </p>
    * <p>
    * Note that this class should not be used to hide elements from a Graph2D for pure hiding purposes.
    * Since this class will by default prevent the graph instance from firing events, other code
    * might cease to work correctly. Use this class for short term removal of nodes and edges, only.
    * </p>
    */
    export interface GraphPartitionManager extends Object{
      /**
      * Initializes internal data structures using the new DataProvider.
      * This method must also be called whenever the content of the given
      * DataProvider changes.
      * @param {yfiles.algorithms.IDataProvider} partitionId 
      * the data provider that holds the partitionIds for all
      * elements.
      */
      initPartitions(partitionId:yfiles.algorithms.IDataProvider):void;
      /**
      * Hides nodes and adjacent edges that have the given partitionId associated.
      * @param {Object} partitionId the id
      */
      hidePartition(partitionId:Object):void;
      /**
      * Unhides nodes that have the given partitionId associated.
      * @param {Object} partitionId the id
      */
      unhidePartition(partitionId:Object):void;
      /**
      * Assures that only nodes are visible in the graph that are associated with
      * the given partitionId.
      * @param {Object} partitionId the partitionId for the nodes that will be made visible
      */
      displayPartition(partitionId:Object):void;
      /**
      * Specifies whether or not this partition manager should fire graph events.
      * By default the partition manager does not fire graph events.
      */
      fireGraphEventsEnabled:boolean;
      /**
      * Hides all nodes and edges from this graph.
      * The hidden elements will be stored so that they can be unhidden
      * again at a later time.
      */
      hideAll():void;
      /**
      * Hides all edges from this graph.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      hideEdges():void;
      /**
      * Hides all self-loop edges from this graph.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      hideSelfLoops():void;
      /**
      * Hides all self-loops and multiple edges from the graph.
      * The overall effect of this method is that the minimum number of
      * edges are hidden from the graph such that it contains no
      * self-loops and no multiple edges anymore.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      simplifyGraph():void;
      /**
      * Hides multiple edges from the graph.
      * If there are multiple edges connecting two nodes then
      * all but one (representative) of these edges will be hidden.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      hideMultipleEdges():void;
      /**
      * Unhides all formerly hidden elements in the graph.
      */
      unhideAll():void;
      /**
      * Unhides all formerly hidden nodes in the graph.
      * Note that this
      * method does not unhide hidden edges.
      */
      unhideNodes():void;
      /**
      * Unhides all formerly hidden edges in the graph.
      * <b>Precondition:</b> 
      * Both source or target node of all
      * such edges must be contained in the graph.
      */
      unhideEdges():void;
      /**
      * Hides the given node and all it's adjacent edges from the graph.
      * The hidden elements will be stored so that they can be unhidden
      * again at a later time.
      */
      hideNode(v:yfiles.algorithms.Node):void;
      /**
      * Hides the given edge from the graph.
      * The hidden edge will be stored so that they can be unhidden
      * again at a later time.
      */
      hideEdge(e:yfiles.algorithms.Edge):void;
      /**
      * Hides the given list of edges from the graph.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      hideEdgeList(el:yfiles.algorithms.EdgeList):void;
      /**
      * Hides the given list of nodes from the graph.
      * The hidden nodes and adjacent edges will be stored
      * so that they can be unhidden
      * again at a later time.
      */
      hideNodeList(nl:yfiles.algorithms.NodeList):void;
      /**
      * Hides the given edges from the graph.
      * The hidden edges will be stored so that they can be unhidden
      * again at a later time.
      */
      hideEdgeCursor(ec:yfiles.algorithms.IEdgeCursor):void;
      /**
      * Hides the given nodes from the graph.
      * The hidden nodes and adjacent edges will be stored
      * so that they can be unhidden
      * again at a later time.
      */
      hideNodeCursor(nc:yfiles.algorithms.INodeCursor):void;
      /**
      * Hides the given elements from the graph.
      * The hidden nodes and adjacent edges will be stored
      * so that they can be unhidden
      * again at a later time.
      */
      hideItemCursor(cursor:yfiles.algorithms.ICursor):void;
      /**
      * The <code>Graph</code> for which this partition manager was
      * created.
      */
      graph:yfiles.algorithms.Graph;
      /**
      * This method will be called whenever the partition manager is requested to
      * unhide the given edge from the graph.
      */
      unhideEdge(e:yfiles.algorithms.Edge):void;
      /**
      * This method will be called whenever the partition manager is requested to
      * unhide the given node from the graph.
      */
      unhideNode(v:yfiles.algorithms.Node):void;
    }
    var GraphPartitionManager:{
      $class:yfiles.lang.Class;
      /**
      * Instantiates a new GraphPartitionManager for the given graph.
      * All non-static hiding and unhiding methods will refer
      * to the given graph.
      */
      new (graph:yfiles.algorithms.Graph,partitionId:yfiles.algorithms.IDataProvider):yfiles.algorithms.GraphPartitionManager;
    };
    export enum GraphElementInsertion{
      /**
      * Object insertion specifier. 
      * An object gets inserted before another one.
      */
      BEFORE,
      /**
      * Object insertion specifier. 
      * An object gets inserted after another one.
      */
      AFTER
    }
    export enum BfsDirection{
      /**
      * Edge direction specifier for incoming edges.
      * @see {@link yfiles.algorithms.Bfs#getLayersWithDirection}
      */
      PREDECESSOR,
      /**
      * Edge direction specifier for outgoing edges.
      * @see {@link yfiles.algorithms.Bfs#getLayersWithDirection}
      */
      SUCCESSOR,
      /**
      * Edge direction specifier for both incoming and outgoing edges.
      * @see {@link yfiles.algorithms.Bfs#getLayersWithDirection}
      */
      BOTH
    }
    /**
    * This class represents a line in the 2D-dimensional affine space.
    * The line is defined by the equation ax + by + c = 0
    */
    export interface AffineLine extends Object{
      /**
      * A from ax+by+c = 0.
      */
      a:number;
      /**
      * B from ax+by+c = 0.
      */
      b:number;
      /**
      * C from ax+by+c = 0.
      */
      c:number;
      /**
      * Returns the equation of the line as String.
      */
      toString():string;
      /**
      * Projects an point on the line in direction of the X-axis.
      */
      getXProjection(p:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
      /**
      * Projects an point on the line in direction of the Y-axis.
      */
      getYProjection(p:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
    }
    var AffineLine:{
      $class:yfiles.lang.Class;
      /**
      * Creates an affine line which is defined by a point
      * and a vector.
      */
      FromPointAndVector:{
        new (p1:yfiles.algorithms.YPoint,v:yfiles.algorithms.YVector):yfiles.algorithms.AffineLine;
      };
      /**
      * Creates an affine line which is defined by two points.
      */
      new (p1:yfiles.algorithms.YPoint,p2:yfiles.algorithms.YPoint):yfiles.algorithms.AffineLine;
      /**
      * Returns the crossing of two lines.
      * If the lines are parallel, <code>null</code> is returned.
      */
      getCrossing(l1:yfiles.algorithms.AffineLine,l2:yfiles.algorithms.AffineLine):yfiles.algorithms.YPoint;
    };
    export enum GraphEventType{
      /**
      * Type constant that identifies an event that gets fired immediately after a 
      * node has been created. 
      * The data of the event is the newly created node.
      */
      NODE_CREATION,
      /**
      * Type constant that identifies an event that gets fired immediately after an 
      * edge has been created. 
      * The data of the event is the newly created edge.
      */
      EDGE_CREATION,
      /**
      * Type constant that identifies an event that gets fired immediately before a 
      * node will be removed from the graph. 
      * The data of the event is the node to be removed.
      */
      PRE_NODE_REMOVAL,
      /**
      * Type constant that identifies an event that gets fired immediately after a 
      * node has been removed from the graph. 
      * The data of the event is the removed node.
      */
      POST_NODE_REMOVAL,
      /**
      * Type constant that identifies an event that gets fired immediately before an 
      * edge will be removed from the graph. 
      * The data of the event is the edge to be removed.
      */
      PRE_EDGE_REMOVAL,
      /**
      * Type constant that identifies an event that gets fired immediately after an 
      * edge has been removed from the graph. 
      * The data of the event is the removed edge.
      */
      POST_EDGE_REMOVAL,
      /**
      * Type constant that identifies an event that gets fired immediately after a 
      * node has been reinserted into the graph. 
      * The data of the event is the reinserted node.
      */
      NODE_REINSERTION,
      /**
      * Type constant that identifies an event that gets fired immediately after an 
      * edge has been reinserted into the graph. 
      * The data of the event is the reinserted edge.
      */
      EDGE_REINSERTION,
      /**
      * Type constant that identifies an event that gets fired immediately before the 
      * end points of an edge will be changed. 
      * The data of the event is the edge to be redefined.
      */
      PRE_EDGE_CHANGE,
      /**
      * Type constant that identifies an event that gets fired immediately after the 
      * end points of an edge have been changed. 
      * The data of the event is the redefined edge.
      */
      POST_EDGE_CHANGE,
      /**
      * Type constant that identifies an event that gets fired after a subgraph of 
      * a graph G has been moved to the emitting graph. 
      * The data of the event is a {@link yfiles.algorithms.NodeList} containing the nodes that induce 
      * the moved subgraph. 
      * This event gets fired just after the {@link yfiles.algorithms.GraphEventType#SUBGRAPH_REMOVAL} event got fired 
      * on the subgraph's original graph G. 
      * Note that at the time the event gets fired, the nodes from the node list are 
      * already part of the emitting graph.
      */
      SUBGRAPH_INSERTION,
      /**
      * Type constant that identifies an event that gets fired after a subgraph of 
      * the emitting graph has been moved to a graph G. 
      * The data of the event is a {@link yfiles.algorithms.NodeList} containing the nodes that induce 
      * the moved subgraph. 
      * This event gets fired just before the {@link yfiles.algorithms.GraphEventType#SUBGRAPH_INSERTION} event will 
      * be fired on the subgraph's new graph G. 
      * Note that at the time the event gets fired, the nodes from the node list are 
      * already part of graph G.
      */
      SUBGRAPH_REMOVAL,
      /**
      * Type constant that signals the start of a some logically coherent event sequence. 
      * If specified, the data of this event is its ID.
      */
      PRE_EVENT,
      /**
      * Type constant that signals the end of a some logically coherent event sequence. 
      * If specified, the data of this event is its ID.
      */
      POST_EVENT
    }
    /**
    * Specialized list implementation for instances of type {@link yfiles.algorithms.Edge}.
    */
    export interface EdgeList extends yfiles.algorithms.YList{
      /**
      * Returns an edge cursor for this edge list.
      * @return {yfiles.algorithms.IEdgeCursor} An edge cursor granting access to the edges within this list.
      */
      edges():yfiles.algorithms.IEdgeCursor;
      /**
      * Returns the first edge in this list, or <code>null</code> when the list is
      * empty.
      * @return {yfiles.algorithms.Edge} The first edge in the list.
      */
      firstEdge():yfiles.algorithms.Edge;
      /**
      * Returns the last edge in this list, or <code>null</code> when the list is empty.
      * @return {yfiles.algorithms.Edge} The last edge in the list.
      */
      lastEdge():yfiles.algorithms.Edge;
      /**
      * Removes the first edge from this list and returns it.
      * @return {yfiles.algorithms.Edge} The first edge from the list.
      */
      popEdge():yfiles.algorithms.Edge;
      /**
      * Returns an edge array containing all elements of this list in the canonical
      * order.
      */
      toEdgeArray():yfiles.algorithms.Edge[];
      getEnumerator():yfiles.collections.IEnumerator<yfiles.algorithms.Edge>;
    }
    var EdgeList:{
      $class:yfiles.lang.Class;
      /**
      * Creates an empty edge list.
      */
      new ():yfiles.algorithms.EdgeList;
      /**
      * Creates a list that is initialized with the edges provided by the given array
      * of edges.
      */
      FromEdgeArray:{
        new (a:yfiles.algorithms.Edge[]):yfiles.algorithms.EdgeList;
      };
      /**
      * Creates a list that is initialized with the edges provided by the given EdgeCursor
      * object.
      */
      FromEdgeCursor:{
        new (c:yfiles.algorithms.IEdgeCursor):yfiles.algorithms.EdgeList;
      };
      /**
      * Creates a list that is initialized with those edges from the given EdgeCursor
      * object for which the given data provider returns <code>true</code> upon
      * calling its {@link yfiles.algorithms.IDataProvider#getBool  getBool} method.
      * @param {yfiles.algorithms.IEdgeCursor} ec An edge cursor providing edges that should be added to this list.
      * @param {yfiles.algorithms.IDataProvider} predicate 
      * A data provider that acts as a inclusion predicate for each edge accessible
      * by the given edge cursor.
      */
      FromEdgeCursorFiltered:{
        new (ec:yfiles.algorithms.IEdgeCursor,predicate:yfiles.algorithms.IDataProvider):yfiles.algorithms.EdgeList;
      };
      /**
      * Creates a list that is initialized with the elements provided by the given
      * Iterator object.
      */
      FromIterator:{
        new (it:yfiles.algorithms.IIterator):yfiles.algorithms.EdgeList;
      };
      /**
      * Creates a list that is initialized with a single edge provided.
      */
      WithEdge:{
        new (e:yfiles.algorithms.Edge):yfiles.algorithms.EdgeList;
      };
      /**
      * Creates a list that is initialized with an EdgeList.
      */
      FromEdgeList:{
        new (edgeList:yfiles.algorithms.EdgeList):yfiles.algorithms.EdgeList;
      };
    };
    /**
    * This class calculates the intersection of rectangles in the plane with
    * the help of a sweep-line algorithm.
    * The complexity is <code>O(n log n + s)</code> where <code>n</code>
    * is the number of rectangles and <code>s</code> the number of intersections.
    */
    export interface IntersectionAlgorithm extends Object{
    }
    export module IntersectionAlgorithm{
      /**
      * An instance of this interface handles intersections found by the
      * <code>IntersectionAlgorithm</code>,.
      */
      export interface IIntersectionHandler extends Object{
        /**
        * This method is called at every intersection.
        * @see Specified by {@link yfiles.algorithms.IntersectionAlgorithm.IIntersectionHandler#checkIntersection}.
        */
        checkIntersection(a:Object,b:Object):void;
      }
    }
    var IntersectionAlgorithm:{
      $class:yfiles.lang.Class;
      /**
      * Calculates the intersections of rectangles in the plane.
      * Every found intersection is reported to an
      * <code>IntersectionHandler</code>.
      * Rectangles with negative size are completely ignored by this implementation (i.e.
      * never generate intersections)
      * @param {yfiles.algorithms.YList} objects a list of <code>PlaneObject</code> objects.
      * @param {yfiles.algorithms.IntersectionAlgorithm.IIntersectionHandler} iHandler intersections are reported to this class.
      */
      intersect(objects:yfiles.algorithms.YList,iHandler:yfiles.algorithms.IntersectionAlgorithm.IIntersectionHandler):void;
      /**
      * Initializes the sweep line data structures from a set of objects.
      */
      createXStruct(objects:yfiles.algorithms.YList):yfiles.algorithms.YList;
    };
    /**
    * This is an interface for a sequence of instances of YPoint.
    */
    export interface IPointCursor extends Object,yfiles.algorithms.ICursor{
      /**
      * The instance of YPoint the cursor is currently pointing on.
      * @see Specified by {@link yfiles.algorithms.IPointCursor#point}.
      */
      point:yfiles.algorithms.YPoint;
    }
    var IPointCursor:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This interface describes a 2-dimensional object which has a finite
    * bounding box.
    */
    export interface IPlaneObject extends Object{
      /**
      * The smallest Rectangle which contains the object.
      * @see Specified by {@link yfiles.algorithms.IPlaneObject#boundingBox}.
      */
      boundingBox:yfiles.algorithms.YRectangle;
    }
    var IPlaneObject:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This class can be used to easily model an orthogonal
    * border line or sky-line.
    * It provides methods for measuring
    * the distance between different BorderLine instances, merging
    * multiple instances, modifying and efficiently moving them around.
    */
    export interface BorderLine extends Object{
      /**
      * Creates a copy of this borderline.
      * Optionally negates the values or offsets.
      * @param {boolean} negateValues whether the values are negated
      * @param {boolean} negateOffsets whether the offsets are negated
      * @return {yfiles.algorithms.BorderLine} the copy of the borderline
      */
      createCopy(negateValues:boolean,negateOffsets:boolean):yfiles.algorithms.BorderLine;
      /**
      * Assures that all values in the given interval are less or equal than the given value.
      * @param {number} min the lower end of the interval
      * @param {number} max the upper end of the interval
      * @param {number} value the greatest possible value for the interval
      */
      setMinValue(min:number,max:number,value:number):void;
      /**
      * Assures that all values in the given interval are greater or equal than the given value.
      * @param {number} min the lower end of the interval
      * @param {number} max the upper end of the interval
      * @param {number} value the smallest possible value for the interval
      */
      setMaxValue(min:number,max:number,value:number):void;
      /**
      * Convenience method that copies the actual data from the given
      * argument to this instance.
      * @param {yfiles.algorithms.BorderLine} other the argument to retrieve the values from
      */
      adoptValues(other:yfiles.algorithms.BorderLine):void;
      /**
      * Sets a specific interval described by <code>min</code> and <code>max</code> to a given value.
      * @param {number} min the left side of the interval.
      * @param {number} max the right side of the interval.
      * @param {number} value the value for the whole interval.
      */
      setValue(min:number,max:number,value:number):void;
      /**
      * Sets a specific interval to a slope starting at a given value.
      * @param {number} min the left side of the interval.
      * @param {number} max the right side of the interval.
      * @param {number} value the value at <code>min</code> where the slope starts.
      * @param {number} slope the slope of the segment in the given interval.
      * @throws {yfiles.system.ArgumentException} if <code>min</code> is greater than <code>max</code>.
      */
      setSloped(min:number,max:number,value:number,slope:number):void;
      /**
      * Adds the given offset to the current values of
      * the whole borderline.
      * This method has complexity O(1).
      * @param {number} delta the delta to add to the values
      */
      addValueOffset(delta:number):void;
      /**
      * Adds the given offset to the segments' positions.
      * This method has complexity O(1).
      * @param {number} delta the delta to add to the positions
      */
      addOffset(delta:number):void;
      /**
      * The smallest position of this borderline.
      */
      min:number;
      /**
      * The greatest position of this borderline.
      */
      max:number;
      /**
      * The minimum value that is set on this borderline.
      */
      minValue:number;
      /**
      * The maximum value that is set on this borderline.
      */
      maxValue:number;
      /**
      * Returns the value that is set on this borderline
      * at the specified position.
      * @param {number} pos the position
      * @return {number} the value
      * @throws {yfiles.system.IndexOutOfRangeException} if the position is outside of the borderline.
      */
      getValueAt(pos:number):number;
      /**
      * Returns the value that is set on this borderline at the specified position.
      * The position must lie within the range of the segment that is stored in <code>cell</code>.
      * @param {yfiles.algorithms.ListCell} cell The list cell containing the segment whose value shall be returned.
      * @param {number} pos the position
      * @return {number} the value
      * @throws {yfiles.system.ArgumentException} if <code>pos</code> is outside the segment's range that is stored in <code>cell</code>.
      */
      getValueAtWithListCell(cell:yfiles.algorithms.ListCell,pos:number):number;
      /**
      * Returns the value that is set on this borderline at the specified position.
      * The position must lie within the range of the segment.
      * @param {yfiles.algorithms.BorderLine.Segment} segment The segment whose value shall be returned.
      * @param {number} pos the position where the value will be retrieved.
      * @return {number} the value
      * @throws {yfiles.system.ArgumentException} if <code>pos</code> is outside the segment's range.
      */
      getValueAtWithSegment(segment:yfiles.algorithms.BorderLine.Segment,pos:number):number;
      /**
      * Merges this borderline with the given borderline
      * using the "maximum" policy.
      * That means the resulting borderline will have greater value of both borderline on each position. If you imagine
      * each borderline as a the upper border of a plane, the resulting borderline will be the upper border of the merged
      * planes.
      * @param {yfiles.algorithms.BorderLine} other the other borderline
      * @return {yfiles.algorithms.BorderLine} a new borderline that is the result of the merge
      */
      createMax(other:yfiles.algorithms.BorderLine):yfiles.algorithms.BorderLine;
      /**
      * Merges this borderline with the given borderline
      * using the "minimum" policy.
      * That means the resulting borderline will have smaller value of both borderline on each position. If you imagine
      * each borderline as a the lower border of a plane, the resulting borderline will be the lower border of the merged
      * planes.
      * @param {yfiles.algorithms.BorderLine} other the other borderline
      * @return {yfiles.algorithms.BorderLine} a new borderline that is the result of the merge
      */
      createMin(other:yfiles.algorithms.BorderLine):yfiles.algorithms.BorderLine;
      /**
      * Merges this borderline with the given borderline
      * using the "maximum" policy.
      * @param {yfiles.algorithms.BorderLine} other the other borderline
      */
      mergeWithMax(other:yfiles.algorithms.BorderLine):void;
      /**
      * Merges this borderline with the given borderline
      * using the "minimum" policy.
      * @param {yfiles.algorithms.BorderLine} other the other borderline
      */
      mergeWithMin(other:yfiles.algorithms.BorderLine):void;
      /**
      * Returns the value of the minimum of the given segment.
      * If the segment's slope is 0, it's the value of the whole
      * segment. In case the slope differs from 0, it's the value of the start of the slope.
      * @param {yfiles.algorithms.BorderLine.Segment} s the segment
      */
      getValue(s:yfiles.algorithms.BorderLine.Segment):number;
      /**
      * Returns the minimum position of the given segment.
      * @param {yfiles.algorithms.BorderLine.Segment} s the segment
      */
      getMin(s:yfiles.algorithms.BorderLine.Segment):number;
      /**
      * Returns the slope of the given segment.
      * @param {yfiles.algorithms.BorderLine.Segment} s the segment
      */
      getSlope(s:yfiles.algorithms.BorderLine.Segment):number;
      /**
      * Returns the segment at the given position.
      * @param {number} pos the position
      */
      getSegmentAt(pos:number):yfiles.algorithms.BorderLine.Segment;
      /**
      * Returns the maximum position of the given segment.
      * @param {yfiles.algorithms.BorderLine.Segment} s the segment
      */
      getMax(s:yfiles.algorithms.BorderLine.Segment):number;
      /**
      * Returns the first segment or <code>null</code> if there is
      * no such segment.
      */
      firstSegment():yfiles.algorithms.BorderLine.Segment;
      /**
      * Returns the last segment or <code>null</code> if there is
      * no such segment.
      */
      lastSegment():yfiles.algorithms.BorderLine.Segment;
      /**
      * Returns the previous segment or <code>null</code> if there is
      * no such segment.
      */
      prev(s:yfiles.algorithms.BorderLine.Segment):yfiles.algorithms.BorderLine.Segment;
      /**
      * Returns the next segment or <code>null</code> if there is
      * no such segment.
      */
      next(s:yfiles.algorithms.BorderLine.Segment):yfiles.algorithms.BorderLine.Segment;
      /**
      * Calculates the maximum value in the interval from->to.
      */
      getMaxValue(from:number,to:number):number;
      /**
      * Calculates the minimum value in the interval from->to.
      */
      getMinValue(from:number,to:number):number;
      /**
      * Calculates the minimal distance between this borderline and the other one.
      * The other one is treated as if the values were all greater.
      */
      getDistanceTo(greater:yfiles.algorithms.BorderLine):number;
      /**
      * Returns a lengthy String representation of this borderline.
      */
      toString():string;
      /**
      * Grows this BorderLine horizontally, so that the {@link yfiles.algorithms.BorderLine#getValueAtWithSegment  values}
      * of the BorderLine stay the same however their {@link yfiles.algorithms.BorderLine#getMin  start} and
      * {@link yfiles.algorithms.BorderLine#getMax  end} points are moved in the direction of <code>toMin</code>
      * and <code>toMax</code>.
      * This is useful for scenarios where a BorderLine is needed that consists of an enlarged border.
      * <p>
      * Note that this method normalizes the segments, i.e., it transforms each segment with slope != 0 to
      * a segment with slope == 0.
      * </p>
      * @param {number} toMin the delta by which the border should be extended towards -Infinity
      * @param {number} toMax the delta by which the border should be extended towards +Infinity
      * @param {boolean} positive 
      * whether the BorderLine should be interpreted to point in positive direction. This influences the
      * direction into which a segment's border is extended.
      */
      grow(toMin:number,toMax:number,positive:boolean):void;
    }
    export module BorderLine{
      /**
      * The handle of a segment of a borderline.
      */
      export interface Segment extends Object{
        /**
        * Returns the segment's value at the given position.
        * Note: In case the position lies outside the segments range, the calculated value might be invalid. As the segment
        * is not aware of any offsets the position also must not include any offsets.
        * @param {number} position the position the value is retrieved for.
        * @return {number} the segment's value at the given position.
        */
        getValueAt(position:number):number;
        /**
        * The end of this segment.
        */
        end:number;
        /**
        * Returns the previous segment or <code>null</code> if there is
        * no such segment.
        */
        prev():yfiles.algorithms.BorderLine.Segment;
        /**
        * Returns the next segment or <code>null</code> if there is
        * no such segment.
        */
        next():yfiles.algorithms.BorderLine.Segment;
        toString():string;
      }
    }
    var BorderLine:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new BorderLine with the given value
      * from -Double.MAX_VALUE to Double.MAX_VALUE.
      * @param {number} value the value of the segment
      */
      WithValue:{
        new (value:number):yfiles.algorithms.BorderLine;
      };
      /**
      * Creates a new BorderLine from a single segment.
      * @param {number} min the beginning of this borderline
      * @param {number} max the ending of this borderline
      * @param {number} value the value of the segment
      */
      FromMinToMax:{
        new (min:number,max:number,value:number):yfiles.algorithms.BorderLine;
      };
      /**
      * Creates a new BorderLine from a single segment.
      * @param {number} min the beginning of this borderline
      * @param {number} max the ending of this borderline
      * @param {number} valueAtMin the value of the segment at the beginning of this borderline
      * @param {number} valueAtMax the value of the segment at the ending of this borderline
      */
      FromSegment:{
        new (min:number,max:number,valueAtMin:number,valueAtMax:number):yfiles.algorithms.BorderLine;
      };
    };
    /**
    * This is an interface for a sequence of instances of LineSegment.
    */
    export interface ILineSegmentCursor extends Object,yfiles.algorithms.ICursor{
      /**
      * The instance of LineSegment the cursor is currently pointing on.
      * @see Specified by {@link yfiles.algorithms.ILineSegmentCursor#lineSegment}.
      */
      lineSegment:yfiles.algorithms.LineSegment;
    }
    var ILineSegmentCursor:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This class provides useful geometric primitives and advanced
    * geometric algorithms.
    * This class is intended to provide static methods for geometric
    * calculations. It can be compared to the class <code>java.lang.Math</code>
    * which provides methods for general mathematical calculations.
    */
    export interface Geom extends Object{
    }
    var Geom:{
      $class:yfiles.lang.Class;
      /**
      * Returns the orientation of point <code>r</code> relative to the directed
      * line  from point <code>p</code> to point <code>q</code>.
      * The given tuple of points is said to have positive orientation if
      * <code>p</code> and <code>q</code> are distinct and <code>r</code> lies
      * to the left of the oriented line passing through <code>p</code>
      * and <code>q</code> and oriented from <code>p</code> to <code>q</code>.
      * The tuple is said to have negative orientation if
      * <code>p</code> and <code>q</code> are distinct and <code>r</code> lies
      * to the right of the line, and the tuple is said to have orientation zero
      * if the three points are collinear.
      * @return {number} 
      * <b>+1</b> in the case of positive orientation, <b>-1</b> in the
      * case of  negative orientation and <b>0</b> in the case of zero
      * orientation.
      */
      orientation(p:yfiles.algorithms.YPoint,q:yfiles.algorithms.YPoint,r:yfiles.algorithms.YPoint):number;
      /**
      * Same as {@link yfiles.algorithms.Geom#orientation} with double values as arguments.
      */
      orientationDouble(px:number,py:number,qx:number,qy:number,rx:number,ry:number):number;
      /**
      * Same as {@link yfiles.algorithms.Geom#orientation  orientation(p,q,r) > 0}.
      */
      leftTurn(p:yfiles.algorithms.YPoint,q:yfiles.algorithms.YPoint,r:yfiles.algorithms.YPoint):boolean;
      /**
      * Same as {@link yfiles.algorithms.Geom#orientation  orientation(p,q,r) &lt; 0}.
      */
      rightTurn(p:yfiles.algorithms.YPoint,q:yfiles.algorithms.YPoint,r:yfiles.algorithms.YPoint):boolean;
      /**
      * Returns <code>true</code> iff the given points are collinear, i.e.
      * all
      * three points lie on a common line.
      * Same as {@link yfiles.algorithms.Geom#orientation  orientation(p,q,r) == 0}
      */
      collinear(p:yfiles.algorithms.YPoint,q:yfiles.algorithms.YPoint,r:yfiles.algorithms.YPoint):boolean;
      /**
      * Returns +1 if point <code>d</code> lies left of the directed circle through
      * points <code>a</code>, <code>b</code>, and <code>c</code>,
      * 0 if <code>a,b,c</code> and <code>d</code> are cocircular, and -1 otherwise.
      */
      sideOfCircle(a:yfiles.algorithms.YPoint,b:yfiles.algorithms.YPoint,c:yfiles.algorithms.YPoint,d:yfiles.algorithms.YPoint):number;
      /**
      * Calculates the convex hull for a set of points.
      * <b>Complexity:</b> <code>O(n)*log(n), n := points.size()</code>
      * @param {yfiles.algorithms.YList} points 
      * a list of {@link yfiles.algorithms.YPoint} objects
      * @return {yfiles.algorithms.YList} 
      * a list of {@link yfiles.algorithms.YPoint} objects that constitute the convex hull of
      * the given points. The list contains points in counter clockwise order
      * around the hull. The first point is the one with the smallest
      * <code>x</code> coordinate. If two such points exist then of these points
      * the one with the smallest <code>y</code> coordinate is chosen as the first
      * one.
      */
      calcConvexHull(points:yfiles.algorithms.YList):yfiles.algorithms.YList;
      /**
      * Converts the given degree value from angular to radian.
      */
      toRadians(angdeg:number):number;
      /**
      * Converts the given degree value from radian to angular.
      */
      toDegrees(angrad:number):number;
      /**
      * Calculates the intersection point of two affine lines.
      * Each line is given by a point and a direction vector.
      * @param {yfiles.algorithms.YPoint} p1 origin point of the first line.
      * @param {yfiles.algorithms.YVector} d1 direction vector of the first line.
      * @param {yfiles.algorithms.YPoint} p2 origin point of the second line.
      * @param {yfiles.algorithms.YVector} d2 direction vector of the second line.
      * @return {yfiles.algorithms.YPoint} 
      * the intersection point of the specified lines or <code>null</code>
      * if there is no intersection.
      */
      calcIntersectionWithPointsAndVectors(p1:yfiles.algorithms.YPoint,d1:yfiles.algorithms.YVector,p2:yfiles.algorithms.YPoint,d2:yfiles.algorithms.YVector):yfiles.algorithms.YPoint;
      /**
      * Calculates the intersection point of two <b>affine</b> lines.
      * Each line is given by two points.
      * @param {yfiles.algorithms.YPoint} p1 one point on the first line.
      * @param {yfiles.algorithms.YPoint} p2 another point on the first line.
      * @param {yfiles.algorithms.YPoint} p3 one point on the second line.
      * @param {yfiles.algorithms.YPoint} p4 another point on the second line.
      * @return {yfiles.algorithms.YPoint} 
      * the intersection point of the specified lines or <code>null</code>
      * if there is no intersection.
      */
      calcIntersectionWithPoints(p1:yfiles.algorithms.YPoint,p2:yfiles.algorithms.YPoint,p3:yfiles.algorithms.YPoint,p4:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
      /**
      * Calculates the intersection point of two <b>affine</b> lines.
      * Each line is given by the coordinates of two points.
      * @param {number} x1 x-coordinate of one point on the first line.
      * @param {number} y1 y-coordinate of one point on the first line.
      * @param {number} x2 x-coordinate of another point on the first line.
      * @param {number} y2 y-coordinate of another point on the first line.
      * @param {number} x3 x-coordinate of one point on the second line.
      * @param {number} y3 y-coordinate of one point on the second line.
      * @param {number} x4 x-coordinate of another point on the second line.
      * @param {number} y4 y-coordinate of another point on the second line.
      * @return {yfiles.algorithms.YPoint} 
      * the intersection point of the specified lines or <code>null</code>
      * if there is no intersection.
      */
      calcIntersectionWithCoordinates(x1:number,y1:number,x2:number,y2:number,x3:number,y3:number,x4:number,y4:number):yfiles.algorithms.YPoint;
      /**
      * Returns whether the two lines defined by the given coordinates intersect or not.
      */
      linesIntersect(x1:number,y1:number,x2:number,y2:number,x3:number,y3:number,x4:number,y4:number):boolean;
      /**
      * Determines the projection of the point <code>p</code> onto the line
      * segment <code>[l1, l2]</code>.
      * The resulting point is
      * <ul>
      * <li>the orthogonal projection of <code>p</code> onto the line through
      * <code>l1</code> and <code>l2</code>, iff the projection lies on the
      * line segment <code>[l1, l2]</code></li>
      * <li>the end point of the line segment <code>[l1, l2]</code> that is closest
      * to <code>p</code></li>, otherwise
      * </ul>
      * @param {number} pointX the x coordinate of p
      * @param {number} pointY the y coordinate of p
      * @param {number} lineX1 the x coordinate of l1
      * @param {number} lineY1 the y coordinate of l1
      * @param {number} lineX2 the x coordinate of l2
      * @param {number} lineY2 the y coordinate of l2
      */
      projection(pointX:number,pointY:number,lineX1:number,lineY1:number,lineX2:number,lineY2:number):yfiles.algorithms.YPoint;
      /**
      * Determines the distance of the point <code>p</code> to the line segment
      * <code>[l1, l2]</code>.
      * @param {number} pointX the x coordinate of p
      * @param {number} pointY the y coordinate of p
      * @param {number} lineX1 the x coordinate of l1
      * @param {number} lineY1 the y coordinate of l1
      * @param {number} lineX2 the x coordinate of l2
      * @param {number} lineY2 the y coordinate of l2
      */
      distanceToLineSegment(pointX:number,pointY:number,lineX1:number,lineY1:number,lineX2:number,lineY2:number):number;
      /**
      * Unions the pair of source <code>Rectangle2D</code> objects
      * and puts the result into the specified destination
      * <code>Rectangle2D</code> object.
      * If one of the source rectangles has negative width or height,
      * it is excluded from the union.
      * If both source rectangles have negative width or height,
      * the destination rectangle will become a copy of <code>r1</code>.
      * One of the source rectangles can also be the destination to avoid creating
      * a third Rectangle2D object, but in this case the original points of this
      * source rectangle will be overwritten by this method.
      * If the destination is <code>null</code>, a new <code>Rectangle2D</code>
      * is created.
      * @param {yfiles.algorithms.Rectangle2D} r1 
      * the first of a pair of <code>Rectangle2D</code>
      * objects to be combined with each other
      * @param {yfiles.algorithms.Rectangle2D} r2 
      * the second of a pair of <code>Rectangle2D</code>
      * objects to be combined with each other
      * @param {yfiles.algorithms.Rectangle2D} dest 
      * the <code>Rectangle2D</code> that holds the
      * results of the union of <code>r1</code> and
      * <code>r2</code>
      */
      calcUnion(r1:yfiles.algorithms.Rectangle2D,r2:yfiles.algorithms.Rectangle2D,dest:yfiles.algorithms.Rectangle2D):yfiles.algorithms.Rectangle2D;
      /**
      * Intersects the pair of specified source <code>Rectangle2D</code>
      * objects and puts the result into the specified destination
      * <code>Rectangle2D</code> object.
      * If one or both of the source rectangles have negative width or height,
      * the resulting rectangle will be located at (0,0) with a width and height
      * of -1.
      * One of the source rectangles can also be the destination to avoid
      * creating a third Rectangle2D object, but in this case the original
      * points of this source rectangle will be overwritten by this method.
      * @param {yfiles.algorithms.Rectangle2D} r1 
      * the first of a pair of <code>Rectangle2D</code>
      * objects to be intersected with each other
      * @param {yfiles.algorithms.Rectangle2D} r2 
      * the second of a pair of <code>Rectangle2D</code>
      * objects to be intersected with each other
      * @param {yfiles.algorithms.Rectangle2D} dest 
      * the <code>Rectangle2D</code> that holds the
      * results of the intersection of <code>r1</code> and
      * <code>r2</code>
      */
      calcIntersection(r1:yfiles.algorithms.Rectangle2D,r2:yfiles.algorithms.Rectangle2D,dest:yfiles.algorithms.Rectangle2D):yfiles.algorithms.Rectangle2D;
    };
    /**
    * This class provides services that center around breadth first search (BFS).
    */
    export interface Bfs extends Object{
    }
    var Bfs:{
      $class:yfiles.lang.Class;
      /**
      * Returns layers of nodes constructed by a breadth first search.
      * The first of these layers contains all nodes within the given NodeList.
      * These nodes are the core nodes from where an
      * undirected breath first search to the other nodes starts.
      * In the i-th layer are previously unassigned nodes that are
      * connected to nodes in the (i-1)-th layer.
      * <b>Complexity:</b> O(graph.N()+graph.E())
      */
      getLayersFromNodeList(graph:yfiles.algorithms.Graph,coreNodes:yfiles.algorithms.NodeList):yfiles.algorithms.NodeList[];
      /**
      * Like {@link yfiles.algorithms.Bfs#getLayersFromNodeList}, but this time the core nodes
      * are identified by a boolean predicate.
      * <b>Precondition:</b> isCoreNode.getBool(node) defined for all nodes in graph.
      */
      getLayersFromNodeMap(graph:yfiles.algorithms.Graph,isCoreNode:yfiles.algorithms.IDataProvider):yfiles.algorithms.NodeList[];
      /**
      * Like {@link yfiles.algorithms.Bfs#getLayersFromNodeMap}.
      * Additionally
      * the provided node map will be filled with integers that
      * hold the layer number for each node.
      */
      getLayersFromNodeMapToMap(graph:yfiles.algorithms.Graph,isCoreNode:yfiles.algorithms.IDataProvider,layerIDMap:yfiles.algorithms.INodeMap):yfiles.algorithms.NodeList[];
      /**
      * Like {@link yfiles.algorithms.Bfs#getLayersFromNodeList}.
      * Additionally
      * the provided node map will be filled with integers that
      * hold the layer number for each node.
      */
      getLayersFromNodeListUndirected(graph:yfiles.algorithms.Graph,coreNodes:yfiles.algorithms.NodeList,layerIDMap:yfiles.algorithms.INodeMap):yfiles.algorithms.NodeList[];
      /**
      * Returns layers of nodes constructed by a breadth first search.
      * The first of these layers contains all nodes within the given NodeList.
      * These nodes are the core nodes from where either a directed or undirected
      * breath first search to the other nodes starts.
      * In the i-th layer are previously unassigned nodes that are
      * successors to nodes in the (i-1)-th layer.
      * <b>Complexity:</b> O(graph.N()+graph.E())
      */
      getLayersFromNodeListToMap(graph:yfiles.algorithms.Graph,coreNodes:yfiles.algorithms.NodeList,directed:boolean,layerIDMap:yfiles.algorithms.INodeMap):yfiles.algorithms.NodeList[];
      /**
      * Returns layers of nodes constructed by a breadth first search.
      * The first of these layers contains all nodes within the given NodeList.
      * These nodes are the core nodes from where either a directed or undirected
      * breath first search to the other nodes starts.
      * In the i-th layer are previously unassigned nodes that are
      * successors to nodes in the (i-1)-th layer.
      * <b>Complexity:</b> O(graph.N()+graph.E())
      * @param {yfiles.algorithms.Graph} graph the graph the bfs is running on
      * @param {yfiles.algorithms.NodeList} coreNodes contains the nodes the bfs run starts from
      * @param {boolean} directed true: only outgoing edges are attended, false: all edges
      * @param {yfiles.algorithms.INodeMap} layerIDMap is used to store the layer depths information in
      * @param {number} maxLayers number of layers that will be returned. "0" for all layers
      * @return {yfiles.algorithms.NodeList[]} 
      * an array of {@link yfiles.algorithms.NodeList}s representing the layers
      */
      getLayersWithMaxLayers(graph:yfiles.algorithms.Graph,coreNodes:yfiles.algorithms.NodeList,directed:boolean,layerIDMap:yfiles.algorithms.INodeMap,maxLayers:number):yfiles.algorithms.NodeList[];
      /**
      * Returns layers of nodes constructed by a breadth first search.
      * The first of these layers contains all nodes within the given NodeList.
      * These nodes are the core nodes from where either a directed or undirected
      * breath first search to the other nodes starts.
      * In the i-th layer are previously unassigned nodes that are
      * successors to nodes in the (i-1)-th layer.
      * <b>Complexity:</b> O(graph.N()+graph.E())
      * @param {yfiles.algorithms.Graph} graph the graph the bfs is running on
      * @param {yfiles.algorithms.NodeList} coreNodes contains the nodes the bfs run starts from
      * @param {yfiles.algorithms.BfsDirection} direction 
      * specifies which edges to follow. One of
      * <ul>
      * <li>{@link yfiles.algorithms.BfsDirection#PREDECESSOR},</li>
      * <li>{@link yfiles.algorithms.BfsDirection#SUCCESSOR}, or</li>
      * <li>{@link yfiles.algorithms.BfsDirection#BOTH}</li>
      * </ul>
      * @param {yfiles.algorithms.INodeMap} layerIDMap is used to store the layer depths information in
      * @param {number} maxLayers number of layers that will be returned. "0" for all layers
      * @return {yfiles.algorithms.NodeList[]} 
      * an array of {@link yfiles.algorithms.NodeList}s representing the layers
      */
      getLayersWithDirection(graph:yfiles.algorithms.Graph,coreNodes:yfiles.algorithms.NodeList,direction:yfiles.algorithms.BfsDirection,layerIDMap:yfiles.algorithms.INodeMap,maxLayers:number):yfiles.algorithms.NodeList[];
    };
    /**
    * This class provides methods to determine various centrality indices of nodes or edges of a graph.
    * Centrality indices serve to quantify an intuitive feeling that in most networks some nodes
    * or edges are "more central" than others. The provided methods assign a value of type double to each node or edge of
    * a graph that represents its centrality. The higher an assigned value the more central the element
    * is considered by the algorithm.
    * Also, this class provides convenience methods that normalize the returned centrality values to lie within
    * the interval <code>[0..1]</code>.
    */
    export interface Centrality extends Object{
    }
    var Centrality:{
      $class:yfiles.lang.Class;
      /**
      * Computes betweenness centrality for each node of a given graph.
      * Betweenness Centrality is a measure for how often a node lies on a shortest path between
      * each pair of nodes in the graph. Removing a central node will cause many shortest paths to change.
      * <b>Complexity:</b> O(graph.N()*graph.E()) for unweighted graphs, O(graph.N() * (graph.E()+graph.N()) * log(graph.N()) for weighted graphs.
      * <b>Precondition:</b> NodeMap centrality with values initially zero
      * @param {yfiles.algorithms.Graph} graph the input graph.
      * @param {yfiles.algorithms.INodeMap} centrality return value. A NodeMap which will holds a non-negative centrality value of type <code>double</code> for each node.
      * @param {boolean} directed 
      * whether to consider the edges of the graph as directed or undirected.
      * If false, the algorithm traverse every edge in both direction regardless of the direction of the edge.
      * @param {yfiles.algorithms.IDataProvider} edgeCosts 
      * if <code>null</code> the edges of the graph are considered to have equal cost. Otherwise
      * it must provide a strictly positive <code>double</code> value (its cost) for every edge. Invalid values are assumed
      * to be <code>1.0</code>.
      */
      nodeBetweenness(graph:yfiles.algorithms.Graph,centrality:yfiles.algorithms.INodeMap,directed:boolean,edgeCosts:yfiles.algorithms.IDataProvider):void;
      /**
      * Computes betweenness centrality for each edge of a given graph.
      * Like {@link yfiles.algorithms.Centrality#nodeBetweenness} but applied to edges.
      * <b>Precondition:</b> EdgeMap centrality with values initially zero
      * @param {yfiles.algorithms.IEdgeMap} centrality return value. A EdgeMap which will hold a non-negative centrality value of type <code>double</code> for each edge.
      */
      edgeBetweenness(graph:yfiles.algorithms.Graph,centrality:yfiles.algorithms.IEdgeMap,directed:boolean,edgeCosts:yfiles.algorithms.IDataProvider):void;
      /**
      * Computes betweenness centrality for each node and edge of a given graph.
      * Like {@link yfiles.algorithms.Centrality#nodeBetweenness} but applied to both nodes and edges.
      * <b>Precondition:</b> NodeMap nodeCentrality with values initially zero
      * <b>Precondition:</b> EdgeMap edgeCentrality with values initially zero
      * @param {yfiles.algorithms.INodeMap} nodeCentrality return value. A NodeMap which will hold the centrality value of type <code>double</code> for every node.
      * @param {yfiles.algorithms.IEdgeMap} edgeCentrality return value. A EdgeMap which will hold the centrality value of type <code>double</code> for every edge.
      */
      nodeEdgeBetweenness(graph:yfiles.algorithms.Graph,nodeCentrality:yfiles.algorithms.INodeMap,edgeCentrality:yfiles.algorithms.IEdgeMap,directed:boolean,edgeCosts:yfiles.algorithms.IDataProvider):void;
      /**
      * Computes the closeness centrality for the nodes of a graph.
      * Closeness centrality is defined as the reciprocal
      * of the sum of
      * shortest path distances of a node to all other nodes in the graph. Therefore a node with high closeness
      * centrality has short distances to all other nodes of a graph. Also note, that for unconnected graphs
      * the centrality values of all nodes will be zero, since the distance to some nodes is infinite.
      * <b>Precondition:</b> <code>GraphChecker.isConnected(graph)</code>
      * <b>Complexity:</b> 
      * O(graph.N()^2 + graph.N()*graph.E()) for unweighted graphs, O( (graph.N()*graph.E()) + graph.N()^2 *log(graph.N())) 
      * or: O(graph.N()) * O(Uniform) for unweighted, O(allPairs) for weighted graphs
      * @param {yfiles.algorithms.Graph} graph the input graph.
      * @param {yfiles.algorithms.INodeMap} closeness return value. A map which hold the centrality value of type <code>double</code> for every node.
      * @param {boolean} directed whether to consider the edges of the graph as directed or undirected.
      * @param {yfiles.algorithms.IDataProvider} edgeCosts 
      * when <code>null</code> the edges of the graph are considered to have equal cost. Otherwise
      * it must provide a non-negative <code>double</code> value (its cost) for every edge.
      */
      closenessCentrality(graph:yfiles.algorithms.Graph,closeness:yfiles.algorithms.INodeMap,directed:boolean,edgeCosts:yfiles.algorithms.IDataProvider):void;
      /**
      * Computes the graph centrality for the nodes of a graph.
      * Graph centrality is defined as the reciprocal
      * of the maximum of all shortest path distances from a node to all other nodes in the graph.
      * Nodes with high graph centrality have short distances to all other nodes in the graph.
      * Also note, that for unconnected graphs the centrality values of all nodes will be zero, since the
      * distance to some nodes is infinite.
      * <b>Complexity:</b> 
      * O(graph.N()^2 + graph.N()*graph.E()) for unweighted graphs, O( (graph.N()*graph.E()) + graph.N()^2 *log(graph.N()))
      * or: O(graph.N()) * O(Uniform) for unweighted, O(allPairs) for weighted graphs
      * @param {yfiles.algorithms.Graph} graph the input graph.
      * @param {yfiles.algorithms.INodeMap} centrality return value. A map which hold the centrality value of type <code>double</code> for every node.
      * @param {boolean} directed whether to consider the edges of the graph as directed or undirected.
      * @param {yfiles.algorithms.IDataProvider} edgeCosts 
      * when <code>null</code> the edges of the graph are considered to have equal cost. Otherwise
      * it must provide a non-negative <code>double</code> value (its cost) for every edge.
      */
      graphCentrality(graph:yfiles.algorithms.Graph,centrality:yfiles.algorithms.INodeMap,directed:boolean,edgeCosts:yfiles.algorithms.IDataProvider):void;
      /**
      * Computes the degree centrality for the nodes of a graph.
      * Degree centrality measures in-, out- or overall degree of
      * a node.
      * <b>Complexity:</b> O(graph.N())
      * <b>Precondition:</b> at least one of the flags considerInEdges and considerOutEdges must be true.
      * @param {yfiles.algorithms.Graph} graph the input graph.
      * @param {yfiles.algorithms.INodeMap} centrality return value. A map which provides the degree centrality as <code>double</code> value for every node.
      */
      degreeCentrality(graph:yfiles.algorithms.Graph,centrality:yfiles.algorithms.INodeMap,considerInEdges:boolean,considerOutEdges:boolean):void;
      /**
      * Computes the weight centrality for the nodes of a graph.
      * Weight centrality measures the weight associated with incoming, outgoing, or
      * all edges of a node.
      * Note that weight centrality degenerates to degree centrality when the edges
      * have uniform weight.
      * In particular, when parameter 'edgeWeights' is <code>null</code> then
      * {@link yfiles.algorithms.Centrality#degreeCentrality  degreeCentrality}
      * is invoked instead.
      * <b>Complexity:</b> O(graph.E())
      * @param {yfiles.algorithms.Graph} graph The input graph.
      * @param {yfiles.algorithms.INodeMap} centrality 
      * Return value.
      * A map which provides the value centrality as <code>double</code> value for
      * every node.
      * @param {boolean} considerInEdges Whether the weights associated with incoming edges should be considered.
      * @param {boolean} considerOutEdges Whether the weights associated with outgoing edges should be considered.
      * @param {yfiles.algorithms.IDataProvider} edgeWeights 
      * When <code>null</code>, the edges of the graph are considered to have uniform
      * weight of 1.0.
      * Otherwise it must provide a non-negative <code>double</code> value (the weight)
      * for every edge.
      */
      weightCentrality(graph:yfiles.algorithms.Graph,centrality:yfiles.algorithms.INodeMap,considerInEdges:boolean,considerOutEdges:boolean,edgeWeights:yfiles.algorithms.IDataProvider):void;
      /**
      * This method normalizes the <code>double</code> values of a node map by dividing all values by the maximum of all values (maximum norm).
      * Note, if the maximum value is <code>Double.POSITIVE_INFINITY</code>, all values other than <code>Double.POSITIVE_INFINITY</code>
      * are set to <code>0</code>.
      * <b>Precondition:</b> for each node n: map.getDouble(n) >= 0
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.INodeMap} map return value that holds <code>double</code> values between zero and one.
      */
      normalizeNodeMap(graph:yfiles.algorithms.Graph,map:yfiles.algorithms.INodeMap):void;
      /**
      * Like {@link yfiles.algorithms.Centrality#normalizeNodeMap}, but for EdgeMap.
      * <b>Precondition:</b> for each edge e: map.getDouble(e) >= 0
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.IEdgeMap} map return value that holds <code>double</code> values between zero and one.
      */
      normalizeEdgeMap(graph:yfiles.algorithms.Graph,map:yfiles.algorithms.IEdgeMap):void;
    };
    /**
    * Responsible for graph bipartition problems.
    * A bipartite graph is a graph whose node set can be partitioned
    * into two sets in such a way that all edges in the graph
    * connect nodes that belong to different  partitions. In other words,
    * there are no edges connecting nodes that belong to the same
    * partition.
    */
    export interface Bipartitions extends Object{
    }
    var Bipartitions:{
      $class:yfiles.lang.Class;
      /**
      * Marker for a node that belongs to the red partition.
      */
      RED:Object;
      /**
      * Marker for a node that belongs to the blue partition.
      */
      BLUE:Object;
      /**
      * Tests whether or not the given graph is bipartite.
      * <b>Complexity:</b> <code>O(nodeCount()+edgeCount())</code>
      */
      isBipartite(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Calculates a bipartition of the given graph if one exists.
      * If the graph is bipartite then for all nodes of the
      * given graph either {@link yfiles.algorithms.Bipartitions#RED} or {@link yfiles.algorithms.Bipartitions#BLUE}
      * objects will put in the given node map, depending on
      * the partition the node belongs to.
      * <b>Complexity:</b> <code>O(nodeCount()+edgeCount())</code>
      * @return {boolean} <code>isBipartite(graph)</code>
      */
      getBipartition(graph:yfiles.algorithms.Graph,markMap:yfiles.algorithms.INodeMap):boolean;
    };
    /**
    * This class provides a means for early termination of graph algorithms.
    * Instances of this class may be attached to and retrieved from a graph
    * and may receive requests for stopping and canceling an algorithm working
    * on the graph.
    * <p>
    * <b>Client Code Usage</b>:
    * The handler's
    * {@link yfiles.algorithms.AbortHandler#stopDuration}
    * and
    * {@link yfiles.algorithms.AbortHandler#cancelDuration}
    * methods can be used to automatically stop or cancel an algorithm after a specified
    * period of time has elapsed.
    * <ul>
    * <b>
    * Stop
    * </b>
    * The algorithm should terminate gracefully, delivering a consistent result.
    * Although the termination will be early, it usually will not be immediate.
    * <b>
    * Cancel
    * </b>
    * The algorithm should terminate immediately, all work done so far will be
    * discarded.
    * IMPORTANT: It is not guaranteed that the processed graph will be in a
    * consistent state after cancellation. For this reason it is strongly
    * recommended to cancel only algorithms that work on copies of the real
    * graph structure such as layout algorithms running in buffered mode.
    * Furthermore, the state of the used layouter
    * instance may become corrupted. Hence, a new
    * instance has to be created after each cancellation.
    * </ul>
    * <p>
    * If a graph with an attached handler is processed by multiple algorithms
    * (or multiple times by one algorithm), the attached handler has to be
    * {@link yfiles.algorithms.AbortHandler#reset} between algorithm runs. Otherwise, previous requests for
    * early termination may lead to an undesired early termination of the next
    * algorithm run. Typically, the LayoutExecutor takes care of this.
    * </p>
    * <p>
    * <b>Usage in Algorithms</b>:
    * Algorithms have to retrieve an instance of this class from the graph
    * that is processed using method {@link yfiles.algorithms.AbortHandler#getFromGraph}.
    * The algorithm then needs to query the retrieved instance of this class for
    * stop or cancel requests using method {@link yfiles.algorithms.AbortHandler#check}.
    * Alternatively, convenience method {@link yfiles.algorithms.AbortHandler#check} for
    * one-time checks is available. For performance critical code that checks
    * repeatedly, it is recommended to follow the first approach, though.
    * When handling a stop request, algorithms should ensure that the resulting
    * graph is still in a consistent state.
    * </p></p>
    */
    export interface AbortHandler extends Object{
      /**
      * Schedules a stop request.
      * Algorithms that detect stop requests should terminate gracefully and ensure
      * that the processed graph remains in a consistent state.
      * <p>
      * Since JavaScript is not multi-threaded, this method is not meant to be called
      * in an interactive context on user request. Instead, it can be used in
      * an algorithm or layout stage to end the complete current calculation. 
      * </p>
      * @see {@link yfiles.algorithms.AbortHandler#check}
      */
      stop():void;
      /**
      * Returns whether or not a stop request was scheduled explicitly with the {@link yfiles.algorithms.AbortHandler#stop} method.
      */
      stopRequested:boolean;
      /**
      * Determines the remaining time (in milliseconds) until an algorithm that
      * {@link yfiles.algorithms.AbortHandler#check checks} this handler is stopped automatically.
      * @return {number} 
      * the remaining time (in milliseconds) until the algorithm is
      * stopped automatically.
      * @see {@link yfiles.algorithms.AbortHandler#stopDuration}
      * @see {@link yfiles.algorithms.AbortHandler#reset}
      * @see {@link yfiles.algorithms.AbortHandler#stop}
      */
      timeToStop():number;
      /**
      * The duration (in milliseconds) an algorithm may run before being
      * stopped automatically.
      * An algorithm is terminated gracefully, if the time in between
      *  or {@link yfiles.algorithms.AbortHandler#reset  resetting} this handler
      * and calling {@link yfiles.algorithms.AbortHandler#check} exceeds the stop duration.
      * <p>
      * Note, automatic termination will only occur for positive values.
      * </p><p>
      * Defaults to <code>0</code>, i.e. no automatic termination will occur.
      * </p>
      * @see {@link yfiles.algorithms.AbortHandler#timeToStop}
      * @see {@link yfiles.algorithms.AbortHandler#reset}
      * @see {@link yfiles.algorithms.AbortHandler#stop}
      */
      stopDuration:number;
      /**
      * Determines the remaining time (in milliseconds) until an algorithm that
      * {@link yfiles.algorithms.AbortHandler#check checks}
      * this handler is cancelled automatically.
      * @return {number} 
      * the remaining time (in milliseconds) until the algorithm is
      * cancelled automatically.
      * @see {@link yfiles.algorithms.AbortHandler#cancelDuration}
      * @see {@link yfiles.algorithms.AbortHandler#reset}
      */
      timeToCancel():number;
      /**
      * The duration (in milliseconds) an algorithm may run before being
      * cancelled automatically.
      * An algorithm is terminated immediately, if the time in between
      *  or {@link yfiles.algorithms.AbortHandler#reset  resetting} this handler
      * and calling {@link yfiles.algorithms.AbortHandler#check} exceeds the cancel duration.
      * <p>
      * Note, automatic termination will only occur for positive values.
      * </p><p>
      * Defaults to <code>0</code>, i.e. no automatic termination will occur.
      * </p>
      * @see {@link yfiles.algorithms.AbortHandler#timeToCancel}
      * @see {@link yfiles.algorithms.AbortHandler#reset}
      */
      cancelDuration:number;
      /**
      * <code>true</code> if method{@link yfiles.algorithms.AbortHandler#check} or {@link yfiles.algorithms.AbortHandler#check}
      * were called after a stop or cancel event.
      * More precisely, it returns <code>true</code> if one of the check methods
      * either threw an {@link yfiles.algorithms.AlgorithmAbortedException} or returned <code>true</code> to indicate
      * that the calling algorithm should terminate gracefully.
      * Otherwise, this method returns <code>false</code>.
      * @see {@link yfiles.algorithms.AbortHandler#check}
      * @see {@link yfiles.algorithms.AbortHandler#check}
      */
      checkFailed:boolean;
      /**
      * Determines if an algorithm should terminate its work early.
      * This method returns <code>true</code> if the algorithm should terminate
      * gracefully and ensures that the processed graph remains in a consistent
      * state.
      * This method throws an {@link yfiles.algorithms.AlgorithmAbortedException} if the algorithm
      * should terminate immediately.
      * @return {boolean} 
      * <code>true</code>, if the algorithm should stop as soon as possible
      * while still providing some valid result and <code>false</code> if the
      * algorithm should continue normally.
      * @throws {yfiles.algorithms.AlgorithmAbortedException} 
      * if the algorithm should terminate
      * immediately.
      * @see {@link yfiles.algorithms.AbortHandler#stop}
      */
      check():boolean;
      /**
      * Resets the state of the handler.
      * Resetting the handler discards any
      * previous stop or cancel requests. Moreover, the handler's internal
      * timestamp that is used to determine whether or not an algorithm should
      * be stopped or cancelled automatically is updated to the
      * current time
      * as well.
      * <p>
      * This method should be called whenever a graph with an attached handler
      * is processed an additional time to prevent previous requests for
      * early termination to result in an undesired early termination of the next
      * algorithm run.
      * </p>
      * @see {@link yfiles.algorithms.AbortHandler#cancelDuration}
      * @see {@link yfiles.algorithms.AbortHandler#stopDuration}
      */
      reset():void;
    }
    var AbortHandler:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to attach an {@link yfiles.algorithms.AbortHandler} instance to a graph.
      * Only instances of {@link yfiles.algorithms.AbortHandler} should be assigned to this data provider, otherwise a
      * {@link yfiles.system.InvalidCastException} will occur.
      * Layout algorithms will use the attached handler to check for requests to cancel or stop the layout process.
      */
      ABORT_HANDLER_DP_KEY:Object;
      /**
      * Initializes a new <code>AbortHandler</code> instance with the
      * {@link yfiles.algorithms.Runtime#currentTimeMillis  current time} to be used as timestamp
      * for determining whether or not an algorithm should be stopped or cancelled
      * automatically.
      * @see {@link yfiles.algorithms.AbortHandler#stopDuration}
      * @see {@link yfiles.algorithms.AbortHandler#cancelDuration}
      * @see {@link yfiles.algorithms.AbortHandler#reset}
      */
      new ():yfiles.algorithms.AbortHandler;
      /**
      * Creates an instance of this class and attaches it to the given graph.
      * If the given graph already has an attached handler instance, said instance
      * will be returned and this method will not create a new handler instance.
      * <p>
      * This method should be called by client code prior to starting a graph
      * algorithm that may be terminated early.
      * </p>
      * @param {yfiles.algorithms.Graph} graph the graph to which the handler will be attached.
      * @return {yfiles.algorithms.AbortHandler} the handler instance for the given graph.
      * @throws {yfiles.system.ArgumentNullException} if the given graph is <code>null</code>.
      * @see {@link yfiles.algorithms.AbortHandler#hasHandler}
      */
      createForGraph(graph:yfiles.algorithms.Graph):yfiles.algorithms.AbortHandler;
      /**
      * Removes any attached instance of this class from the given graph.
      * @param {yfiles.algorithms.Graph} graph the graph from which the handler will be removed.
      * @throws {yfiles.system.ArgumentNullException} if the given graph is <code>null</code>.
      */
      removeFromGraph(graph:yfiles.algorithms.Graph):void;
      /**
      * Returns an instance of this class for the given graph.
      * If {@link yfiles.algorithms.AbortHandler#createForGraph} has been used to attach a new
      * handler to the given graph, said instance is returned. Otherwise a
      * non-functional instance is returned whose methods do nothing. Use
      * {@link yfiles.algorithms.AbortHandler#hasHandler} whether or not a handler
      * has been already attached to the given graph.
      * @param {yfiles.algorithms.Graph} graph the graph for which the handler should be retrieved.
      * @return {yfiles.algorithms.AbortHandler} 
      * a handler for the given graph. Maybe a non-functional instance
      * if no handler has been previously created.
      * @throws {yfiles.system.ArgumentNullException} if the given graph is <code>null</code>.
      * @see {@link yfiles.algorithms.AbortHandler#createForGraph}
      * @see {@link yfiles.algorithms.AbortHandler#hasHandler}
      */
      getFromGraph(graph:yfiles.algorithms.Graph):yfiles.algorithms.AbortHandler;
      /**
      * Attaches the handler instance of the given source graph to the target
      * graph as well.
      * <p>
      * Note, if there is a handler attached to the given target graph,
      * this method will silently replace said instance with the one attached
      * to the source graph.
      * </p>
      * @param {yfiles.algorithms.Graph} source the graph whose handler is attached to the target graph.
      * @param {yfiles.algorithms.Graph} target 
      * the graph to which the handler of the source graph is
      * attached.
      * @throws {yfiles.system.ArgumentNullException} if the given source is <code>null</code>.
      */
      copyHandler(source:yfiles.algorithms.Graph,target:yfiles.algorithms.Graph):void;
      /**
      * Determines whether or not an instance of this class is attached to the
      * given graph.
      * @param {yfiles.algorithms.Graph} graph the graph which to check for a handler.
      * @return {boolean} 
      * <code>true</code> if a handler is attached to the given graph;
      * <code>false</code> otherwise.
      * @throws {yfiles.system.ArgumentNullException} if the given graph is <code>null</code>.
      */
      hasHandler(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Determines if an algorithm should terminate its work early.
      * This method returns <code>true</code> if the algorithm should terminate
      * gracefully and ensure that the processed graph remains in a consistent
      * state.
      * This method throws an {@link yfiles.algorithms.AlgorithmAbortedException} if the algorithm
      * should terminate immediately.
      * <p>
      * This convenience method is meant for one-time checks only.
      * For performance critical code that checks repeatedly, it is recommended to
      * retrieve the given graph's attached handler once and only call the
      * handler's {@link yfiles.algorithms.AbortHandler#check} method repeatedly.
      * </p>
      * @return {boolean} 
      * <code>true</code>, if the algorithm should stop as soon as possible
      * while still providing some valid result and <code>false</code> if the
      * algorithm should continue normally.
      * @throws {yfiles.algorithms.AlgorithmAbortedException} 
      * if the algorithm should terminate
      * immediately.
      * @throws {yfiles.system.ArgumentNullException} if the given graph is <code>null</code>.
      * @see {@link yfiles.algorithms.AbortHandler#check}
      * @see {@link yfiles.algorithms.AbortHandler#stop}
      */
      check(graph:yfiles.algorithms.Graph):boolean;
    };
    /**
    * Exception that gets thrown by an algorithm if a immediate termination
    * request is detected.
    * @see {@link yfiles.algorithms.AbortHandler}
    * @see {@link yfiles.algorithms.AbortHandler}
    * @see {@link yfiles.algorithms.AbortHandler#check}
    */
    export interface AlgorithmAbortedException extends yfiles.lang.Exception{
    }
    var AlgorithmAbortedException:{
      $class:yfiles.lang.Class;
      WithMessage:{
        new (msg:string):yfiles.algorithms.AlgorithmAbortedException;
      };
      new ():yfiles.algorithms.AlgorithmAbortedException;
    };
    /**
    * Framework class for depth first search (DFS) based algorithms.
    * To write graph algorithms that are based on a depth first search
    * one can extend this class and overwrite appropriate callback
    * methods provided by this class.
    */
    export interface Dfs extends Object{
      /**
      * NodeMap that indicates the state of the nodes as they
      * are visited by this algorithm.
      * Possible states of a node are
      * {@link yfiles.algorithms.Dfs#WHITE  WHITE}, {@link yfiles.algorithms.Dfs#GRAY  GRAY} and {@link yfiles.algorithms.Dfs#BLACK  BLACK}.
      */
      stateMap:yfiles.algorithms.INodeMap;
      /**
      * Specifies whether or not to interpret the edges of the graph
      * as directed.
      * By default directed mode is disabled.
      */
      directedMode:boolean;
      /**
      * Specifies whether or not to continue the depth first search
      * after all nodes reachable from the first node were
      * visited.
      * By default look further mode is active.
      */
      lookFurtherMode:boolean;
      /**
      * Starts a depth first search on the given graph.
      * The first node in the graph will be visited first.
      */
      start(graph:yfiles.algorithms.Graph):void;
      /**
      * Starts a depth first search on the given graph.
      * The given node will be visited first.
      * If <code>start</code> is null, this method returns silently.
      */
      startFromNode(graph:yfiles.algorithms.Graph,start:yfiles.algorithms.Node):void;
      /**
      * Callback method that will be invoked whenever a formerly unvisited node
      * gets visited the first time.
      * The given int is the dfs number of that
      * node.
      * By default this method does nothing
      */
      preVisit(node:yfiles.algorithms.Node,dfsNumber:number):void;
      /**
      * Callback method that will be invoked whenever a node visit has
      * been completed.
      * The dfs number and the completion number
      * of the given node will be passed in.
      * By default this method does nothing
      */
      postVisit(node:yfiles.algorithms.Node,dfsNumber:number,compNumber:number):void;
      /**
      * Callback method that will be invoked if the given edge
      * will be looked at in the search the first (and only) time.
      * The given node is the node that will be visited next iff
      * <code>treeEdge == true</code>.
      * By default this method does nothing
      */
      preTraverse(edge:yfiles.algorithms.Edge,node:yfiles.algorithms.Node,treeEdge:boolean):void;
      /**
      * Callback method that will be invoked after the search returns
      * from the given node.
      * The node has been reached via the given edge.
      * By default this method does nothing.
      */
      postTraverse(edge:yfiles.algorithms.Edge,node:yfiles.algorithms.Node):void;
      /**
      * Callback method that will be invoked whenever dfs continues
      * its search at a new root node.
      * By default this method does nothing
      */
      lookFurther(v:yfiles.algorithms.Node):void;
      /**
      * Subclasses can call this method to cancel the dfs.
      */
      cancel():void;
    }
    var Dfs:{
      $class:yfiles.lang.Class;
      /**
      * Node state specifier.
      * Indicates that a node was not yet visited.
      */
      WHITE:Object;
      /**
      * Node state specifier.
      * Indicates that a node was already visited but
      * has not been completed yet, i.e. it is still part of an active
      * path of the dfs tree.
      */
      GRAY:Object;
      /**
      * Node state specifier.
      * Indicates that the node has been completed,
      * i.e. it has been visited before and is not part of an active
      * path in the dfs tree anymore.
      */
      BLACK:Object;
      /**
      * Instantiates a new Dfs object.
      */
      new ():yfiles.algorithms.Dfs;
    };
    /**
    * Responsible for finding cycles within a graph that have certain properties.
    */
    export interface Cycles extends Object{
    }
    var Cycles:{
      $class:yfiles.lang.Class;
      /**
      * This method marks edges of a given graph whose removal or reversal would make
      * that graph acyclic.
      * This method tries to minimize the number of marked edges
      * for that task heuristically, since it is a well known hard problem to come up
      * with an optimal solution.
      * <b>Complexity:</b> O(graph.E()+graph.N()*log(graph.E()))
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.IEdgeMap} cycleEdges 
      * return value. cycleEdge.getBool(e) == true  iff
      * e is a detected cycle edge.
      */
      findCycleEdges(graph:yfiles.algorithms.Graph,cycleEdges:yfiles.algorithms.IEdgeMap):void;
      /**
      * This method is similar to {@link yfiles.algorithms.Cycles#findCycleEdges}, but instead of minimizing the
      * number of marked edges it tries to find a set of marked edges, for which the associated
      * cost is minimal.
      * In case each edge has cost <code>1.0</code> the result will be
      * the same as the one returned by {@link yfiles.algorithms.Cycles#findCycleEdges}.
      * <b>Complexity:</b> O(graph.E()+graph.N()*log(graph.E()))
      * @param {yfiles.algorithms.IDataProvider} costDP 
      * data provider that yields the reversal cost for each edge. The reversal cost
      * for each edge must be a non-negative value of type <code>double</code>.
      */
      findCycleEdgesWithCost(graph:yfiles.algorithms.Graph,cycleEdges:yfiles.algorithms.IEdgeMap,costDP:yfiles.algorithms.IDataProvider):void;
      /**
      * Like {@link yfiles.algorithms.Cycles#findCycleEdges} this method marks
      * edges of a given graph whose removal or reversal would make
      * that graph acyclic.
      * The implementation of this method is
      * based on a Depth First Search. The number of marked cycle edges
      * is expected to be slightly larger than when using
      * {@link yfiles.algorithms.Cycles#findCycleEdges}. The advantage of this method
      * is that the result set is more stable when edges get added or removed
      * over the time.
      * <b>Complexity:</b> O(graph.E()+graph.N())
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {yfiles.algorithms.IEdgeMap} cycleEdges 
      * return value. cycleEdge.getBool(e) == true  iff
      * e is a detected cycle edge.
      */
      findCycleEdgesDFS(graph:yfiles.algorithms.Graph,cycleEdges:yfiles.algorithms.IEdgeMap):void;
      /**
      * Returns an edge list that contains the edges of a cycle
      * found in the given graph.
      * The edges are returned in the
      * order they appear in the found cycle.
      * If the returned cycle is empty then no cycle has been
      * found in the given graph.
      * <b>Complexity:</b> O(graph.N()+graph.E())
      */
      findCycle(graph:yfiles.algorithms.Graph,directed:boolean):yfiles.algorithms.EdgeList;
      /**
      * Returns all edges that are part of at least one directed or undirected
      * simple cycle.
      * A simple cycle is a closed edge path without repeating edges.
      * Moreover, selfloops are always considered to be cycle edges.
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @param {boolean} directed whether or not to look for edges on directed cycles
      * @return {yfiles.algorithms.EdgeList} all edges that belong to a cycle
      */
      findAllCycleEdges(graph:yfiles.algorithms.Graph,directed:boolean):yfiles.algorithms.EdgeList;
    };
    /**
    * Represents an edge, i.e., a directed connection between two nodes (represented
    * by instances of class {@link yfiles.algorithms.Node}) in the directed graph data type {@link yfiles.algorithms.Graph}.
    * The <i>directed</i> stems from the fact that an edge has a distinct source node
    * and a distinct target node.
    * Using pair notation, an edge would be written as
    * (<i>&lt;source node&gt;</i>, <i>&lt;target node&gt;</i>).
    * Most notably, an edge provides access to its source node ({@link yfiles.algorithms.Edge#source})
    * and its target node ({@link yfiles.algorithms.Edge#target}).
    * Note that an edge can have the same node as its source and target.
    * Such an edge is then called "self-loop" and method {@link yfiles.algorithms.Edge#selfLoop} yields
    * <code>true</code>.
    * <b>Important:</b>
    * Class Graph is the single authority for any structural changes to the graph data
    * type.
    * Specifically, this means that there is no way to create or delete a node or an
    * edge without using an actual Graph instance.
    */
    export interface Edge extends yfiles.algorithms.GraphObject{
      /**
      * Creates a copy of this edge that will be inserted into the given graph connecting
      * the given source and target nodes.
      * @param {yfiles.algorithms.Graph} g The graph the created edge will belong to.
      * @param {yfiles.algorithms.Node} v The source node of the created edge.
      * @param {yfiles.algorithms.Node} w The target node of the created edge.
      * @return {yfiles.algorithms.Edge} The newly created Edge object.
      */
      createCopy(g:yfiles.algorithms.Graph,v:yfiles.algorithms.Node,w:yfiles.algorithms.Node):yfiles.algorithms.Edge;
      /**
      * The graph this edge belongs to.
      * If the edge does not belong to a graph, because it was removed or hidden from
      * it, this method returns <code>null</code>.
      */
      graph:yfiles.algorithms.Graph;
      /**
      * The index of this edge within its graph G.
      * Edge indices represent the ordering of standard edge iteration on G.
      * The value of an index is <code> &gt;= 0</code> and <code> &lt; G.edgeCount()</code>.
      * Note that indices are subject to change whenever the sequence of edges in a
      * graph is modified by either removing, hiding, reinserting, or unhiding an edge,
      * or by explicitly changing its position in the sequence.
      * <b>Precondition:</b> This edge must belong to some graph.
      * @see {@link yfiles.algorithms.Graph#removeEdge}
      * @see {@link yfiles.algorithms.Graph#hideEdge}
      * @see {@link yfiles.algorithms.Graph#reInsertEdge}
      * @see {@link yfiles.algorithms.Graph#unhideEdge}
      * @see {@link yfiles.algorithms.Graph#moveToFirstEdge}
      * @see {@link yfiles.algorithms.Graph#moveToLastEdge}
      */
      index:number;
      /**
      * The source node connected to this edge.
      * @see {@link yfiles.algorithms.Edge#target}
      */
      source:yfiles.algorithms.Node;
      /**
      * The target node connected to this edge.
      * @see {@link yfiles.algorithms.Edge#source}
      */
      target:yfiles.algorithms.Node;
      /**
      * Returns the node at the opposite edge end with respect to the given node.
      * Note that self-loops have the same node at both edge ends.
      * <b>Precondition:</b> The given node must be either the edge's source node or target node.
      */
      opposite(v:yfiles.algorithms.Node):yfiles.algorithms.Node;
      /**
      * <code>true</code> if and only if this edge is a self-loop.
      * An edge is called a self-loop, if it is adjacent to only one node, i.e.,
      * source node and target node are the same.
      */
      selfLoop:boolean;
      /**
      * Returns a String representation of this edge.
      */
      toString():string;
      /**
      * Callback method that is invoked from a graph just before this edge will be
      * reinserted into that graph.
      */
      onReinsert():void;
      /**
      * The successor of this edge in the list of outgoing edges at its source
      * node.
      * If this edge is the last outgoing edge at its source node, then <code>null</code>
      * is returned.
      * <b>Precondition:</b> This edge must belong to some graph.
      * @see {@link yfiles.algorithms.Edge#prevOutEdge}
      * @see {@link yfiles.algorithms.Edge#nextInEdge}
      */
      nextOutEdge:yfiles.algorithms.Edge;
      /**
      * The successor of this edge in the list of incoming edges at its target
      * node.
      * If this edge is the last incoming edge at its target node, then <code>null</code>
      * is returned.
      * <b>Precondition:</b> This edge must belong to some graph.
      * @see {@link yfiles.algorithms.Edge#prevInEdge}
      * @see {@link yfiles.algorithms.Edge#nextOutEdge}
      */
      nextInEdge:yfiles.algorithms.Edge;
      /**
      * The predecessor of this edge in the list of outgoing edges at its source
      * node.
      * If this edge is the first outgoing edge at its source node, then <code>null</code>
      * is returned.
      * <b>Precondition:</b> This edge must belong to some graph.
      * @see {@link yfiles.algorithms.Edge#nextOutEdge}
      * @see {@link yfiles.algorithms.Edge#prevInEdge}
      */
      prevOutEdge:yfiles.algorithms.Edge;
      /**
      * The predecessor of this edge in the list of incoming edges at its target
      * node.
      * If this edge is the first incoming edge at its target node, then <code>null</code>
      * is returned.
      * <b>Precondition:</b> This edge must belong to some graph.
      * @see {@link yfiles.algorithms.Edge#nextInEdge}
      * @see {@link yfiles.algorithms.Edge#prevOutEdge}
      */
      prevInEdge:yfiles.algorithms.Edge;
    }
    var Edge:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new edge that belongs to the given graph.
      * The new edge <code>e</code> has source node <code>v</code> and target node
      * <code>w</code>.
      * Edge <code>e</code> is inserted in such a way that an iteration over the edges
      * at node <code>v</code> returns <code>e</code>
      * <ul>
      * <li>
      * after <code>e1</code>, if <code>d1 == AFTER</code>
      * </li>
      * <li>
      * before <code>e1</code>, if <code>d1 == BEFORE</code>,
      * </li>
      * </ul>
      * and an iteration over the edges at <code>w</code> returns <code>e</code>
      * <ul>
      * <li>
      * after <code>e2</code>, if <code>d2 == AFTER</code>
      * </li>
      * <li>
      * before <code>e2</code>, if <code>d2 == BEFORE</code>.
      * </li>
      * </ul>
      * <b>Precondition:</b> 
      * Edge <code>e1</code> must have source node <code>v</code> and edge <code>e2</code>
      * must have target node <code>w</code>.
      * @param {yfiles.algorithms.Node} v The source node of the edge.
      * @param {yfiles.algorithms.Edge} e1 An edge with source node <code>v</code>.
      * @param {yfiles.algorithms.Node} w The target node of the edge.
      * @param {yfiles.algorithms.Edge} e2 An edge with target node <code>w</code>.
      * @param {yfiles.algorithms.GraphElementInsertion} d1 
      * One of the object insertion specifiers {@link yfiles.algorithms.GraphElementInsertion#BEFORE} or {@link yfiles.algorithms.GraphElementInsertion#AFTER}.
      * @param {yfiles.algorithms.GraphElementInsertion} d2 
      * One of the object insertion specifiers {@link yfiles.algorithms.GraphElementInsertion#BEFORE} or {@link yfiles.algorithms.GraphElementInsertion#AFTER}.
      */
      new (g:yfiles.algorithms.Graph,v:yfiles.algorithms.Node,e1:yfiles.algorithms.Edge,w:yfiles.algorithms.Node,e2:yfiles.algorithms.Edge,d1:yfiles.algorithms.GraphElementInsertion,d2:yfiles.algorithms.GraphElementInsertion):yfiles.algorithms.Edge;
    };
    /**
    * This class represents a line segment in the plane.
    * A line segment is defined by its two end points.
    */
    export interface LineSegment extends Object,yfiles.algorithms.IPlaneObject{
      /**
      * If this segment is considered vertical, i.e.
      * the x values of the end point differ less then 0.00000001
      */
      isVertical:boolean;
      /**
      * Determines if the interval is horizontal.
      */
      isHorizontal:boolean;
      /**
      * The first end point of the line segment.
      */
      firstEndPoint:yfiles.algorithms.YPoint;
      /**
      * The second end point of the line segment.
      */
      secondEndPoint:yfiles.algorithms.YPoint;
      /**
      * Returns if the projection on the Y axis of the line segment
      * covers a certain point on the Y Axis.
      */
      isInYIntervall(y:number):boolean;
      /**
      * Returns if the projection on the X axis of the line segment
      * covers a certain point on the X Axis.
      */
      isInXIntervall(x:number):boolean;
      /**
      * The y value of the line on x coordinate 0.
      */
      xOffset:number;
      /**
      * The slope of the line segment.
      */
      slope:number;
      /**
      * Returns the length of the line segment,
      * this is the value of the Euclidean norm.
      * @return {number} an value > 0.
      */
      length():number;
      /**
      * The smallest Rectangle which contains the object.
      * @see Specified by {@link yfiles.algorithms.IPlaneObject#boundingBox}.
      */
      boundingBox:yfiles.algorithms.YRectangle;
      /**
      * Checks whether the line segment intersects a box.
      * @param {yfiles.algorithms.YRectangle} box A rectangle.
      * @return {boolean} 
      * <code>true</code> if the line segments intersects the box,
      * <code>false</code> otherwise.
      */
      intersectsRectangle(box:yfiles.algorithms.YRectangle):boolean;
      /**
      * Checks whether a given point lies on  this line segment.
      * @param {yfiles.algorithms.YPoint} point an arbitrary point.
      * @return {boolean} 
      * <code>true</code> if the line segments intersects the box,
      * <code>false</code> otherwise.
      */
      contains(point:yfiles.algorithms.YPoint):boolean;
      /**
      * Checks whether the line segment intersects a point.
      * @param {yfiles.algorithms.YPoint} p a point
      * @return {boolean} 
      * <code>true</code> if the line segments intersects the box,
      * <code>false</code> otherwise.
      */
      intersectsPoint(p:yfiles.algorithms.YPoint):boolean;
      /**
      * Returns the vector pointing from the first end point to the second
      * end point of the line segment.
      */
      toYVector():yfiles.algorithms.YVector;
      /**
      * Returns the affine line defined by the end points of the
      * line segment.
      */
      toAffineLine():yfiles.algorithms.AffineLine;
      /**
      * The distance from start to end point in x-coordinates.
      */
      deltaX:number;
      /**
      * The distance from start to end point in y-coordinates.
      */
      deltaY:number;
      /**
      * String representation of the line.
      */
      toString():string;
    }
    var LineSegment:{
      $class:yfiles.lang.Class;
      /**
      * Returns a new LineSegment.
      * @param {yfiles.algorithms.YPoint} p1 the first end point of the line segment.
      * @param {yfiles.algorithms.YPoint} p2 the second end point of the line segment.
      */
      new (p1:yfiles.algorithms.YPoint,p2:yfiles.algorithms.YPoint):yfiles.algorithms.LineSegment;
      /**
      * Checks whether a line segment intersects a box.
      * @param {yfiles.algorithms.YRectangle} box A rectangle.
      * @param {yfiles.algorithms.YPoint} s first end point of the line segment.
      * @param {yfiles.algorithms.YPoint} t second end point of the line segment.
      * @return {boolean} 
      * <code>true</code> if the line segments intersects the box,
      * <code>false</code> otherwise.
      */
      boxIntersectsSegment(box:yfiles.algorithms.YRectangle,s:yfiles.algorithms.YPoint,t:yfiles.algorithms.YPoint):boolean;
      /**
      * Checks whether a line segment intersects a box.
      * Implemented using the Cohen-Sutherland algorithm.
      * @param {yfiles.algorithms.YRectangle} box A rectangle
      * @param {number} x1 X-coordinate of start point of vector
      * @param {number} y1 Y-coordinate of start point of vector
      * @param {number} x2 X-coordinate of target point of vector
      * @param {number} y2 Y-coordinate of target point of vector
      * @return {boolean} 
      * <code>true</code> if the line segments intersects the box,
      * <code>false</code> otherwise.
      */
      boxIntersectsSegmentDouble(box:yfiles.algorithms.YRectangle,x1:number,y1:number,x2:number,y2:number):boolean;
      /**
      * Returns intersection point between the two line segments, if there is
      * one or <code>null</code> if the two line segments do not intersect.
      * @param {yfiles.algorithms.LineSegment} s1 first line segment
      * @param {yfiles.algorithms.LineSegment} s2 second line segment
      */
      getIntersection(s1:yfiles.algorithms.LineSegment,s2:yfiles.algorithms.LineSegment):yfiles.algorithms.YPoint;
    };
    /**
    * This class provides algorithms for the triangulation of point
    * sets in the plane.
    */
    export interface Triangulator extends Object{
    }
    var Triangulator:{
      $class:yfiles.lang.Class;
      /**
      * Computes a triangulation of the given points.
      * The calculated triangulation is represented by an embedded graph,
      * i.e. to each edge there exists a reverse edge and the outedges
      * around each node are in embedded order. The returned edge and
      * the (optional) reverseEdgeMap can be used to construct all faces of the
      * plane graph and to determine its outer face.
      * @param {yfiles.algorithms.Graph} result 
      * a graph whose nodes represent the points that need
      * to be triangulated.
      * @param {yfiles.algorithms.IDataProvider} pointData must provide the location (YPoint) for each node in the given graph.
      * @param {yfiles.algorithms.IEdgeMap} reverseEdgeMap 
      * a node map that will contain for each edge its reverse
      * edge. If this argument is <code>null</code> then no reverse edge information
      * will be available.
      * @return {yfiles.algorithms.Edge} an edge on the outer face of the result graph.
      */
      triangulatePoints(result:yfiles.algorithms.Graph,pointData:yfiles.algorithms.IDataProvider,reverseEdgeMap:yfiles.algorithms.IEdgeMap):yfiles.algorithms.Edge;
      /**
      * Computes a triangulation of the given points.
      * The calculated triangulation is represented by an embedded graph,
      * i.e. to each edge there exists a reverse edge and the outedges
      * around each node are in embedded order. The returned edge and
      * the (optional) reverseEdgeMap can be used to construct all faces of the
      * plane graph and to determine its outer face.
      * @param {yfiles.algorithms.YList} points 
      * the point set to be triangulated. The points must be provided
      * as a YList of YPoints.
      * @param {yfiles.algorithms.Graph} result the resulting triangulation
      * @param {yfiles.algorithms.INodeMap} resultMap the node map that forms the link between a point and a node.
      * @param {yfiles.algorithms.IEdgeMap} reverseEdgeMap 
      * a node map that will contain for each edge its reverse
      * edge. If this argument is <code>null</code> then no reverse edge information
      * will be available.
      * @return {yfiles.algorithms.Edge} an edge on the outer face of the result graph.
      */
      triangulatePointsFromList(points:yfiles.algorithms.YList,result:yfiles.algorithms.Graph,resultMap:yfiles.algorithms.INodeMap,reverseEdgeMap:yfiles.algorithms.IEdgeMap):yfiles.algorithms.Edge;
      /**
      * Computes a Delauney triangulation of the given points.
      * A Delauney triangulation
      * is a triangulation such that none of the given points is inside the circumcircle
      * of any of the calculated triangles.
      * <p>
      * The calculated triangulation is represented by an embedded graph,
      * i.e. to each edge there exists a reverse edge and the outedges
      * around each node are in embedded order. The returned edge and
      * the (optional) reverseEdgeMap can be used to construct all faces of the
      * plane graph and to determine its outer face.
      * </p>
      * @param {yfiles.algorithms.Graph} result 
      * a graph whose nodes represent the points that need
      * to be triangulated.
      * @param {yfiles.algorithms.IDataProvider} pointData must provide the location (YPoint) for each node in the given graph.
      * @param {yfiles.algorithms.IEdgeMap} revMap 
      * a node map that will contain for each edge its reverse
      * edge. If this argument is <code>null</code> then no reverse edge information
      * will be available.
      * @return {yfiles.algorithms.Edge} an edge on the outer face of the result graph.
      */
      calcDelauneyTriangulation(result:yfiles.algorithms.Graph,pointData:yfiles.algorithms.IDataProvider,revMap:yfiles.algorithms.IEdgeMap):yfiles.algorithms.Edge;
    };
    /**
    * Provides methods that check structural properties of a given graph.
    */
    export interface GraphChecker extends Object{
    }
    var GraphChecker:{
      $class:yfiles.lang.Class;
      /**
      * Checks whether or not the given graph is acyclic, that is, if it contains no directed cycle.
      * Note: <code>isAcyclic(graph) &lt;=&gt; !isCyclic(graph)</code>.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {boolean} <code>true</code> if the graph is acyclic; <code>false</code>, otherwise.
      */
      isAcyclic(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given graph is cyclic, that is, if it contains a directed cycle.
      * Note: <code>isCyclic(graph) &lt;=&gt; !isAcyclic(graph)</code>.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {boolean} <code>true</code> if the graph is cyclic; <code>false</code>, otherwise.
      */
      isCyclic(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given graph is planar.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {boolean} <code>true</code> if the graph is planar; <code>false</code>, otherwise.
      */
      isPlanar(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given graph is connected.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {boolean} <code>true</code> if the graph is connected; <code>false</code>, otherwise.
      */
      isConnected(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given directed graph is strongly connected.
      * @param {yfiles.algorithms.Graph} graph the given directed graph.
      * @return {boolean} <code>true</code> if the graph is strongly connected; <code>false</code>, otherwise.
      */
      isStronglyConnected(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given undirected graph is biconnected.
      * @param {yfiles.algorithms.Graph} graph the given undirected graph.
      * @return {boolean} <code>true</code> if the graph is biconnected; <code>false</code>, otherwise.
      */
      isBiconnected(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given undirected graph is bipartite.
      * @param {yfiles.algorithms.Graph} graph the given undirected graph.
      * @return {boolean} <code>true</code> if the graph is bipartite; <code>false</code>, otherwise.
      */
      isBipartite(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given graph is a directed rooted tree
      * where each node has a maximum of <code>n</code> children.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {boolean} 
      * <code>true</code> if the graph is a directed rooted tree where each node has <code>&lt;= n</code> children;
      * <code>false</code>, otherwise.
      */
      isNaryTree(graph:yfiles.algorithms.Graph,n:number):boolean;
      /**
      * Checks whether or not the given graph is a directed rooted tree.
      * Note: <code>isRootedTree(graph) =&gt; isTree(graph)</code>.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {boolean} <code>true</code> if the graph is a directed rooted tree; <code>false</code>, otherwise.
      */
      isRootedTree(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given graph is an undirected tree.
      * Note: <code>isRootedTree(graph) =&gt; isTree(graph)</code>.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {boolean} <code>true</code> if the graph is an undirected tree; <code>false</code>, otherwise.
      */
      isTree(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether the given graph is a forest, that is,
      * a graph whose connected components are directed rooted trees.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {boolean} <code>true</code> if the graph is a forest; <code>false</code>, otherwise.
      */
      isForest(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given graph contains no self-loops.
      * Note: <code>!isSelfLoopFree(graph) =&gt; !isAcyclic(graph)</code>.
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {boolean} <code>true</code> if the graph contains no self-loops; <code>false</code>, otherwise.
      */
      isSelfLoopFree(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given directed graph is simple.
      * A graph is called simple if it contains no two distinct edges <code>e1, e2</code> where
      * <code>e1.source() == e2.source() &amp;&amp; e1.target() == e2.target().</code>
      * Note: <code>isMultipleEdgeFree(graph) =&gt; isSimple(graph)</code>.
      * @param {yfiles.algorithms.Graph} graph the given directed graph.
      * @return {boolean} <code>true</code> if the graph is simple; <code>false</code>, otherwise.
      */
      isSimple(graph:yfiles.algorithms.Graph):boolean;
      /**
      * Checks whether or not the given undirected graph contains no multiple edges.
      * More precisely, the method returns <code>true</code> if the graph contains no two distinct
      * edges <code>e1, e2</code> that connect the same pairs of nodes in either direction.
      * Note: <code>isMultipleEdgeFree(graph) =&gt; isSimple(graph)</code>.
      * @param {yfiles.algorithms.Graph} graph the given undirected graph.
      * @return {boolean} <code>true</code> if the graph contains no multiple edges; <code>false</code>, otherwise.
      */
      isMultipleEdgeFree(graph:yfiles.algorithms.Graph):boolean;
    };
    /**
    * Provides some convenience methods for code debugging
    * and exception handling.
    * <p>
    * The behavior of this class can be adapted by starting
    * the Java Virtual Machine with a set system property
    * <code>y.debug</code> and <code>y.debug.level</code>.
    * The default debug level is 2. It can be changed by
    * setting the system property <code>y.debug.level</code>
    * appropriately.
    * </p>
    */
    export interface LoggingUtil extends Object{
    }
    var LoggingUtil:{
      $class:yfiles.lang.Class;
      /**
      * The debug level threshold.
      * Its default value is
      * 2 but may be changed by setting the system property
      * <code>y.debug.level</code>.
      */
      DEBUG_LEVEL:number;
      /**
      * Prints the given string to <code>System.out</code> if
      * the given debug level if bigger than
      * <code>DEBUG_LEVEL</code>.
      */
      logWithLevel(level:number,msg:string):void;
      /**
      * Prints the given object to <code>System.err</code> unconditionally.
      */
      logMessage(msg:Object):void;
      /**
      * Like {@link yfiles.algorithms.LoggingUtil#logMessage}, but omits newline.
      */
      shortLogMessage(msg:Object):void;
      /**
      * Print the given message to <code>System.err</code> if the fully qualified
      * class name of the given source object is encoded
      * in the system property <code>y.debug</code> and
      * if the given debug level if bigger than
      * <code>DEBUG_LEVEL</code>.
      * <p>
      * The value of the <code>y.debug</code> property is a colon separated
      * list of fully qualified class name prefixes. If the name of the given
      * class starts with one of the specified prefixes the debug message will
      * be printed to <code>System.err</code>.
      * </p>
      */
      logWithSourceAndMsg(source:Object,msg:Object):void;
      /**
      * Print the given message to <code>System.err</code> if the fully qualified
      * class name of the given source object is encoded
      * in the system property <code>y.debug</code>.
      * <p>
      * The value of the <code>y.debug</code> property is a colon separated
      * list of fully qualified class name prefixes. If the name of the given
      * class starts with one of the specified prefixes the debug message will
      * be printed to <code>System.err</code>.
      * </p>
      */
      log(source:Object,level:number,msg:Object):void;
      /**
      * Like {@link yfiles.algorithms.LoggingUtil#logWithSourceAndMsg}, but does not append a newline to the
      * output.
      */
      shortLogWithSource(source:Object,msg:Object):void;
      /**
      * Returns true if the given object type is under observation
      * due to the <code>-Dy.debug</code> mechanism.
      */
      watchSource(source:Object):boolean;
      /**
      * Returns true if the given object type is under observation
      * due to the <code>-Dy.debug</code> mechanism.
      */
      watch(source:string):boolean;
      /**
      * Outputs the class of the given object and the given message.
      * Then throws a RuntimeException using the same message.
      * Mostly used in a catch statement to
      * signal a definite bug.
      */
      fatalWithMessage(source:Object,msg:Object):void;
      /**
      * Called on a fatal error.
      * Mostly used in a catch statement to
      * signal a definite bug.
      */
      fatal(msg:Object):void;
      /**
      * Like {@link yfiles.algorithms.LoggingUtil#logWithLevel}, but uses no line-feed.
      */
      shortLogWithLevel(level:number,output:string):void;
      /**
      * Outputs a stack trace on <code>System.err</code>.
      */
      traceException(ex:yfiles.lang.Exception):void;
      /**
      * Outputs a stack trace on <code>System.err.</code>
      */
      trace():void;
    };
    /**
    * A specialized priority queue that contains nodes which are
    * prioritized by associated int values.
    * This queue is designed for efficiency in scenario's where the
    * set of possible integral priority keys is small and
    * tight (i.e their values are not far apart).
    * Typical int values chosen are the degree of a node.
    */
    export interface ListIntNodePQ extends Object,yfiles.algorithms.IIntNodePQ{
      /**
      * Disposes this queue.
      * It is important to call this method after the queue
      * is not needed anymore, since it allocates node maps from the graph
      * that owns the nodes within the queue.
      * Calling this method frees these node maps again.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#dispose}.
      */
      dispose():void;
      /**
      * Specifies whether or not this queue is empty.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#empty}.
      */
      empty:boolean;
      /**
      * Whether or not the given node is contained within this queue.
      * <b>Complexity:</b> <code> O(1) </code>
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#contains}.
      */
      contains(v:yfiles.algorithms.Node):boolean;
      /**
      * Returns the number of nodes still in the queue.
      */
      size():number;
      /**
      * Adds a node to this queue with the given priority.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#add}.
      */
      add(v:yfiles.algorithms.Node,value:number):void;
      /**
      * Decreases the priority of a node in the queue to a certain value.
      * @param {yfiles.algorithms.Node} v a node in the priority queue.
      * @param {number} value the new priority value of the node.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#decreasePriority}.
      */
      decreasePriority(v:yfiles.algorithms.Node,value:number):void;
      /**
      * Returns the current priority of the given node.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#getPriority}.
      */
      getPriority(v:yfiles.algorithms.Node):number;
      /**
      * Increases the priority of a node in the queue to a certain value.
      * @param {yfiles.algorithms.Node} v a node in the priority queue.
      * @param {number} value the new priority value of the node.
      */
      increasePriority(v:yfiles.algorithms.Node,value:number):void;
      /**
      * The node with the minimal value in the queue.
      * <b>Precondition:</b> <code>!isEmpty()</code>
      * <b>Complexity:</b> Amortized O(1)
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#min}.
      */
      min:yfiles.algorithms.Node;
      /**
      * Removes all entries from the queue.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#clear}.
      */
      clear():void;
      /**
      * Removes a node from the queue.
      * <b>Complexity:</b> O(1)
      */
      remove(v:yfiles.algorithms.Node):void;
      /**
      * Same as popMinNode.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#removeMin}.
      */
      removeMin():yfiles.algorithms.Node;
      /**
      * Returns a node with smallest associated int key within this
      * queue.
      * the returned node will be removed from the queue by
      * this method.
      * <b>Precondition:</b> <code>!isEmpty()</code>
      * <b>Complexity:</b> Amortized O(1)
      */
      popMinNode():yfiles.algorithms.Node;
      /**
      * Returns a node with highest associated int key within this
      * queue.
      * the returned node will be removed from the queue by
      * this method.
      * <b>Precondition:</b> <code>!isEmpty()</code>
      * <b>Complexity:</b> Amortized O(1)
      */
      popMaxNode():yfiles.algorithms.Node;
      /**
      * Increments the associated priority value for the given node by 1
      * and updates it's position within the queue accordingly.
      * <b>Precondition:</b> <code>contains(v)</code>
      * <b>Complexity:</b> O(1)
      */
      incrementPriority(v:yfiles.algorithms.Node):void;
      /**
      * Decrements the associated priority value for the given node by 1
      * and updates it's position within the queue accordingly.
      * <b>Precondition:</b> <code>contains(v)</code>
      * <b>Complexity:</b> O(1)
      */
      decrementPriority(v:yfiles.algorithms.Node):void;
    }
    var ListIntNodePQ:{
      $class:yfiles.lang.Class;
      /**
      * Constructs an initially empty PQ.
      */
      new (graph:yfiles.algorithms.Graph):yfiles.algorithms.ListIntNodePQ;
      /**
      * Constructs a PQ that holds all nodes of the given graph.
      * the given data provider has to provide for each defined node
      * an int value that is not bigger than <code>minValue</code> and
      * not smaller than <code>maxValue</code>
      * <b>Complexity:</b> <code>O(nc.size()+(maxValue-minValue))</code>
      */
      WithMinValueAndMaxValue:{
        new (graph:yfiles.algorithms.Graph,intData:yfiles.algorithms.IDataProvider,minValue:number,maxValue:number):yfiles.algorithms.ListIntNodePQ;
      };
      /**
      * Like .
      * Additionally a data provider
      * can be specified, that holds boolean values for each node in the
      * graph. Only nodes for which the data provider returns <code>true</code>
      * will be entered in the queue.
      */
      WithWantedNodes:{
        new (graph:yfiles.algorithms.Graph,intData:yfiles.algorithms.IDataProvider,minValue:number,maxValue:number,wantedNodes:yfiles.algorithms.IDataProvider):yfiles.algorithms.ListIntNodePQ;
      };
    };
    /**
    * This class represents a vector in the 2-dimensional real vector space.
    * This vector is an ordered 2 tuple and is defined by two doubles.
    */
    export interface YVector extends Object{
      /**
      * The first coordinate of the vector.
      */
      x:number;
      /**
      * The second coordinate of the vector.
      */
      y:number;
      /**
      * Assigns unit length to the vector.
      * <b>Postcondition:</b> length() == 1.
      */
      norm():void;
      /**
      * Returns a new <code>YVector</code> instance that is obtained by rotating
      * this vector by the given angle (measured in radians) in clockwise
      * direction (with regards to screen coordinates).
      * Screen coordinates mean positive x-direction is from left to right and
      * positive y-direction is from top to bottom.
      * @param {number} angle the angle of rotation in radians.
      * @return {yfiles.algorithms.YVector} the rotated vector.
      */
      rotate(angle:number):yfiles.algorithms.YVector;
      /**
      * Adds a vector to this vector.
      * @param {yfiles.algorithms.YVector} v the vector to add.
      */
      add(v:yfiles.algorithms.YVector):void;
      /**
      * Scales the vector by an factor.
      * @param {number} factor the scale factor, with which the length is multiplied.
      */
      scale(factor:number):void;
      /**
      * Returns the length of the vector, this is the value of the euclidean norm.
      * @return {number} a value > 0.
      */
      length():number;
      /**
      * Returns a string representation of this vector.
      */
      toString():string;
    }
    var YVector:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new vector with given direction.
      * @param {number} dx the first coordinate
      * @param {number} dy the second coordinate
      */
      FromOrigin:{
        new (dx:number,dy:number):yfiles.algorithms.YVector;
      };
      /**
      * Creates a new vector which is a copy of another vector.
      * @param {yfiles.algorithms.YVector} v the vector, whose values are copied.
      */
      FromVector:{
        new (v:yfiles.algorithms.YVector):yfiles.algorithms.YVector;
      };
      /**
      * Creates a new vector, whose direction is given by two points.
      * The vector is defined by <code>p1</code> - <code>p2</code>.
      * @param {yfiles.algorithms.YPoint} p1 the first point.
      * @param {yfiles.algorithms.YPoint} p2 the second point.
      */
      FromPoints:{
        new (p1:yfiles.algorithms.YPoint,p2:yfiles.algorithms.YPoint):yfiles.algorithms.YVector;
      };
      /**
      * Creates a new vector, whose direction is given by a point.
      * The vector is defined by <code>p1</code> - (0,0).
      * @param {yfiles.algorithms.YPoint} p1 the point.
      */
      FromPoint:{
        new (p1:yfiles.algorithms.YPoint):yfiles.algorithms.YVector;
      };
      /**
      * Creates a new vector, whose direction is given by two points.
      * The vector is defined by <code>(x1 - x2, y1 - y2)</code>.
      * @param {number} x1 the X-coordinate of the first point.
      * @param {number} y1 the Y-coordinate of the first point.
      * @param {number} x2 the X-coordinate of the second point.
      * @param {number} y2 the Y-coordinate of the second point.
      */
      new (x1:number,y1:number,x2:number,y2:number):yfiles.algorithms.YVector;
      /**
      * Adds two vectors and returns the result.
      * @param {yfiles.algorithms.YVector} v first vector to sum.
      * @param {yfiles.algorithms.YVector} w second vector to sum.
      * @return {yfiles.algorithms.YVector} v+w
      */
      addVectors(v:yfiles.algorithms.YVector,w:yfiles.algorithms.YVector):yfiles.algorithms.YVector;
      /**
      * Adds the vector to a point and returns the resulting point.
      * @param {yfiles.algorithms.YPoint} p a point.
      * @param {yfiles.algorithms.YVector} v the vector to add to the point.
      * @return {yfiles.algorithms.YPoint} p+v
      */
      addPointToVector(p:yfiles.algorithms.YPoint,v:yfiles.algorithms.YVector):yfiles.algorithms.YPoint;
      /**
      * Returns true if vector v1 is on the right side of v2.
      */
      rightOf(v1:yfiles.algorithms.YVector,v2:yfiles.algorithms.YVector):boolean;
      /**
      * Returns this vector with unit length.
      */
      getNormal(v:yfiles.algorithms.YVector):yfiles.algorithms.YVector;
      /**
      * Returns the vector which is orthogonal to the given one and has unit
      * length.
      * @param {yfiles.algorithms.YVector} v a vector.
      * @return {yfiles.algorithms.YVector} a vector which is orthogonal to v with unit length.
      */
      orthoNormal(v:yfiles.algorithms.YVector):yfiles.algorithms.YVector;
      /**
      * Returns the value of the scalar product of two vectors.
      * @param {yfiles.algorithms.YVector} v1 the first vector.
      * @param {yfiles.algorithms.YVector} v2 the second vector.
      * @return {number} <code>v1.x * v2.x + v1.y * v2.y</code>
      */
      scalarProduct(v1:yfiles.algorithms.YVector,v2:yfiles.algorithms.YVector):number;
      /**
      * Returns the angle (measured in radians) between two vectors in
      * clockwise order (with regards to screen coordinates) from v1 to v2.
      * Screen coordinates mean positive x-direction is from left to right and
      * positive y-direction is from top to bottom:
      */
      angle(v1:yfiles.algorithms.YVector,v2:yfiles.algorithms.YVector):number;
    };
    /**
    * This class defines a rectangle and provides utility methods for it.
    */
    export interface YRectangle extends yfiles.algorithms.YDimension,yfiles.algorithms.IPlaneObject{
      /**
      * Returns the Manhattan distance to the passed rectangle.
      * If they overlap the distance is 0.
      * @param {yfiles.algorithms.YRectangle} other the second rectangle.
      * @return {number} the distance to the given rectangle.
      */
      getManhattanDistance(other:yfiles.algorithms.YRectangle):number;
      /**
      * X-coordinate of upper left corner.
      */
      x:number;
      /**
      * Y-coordinate of upper left corner.
      */
      y:number;
      /**
      * Coordinates of upper left corner.
      */
      location:yfiles.algorithms.YPoint;
      /**
      * This object.
      * @see Specified by {@link yfiles.algorithms.IPlaneObject#boundingBox}.
      */
      boundingBox:yfiles.algorithms.YRectangle;
      /**
      * Checks whether or not this <code>YRectangle</code> contains the
      * given point.
      * @param {number} x the x-coordinate of the point to check.
      * @param {number} y the x-coordinate of the point to check.
      * @return {boolean} 
      * <code>true</code> if the point lies inside the rectangle;
      * <code>false</code> otherwise.
      */
      containsPointDouble(x:number,y:number):boolean;
      /**
      * Checks whether or not this <code>YRectangle</code> contains the
      * given point.
      */
      contains(p:yfiles.algorithms.YPoint):boolean;
      /**
      * Checks whether or not this <code>YRectangle</code> contains the
      * given rectangle.
      */
      containsRectangle(p:yfiles.algorithms.YRectangle):boolean;
      /**
      * Checks whether or not this <code>YRectangle</code> contains the
      * rectangle defined by the given frame.
      */
      containsRectangleDouble(x:number,y:number,width:number,height:number):boolean;
      /**
      * Returns a string representation of this rectangle.
      * @see Overrides {@link yfiles.algorithms.YDimension#toString}
      */
      toString():string;
      /**
      * @see Overrides {@link yfiles.algorithms.YDimension#hashCode}
      */
      hashCode():number;
      /**
      * @see Overrides {@link yfiles.algorithms.YDimension#equals}
      */
      equals(o:Object):boolean;
      /**
      * Compares this object to the given object of the same type.
      * @param {Object} obj The object to compare this to.
      * @return {number} <ul>
      * <li>-1: this is less than <code>obj</code></li>
      * <li>0: this is equal to <code>obj</code></li>
      * <li>1: this is greater than <code>obj</code></li>
      * </ul>
      * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
      */
      compareToObject(o:Object):number;
    }
    var YRectangle:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new rectangle with upper left corner (0,0) and size (0,0).
      */
      new ():yfiles.algorithms.YRectangle;
      /**
      * Creates a new rectangle with given upper left corner and size.
      * @param {yfiles.algorithms.YPoint} pos upper left corner of the rectangle.
      * @param {yfiles.algorithms.YDimension} size size of the rectangle.
      */
      FromPointAndSize:{
        new (pos:yfiles.algorithms.YPoint,size:yfiles.algorithms.YDimension):yfiles.algorithms.YRectangle;
      };
      /**
      * Creates a new rectangle with given upper left corner and size.
      * @param {number} x x-coordinate of upper left corner of the rectangle.
      * @param {number} y y-coordinate of upper left corner of the rectangle.
      * @param {number} width width of the rectangle.
      * @param {number} height height of the rectangle.
      */
      FromDouble:{
        new (x:number,y:number,width:number,height:number):yfiles.algorithms.YRectangle;
      };
      /**
      * Determines whether the specified rectangle contains the specified point.
      * @param {number} rx the x-coordinate of the upper left corner of the rectangle.
      * @param {number} ry the y-coordinate of the upper left corner of the rectangle.
      * @param {number} rw the width of the rectangle.
      * @param {number} rh the height of the rectangle.
      * @param {number} x the x-coordinate of the point to check.
      * @param {number} y the x-coordinate of the point to check.
      * @return {boolean} 
      * <code>true</code> if the point lies inside the rectangle;
      * <code>false</code> otherwise.
      */
      containsRectangleCoordinates(rx:number,ry:number,rw:number,rh:number,x:number,y:number):boolean;
      /**
      * Determines whether the specified rectangle contains the specified point.
      * @param {number} rx the x-coordinate of the upper left corner of the rectangle.
      * @param {number} ry the y-coordinate of the upper left corner of the rectangle.
      * @param {number} rw the width of the rectangle.
      * @param {number} rh the height of the rectangle.
      * @param {number} x the x-coordinate of the point to check.
      * @param {number} y the x-coordinate of the point to check.
      * @param {boolean} closed 
      * if <code>true</code>, all points on the border of the
      * rectangle are considered to be <em>contained</em>.
      * @return {boolean} 
      * <code>true</code> if the point lies inside the rectangle;
      * <code>false</code> otherwise.
      */
      containsRectangleCoordinatesWithBorder(rx:number,ry:number,rw:number,rh:number,x:number,y:number,closed:boolean):boolean;
      /**
      * Returns whether or not the given rectangles intersect.
      */
      intersects(r1:yfiles.algorithms.YRectangle,r2:yfiles.algorithms.YRectangle):boolean;
    };
    /**
    * This class implements a directed graph structure.
    * Basically, a directed graph consists of a set of objects called "nodes" (represented
    * by instances of class {@link yfiles.algorithms.Node}) and a set of node pairs which are called
    * "edges" (represented by instances of class {@link yfiles.algorithms.Edge}).
    * The <i>directed</i> stems from the fact that all edges in the graph have direction,
    * i.e., they have a distinct source node and a distinct target node.
    * Using the aforementioned pair notation, an edge would be written as
    * (<i>&lt;source node&gt;</i>, <i>&lt;target node&gt;</i>).
    * Class Graph presents a proper data type that provides support for all essential
    * operations like element creation, removal, access, and iteration.
    * <b>Important:</b>
    * Class Graph is the single authority for any structural changes to the graph data
    * type.
    * Specifically, this means that there is no way to create or delete a node or an
    * edge without using an actual Graph instance.
    * Furthermore, this class is also responsible for providing access to its elements.
    * This is done by means of bidirectional cursors that present a read-only view
    * on the node set (interface {@link yfiles.algorithms.INodeCursor}) and edge set (interface
    * {@link yfiles.algorithms.IEdgeCursor}).
    * Class Graph fires notification events that signal structural changes, like, e.g.,
    * creation, removal, reinsertion, or modification of graph elements.
    * Classes that implement the {@link yfiles.algorithms.IGraphListener} interface can be registered
    * with this class using the {@link yfiles.algorithms.Graph#addGraphListener  addGraphListener}
    * method in order to receive such events.
    * This class provides direct support for the notion of data accessors.
    * It allows to register so-called data providers (implementations of interface
    * {@link yfiles.algorithms.IDataProvider}) that hold arbitrary data which is associated to its nodes
    * and/or edges.
    * Also, it serves as a factory to create so-called maps ({@link yfiles.algorithms.INodeMap},
    * {@link yfiles.algorithms.IEdgeMap}) that can be utilized to bind arbitrary data to nodes and edges.
    * <a href="@DGUIDE_LAYOUT_PREFIX@/concepts.html">General Concepts in yFiles</a>
    * <a href="@DGUIDE_LAYOUT_PREFIX@/base.html">Working With the Graph Structure</a>
    */
    export interface Graph extends Object,yfiles.algorithms.IGraphInterface{
      /**
      * The copy factory that is associated with this instance.
      * The factory should be used by software that wants to create
      * copies of this graph instance if it is in need of a factory.
      * If no factory has been set, this method will initialize this instance's
      * factory using factory method {@link yfiles.algorithms.Graph#createGraphCopyFactory}.
      * @see {@link yfiles.algorithms.Graph#createGraphCopyFactory}
      * @see {@link yfiles.algorithms.Graph#createGraphCopyFactory}
      */
      graphCopyFactory:yfiles.algorithms.GraphCopier.ICopyFactory;
      /**
      * Factory method that is called by {@link yfiles.algorithms.Graph#graphCopyFactory}
      * to create a (possibly shared) instance.
      * @return {yfiles.algorithms.GraphCopier.ICopyFactory} the (possibly shared) instance.
      */
      createGraphCopyFactory():yfiles.algorithms.GraphCopier.ICopyFactory;
      /**
      * Determines whether there are listeners registered with this instance.
      */
      hasListeners():boolean;
      /**
      * Creates a copy of this graph.
      * Invokes .
      * @return {yfiles.algorithms.Graph} The newly created Graph object.
      */
      createCopy():yfiles.algorithms.Graph;
      /**
      * Creates a new node in this graph and fires a corresponding notification event
      * to inform registered listeners.
      * @return {yfiles.algorithms.Node} The newly created Node object.
      */
      createNode():yfiles.algorithms.Node;
      /**
      * Creates a new edge in this graph and fires a corresponding notification event
      * to inform registered listeners.
      * The new edge has source node <code>v</code> and target node <code>w</code>,
      * i.e., would be written as edge <code>e = (v, w)</code>.
      * The edge is appended to the lists of incoming and outgoing edges at the source
      * node and target node, respectively.
      * @param {yfiles.algorithms.Node} v The source node of the edge.
      * @param {yfiles.algorithms.Node} w The target node of the edge.
      * @return {yfiles.algorithms.Edge} The newly created Edge object.
      */
      createEdgeBetween(v:yfiles.algorithms.Node,w:yfiles.algorithms.Node):yfiles.algorithms.Edge;
      /**
      * Creates a new edge in this graph to be ordered before or after a given edge
      * and fires a corresponding notification event to inform registered listeners.
      * The new edge <code>e</code> has source node <code>v</code> and target node
      * <code>w</code>, i.e., would be written as edge <code>e = (v, w)</code>.
      * Edge <code>e</code> is inserted in such a way that an iteration over the edges
      * at node <code>v</code> returns <code>e</code>
      * <ul>
      * <li>
      * after <code>e1</code>, if <code>d1 == AFTER</code>
      * </li>
      * <li>
      * before <code>e1</code>, if <code>d1 == BEFORE</code>,
      * </li>
      * </ul>
      * and an iteration over the edges at <code>w</code> returns <code>e</code>
      * <ul>
      * <li>
      * after <code>e2</code>, if <code>d2 == AFTER</code>
      * </li>
      * <li>
      * before <code>e2</code>, if <code>d2 == BEFORE</code>.
      * </li>
      * </ul>
      * <b>Precondition:</b> 
      * Edge <code>e1</code> must have source node <code>v</code>
      * and
      * edge <code>e2</code> must have target node <code>w</code>.
      * @param {yfiles.algorithms.Node} v The source node of the edge.
      * @param {yfiles.algorithms.Edge} e1 An edge with source node <code>v</code>.
      * @param {yfiles.algorithms.Node} w The target node of the edge.
      * @param {yfiles.algorithms.Edge} e2 An edge with target node <code>w</code>.
      * @param {yfiles.algorithms.GraphElementInsertion} d1 
      * One of the object insertion specifiers {@link yfiles.algorithms.GraphElementInsertion#BEFORE} or {@link yfiles.algorithms.GraphElementInsertion#AFTER}.
      * @param {yfiles.algorithms.GraphElementInsertion} d2 
      * One of the object insertion specifiers {@link yfiles.algorithms.GraphElementInsertion#BEFORE} or {@link yfiles.algorithms.GraphElementInsertion#AFTER}.
      * @return {yfiles.algorithms.Edge} The newly created Edge object.
      */
      createEdgeWithGraphElementInsertion(v:yfiles.algorithms.Node,e1:yfiles.algorithms.Edge,w:yfiles.algorithms.Node,e2:yfiles.algorithms.Edge,d1:yfiles.algorithms.GraphElementInsertion,d2:yfiles.algorithms.GraphElementInsertion):yfiles.algorithms.Edge;
      /**
      * Removes the given node from this graph.
      * All edges connecting to the given node are removed as well (preceding the actual
      * node removal).
      * Corresponding notification events are fired to inform registered listeners.
      * The node will be deselected before it gets removed.
      * @param {yfiles.algorithms.Node} v The node to be removed from this graph.
      */
      removeNode(v:yfiles.algorithms.Node):void;
      /**
      * Removes the given edge from this graph and fires a corresponding notification
      * event to inform registered listeners.
      * The edge will be deselected before it gets removed.
      * @param {yfiles.algorithms.Edge} e The edge to be removed.
      */
      removeEdge(e:yfiles.algorithms.Edge):void;
      /**
      * Reinserts a formerly removed node into this graph and fires a corresponding
      * notification event to inform registered listeners.
      * The reinserted node is appended to the sequence of nodes in this graph, i.e.,
      * normally, its new position does not match the position before its removal.
      * @param {yfiles.algorithms.Node} v The node to be reinserted.
      * @see {@link yfiles.algorithms.Graph#removeNode}
      */
      reInsertNode(v:yfiles.algorithms.Node):void;
      /**
      * Reinserts a formerly removed edge into this graph and fires a corresponding
      * notification event to inform registered listeners.
      * The reinserted edge is appended to the sequence of edges in this graph, i.e.,
      * normally, its new position does not match the position before its removal.
      * The same holds for the edge's positions in the list of incoming and outgoing
      * edges at its source node and target node, respectively.
      * <p>
      * Note that reinserting an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed)
      * causes an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.
      * </p>
      * @param {yfiles.algorithms.Edge} e The edge to be reinserted.
      * @see {@link yfiles.algorithms.Graph#removeEdge}
      */
      reInsertEdge(e:yfiles.algorithms.Edge):void;
      /**
      * Redefines an edge's end points and fires corresponding notification events
      * to inform registered listeners.
      * Edge <code>e</code> has
      * source node <code>v := e1.source()</code>
      * and
      * target node <code>w := e2.target()</code>.
      * Edge <code>e</code> is inserted in such a way that an iteration over the edges
      * at <code>v</code> returns <code>e</code>
      * <ul>
      * <li>
      * after <code>e1</code>, if <code>d1 == AFTER</code>
      * </li>
      * <li>
      * before <code>e1</code>, if <code>d1 == BEFORE</code>,
      * </li>
      * </ul>
      * and an iteration over the edges at <code>w</code> returns <code>e</code>
      * <ul>
      * <li>
      * after <code>e2</code>, if <code>d2 == AFTER</code>
      * </li>
      * <li>
      * before <code>e2</code>, if <code>d2 == BEFORE</code>.
      * </li>
      * </ul>
      * <b>Precondition:</b> 
      * Edges <code>e</code>, <code>e1</code>, and <code>e2</code> must belong to this
      * graph.
      * @param {yfiles.algorithms.Edge} e The edge to be changed.
      * @param {yfiles.algorithms.Edge} e1 Reference edge for insertion at a new source node.
      * @param {yfiles.algorithms.Edge} e2 Reference edge for insertion at a new target node.
      * @param {yfiles.algorithms.GraphElementInsertion} d1 
      * One of the object insertion specifiers {@link yfiles.algorithms.GraphElementInsertion#BEFORE} or {@link yfiles.algorithms.GraphElementInsertion#AFTER}.
      * @param {yfiles.algorithms.GraphElementInsertion} d2 
      * One of the object insertion specifiers {@link yfiles.algorithms.GraphElementInsertion#BEFORE} or {@link yfiles.algorithms.GraphElementInsertion#AFTER}.
      */
      changeEdgeWithReferences(e:yfiles.algorithms.Edge,e1:yfiles.algorithms.Edge,e2:yfiles.algorithms.Edge,d1:yfiles.algorithms.GraphElementInsertion,d2:yfiles.algorithms.GraphElementInsertion):void;
      /**
      * Redefines an edge's end points and fires corresponding notification events
      * to inform registered listeners.
      * Edge <code>e</code> has
      * source node <code>v := sourceReference.source()</code> or <code>v := newSource</code>,
      * if <code>sourceReference == null</code>
      * and
      * target node <code>w := targetReference.target()</code> or <code>w := newTarget</code>,
      * if <code>targetReference == null</code>.
      * Edge <code>e</code> is inserted in such a way that an iteration over the edges
      * at <code>v</code> returns <code>e</code>
      * <ul>
      * <li>
      * after <code>sourceReference</code>, if <code>sourceD == AFTER</code>
      * </li>
      * <li>
      * before <code>sourceReference</code>, if <code>sourceD == BEFORE</code>,
      * </li>
      * </ul>
      * and an iteration over the edges at <code>w</code> returns <code>e</code>
      * <ul>
      * <li>
      * after <code>targetReference</code>, if <code>targetD == AFTER</code>
      * </li>
      * <li>
      * before <code>targetReference</code>, if <code>targetD == BEFORE</code>.
      * </li>
      * </ul>
      * <b>Precondition:</b> 
      * Edge <code>e</code> must belong to this graph.
      * Also, either <code>sourceReference</code> or <code>newSource</code> must be
      * non-null and belong to this graph, and either <code>targetReference</code>
      * or <code>newTarget</code> must be non-null and belong to this graph.
      * @param {yfiles.algorithms.Edge} e The edge to be changed.
      * @param {yfiles.algorithms.Node} newSource The new source node.
      * @param {yfiles.algorithms.Edge} sourceReference Reference edge for insertion at the new source node.
      * @param {yfiles.algorithms.GraphElementInsertion} sourceD 
      * One of the object insertion specifiers {@link yfiles.algorithms.GraphElementInsertion#BEFORE} or {@link yfiles.algorithms.GraphElementInsertion#AFTER}.
      * @param {yfiles.algorithms.Node} newTarget The new target node.
      * @param {yfiles.algorithms.Edge} targetReference Reference edge for insertion at the new target node.
      * @param {yfiles.algorithms.GraphElementInsertion} targetD 
      * One of the object insertion specifiers {@link yfiles.algorithms.GraphElementInsertion#BEFORE} or {@link yfiles.algorithms.GraphElementInsertion#AFTER}.
      */
      changeEdgeWithReference(e:yfiles.algorithms.Edge,newSource:yfiles.algorithms.Node,sourceReference:yfiles.algorithms.Edge,sourceD:yfiles.algorithms.GraphElementInsertion,newTarget:yfiles.algorithms.Node,targetReference:yfiles.algorithms.Edge,targetD:yfiles.algorithms.GraphElementInsertion):void;
      /**
      * Redefines an edge's end points and fires corresponding notification events
      * to inform registered listeners.
      * The edge is appended to the lists of incoming and outgoing edges at the given
      * source node and target node, respectively.
      * <b>Precondition:</b> <code>newSource</code> and <code>newTarget</code> must belong to this graph.
      * @param {yfiles.algorithms.Edge} e The edge to be changed.
      * @param {yfiles.algorithms.Node} newSource The new source node of the given edge.
      * @param {yfiles.algorithms.Node} newTarget The new target node of the given edge.
      */
      changeEdge(e:yfiles.algorithms.Edge,newSource:yfiles.algorithms.Node,newTarget:yfiles.algorithms.Node):void;
      /**
      * Reverses the given edge and fires corresponding notification events to inform
      * registered listeners.
      * This operation exchanges source and target node of the edge.
      */
      reverseEdge(e:yfiles.algorithms.Edge):void;
      /**
      * Hides the given edge from this graph.
      * Hiding an edge means to (temporarily) remove the edge from the graph.
      * The only difference to a proper edge removal as performed by {@link yfiles.algorithms.Graph#removeEdge}
      * is that no {@link yfiles.algorithms.GraphEvent} will be emitted that signals the structural change
      * (i.e. the edge's removal).
      * Generally, hiding should <i>only</i> be used in the sense of temporarily removing
      * an object that will be reinserted shortly after.
      * To reinsert a hidden edge use {@link yfiles.algorithms.Graph#unhideEdge}.
      * @see {@link yfiles.algorithms.Graph#hideNode}
      * @see {@link yfiles.algorithms.Graph#unhideNode}
      */
      hideEdge(e:yfiles.algorithms.Edge):void;
      /**
      * Unhides the given edge in this graph.
      * Unhiding an edge means to reinsert an edge that was formerly hidden from this
      * graph by a call to {@link yfiles.algorithms.Graph#hideEdge}.
      * The only difference to a proper edge reinsertion as performed by {@link yfiles.algorithms.Graph#reInsertEdge}
      * is that no {@link yfiles.algorithms.GraphEvent} will be emitted that signals the structural change
      * (i.e. the edge's reinsertion).
      * <p>
      * Note that unhiding an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed)
      * causes an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.
      * </p>
      * @see {@link yfiles.algorithms.Graph#hideNode}
      * @see {@link yfiles.algorithms.Graph#unhideNode}
      */
      unhideEdge(e:yfiles.algorithms.Edge):void;
      /**
      * Hides the given node from this graph.
      * Hiding a node means to (temporarily) remove the node from the graph.
      * The only difference to a proper node removal as performed by {@link yfiles.algorithms.Graph#removeNode}
      * is that no {@link yfiles.algorithms.GraphEvent} will be emitted that signals the structural change
      * (i.e. the node's removal).
      * Generally, hiding should <i>only</i> be used in the sense of temporarily removing
      * an object that will be reinserted shortly after.
      * To reinsert a hidden node use {@link yfiles.algorithms.Graph#unhideNode}.
      * @see {@link yfiles.algorithms.Graph#hideEdge}
      * @see {@link yfiles.algorithms.Graph#unhideEdge}
      */
      hideNode(v:yfiles.algorithms.Node):void;
      /**
      * Unhides the given node in this graph.
      * Unhiding a node means to reinsert a node that was formerly hidden from this
      * graph by a call to {@link yfiles.algorithms.Graph#hideNode}.
      * The only difference to a proper node reinsertion as performed by {@link yfiles.algorithms.Graph#reInsertNode}
      * is that no {@link yfiles.algorithms.GraphEvent} will be emitted that signals the structural change
      * (i.e. the node's reinsertion).
      */
      unhideNode(v:yfiles.algorithms.Node):void;
      /**
      * Moves the given node to the last position within the sequence of nodes in this
      * graph.
      */
      moveToLastNode(v:yfiles.algorithms.Node):void;
      /**
      * Moves the given node to the first position within the sequence of nodes in
      * this graph.
      */
      moveToFirstNode(v:yfiles.algorithms.Node):void;
      /**
      * Moves the given edge to the last position within the sequence of edges in this
      * graph.
      */
      moveToLastEdge(e:yfiles.algorithms.Edge):void;
      /**
      * Moves the given edge to the first position within the sequence of edges in
      * this graph.
      */
      moveToFirstEdge(e:yfiles.algorithms.Edge):void;
      /**
      * The number of nodes in this graph.
      * Same as {@link yfiles.algorithms.Graph#nodeCount}.
      */
      n:number;
      /**
      * The number of nodes in this graph.
      */
      nodeCount:number;
      /**
      * The number of edges in this graph.
      * Same as {@link yfiles.algorithms.Graph#edgeCount}.
      */
      e:number;
      /**
      * The number of edges in this graph.
      */
      edgeCount:number;
      /**
      * <code>true</code> if this graph contains no nodes.
      */
      empty:boolean;
      /**
      * Removes all nodes and edges from this graph and fires corresponding notification
      * events to inform registered listeners.
      */
      clear():void;
      /**
      * Whether or not this graph contains the given node.
      */
      containsNode(v:yfiles.algorithms.Node):boolean;
      /**
      * Whether or not this graph contains the given edge.
      */
      containsEdge(e:yfiles.algorithms.Edge):boolean;
      /**
      * Returns whether or not this graph contains an edge that connects the given
      * nodes.
      * @param {yfiles.algorithms.Node} source The source node.
      * @param {yfiles.algorithms.Node} target The target node.
      * @see {@link yfiles.algorithms.Node#getEdgeTo}
      * @see {@link yfiles.algorithms.Node#getEdgeFrom}
      * @see {@link yfiles.algorithms.Node#getEdge}
      */
      containsEdgeBetweenNodes(source:yfiles.algorithms.Node,target:yfiles.algorithms.Node):boolean;
      /**
      * The first node in this graph.
      * <b>Precondition:</b> <code>!isEmpty()</code>
      */
      firstNode:yfiles.algorithms.Node;
      /**
      * The first edge in this graph.
      * <b>Precondition:</b> <code>edgeCount() > 0</code>
      */
      firstEdge:yfiles.algorithms.Edge;
      /**
      * The last node in this graph.
      * <b>Precondition:</b> <code>!isEmpty()</code>
      */
      lastNode:yfiles.algorithms.Node;
      /**
      * The last edge in this graph.
      * <b>Precondition:</b> <code>edgeCount() > 0</code>
      */
      lastEdge:yfiles.algorithms.Edge;
      /**
      * Returns an array containing all nodes of this graph.
      */
      getNodeArray():yfiles.algorithms.Node[];
      /**
      * Returns an array containing all edges of this graph.
      */
      getEdgeArray():yfiles.algorithms.Edge[];
      /**
      * Provides access to the nodes of the graph.
      * @return {yfiles.algorithms.INodeCursor} A NodeCursor to iterate over the nodes in the graph.
      */
      getNodeCursor():yfiles.algorithms.INodeCursor;
      /**
      * Provides access to the edges of the graph.
      * @return {yfiles.algorithms.IEdgeCursor} An EdgeCursor to iterate over the edges in the graph.
      */
      getEdgeCursor():yfiles.algorithms.IEdgeCursor;
      /**
      * Moves an induced subgraph to another graph.
      * <b>Precondition:</b> The nodes in <code>subNodes</code> must belong to this graph.
      * @param {yfiles.algorithms.NodeList} subNodes A list of nodes that induce the subgraph to be moved.
      * @param {yfiles.algorithms.Graph} targetGraph The graph where the subgraph is moved to.
      * @return {yfiles.algorithms.EdgeList} A list of removed edges that connected the induced subgraph to this graph.
      */
      moveSubGraph(subNodes:yfiles.algorithms.NodeList,targetGraph:yfiles.algorithms.Graph):yfiles.algorithms.EdgeList;
      /**
      * Creates an empty base object of the same type as this graph.
      * Subclasses should override this method.
      */
      createGraph():yfiles.algorithms.Graph;
      /**
      * Sorts the internally held list of edges.
      * If the given comparator is <code>null</code>, then the edges will not be sorted.
      * This list determines the order of the edges as returned by {@link yfiles.algorithms.Graph#getEdgeCursor}.
      * @param {yfiles.objectcollections.IComparer} comp The comparator used for the edges.
      */
      sortEdges(comp:yfiles.objectcollections.IComparer):void;
      /**
      * Sorts the internally held list of nodes.
      * If the given comparator is <code>null</code>, then the nodes will not be sorted.
      * This list determines the order of the nodes as returned by {@link yfiles.algorithms.Graph#getNodeCursor}.
      * @param {yfiles.objectcollections.IComparer} comp The comparator used for the nodes.
      */
      sortNodes(comp:yfiles.objectcollections.IComparer):void;
      /**
      * Sorts incoming and outgoing edges at each node of the graph.
      * If a given comparator is <code>null</code>, then the corresponding edges (i.e.,
      * incoming/outgoing) will not be sorted.
      * This sorts the order of the edges as returned by {@link yfiles.algorithms.Node#getOutEdgeCursor}
      * and {@link yfiles.algorithms.Node#getInEdgeCursor} respectively.
      * @param {yfiles.objectcollections.IComparer} inComp The comparator used for the incoming edges at each node.
      * @param {yfiles.objectcollections.IComparer} outComp The comparator used for the outgoing edges at each node.
      */
      sortEdgesInAndOut(inComp:yfiles.objectcollections.IComparer,outComp:yfiles.objectcollections.IComparer):void;
      /**
      * Registers the given graph listener with this graph.
      * The listener will receive graph events that signal structural changes occurring
      * within this graph.
      * @see {@link yfiles.algorithms.GraphEvent}
      */
      addGraphListener(listener:yfiles.algorithms.IGraphListener):void;
      /**
      * Removes the given graph listener from this graph.
      */
      removeGraphListener(listener:yfiles.algorithms.IGraphListener):void;
      /**
      * An iterator that grants access to all registered graph listeners.
      */
      graphListeners:yfiles.algorithms.IIterator;
      /**
      * Propagates a so-called PRE event to all registered graph listeners.
      * This method should only be used if a corresponding call to {@link yfiles.algorithms.Graph#firePostEvent}
      * follows.
      * Generally, PRE and POST events serve as a means to bracket a sequence of graph
      * events.
      * @see {@link yfiles.algorithms.IGraphListener}
      */
      firePreEvent():void;
      /**
      * Like {@link yfiles.algorithms.Graph#firePreEvent}.
      * Additionally, an event ID may be specified.
      * @param {Object} id An identifying tag for the event.
      * @see {@link yfiles.algorithms.IGraphListener}
      */
      firePreEventWithId(id:Object):void;
      /**
      * Propagates a so-called POST event to all registered graph listeners.
      * This method should only be used if a corresponding call to {@link yfiles.algorithms.Graph#firePreEvent}
      * was made.
      * Generally, PRE and POST events serve as a means to bracket a sequence of graph
      * events.
      * @see {@link yfiles.algorithms.IGraphListener}
      */
      firePostEvent():void;
      /**
      * Like {@link yfiles.algorithms.Graph#firePostEvent}.
      * Additionally, an event ID may be specified.
      * @param {Object} id An identifying tag for the event.
      * @see {@link yfiles.algorithms.IGraphListener}
      */
      firePostEventWithId(id:Object):void;
      /**
      * Propagates the given graph event to all registered graph listeners.
      */
      fireGraphEvent(e:yfiles.algorithms.GraphEvent):void;
      /**
      * Returns a newly created node map that is valid for the nodes in this graph.
      * The implementation returned by this method can be used for any node that is
      * part of this Graph instance at any point of time, i.e., it is safe to modify
      * the graph structure (add and remove nodes and edges) freely.
      * The implementation returned uses <code>O(n)</code> memory at all times and
      * provides true <code>O(1)</code> read and write access for each node.
      * In order to release the resources held by this map, {@link yfiles.algorithms.Graph#disposeNodeMap}
      * has to be called.
      */
      createNodeMap():yfiles.algorithms.INodeMap;
      /**
      * Returns a newly created edge map that is valid for the edges in this graph.
      * The implementation returned by this method can be used for any edge that is
      * part of this Graph instance at any point of time, i.e., it is safe to modify
      * the graph structure (add and remove nodes and edges) freely.
      * The implementation returned uses <code>O(m)</code> memory at all times and
      * provides true <code>O(1)</code> read and write access for each edge.
      * In order to release the resources held by this map, {@link yfiles.algorithms.Graph#disposeEdgeMap}
      * has to be called.
      */
      createEdgeMap():yfiles.algorithms.IEdgeMap;
      /**
      * Informs the graph that the given node map is no longer needed.
      * This method is used for NodeMap implementations that have been obtained using
      * the {@link yfiles.algorithms.Graph#createNodeMap} factory method.
      * Calling this method will destroy the node map and associated resources can
      * be freed.
      * It is strongly recommended to dispose of all node maps that are not needed
      * anymore using this method.
      */
      disposeNodeMap(map:yfiles.algorithms.INodeMap):void;
      /**
      * Informs the graph that the given edge map is no longer needed.
      * This method is used for EdgeMap implementations that have been obtained using
      * the {@link yfiles.algorithms.Graph#createEdgeMap} factory method.
      * Calling this method will destroy the edge map and associated resources can
      * be freed.
      * It is strongly recommended to dispose of all edge maps that are not needed
      * anymore using this method.
      */
      disposeEdgeMap(map:yfiles.algorithms.IEdgeMap):void;
      /**
      * All node maps that have been created by this graph but have not yet
      * been disposed.
      * @see {@link yfiles.algorithms.Graph#createNodeMap}
      * @see {@link yfiles.algorithms.Graph#disposeNodeMap}
      */
      registeredNodeMaps:yfiles.algorithms.INodeMap[];
      /**
      * All edge maps that have been created by this graph but have not yet
      * been disposed.
      * @see {@link yfiles.algorithms.Graph#createEdgeMap}
      * @see {@link yfiles.algorithms.Graph#disposeEdgeMap}
      */
      registeredEdgeMaps:yfiles.algorithms.IEdgeMap[];
      /**
      * Returns the source node associated with the given edge.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#getSource}.
      */
      getSource(edge:Object):Object;
      /**
      * Returns the target node associated with the given edge.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#getTarget}.
      */
      getTarget(edge:Object):Object;
      /**
      * Returns an iterator that provides access to all nodes residing in this graph.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#nodeObjects}.
      */
      nodeObjects():yfiles.algorithms.IIterator;
      /**
      * Returns an iterator that provides access to all edges residing in this graph.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#edgeObjects}.
      */
      edgeObjects():yfiles.algorithms.IIterator;
      /**
      * Returns the data provider that is registered with the graph using the given
      * look-up key.
      * The look-up domain of a returned data provider normally consists of either
      * the nodes of the graph, or its edges, or both.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#getDataProvider}.
      */
      getDataProvider(providerKey:Object):yfiles.algorithms.IDataProvider;
      /**
      * Registers the given data provider using the given look-up key.
      * If there is already a data provider registered with that key, then it will
      * be overwritten with the new one.
      */
      addDataProvider(providerKey:Object,data:yfiles.algorithms.IDataProvider):void;
      /**
      * Removes the data provider that is registered using the given look-up key.
      */
      removeDataProvider(providerKey:Object):void;
      /**
      * An array of all data provider look-up keys that are registered with
      * this graph.
      * @see Specified by {@link yfiles.algorithms.IGraphInterface#dataProviderKeys}.
      */
      dataProviderKeys:Object[];
      /**
      * For internal debugging purposes only.
      */
      printNodeSlotSize():void;
      /**
      * Returns a String representation of this graph.
      * The result contains the String representations of all nodes followed by the
      * String representations of all edges.
      */
      toString():string;
      /**
      * Yields a dynamic {@link yfiles.collections.IEnumerable}
      * for {@link yfiles.algorithms.Node}s that can be used to iterate over the nodes that are contained in this instance.
      * This is a live enumerable and will thus reflect the current state of the graph.
      * Note that changes to the graph structure during the traversal should be carried out with great care.
      */
      nodes:yfiles.collections.IEnumerable<yfiles.algorithms.Node>;
      /**
      * Yields a dynamic {@link yfiles.collections.IEnumerable}
      * for {@link yfiles.algorithms.Edge}s that can be used to iterate over the edges that are contained in this instance.
      * This is a live enumerable and will thus reflect the current state of the graph.
      * Note that changes to the graph structure during the traversal should be carried out with great care.
      */
      edges:yfiles.collections.IEnumerable<yfiles.algorithms.Edge>;
    }
    var Graph:{
      $class:yfiles.lang.Class;
      /**
      * Instantiates an empty Graph object.
      */
      new ():yfiles.algorithms.Graph;
      /**
      * Instantiates a new Graph object as a copy of the given graph.
      * Values bound to the argument graph via node and edge keys are available in
      * the new Graph instance with the keys registered with <code>argGraph</code>.
      * Only references to these values are copied.
      * The new Graph instance also inherits all graph listeners registered with the
      * given graph.
      * This constructor does not use a {@link yfiles.algorithms.GraphCopier}.
      * @param {yfiles.algorithms.Graph} argGraph The graph to be copied.
      */
      FromOther:{
        new (argGraph:yfiles.algorithms.Graph):yfiles.algorithms.Graph;
      };
      /**
      * Instantiates a new Graph object as a partial copy of the given graph.
      * Only the subgraph induced by the given cursor will be copied to the new Graph
      * instance.
      * Values bound to the argument graph via node and edge keys are available in
      * the new Graph instance with the keys registered with <code>graph</code>.
      * Only references to these values are copied.
      * The new Graph instance also inherits all graph listeners registered with the
      * given graph.
      * This constructor does not use a {@link yfiles.algorithms.GraphCopier}.
      * @param {yfiles.algorithms.Graph} graph The graph to be (partially) copied.
      * @param {yfiles.algorithms.ICursor} subNodes 
      * A cursor to iterate over the nodes that actually induce the subgraph to be
      * copied.
      */
      FromSubset:{
        new (graph:yfiles.algorithms.Graph,subNodes:yfiles.algorithms.ICursor):yfiles.algorithms.Graph;
      };
      /**
      * Low-level iteration support for adjacent edges.
      */
      firstOutEdge(v:yfiles.algorithms.Node):yfiles.algorithms.Edge;
    };
    /**
    * An oriented rectangle in 2D coordinate space with double precision
    * coordinates.
    * The rectangle's <code>height</code> extends from its
    * {@link yfiles.algorithms.YOrientedRectangle#anchor  anchor point} in the direction of its <code>up
    * vector</code> ({@link yfiles.algorithms.YOrientedRectangle#upX  ux}, {@link yfiles.algorithms.YOrientedRectangle#upY  uy}).
    * Its <code>width</code> extends from its
    * {@link yfiles.algorithms.YOrientedRectangle#anchor  anchor point} in direction
    * <code>(-uy, ux)</code> (i.e. perpendicular to the <em>up vector</em>).
    * This means that an oriented rectangle with anchor point <code>(0, 0)</code>
    * width <code>100</code>, height <code>10</code>, and up vector
    * <code>(0, -1)</code> is a paraxial rectangle with upper left corner
    * <code>(0, -10)</code> and lower right corner <code>(100, 0)</code>.
    */
    export interface YOrientedRectangle extends Object,yfiles.algorithms.IPlaneObject{
      /**
      * Specifies whether this instance has negative width or height.
      */
      empty:boolean;
      /**
      * The anchor of this oriented rectangle.
      */
      anchor:yfiles.algorithms.YPoint;
      /**
      * Sets the anchor of this rectangle.
      * @param {number} x the new x-coordinate of the anchor point.
      * @param {number} y the new y-coordinate of the anchor point.
      */
      setAnchor(x:number,y:number):void;
      /**
      * The x-coordinate of this rectangle's anchor point.
      */
      anchorX:number;
      /**
      * The y-coordinate of this rectangle's anchor point.
      */
      anchorY:number;
      /**
      * The size of this rectangle.
      */
      size:yfiles.algorithms.YDimension;
      /**
      * Sets the size of this rectangle.
      * @param {number} width the new width.
      * @param {number} height the new height.
      */
      setSize(width:number,height:number):void;
      /**
      * The width of this rectangle.
      */
      width:number;
      /**
      * The height of this rectangle.
      */
      height:number;
      /**
      * Sets the components of the up vector to the new values.
      * @param {number} upX The x component of the normalized up vector.
      * @param {number} upY The y component of the normalized up vector.
      */
      setUpVector(upX:number,upY:number):void;
      /**
      * The x-component of this rectangle's up vector.
      */
      upX:number;
      /**
      * The y-component of this rectangle's up vector.
      */
      upY:number;
      /**
      * The angle (measured in radians) of this rectangle.
      * The angle of an oriented rectangle is the angle between the vector
      * <code>(0, -1)</code> and the rectangle's up vector in counter clockwise
      * order.
      * An angle of 0 means the up vector points up in direction <code>(0, -1)</code>.
      */
      angle:number;
      /**
      * Moves this rectangle by applying the offset to the anchor.
      * @param {number} dx The x offset to move the rectangle's position by.
      * @param {number} dy The y offset to move the rectangle's position by.
      */
      moveBy(dx:number,dy:number):void;
      /**
      * The current center of the oriented rectangle.
      */
      center:yfiles.algorithms.YPoint;
      /**
      * Sets the anchor of the OrientedRectangle so that the center of the
      * rectangle coincides with the given coordinate pair.
      * @param {number} cx The x coordinate of the center.
      * @param {number} cy The y coordinate of the center.
      */
      setCenter(cx:number,cy:number):void;
      /**
      * Calculates the paraxial bounding box of this oriented rectangle.
      * @see Specified by {@link yfiles.algorithms.IPlaneObject#boundingBox}.
      */
      boundingBox:yfiles.algorithms.YRectangle;
      /**
      * Determines whether or not the specified point lies inside this oriented
      * rectangle.
      * @param {number} x the x-coordinate of the point to check.
      * @param {number} y the y-coordinate of the point to check.
      * @return {boolean} 
      * <code>true</code> iff the specified point lies inside;
      * <code>false</code> otherwise.
      */
      containsPoint(x:number,y:number):boolean;
      /**
      * Determines whether or not the specified point lies inside this oriented
      * rectangle.
      * @param {number} x the x-coordinate of the point to check.
      * @param {number} y the y-coordinate of the point to check.
      * @param {boolean} closed 
      * if <code>true</code>, all points on the border of the
      * rectangle are considered to be <em>contained</em>.
      * @return {boolean} 
      * <code>true</code> iff the specified point lies inside;
      * <code>false</code> otherwise.
      */
      containsPointWithBorder(x:number,y:number,closed:boolean):boolean;
      toString():string;
      equals(o:Object):boolean;
      hashCode():number;
      /**
      * Creates a new <code>OrientedRectangle</code> instance whose anchor point
      * is moved by the specified distance values, but has the same width, height,
      * and up vector as this rectangle.
      * @param {number} dx 
      * the distance to move the anchor point in x-direction. A positive
      * value means "move" to the right, a negative value means "move" to the left.
      * @param {number} dy 
      * the distance to move the anchor point in y-direction. A positive
      * value means "move" downwards, a negative value means "move" upwards.
      * @return {yfiles.algorithms.YOrientedRectangle} 
      * a new <code>OrientedRectangle</code> instance whose anchor point
      * is moved by the specified distance values.
      */
      getMovedInstance(dx:number,dy:number):yfiles.algorithms.YOrientedRectangle;
      /**
      * Creates a new <code>OrientedRectangle</code> instance that has the
      * specified width and height, but has the same anchor point and up vector
      * as this rectangle.
      * @param {number} width the width of the new rectangle.
      * @param {number} height the height of the new rectangle.
      * @return {yfiles.algorithms.YOrientedRectangle} 
      * a new <code>OrientedRectangle</code> instance that has the
      * specified width and height.
      */
      getResizedInstance(width:number,height:number):yfiles.algorithms.YOrientedRectangle;
      /**
      * Copies the actual values from the given <code>OrientedRectangle</code> to this instance.
      * @param {yfiles.algorithms.YOrientedRectangle} other the <code>OrientedRectangle</code> to retrieve the values from
      */
      adoptValues(other:yfiles.algorithms.YOrientedRectangle):void;
    }
    var YOrientedRectangle:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance using the provided rectangle's values to initialize
      * anchor and size.
      * The oriented rectangle's up vector will be
      * <code>(0, -1)</code>.
      * @param {yfiles.algorithms.YRectangle} rect the provided rectangle.
      */
      FromRect:{
        new (rect:yfiles.algorithms.YRectangle):yfiles.algorithms.YOrientedRectangle;
      };
      /**
      * Creates a new instance using the provided rectangle's values to initialize
      * anchor, size, and up vector.
      * @param {yfiles.algorithms.YOrientedRectangle} rect the provided rectangle.
      */
      YOrientedRectangle:{
        new (rect:yfiles.algorithms.YOrientedRectangle):yfiles.algorithms.YOrientedRectangle;
      };
      /**
      * Creates a new instance using the provided values to initialize the anchor and size.
      * The oriented rectangle's up vector will be <code>(0, -1)</code>.
      * @param {yfiles.algorithms.YPoint} anchor The provider for the dynamic anchor of this instance.
      * @param {yfiles.algorithms.YDimension} size The provider for the dynamic size of this instance.
      */
      FromAnchorAndSize:{
        new (anchor:yfiles.algorithms.YPoint,size:yfiles.algorithms.YDimension):yfiles.algorithms.YOrientedRectangle;
      };
      /**
      * Creates a new instance using the provided values to initialize anchor,
      * size, and up vector.
      * @param {yfiles.algorithms.YPoint} position The provider for the dynamic anchor of this instance.
      * @param {yfiles.algorithms.YDimension} size The provider for the dynamic size of this instance.
      * @param {yfiles.algorithms.YVector} upVector The up vector.
      */
      FromPositionSizeAndUpVector:{
        new (position:yfiles.algorithms.YPoint,size:yfiles.algorithms.YDimension,upVector:yfiles.algorithms.YVector):yfiles.algorithms.YOrientedRectangle;
      };
      /**
      * Creates a new instance using the provided values to initialize anchor and
      * size.
      * The oriented rectangle's up vector will be
      * <code>(0, -1)</code>.
      * @param {number} anchorX The x coordinate of the anchor of the oriented rectangle.
      * @param {number} anchorY The y coordinate of the anchor of the oriented rectangle.
      * @param {number} width The width of the rectangle.
      * @param {number} height The height of the rectangle.
      */
      FromAnchorXAnchorYWidthAndHeight:{
        new (anchorX:number,anchorY:number,width:number,height:number):yfiles.algorithms.YOrientedRectangle;
      };
      /**
      * Creates a new instance using the provided values to initialize anchor,
      * size, and up vector.
      * @param {number} anchorX The x coordinate of the anchor of the oriented rectangle.
      * @param {number} anchorY The y coordinate of the anchor of the oriented rectangle.
      * @param {number} width The width of the rectangle.
      * @param {number} height The height of the rectangle.
      * @param {number} upX The x component of the up vector.
      * @param {number} upY The y component of the up vector.
      */
      FromAnchorXAnchorYWidthHeightUpXAndUpY:{
        new (anchorX:number,anchorY:number,width:number,height:number,upX:number,upY:number):yfiles.algorithms.YOrientedRectangle;
      };
      /**
      * Determines the four corner points of an oriented rectangle.
      * @param {yfiles.algorithms.YOrientedRectangle} rect The rectangle to determine the bounds.
      * @return {yfiles.algorithms.YPoint[]} the array of corner points.
      */
      calcPoints(rect:yfiles.algorithms.YOrientedRectangle):yfiles.algorithms.YPoint[];
      /**
      * Determines whether a rectangle intersects an oriented rectangle, given an epsilon.
      * @param {yfiles.algorithms.YOrientedRectangle} orientedRectangle The oriented rectangle to test.
      * @param {yfiles.algorithms.YRectangle} rectangle The rectangle to test.
      * @param {number} eps 
      * A positive value allows for fuzzy hit testing. If the point lies outside the given object
      * but it's distance is less than or equal to that value, it will be considered a hit.
      * @return {boolean} Whether they have a non-empty intersection.
      */
      intersectsRectangle(orientedRectangle:yfiles.algorithms.YOrientedRectangle,rectangle:yfiles.algorithms.YRectangle,eps:number):boolean;
      /**
      * Determines whether the given oriented rectangle contains the provided
      * point, using an epsilon value.
      * @param {yfiles.algorithms.YOrientedRectangle} rect The rectangle.
      * @param {yfiles.algorithms.YPoint} p The point to test.
      * @param {number} eps 
      * fuzziness range. A positive value allows for fuzzy hit testing.
      * If a point lies outside the given rectangle, but its distance is less than
      * or equal to that value, it will be considered a hit.
      * @return {boolean} 
      * <code>true</code> if the point lies inside the rectangle;
      * <code>false</code> otherwise.
      */
      containsPointWithEps(rect:yfiles.algorithms.YOrientedRectangle,p:yfiles.algorithms.YPoint,eps:number):boolean;
      /**
      * Determines whether the given oriented rectangle contains the provided
      * point, using an epsilon value.
      * @param {yfiles.algorithms.YOrientedRectangle} rect The rectangle.
      * @param {number} x x-coordinate of the point to test.
      * @param {number} y y-coordinate of the point to test.
      * @param {number} eps 
      * fuzziness range. A positive value allows for fuzzy hit testing.
      * If a point lies outside the given rectangle, but its distance is less than
      * or equal to that value, it will be considered a hit.
      * @return {boolean} 
      * <code>true</code> if the point lies inside the rectangle;
      * <code>false</code> otherwise.
      */
      containsPointCoordsWithEps(rect:yfiles.algorithms.YOrientedRectangle,x:number,y:number,eps:number):boolean;
      /**
      * Determines whether the given rectangle r1 contains rectangle r2, using an epsilon value.
      * @param {yfiles.algorithms.YOrientedRectangle} r1 The first rectangle.
      * @param {yfiles.algorithms.YOrientedRectangle} r2 The second rectangle.
      * @param {number} eps 
      * A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's
      * distance is less than or equal to that value, it will be considered a hit.
      * @return {boolean} true iff the r1 contains r2.
      */
      containsRectangle(r1:yfiles.algorithms.YOrientedRectangle,r2:yfiles.algorithms.YOrientedRectangle,eps:number):boolean;
      /**
      * Determines whether or not the specified oriented rectangle and the
      * specified line segment intersect.
      * @return {boolean} 
      * <code>true</code> if the rectangle and the segment intersect and
      * <code>false</code> otherwise.
      */
      intersectsLine(rect:yfiles.algorithms.YOrientedRectangle,line:yfiles.algorithms.LineSegment,eps:number):boolean;
      /**
      * Determines an intersection point of the specified oriented rectangle and
      * the specified line segment.
      * Note: there might be more than one intersection point. However this method only returns one intersection point
      * or <code>null</code> if there is no intersection.
      * @return {yfiles.algorithms.YPoint} 
      * an intersection point of the specified oriented rectangle and
      * the specified line segment or <code>null</code> if the rectangle and the
      * segment do not intersect.
      */
      intersectionPoint(rect:yfiles.algorithms.YOrientedRectangle,line:yfiles.algorithms.LineSegment,eps:number):yfiles.algorithms.YPoint;
    };
    /**
    * This class represents the size of an object.
    * An instance of this class implements the immutable design pattern.
    */
    export interface YDimension extends Object,yfiles.lang.IObjectComparable{
      /**
      * The width of the dimension object.
      */
      width:number;
      /**
      * The height of the dimension object.
      */
      height:number;
      /**
      * Tests a dimension to equality to another dimension.
      */
      equals(o:Object):boolean;
      hashCode():number;
      /**
      * Returns the size in the form: "W: width H: height"
      */
      toString():string;
      /**
      * Compares this object to the given object of the same type.
      * @param {Object} obj The object to compare this to.
      * @return {number} <ul>
      * <li>-1: this is less than <code>obj</code></li>
      * <li>0: this is equal to <code>obj</code></li>
      * <li>1: this is greater than <code>obj</code></li>
      * </ul>
      * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
      */
      compareToObject(o:Object):number;
    }
    var YDimension:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new YDimension2D object for given size.
      */
      new (width:number,height:number):yfiles.algorithms.YDimension;
    };
    /**
    * This class represents an ordered list of points in the plane.
    */
    export interface YPointPath extends Object{
      /**
      * Get the points in the path.
      */
      cursor():yfiles.algorithms.ICursor;
      /**
      * Get the points in the path.
      */
      points():yfiles.algorithms.IPointCursor;
      /**
      * Get the points in the path.
      */
      iterator():yfiles.algorithms.IIterator;
      /**
      * The first point in the path.
      */
      first:yfiles.algorithms.YPoint;
      /**
      * The last point in the path.
      */
      last:yfiles.algorithms.YPoint;
      /**
      * Get the points in the path as list.
      * @return {yfiles.algorithms.IList} 
      * a list of {@link yfiles.algorithms.YPoint} instances.
      */
      toList():yfiles.algorithms.IList;
      /**
      * Get the points in the list as array.
      */
      toArray():yfiles.algorithms.YPoint[];
      /**
      * Create a point path with reverse ordering of the points.
      */
      createReverse():yfiles.algorithms.YPointPath;
      /**
      * Get the number of points in the path.
      */
      length():number;
      /**
      * The number of line segments in the path.
      */
      lineSegmentCount:number;
      /**
      * Get the points in the path.
      */
      lineSegments():yfiles.algorithms.ILineSegmentCursor;
      /**
      * Returns a line segment in the path.
      */
      getLineSegment(i:number):yfiles.algorithms.LineSegment;
      toString():string;
      /**
      * Calculate the (geometric) length of the path.
      * The length of the path is the sum of lengths of all line segments making
      * up the path.
      * @return {number} the (geometric) length of the path
      */
      calculateLength():number;
    }
    var YPointPath:{
      $class:yfiles.lang.Class;
      /**
      * Defines a path with no points.
      */
      EMPTY_PATH:yfiles.algorithms.YPointPath;
      /**
      * Creates a new empty path.
      */
      new ():yfiles.algorithms.YPointPath;
      /**
      * Creates a new path from a list of points.
      * @param {yfiles.algorithms.IList} l 
      * a list of {@link yfiles.algorithms.YPoint} instances.
      */
      FromList:{
        new (l:yfiles.algorithms.IList):yfiles.algorithms.YPointPath;
      };
      /**
      * Creates a new path from an array of points.
      */
      FromPoints:{
        new (path:yfiles.algorithms.YPoint[]):yfiles.algorithms.YPointPath;
      };
    };
    /**
    * This class represents a point in the plane with double coordinates.
    * This class implements the immutable design pattern.
    */
    export interface YPoint extends Object,yfiles.lang.IObjectComparable{
      /**
      * The x-coordinate of the point object.
      */
      x:number;
      /**
      * The y-coordinate of the point object.
      */
      y:number;
      /**
      * Returns the euclidean distance between this point and a given point.
      * @param {number} x the x coordinate of an arbitrary point
      * @param {number} y the y coordinate of an arbitrary point
      * @return {number} the Euclidean distance between this point and the point (x,y).
      */
      distanceToDouble(x:number,y:number):number;
      /**
      * Returns the euclidean distance between this point and a given point.
      * @param {yfiles.algorithms.YPoint} p an arbitrary point
      * @return {number} the Euclidean distance between this point and p.
      */
      distanceTo(p:yfiles.algorithms.YPoint):number;
      /**
      * Returns the point, got by moving this point to another position.
      * @param {number} x the value which is added on the x-coordinate of the point.
      * @param {number} y the value which is added on the y-coordinate of the point.
      * @return {yfiles.algorithms.YPoint} 
      * a new instance of YPoint which is the result of the moving
      * operation.
      */
      moveBy(x:number,y:number):yfiles.algorithms.YPoint;
      /**
      * Tests a point to equality to another point.
      * This test returns true if the <code>o</code> is also an instance of
      * YPoint and has the same coordinates as the instance on which equals is
      * invoked.
      * @param {Object} o an arbitrary instance.
      */
      equals(o:Object):boolean;
      hashCode():number;
      /**
      * Returns the coordinates of the point as string.
      */
      toString():string;
      /**
      * Comparable implementation.
      * YPoints are ordered by ascending x-coordinates.
      * If the x-coordinates of two points equal, then these points are ordered by
      * ascending y-coordinates.
      * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
      */
      compareToObject(o:Object):number;
    }
    var YPoint:{
      $class:yfiles.lang.Class;
      /**
      * A YPoint constant with coordinates (0,0).
      */
      ORIGIN:yfiles.algorithms.YPoint;
      /**
      * Creates a new YPoint at location (0,0).
      */
      AtOrigin:{
        new ():yfiles.algorithms.YPoint;
      };
      /**
      * Creates a new YPoint object for a given position.
      * @param {number} x the x coordinate of the point.
      * @param {number} y the y coordinate of the point.
      */
      new (x:number,y:number):yfiles.algorithms.YPoint;
      /**
      * Returns the euclidean distance between two points.
      * @param {yfiles.algorithms.YPoint} p1 an arbitrary point
      * @param {yfiles.algorithms.YPoint} p2 an arbitrary point
      * @return {number} the Euclidean distance between p1 and p2.
      */
      distance(p1:yfiles.algorithms.YPoint,p2:yfiles.algorithms.YPoint):number;
      /**
      * Returns the euclidean distance between two points.
      * @param {number} x1 x-coordinate of first point
      * @param {number} y1 y-coordinate of first point
      * @param {number} x2 x-coordinate of second point
      * @param {number} y2 y-coordinate of second point
      * @return {number} the euclidean distance between first and second point
      */
      distanceDouble(x1:number,y1:number,x2:number,y2:number):number;
      /**
      * Adds two points and returns the result.
      * @param {yfiles.algorithms.YPoint} p1 an arbitrary instance of YPoint.
      * @param {yfiles.algorithms.YPoint} p2 an arbitrary instance of YPoint.
      */
      add(p1:yfiles.algorithms.YPoint,p2:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
      /**
      * Subtracts two points (p1 - p2) and returns the result.
      * @param {yfiles.algorithms.YPoint} p1 an arbitrary instance of YPoint.
      * @param {yfiles.algorithms.YPoint} p2 an arbitrary instance of YPoint.
      */
      subtract(p1:yfiles.algorithms.YPoint,p2:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
      /**
      * Returns a point that geometrically lies in
      * in the middle of the line formed by the given points.
      * @param {yfiles.algorithms.YPoint} p1 an arbitrary instance of YPoint.
      * @param {yfiles.algorithms.YPoint} p2 an arbitrary instance of YPoint.
      */
      midPoint(p1:yfiles.algorithms.YPoint,p2:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
      /**
      * Returns a copy of the given point with exchanged
      * x- and y-coordinates.
      * @param {yfiles.algorithms.YPoint} p an arbitrary instance of YPoint.
      */
      swap(p:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
    };
    /**
    * Defines an interface for specialized priority queues that contains
    * nodes which are prioritized by associated int values.
    */
    export interface IIntNodePQ extends Object{
      /**
      * Specifies whether or not this queue is empty.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#empty}.
      */
      empty:boolean;
      /**
      * Returns whether or not the given node is contained within this queue.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#contains}.
      */
      contains(n:yfiles.algorithms.Node):boolean;
      /**
      * Adds a node with the given priority to the queue.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#add}.
      */
      add(n:yfiles.algorithms.Node,priority:number):void;
      /**
      * He node with smallest priority in this queue.
      * <b>Precondition:</b> !isEmpty()
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#min}.
      */
      min:yfiles.algorithms.Node;
      /**
      * Removes the node with the minimal priority from the queue.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#removeMin}.
      */
      removeMin():yfiles.algorithms.Node;
      /**
      * Decreases the priority of a node in the queue to a given value.
      * @param {yfiles.algorithms.Node} n a node in the priority queue.
      * @param {number} priority the new priority value of the node.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#decreasePriority}.
      */
      decreasePriority(n:yfiles.algorithms.Node,priority:number):void;
      /**
      * Removes all entries from the queue.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#clear}.
      */
      clear():void;
      /**
      * Returns the current priority of the given node.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#getPriority}.
      */
      getPriority(n:yfiles.algorithms.Node):number;
      /**
      * Disposes this queue.
      * It is important to call this method after the queue
      * is not needed anymore, to free bound resources.
      * @see Specified by {@link yfiles.algorithms.IIntNodePQ#dispose}.
      */
      dispose():void;
    }
    var IIntNodePQ:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This class implements a priority queue for objects whose priority
    * values are of type int.
    * The implementation is based on binary heaps.
    */
    export interface IntObjectPQ extends Object{
      /**
      * Adds the given node with with given priority to this queue.
      * <b>Precondition:</b> !contains(v)
      * <b>Complexity:</b> O(log(size()))
      */
      add(o:Object,priority:number):void;
      /**
      * Decreases the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Precondition:</b> priority &lt; getPriority(v)
      * <b>Complexity:</b> O(log(size()))
      */
      decreasePriority(o:Object,priority:number):void;
      /**
      * Increases the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Precondition:</b> priority > getPriority(v)
      * <b>Complexity:</b> O(log(size()))
      */
      increasePriority(o:Object,priority:number):void;
      /**
      * Changes the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Complexity:</b> O(log(size()))
      */
      changePriority(o:Object,p:number):void;
      /**
      * Removes the node with smallest priority from this queue.
      * <b>Precondition:</b> !isEmpty()
      * <b>Complexity:</b> O(log(size()))
      * @return {Object} the removed node with smallest priority
      */
      removeMin():Object;
      /**
      * He node with smallest priority in this queue.
      * <b>Precondition:</b> !isEmpty()
      */
      min:Object;
      /**
      * The minimum priority value in this queue.
      */
      minPriority:number;
      /**
      * Returns whether or not the given node is contained
      * in this queue.
      * <b>Complexity:</b> O(1)
      */
      contains(o:Object):boolean;
      /**
      * Specifies whether or not this queue is empty.
      * <b>Complexity:</b> O(1)
      */
      empty:boolean;
      /**
      * Returns the number of nodes currently in this queue.
      * <b>Complexity:</b> O(1)
      */
      size():number;
      /**
      * Returns the current priority of the given node.
      * <b>Precondition:</b> contains(v)
      */
      getPriority(o:Object):number;
      /**
      * Removes the given node from this queue.
      * <b>Precondition:</b> contains(v)
      * <b>Complexity:</b> O(log(size()))
      */
      remove(o:Object):void;
      /**
      * Makes this queue the empty queue.
      * in this queue.
      * <b>Complexity:</b> O(graph.N())
      */
      clear():void;
      /**
      * Does nothing.
      */
      dispose():void;
    }
    var IntObjectPQ:{
      $class:yfiles.lang.Class;
      /**
      * Creates an empty ObjectPQ using the given {@link yfiles.algorithms.IDataProvider} and
      * {@link yfiles.algorithms.IDataAcceptor} to store and retrieve Object support information.
      * The contents of the provider should be modified through the use of the
      * acceptor, i.e. they should be based on the same initially empty backing store.
      * Additionally this backing store should not be modified externally as long as
      * this PQ is still in use.
      */
      new (initialSize:number,provider:yfiles.algorithms.IDataProvider,acceptor:yfiles.algorithms.IDataAcceptor):yfiles.algorithms.IntObjectPQ;
    };
    /**
    * Defines an interface for specialized priority queues that contains
    * nodes which are prioritized by a comparable values.
    */
    export interface INodePQ extends Object{
      /**
      * Adds the given node with the given priority to the queue.
      * <b>Precondition:</b> !contains(v)
      * @see Specified by {@link yfiles.algorithms.INodePQ#add}.
      */
      add(v:yfiles.algorithms.Node,priority:Object):void;
      /**
      * Decreased the priority value of the given node.
      * <b>Precondition:</b> contains(v)
      * <b>Precondition:</b> 
      * c.compare(p,getPriority(v)) &lt; 0, where
      * c is the corresponding comparator for the priorities in this
      * queue.
      * @see Specified by {@link yfiles.algorithms.INodePQ#decreasePriority}.
      */
      decreasePriority(v:yfiles.algorithms.Node,priority:Object):void;
      /**
      * Removes the node with smallest priority from this queue.
      * <b>Precondition:</b> !isEmpty()
      * @return {yfiles.algorithms.Node} the removed node with smallest priority
      * @see Specified by {@link yfiles.algorithms.INodePQ#removeMin}.
      */
      removeMin():yfiles.algorithms.Node;
      /**
      * He node with smallest priority in this queue.
      * <b>Precondition:</b> !isEmpty()
      * @see Specified by {@link yfiles.algorithms.INodePQ#min}.
      */
      min:yfiles.algorithms.Node;
      /**
      * Makes this queue the empty queue.
      * in this queue.
      * @see Specified by {@link yfiles.algorithms.INodePQ#clear}.
      */
      clear():void;
      /**
      * Returns whether or not the given node is contained
      * in this queue.
      * @see Specified by {@link yfiles.algorithms.INodePQ#contains}.
      */
      contains(v:yfiles.algorithms.Node):boolean;
      /**
      * Returns the current priority of the given node.
      * @see Specified by {@link yfiles.algorithms.INodePQ#getPriority}.
      */
      getPriority(v:yfiles.algorithms.Node):Object;
      /**
      * Specifies whether or not this queue is empty.
      * @see Specified by {@link yfiles.algorithms.INodePQ#empty}.
      */
      empty:boolean;
      /**
      * Returns the number of nodes currently in this queue.
      * @see Specified by {@link yfiles.algorithms.INodePQ#size}.
      */
      size():number;
    }
    var INodePQ:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Specifies the contract of modifiable integer value objects.
    */
    export interface IIntValueSettable extends Object{
      /**
      * The object's data.
      * @see Specified by {@link yfiles.algorithms.IIntValueSettable#value}.
      */
      value:number;
    }
    var IIntValueSettable:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
  }
  export module circular{
    /**
    * A layouter that places the nodes of a graph on a cycle.
    * Here is an sample output of the layouter with activated automatic radius
    * determination.
    * <center><img src="doc-files/y.layout.circular.SingleCycleLayouter.gif" border="1"/></center>
    */
    export interface SingleCycleLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * The angle for the first node.
      * <b>Getter:</b>Default value is 0.0
      * <b>Setter:</b>The angle is measured in rad and world coordinates, i.e. 0 is east,
      * Pi/4 south etc.
      * Note: This setting is ignored when the SingleCycleLayouter is used in connection with
      * {@link yfiles.circular.CircularLayouter}.
      */
      initialAngle:number;
      /**
      * Specifies whether or not to take the coordinates of the input diagram
      * into account when arranging the nodes.
      * If this features is enabled, the original circular order of peripheral nodes around
      * an estimated circle center is preserved.
      * By default this feature is disabled.
      */
      fromSketchModeEnabled:boolean;
      /**
      * The distance to keep between the nodes on the cycle
      * Default value is 30.0.
      * Default value is 30.0.
      */
      minimalNodeDistance:number;
      /**
      * The fixed radius for the cycle on which the nodes of the graph
      * will be placed.
      * The fixed radius is ignored if the automatic radius feature
      * is activated.
      * Default value is 200.0.
      */
      fixedRadius:number;
      /**
      * The minimal radius for the cycle on which the nodes are placed.
      * This feature is considered if the radius is detected automatically.
      * Default value is 5.0.
      */
      minimalRadius:number;
      /**
      * Specifies whether or not to choose the cycle radius automatically.
      * If enabled a radius will be chosen such that the adjacent nodes on the circle
      * will be approximately {@link yfiles.circular.SingleCycleLayouter#minimalNodeDistance} apart.
      * If this feature is deactivated the radius specified via
      * {@link yfiles.circular.SingleCycleLayouter#fixedRadius} will be applied.
      * By default this feature is enabled.
      */
      automaticRadius:boolean;
      /**
      * The node sequencer used to determine the order of nodes
      * around a cycle.
      */
      nodeSequencer:yfiles.algorithms.INodeSequencer;
      /**
      * The radius last applied by this layouter.
      */
      lastAppliedRadius:number;
      /**
      * Always returns <code>true</code>.
      * Yes we can handle anything!
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Core layout routine.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
    }
    var SingleCycleLayouter:{
      $class:yfiles.lang.Class;
      new ():yfiles.circular.SingleCycleLayouter;
    };
    export enum LayoutStyle{
      /**
      * Layout style specifier. In this layout style the nodes within a
      * biconnected component of the input graph are treated as separate
      * partitions. If a node belongs to more biconnected components,
      * it will be assigned to the one that seems to be more suitable.
      * This parameter can be set with {@link yfiles.circular.CircularLayouter#layoutStyle}
      */
      BCC_COMPACT,
      /**
      * Layout style specifier. In this layout style the nodes within a
      * biconnected component of the input graph are treated as separate
      * partitions.
      * If a node belongs to more biconnected components,
      * it will form an isolated partition and will be laid out
      * in between all of it's biconnected component cycles.
      * This parameter can be set with {@link yfiles.circular.CircularLayouter#layoutStyle}
      */
      BCC_ISOLATED,
      /**
      * Layout style specifier. In this layout style the user can specify groups that
      * will each form a separate partition. To specify groups, a {@link yfiles.algorithms.IDataProvider} with key
      * {@link yfiles.circular.CircularLayouter#CIRCULAR_CUSTOM_GROUPS_DP_KEY} must be registered.
      * This parameter can be set with {@link yfiles.circular.CircularLayouter#layoutStyle}
      */
      CIRCULAR_CUSTOM_GROUPS,
      /**
      * Layout style specifier.  In this layout style all nodes of the input graph
      * will be put on or inside a single cycle.
      * This parameter can be set with {@link yfiles.circular.CircularLayouter#layoutStyle}
      */
      SINGLE_CYCLE
    }
    /**
    * Circular style layouter.
    * This layouter either places all nodes on or inside a circle
    * or partitions the graph in disjoint node sets each of
    * which will be laid out separately. The exact behavior for the layout of these partitions
    * can be controlled via {@link yfiles.circular.CircularLayouter#partitionLayoutStyle}. The partition policy
    * can be set with {@link yfiles.circular.CircularLayouter#layoutStyle}.
    * The separate partitions themselves
    * are arranged using a {@link yfiles.tree.BalloonLayouter}.
    * Here is a sample output of the layouter using {@link yfiles.circular.LayoutStyle#BCC_COMPACT} as partition policy
    * and {@link yfiles.circular.PartitionLayoutStyle#CYCLE} as layout style for the partitions.
    * <center><img src="doc-files/y.layout.circular.CircularLayouter.gif" border="1"/></center>
    */
    export interface CircularLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * Specifies whether or not node labels are taken into account when calculating
      * node positions (thereby preventing possible node/node label or
      * node label/node label overlaps).
      * <p>
      * Note that this option only works correctly if the {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation}
      * is set to {@link yfiles.layout.LayoutOrientation#TOP_TO_BOTTOM} (which is the default).
      * Changing the layout orientation for an undirected layout algorithm like the
      * {@link yfiles.circular.CircularLayouter} doesn't make sense.
      * </p>
      */
      considerNodeLabels:boolean;
      /**
      * Specifies whether or not, in the underlying tree, the children of a node are placed on a common radius.
      * Disabling this feature may produce more compact layout results.
      */
      placeChildrenOnCommonRadius:boolean;
      /**
      * Specifies whether or not to take the coordinates of the input diagram
      * into account when arranging the nodes of the partitions and the partitions themselves.
      * If enabled:
      * <ul>
      * <li>For complex partitions (those consisting of more than one node), the layouter
      * tries to keep peripheral nodes and maintain their circular order around the center of the disk/circle.
      * Other partitions that connect to this node are moved accordingly, if possible.</li>
      * <li>For multiple partitions that connect to the same node, the layouter tries to keep their
      * circular order around this node. This only works as expected for {@link yfiles.circular.LayoutStyle#BCC_COMPACT}
      * as partition policy, since otherwise the underlying tree structure is not well defined</li>
      * </ul>
      * Switching between different partition policies or group layout styles can lead to unexpected results.
      * By default this feature is disabled.
      */
      fromSketchMode:boolean;
      /**
      * The maximal deviation angle allowed for an edge.
      * The deviation angle for an edge is the difference between
      * its optimal radiation angle away from the parent cycle and its
      * actual radiation angle.
      * <p>
      * By default a maximal deviation angle of 90 degrees is applied.
      * </p>
      * <p>
      * Note that using a small maximal deviation angle may significantly increase the length of edges.
      * The same is true for small preferred child wedges set on the used BalloonLayouter instance,
      * see method {@link yfiles.circular.CircularLayouter#balloonLayouter}.
      * </p>
      */
      maximalDeviationAngle:number;
      /**
      * The global layout style for this layouter.
      * Allowed layout styles are {@link yfiles.circular.LayoutStyle#SINGLE_CYCLE}, {@link yfiles.circular.LayoutStyle#BCC_ISOLATED},
      * {@link yfiles.circular.LayoutStyle#BCC_COMPACT} and {@link yfiles.circular.LayoutStyle#CIRCULAR_CUSTOM_GROUPS}
      * By default {@link yfiles.circular.LayoutStyle#BCC_COMPACT} is used as layout style
      */
      layoutStyle:yfiles.circular.LayoutStyle;
      /**
      * The SingleCycleLayouter used for laying out single node cycles
      * Configuring that layouter has effects upon single cycle layouts.
      */
      singleCycleLayouter:yfiles.circular.SingleCycleLayouter;
      /**
      * The BalloonLayouter used for arranging the partitions
      * Configuring that layouter has effect upon the partition arrangement
      * within the overall layout.
      */
      balloonLayouter:yfiles.tree.BalloonLayouter;
      /**
      * The layout style for the arrangement of each partition.
      * Default is {@link yfiles.circular.PartitionLayoutStyle#CYCLE}
      */
      partitionLayoutStyle:yfiles.circular.PartitionLayoutStyle;
      /**
      * Always returns <code>true</code>.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Core layout routine.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Calculates a layout for the given graph.
      * The given graph will not be copied during the
      * layout process and the layout will be
      * immediately applied to the given graph.
      * This method is not side effect free in the sense that
      * the order of edges or nodes in the input graph
      * may change during the layout process.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(layoutGraph:yfiles.layout.LayoutGraph):void;
    }
    var CircularLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Used for publishing the final circle information.
      * If the {@link yfiles.algorithms.IDataProvider} associated to this key is also a
      * {@link yfiles.algorithms.IDataAcceptor}, the integer circle id of each node is stored using
      * the acceptor's {@link yfiles.algorithms.IDataAcceptor#setInt  setInt} method.
      * Otherwise, the provider's values should be of type
      * {@link yfiles.algorithms.IIntValueSettable} whose
      * {@link yfiles.algorithms.IIntValueSettable#value  setValue} method
      * is used to store the integer circle id of each node.
      */
      CIRCLE_ID_HOLDER_DP_KEY:Object;
      /**
      * This key is used to identify custom groups.
      */
      CIRCULAR_CUSTOM_GROUPS_DP_KEY:Object;
      /**
      * Create a new instance of this layouter.
      * The default values are:
      * <ul>
      * <li>Partition policy: {@link yfiles.circular.LayoutStyle#BCC_COMPACT}</li>
      * <li>Partition layout style: {@link yfiles.circular.PartitionLayoutStyle#CYCLE}</li>
      * </ul>
      */
      new ():yfiles.circular.CircularLayouter;
    };
    export enum PartitionLayoutStyle{
      /**
      * Place each node of a partition on the boundary of a circle.
      * This style is very fast, but the results may need much space.
      * This parameter can be set with {@link yfiles.circular.CircularLayouter#partitionLayoutStyle}
      */
      CYCLE,
      /**
      * Create semi-compact layout for each partition.
      * This style places nodes in the inside and the border
      * of a circle and arranges them in an organic manner, leading to more compact
      * layout. Only nodes with connections into other partitions are guaranteed to lie on the boundary of
      * the resulting disk.
      * This style may come with a performance penalty.
      * This parameter can be set with {@link yfiles.circular.CircularLayouter#partitionLayoutStyle}
      */
      DISK,
      /**
      * Create most compact layout for each partition.
      * This style creates an organic circular layout for each partition. Even nodes that connect
      * into different partitions may be placed in the inside of the resulting disk.
      * This style may come with a performance penalty.
      * This parameter can be set with {@link yfiles.circular.CircularLayouter#partitionLayoutStyle}
      */
      ORGANIC
    }
  }
  export module collections{
    /**
    * Abstract base class for {@link yfiles.collections.IEqualityComparer} implementations.
    */
    export interface EqualityComparer<T> extends Object,yfiles.collections.IEqualityComparer<T>{
      /**
      * Whether the given objects are equal.
      * @param {T} x The first object to compare.
      * @param {T} y The second object to compare.
      * @return {boolean} <code>true</code> if both objects are equal.
      * @see Specified by {@link yfiles.collections.IEqualityComparer#itemsEqual}.
      */
      itemsEqual(x:T,y:T):boolean;
      /**
      * Returns the hash code for the given object.
      * For best performance when used in an {@link yfiles.objectcollections.IDictionary}, the hash code should
      * be well distributed, i.e. there should be as many different hash codes for the targeted set of keys as possible.
      * @param {T} obj The object to get the hash code for.
      * @return {number} The hash code for the given object.
      * @see Specified by {@link yfiles.collections.IEqualityComparer#getHashCode}.
      */
      getHashCode(obj:T):number;
    }
    var EqualityComparer:{
      $class:yfiles.lang.Class;
      /**
      * The default {@link yfiles.collections.IEqualityComparer} implementation which relies on an object's
      * capabilities to compare itself to others and to calculate its own hash code.
      */
      DEFAULT:yfiles.collections.IEqualityComparer<any>;
    };
    /**
    * A read-write collection of objects of the same type.
    */
    export interface IList<T> extends Object,yfiles.collections.ICollection<T>{
      /**
      * The index of the given item in the list.
      * @param {T} item The item to search for.
      * @return {number} The index of the given item in the list. <code>-1</code> if the item is not in the list.
      * @see Specified by {@link yfiles.collections.IList#indexOf}.
      */
      indexOf(item:T):number;
      /**
      * Inserts the given <code>item</code> at the given <code>index</code>.
      * @param {number} index The index to insert the item at.
      * @param {T} item The item to insert.
      * @see Specified by {@link yfiles.collections.IList#insert}.
      */
      insert(index:number,item:T):void;
      /**
      * Removes the item at the given index from the list.
      * @param {number} index The index of the item to remove.
      * @see Specified by {@link yfiles.collections.IList#removeAt}.
      */
      removeAt(index:number):void;
      /**
      * Gets or sets the item at the given index.
      * @param {number} index The index of the item to access.
      * @return {T} The item at the given index.
      * @see Specified by {@link yfiles.collections.IList#get}.
      */
      get(index:number):T;
      /**
      * Gets or sets the item at the given index.
      * @param {number} index The index of the item to access.
      * @return {T} The item at the given index.
      * @see Specified by {@link yfiles.collections.IList#get}.
      */
      set(index:number,value:T):void;
    }
    var IList:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * The key/value pair of a {@link yfiles.collections.IDictionary}.
    */
    export interface KeyValuePair<TKey,TValue> extends Object{
      /**
      * The key for this key/value pair.
      */
      key:TKey;
      /**
      * The value for this key/value pair.
      */
      value:TValue;
      /**
      * The next key/value pair.
      */
      next:yfiles.collections.KeyValuePair<TKey,TValue>;
    }
    var KeyValuePair:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with the given <code>key</code> and <code>value</code>.
      * @param {TKey} key The key for this pair.
      * @param {TValue} value The value for this pair.
      */
      With:{
        new <TKey,TValue>(key:TKey,value:TValue):yfiles.collections.KeyValuePair<TKey,TValue>;
      };
      /**
      * Creates a new instance with the given <code>key</code> and <code>value</code> and another
      * <code>next</code> to append to this instance.
      * @param {TKey} key The key for this pair.
      * @param {TValue} value The value for this pair.
      * @param {yfiles.collections.KeyValuePair.<TKey,TValue>} next The key/value pair to append.
      */
      WithKeyValueAndNext:{
        new <TKey,TValue>(key:TKey,value:TValue,next:yfiles.collections.KeyValuePair<TKey,TValue>):yfiles.collections.KeyValuePair<TKey,TValue>;
      };
    };
    /**
    * Defines ways to iterate over the items contained in this type by providing a method to get an {@link yfiles.objectcollections.IEnumerator}.
    */
    export interface IEnumerable<T> extends Object,yfiles.objectcollections.IEnumerable{
      /**
      * Gets an {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance.
      * @return {yfiles.collections.IEnumerator.<T>} The {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance
      * @see Specified by {@link yfiles.collections.IEnumerable#getEnumerator}.
      */
      getEnumerator():yfiles.collections.IEnumerator<T>;
      /**
      * Whether the given value is contained in the enumerable.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#enumeratorContains}.
      * @param {T} value The value to search for.
      * @return {boolean} <code>true</code> if the enumerable contains the given value.
      */
      enumerableContains(value:T):boolean;
      /**
      * Returns the element at the given <code>index</code> in the enumerable.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#elementAt}.
      * @param {number} index The index of the element to return.
      * @return {T} The element at the given <code>index</code>.
      * @throws {yfiles.system.ArgumentException} If the <code>index</code> is not within the enumerable's range.
      */
      getElementAt(index:number):T;
      /**
      * Iterates over the enumerable and invokes the action for each element passing the value as an argument.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#forEach}.
      * @param {function(T)} action The delegate to call.
      */
      forEach(action:(obj:T)=> void):void;
      /**
      * Iterates over the enumerable and invokes the action for each element passing the value and index as arguments.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#forEachWithIndex}.
      * @param {function(T, number)} action The delegate to call.
      */
      forEachWithIndex(action:(arg1:T,arg2:number)=> void):void;
      /**
      * Returns the number of elements contained in the enumerable.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#count}.
      * @return {number} The number of elements contained in the enumerable.
      */
      getElementCount():number;
      /**
      * Returns the first element of the enumerable.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#getFirstElement}.
      * @return {T} The first element of the enumerable.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      * @throws {yfiles.system.InvalidOperationException} If the enumerable is empty.
      */
      getFirstElement():T;
      /**
      * Returns the first element of the enumerable which matches a given filter.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#getFirstElementWithPredicate}.
      * @param {function(T):boolean} predicate A function with the signature <code>function(element):boolean</code> which returns
      * <code>true</code> if the given element should be returned
      * @return {T} The first matching element of the enumerable.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      * @throws {yfiles.system.InvalidOperationException} If the enumerable does not contain a matching element.
      */
      getFirstElementWithPredicate(predicate:(arg:T)=>boolean):T;
      /**
      * Returns the first element of the enumerable or the default for the enumerable's element type if the enumerable is empty.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#getFirstElementOrDefault}.
      * @return {T} The first element of the enumerable or the default value for <code>TSource</code>.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      */
      getFirstElementOrDefault():T;
      /**
      * Returns the first element of the enumerable which matches a given filter 
      * or the default for the enumerable's element type if there is no such element.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#getFirstElementOrDefaultWithPredicate}.
      * @param {function(T):boolean} predicate A function with the signature <code>function(element):boolean</code> which returns
      * <code>true</code> if the given element should be returned
      * @return {T} The first element of the enumerable or the default value for <code>TSource</code>.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      */
      getFirstElementOrDefaultWithPredicate(predicate:(arg:T)=>boolean):T;
      /**
      * Returns the last element of the enumerable or the default for the enumerable's element type if the enumerable is empty.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#getLastElementOrDefault}.
      * @return {T} The last element of the enumerable or the default value for <code>TSource</code>.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      */
      getLastElementOrDefault():T;
      /**
      * Returns the last element of the enumerable.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#getLastElement}.
      * @return {T} The last element of the enumerable.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      * @throws {yfiles.system.InvalidOperationException} If the enumerable is empty.
      */
      getLastElement():T;
      /**
      * Returns an enumerable which only contains elements of the source enumerable which match a given <code>predicate</code>.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#where}.
      * @param {function(Object):boolean} predicate A function with the signature <code>function(element):boolean</code> which returns
      * <code>true</code> if the given element should be included in the resulting enumerable.
      * @return {yfiles.collections.IEnumerable.<T>} An enumerable which contains the elements of the source enumeration which match the given <code>predicate</code>.
      */
      getMatchingElements(predicate:(arg:Object)=>boolean):yfiles.collections.IEnumerable<T>;
      /**
      * Creates a flattened view of a given enumerable using the given <code>selector</code> function which returns
      * an enumerable for each element of the source enumerable.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#selectMany}.
      * @param {function(T):yfiles.collections.IEnumerable.<T>} selector A function with the signature <code>function(element):IEnumerable</code> which returns
      * an enumerable for each element of the source enumerable.
      * @return {yfiles.collections.IEnumerable.<T>} A flattened view of the given enumerable. The enumerables which are returned by the <code>selector</code>
      * method for each element are concatenated in the result.
      */
      getMultiProjection(selector:(arg:T)=>yfiles.collections.IEnumerable<T>):yfiles.collections.IEnumerable<T>;
      /**
      * Creates an array with the values of the enumerable.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#toArray}.
      * @return {T[]} An array with the enumerable's elements.
      */
      getEnumerableAsArray():T[];
      /**
      * Creates a {@link yfiles.collections.List} with the values of the enumerable.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#toList}.
      * @return {yfiles.collections.List.<T>} An {@link yfiles.collections.List} with the enumerable's elements.
      */
      getEnumerableAsList():yfiles.collections.List<T>;
      /**
      * Calculates the sum of the elements of the enumerable.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#sum}.
      * @param {function(T):number} selector A function with the signature <code>function(element):Number</code>
      * which returns a numeric value for the given element.
      * @return {number} The sum of the elements of the enumerable.
      */
      getElementSum(selector:(arg:T)=>number):number;
      /**
      * Whether the enumerable contains any elements.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#notEmpty}.
      * @return {boolean}  Whether the enumerable contains any elements.
      * @throws {yfiles.system.ArgumentNullException} <code>e</code> is <code>null</code>.
      */
      enumerableContainsElements():boolean;
      /**
      * Whether the enumerable contains any elements matching the given <code>predicate</code>.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#any}.
      * @param {function(T):boolean} predicate A function with the signature <code>function(element):boolean</code>
      * which returns <code>true</code> if the element matches a condition.
      * @return {boolean}  Whether the enumerable contains any elements matching the given <code>predicate</code>.
      * @throws {yfiles.system.ArgumentNullException} <code>e</code> is <code>null</code>.
      * @throws {yfiles.system.ArgumentNullException} <code>predicate</code> is <code>null</code>.
      */
      enumerableContainsMatch(predicate:(arg:T)=>boolean):boolean;
      /**
      * Whether all elements of the enumerable match the given <code>predicate</code>.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#every}.
      * @param {function(T):boolean} predicate A function with the signature <code>function(element):boolean</code>
      * which returns <code>true</code> if the element matches a condition.
      * @return {boolean}  Whether all elements of the enumerable match the given <code>predicate</code>.
      * @throws {yfiles.system.ArgumentNullException} <code>e</code> is <code>null</code>.
      * @throws {yfiles.system.ArgumentNullException} <code>predicate</code> is <code>null</code>.
      */
      enumerableMatchesAll(predicate:(arg:T)=>boolean):boolean;
      /**
      * Projects each element of the enumeration into a new element.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#selectWithSelector}.
      * @param {function(T):TResult} selector A function with the signature <code>function(element):TResult</code>
      * which converts each element into a new element of the type <code>TResult</code>.
      * @return {yfiles.collections.IEnumerable.<TResult>} A projection of the original enumerable.
      */
      getProjection<TResult>(selector:(arg:T)=>TResult):yfiles.collections.IEnumerable<TResult>;
      /**
      * Projects each element of the enumeration into a new element.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#select}.
      * @param {function(T, number):TResult} selector A function with the signature <code>function(element, index):TResult</code>
      * which converts each element into a new element of the type <code>TResult</code> depending on the element's index.
      * @return {yfiles.collections.IEnumerable.<TResult>} A projection of the original enumerable.
      */
      getProjectionWithIndex<TResult>(selector:(arg1:T,arg2:number)=>TResult):yfiles.collections.IEnumerable<TResult>;
      /**
      * Returns an enumerable which contains the elements of the original enumerable in reverse order.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#reverse}.
      * @return {yfiles.collections.IEnumerable.<T>} An enumerable which contains the elements of the original enumerable in reverse order.
      */
      getReversedEnumerable():yfiles.collections.IEnumerable<T>;
      /**
      * Returns elements from an enumerable as long as the given <code>predicate</code> is <code>true</code>.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#takeWhile}.
      * @param {function(T):boolean} predicate A function with the signature <code>function(element):boolean</code>
      * which returns <code>true</code> as long as the elements should be added to the returned enumerable.
      * @return {yfiles.collections.IEnumerable.<T>} A subset of the original enumerable.
      */
      getTakeWhileEnumerable(predicate:(arg:T)=>boolean):yfiles.collections.IEnumerable<T>;
      /**
      * Applies an <code>func</code> function over the enumerable's elements.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#aggregate}.
      * @param {TAccumulate} seed The start value for the accumulator.
      * @param {function(TAccumulate, T):TAccumulate} func A function with the signature <code>function(seed,element):TAccumulate</code> which
      * "adds" (accumulates) a value depending on the element to the seed value and returns the result.
      * @return {TAccumulate} The final value of the accumulator.
      */
      getAggregation<TAccumulate>(seed:TAccumulate,func:(arg1:TAccumulate,arg2:T)=>TAccumulate):TAccumulate;
    }
    var IEnumerable:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Provides methods to iterate over a collection or list of elements of the same type.
    */
    export interface IEnumerator<T> extends Object,yfiles.system.IDisposable,yfiles.objectcollections.IEnumerator{
      /**
      * Moves this enumerator to the next element.
      * A newly created enumerator's {@link yfiles.collections.IEnumerator#current current position} is before the first element. Thus, this method
      * must be called before first access to the {@link yfiles.collections.IEnumerator#current} property. The same applies to the state after 
      * calling {@link yfiles.collections.IEnumerator#reset}.
      * @return {boolean} <code>true</code> if the enumerator was moved to a valid position
      * @see Specified by {@link yfiles.collections.IEnumerator#moveNext}.
      */
      moveNext():boolean;
      /**
      * Resets the enumerator to its starting state.
      * In other words: sets the current position before the first element.
      * @see Specified by {@link yfiles.collections.IEnumerator#reset}.
      */
      reset():void;
      /**
      * Gets the element at the enumerator's current position.
      * This value is undefined if the enumerator is in initial state (after creation or {@link yfiles.collections.IEnumerator#reset}) or has been moved past the
      * end of the represented collection.
      * @see Specified by {@link yfiles.collections.IEnumerator#current}.
      */
      current:T;
    }
    var IEnumerator:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * An object which can compare other objects and calculate their hash codes.
    * If two objects are equal, then they should have the same hash code. If they have the same
    * hash code, they don't need to be equal.
    */
    export interface IEqualityComparer<T> extends Object{
      /**
      * Whether the given objects are equal.
      * @param {T} x The first object to compare.
      * @param {T} y The second object to compare.
      * @return {boolean} <code>true</code> if both objects are equal.
      * @see Specified by {@link yfiles.collections.IEqualityComparer#itemsEqual}.
      */
      itemsEqual(x:T,y:T):boolean;
      /**
      * Returns the hash code for the given object.
      * For best performance when used in an {@link yfiles.objectcollections.IDictionary}, the hash code should
      * be well distributed, i.e. there should be as many different hash codes for the targeted set of keys as possible.
      * @param {T} obj The object to get the hash code for.
      * @return {number} The hash code for the given object.
      * @see Specified by {@link yfiles.collections.IEqualityComparer#getHashCode}.
      */
      getHashCode(obj:T):number;
    }
    var IEqualityComparer:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Default implementation of {@link yfiles.collections.IList}.
    * This implementation provides fast random indexed access. However, removing or adding elements
    * from the beginning or in the middle of the list will slower.
    */
    export interface List<T> extends Object,yfiles.collections.IList<T>,yfiles.objectcollections.IList{
      /**
      * Gets an {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
      * This method exists for internal purposes mainly, if available the {@link yfiles.collections.IEnumerable#getEnumerator} should be used instead.
      * @return {yfiles.objectcollections.IEnumerator} The {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
      * @see Specified by {@link yfiles.objectcollections.IEnumerable#getObjectEnumerator}.
      */
      getObjectEnumerator():yfiles.objectcollections.IEnumerator;
      /**
      * Gets an {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance.
      * @return {yfiles.collections.IEnumerator.<T>} The {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance
      * @see Specified by {@link yfiles.collections.IEnumerable#getEnumerator}.
      */
      getEnumerator():yfiles.collections.IEnumerator<T>;
      /**
      * Gets an enumerator which allows to iterate over this list's elements.
      * @return {yfiles.collections.List.Enumerator.<T>} An enumerator for this list.
      */
      getListEnumerator():yfiles.collections.List.Enumerator<T>;
      /**
      * Adds the given <code>item</code> to the collection.
      * @param {T} item 
      * @see Specified by {@link yfiles.collections.ICollection#add}.
      */
      add(item:T):void;
      /**
      * Removes all items from this collection.
      * @see Specified by {@link yfiles.collections.ICollection#clear}.
      */
      clear():void;
      /**
      * Whether the given <code>item</code> is contained in this collection.
      * @param {T} item The item to search for.
      * @return {boolean} <code>true</code> if the given <code>item</code> is contained in this collection.
      * @see Specified by {@link yfiles.collections.ICollection#contains}.
      */
      contains(item:T):boolean;
      /**
      * Copies all elements of this collection into the given array.
      * @param {T[]} array The array to copy the elements to.
      * @param {number} arrayIndex The index in the given array where the first element should be copied to.
      * @see Specified by {@link yfiles.collections.ICollection#copyToArrayAt}.
      */
      copyToArrayAt(array:T[],arrayIndex:number):void;
      /**
      * Removes the given <code>item</code> from this collection.
      * @param {T} item The item to remove.
      * @return {boolean} Whether the item was removed from the collection.
      * @see Specified by {@link yfiles.collections.ICollection#remove}.
      */
      remove(item:T):boolean;
      /**
      * The number of elements in this collection.
      * @see Specified by {@link yfiles.collections.ICollection#count}.
      */
      count:number;
      /**
      * Whether this collection is read-only.
      * @see Specified by {@link yfiles.collections.ICollection#isReadOnly}.
      */
      isReadOnly:boolean;
      /**
      * The index of the given item in the list.
      * @param {T} item The item to search for.
      * @return {number} The index of the given item in the list. <code>-1</code> if the item is not in the list.
      * @see Specified by {@link yfiles.collections.IList#indexOf}.
      */
      indexOf(item:T):number;
      /**
      * Inserts the given <code>item</code> at the given <code>index</code>.
      * @param {number} index The index to insert the item at.
      * @param {T} item The item to insert.
      * @see Specified by {@link yfiles.collections.IList#insert}.
      */
      insert(index:number,item:T):void;
      /**
      * Removes the item at the given index from the list.
      * @param {number} index The index of the item to remove.
      * @see Specified by {@link yfiles.collections.IList#removeAt}.
      */
      removeAt(index:number):void;
      /**
      * Gets or sets the object at the given index.
      * @param {number} index The index of the object to access.
      * @return {Object} The object at the given index.
      * @see Specified by {@link yfiles.objectcollections.IList#getObject}.
      */
      getObject(index:number):Object;
      /**
      * Gets or sets the object at the given index.
      * @param {number} index The index of the object to access.
      * @return {Object} The object at the given index.
      * @see Specified by {@link yfiles.objectcollections.IList#getObject}.
      */
      setObject(index:number,value:Object):void;
      /**
      * Gets or sets the item at the given index.
      * @param {number} index The index of the item to access.
      * @return {T} The item at the given index.
      * @see Specified by {@link yfiles.collections.IList#get}.
      */
      get(index:number):T;
      /**
      * Gets or sets the item at the given index.
      * @param {number} index The index of the item to access.
      * @return {T} The item at the given index.
      * @see Specified by {@link yfiles.collections.IList#get}.
      */
      set(index:number,value:T):void;
      /**
      * Adds the given object at the end of the list.
      * @param {Object} value The object to add.
      * @return {number} The index of the added object.
      * @see Specified by {@link yfiles.objectcollections.IList#addWithValue}.
      */
      addWithValue(value:Object):number;
      /**
      * Whether this list contains the given object.
      * @param {Object} value The object to search for.
      * @return {boolean} <code>true</code> if the given object is contained in the list.
      * @see Specified by {@link yfiles.objectcollections.IList#containsValue}.
      */
      containsValue(value:Object):boolean;
      /**
      * Determines the index of the given item in the {@link yfiles.objectcollections.IList}.
      * @param {Object} item The object to get the index for
      * @return {number} The index of the given item. -1 if the item is not in the list.
      * @see Specified by {@link yfiles.objectcollections.IList#indexOfItem}.
      */
      indexOfItem(value:Object):number;
      /**
      * Inserts the given <code>item</code> at the given <code>index</code>.
      * @param {number} index The index at which the item should be inserted.
      * @param {Object} item The item to insert.
      * @see Specified by {@link yfiles.objectcollections.IList#insertAt}.
      */
      insertAt(index:number,value:Object):void;
      /**
      * Removes the given object from the list.
      * @param {Object} value The object to remove.
      * @see Specified by {@link yfiles.objectcollections.IList#removeValue}.
      */
      removeValue(value:Object):void;
      /**
      * Copies the elements of this collection into the given <code>array</code> starting at the given <code>arrayIndex</code>.
      * @param {Object} array The array to copy the elements to.
      * @param {number} arrayIndex The index in the given array where the first element should be copied to.
      * @see Specified by {@link yfiles.objectcollections.ICollection#copyTo}.
      */
      copyTo(array:Object,index:number):void;
      /**
      * @see Specified by {@link yfiles.objectcollections.ICollection#syncRoot}.
      */
      syncRoot:Object;
      /**
      * @see Specified by {@link yfiles.objectcollections.ICollection#isSynchronized}.
      */
      isSynchronized:boolean;
      /**
      * Whether the collection has a fixed size.
      * @see Specified by {@link yfiles.objectcollections.IList#isFixedSize}.
      */
      isFixedSize:boolean;
      /**
      * Adds the elements of the given collection to this list.
      * @param {yfiles.collections.IEnumerable.<T>} collection The collection to add.
      */
      addRange(collection:yfiles.collections.IEnumerable<T>):void;
      /**
      * Returns a read-only representation of this list.
      * @return {yfiles.collections.ReadOnlyCollection.<T>} A read-only representation of this list.
      */
      asReadOnly():yfiles.collections.ReadOnlyCollection<T>;
      /**
      * Searches the (sorted) list for the given <code>item</code>.
      * This search is done as a binary search, therefore the list must be sorted. The given <code>comparer</code> is used to compare
      * the elements to each other.
      * @param {T} item The item to search for.
      * @param {yfiles.collections.IComparer.<T>} comparer The comparer to use for comparing the elements.
      * @return {number} The index of the item in the list. -1 if the item is not found.
      */
      binarySearch(item:T,comparer:yfiles.collections.IComparer<T>):number;
      capacity:number;
      /**
      * Searches the list for the first element for which <code>match</code> returns <code>true</code>.
      * @param {function(T):boolean} match A predicate function with the signature <code>function(o:Object):boolean</code> which returns
      * <code>true</code> if o matches the conditions of the element to search for.
      * @return {T} The first element for which <code>match</code> returns <code>true</code> or the default value for T
      * if there is no such element in the list.
      */
      find(match:(obj:T)=>boolean):T;
      /**
      * Searches the list for the first element for which <code>match</code> returns <code>true</code> and returns its index.
      * @param {function(T):boolean} match A predicate function with the signature <code>function(o:Object):boolean</code> which returns
      * <code>true</code> if o matches the conditions of the element to search for.
      * @return {number} The index of the first element for which <code>match</code> returns <code>true</code> or -1
      * if there is no such element in the list.
      */
      findIndex(match:(obj:T)=>boolean):number;
      /**
      * Removes all elements for which <code>match</code> returns <code>true</code>.
      * @param {function(T):boolean} match A predicate function with the signature <code>function(o:Object):boolean</code> which returns
      * <code>true</code> if o matches the conditions of the element to search for.
      * @return {number} The number of elements which were removed.
      */
      removeAll(match:(obj:T)=>boolean):number;
      /**
      * Removes a given <code>count</code> of elements starting from the given <code>index</code>.
      * @param {number} index The index of the first element to remove.
      * @param {number} count The number of elements to remove.
      */
      removeRange(index:number,count:number):void;
      /**
      * Reverses the order of the elements in the list.
      */
      reverse():void;
      /**
      * Sorts all elements in list using the default comparer.
      */
      naturalSort():void;
      /**
      * Sorts all elements in the list using the given <code>comparer</code>.
      * @param {yfiles.collections.IComparer.<T>} comparer The comparer to use.
      */
      sort(comparer:yfiles.collections.IComparer<T>):void;
      sortWithComparison(comparison:(arg1:Object,arg2:Object)=>number):void;
      /**
      * Copies the elements of this list into an array.
      * @return {T[]} An array containing the elements of this list.
      */
      toArray():T[];
      /**
      * Copies the elements of the {@link yfiles.collections.List} to the given array.
      * @param {T[]} array 
      */
      copyToArray(array:T[]):void;
    }
    export module List{
      /**
      * An {@link yfiles.collections.IEnumerator} which allows to iterate over the elements of this list.
      */
      export interface Enumerator<T> extends Object,yfiles.collections.IEnumerator<T>{
        /**
        * Causes the implementor to free all resources.
        * @see Specified by {@link yfiles.system.IDisposable#dispose}.
        */
        dispose():void;
        /**
        * Moves this enumerator to the next element.
        * A newly created enumerator's {@link yfiles.objectcollections.IEnumerator#currentObject current position} is before the first element. Thus, this method
        * must be called before first access to the {@link yfiles.objectcollections.IEnumerator#currentObject} property. The same applies to the state after 
        * calling {@link yfiles.objectcollections.IEnumerator#reset}.
        * @return {boolean} <code>true</code> if the enumerator was moved to a valid position
        * @see Specified by {@link yfiles.objectcollections.IEnumerator#moveNext}.
        */
        moveNext():boolean;
        /**
        * Resets the enumerator to its starting state.
        * In other words: sets the current position before the first element.
        * @see Specified by {@link yfiles.objectcollections.IEnumerator#reset}.
        */
        reset():void;
        /**
        * Gets the element at the enumerator's current position.
        * This value is undefined if the enumerator is in initial state (after creation or {@link yfiles.collections.IEnumerator#reset}) or has been moved past the
        * end of the represented collection.
        * @see Specified by {@link yfiles.collections.IEnumerator#current}.
        */
        current:T;
      }
    }
    var List:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance.
      */
      new <T>():yfiles.collections.List<T>;
      /**
      * Creates a new instance with the given <code>initialCapacity</code>.
      * @param {number} initialCapacity The initial capacity of the list. Not used here.
      */
      WithCapacity:{
        new <T>(initialCapacity:number):yfiles.collections.List<T>;
      };
      /**
      * Creates a new instance and fills it with the elements of the given <code>enumerable</code>.
      * @param {yfiles.collections.IEnumerable.<T>} enumerable The enumerable to fill the list with.
      */
      FromEnumerable:{
        new <T>(enumerable:yfiles.collections.IEnumerable<T>):yfiles.collections.List<T>;
      };
      /**
      * Creates a new list with the given array.
      * @param {T[]} array The array to create a list from.
      * @return {yfiles.collections.List.<T>} A list backed by the given array.
      */
      fromArray<T>(array:T[]):yfiles.collections.List<T>;
      Enumerator:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance for the given list.
        * @param {yfiles.collections.List.<T>} list The list to iterate over.
        */
        new <T>(list:yfiles.collections.List<T>):yfiles.collections.List<T>;
      };
    };
    export enum NotifyCollectionChangedAction{
      /**
      * One or more elements were added.
      */
      ADD,
      /**
      * One or more elements were removed.
      */
      REMOVE,
      /**
      * One or more elements were replaced.
      */
      REPLACE,
      /**
      * One or more elements were moved.
      */
      MOVE,
      /**
      * The collection was reset.
      */
      RESET
    }
    /**
    * A read-only collection whose elements are of the same type.
    */
    export interface ReadOnlyCollection<T> extends Object,yfiles.collections.IList<T>{
      /**
      * Gets an {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance.
      * @return {yfiles.collections.IEnumerator.<T>} The {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance
      * @see Specified by {@link yfiles.collections.IEnumerable#getEnumerator}.
      */
      getEnumerator():yfiles.collections.IEnumerator<T>;
      /**
      * The number of elements in this collection.
      * @see Specified by {@link yfiles.collections.ICollection#count}.
      */
      count:number;
      /**
      * Whether this collection is read-only.
      * @see Specified by {@link yfiles.collections.ICollection#isReadOnly}.
      */
      isReadOnly:boolean;
      /**
      * Copies all elements of this collection into the given array.
      * @param {T[]} array The array to copy the elements to.
      * @param {number} arrayIndex The index in the given array where the first element should be copied to.
      * @see Specified by {@link yfiles.collections.ICollection#copyToArrayAt}.
      */
      copyToArrayAt(array:T[],arrayIndex:number):void;
      /**
      * Removes all items from this collection.
      * @see Specified by {@link yfiles.collections.ICollection#clear}.
      */
      clear():void;
      /**
      * Removes the given <code>item</code> from this collection.
      * @param {T} item The item to remove.
      * @return {boolean} Whether the item was removed from the collection.
      * @see Specified by {@link yfiles.collections.ICollection#remove}.
      */
      remove(item:T):boolean;
      /**
      * Adds the given <code>item</code> to the collection.
      * @param {T} item 
      * @see Specified by {@link yfiles.collections.ICollection#add}.
      */
      add(item:T):void;
      /**
      * Whether the given <code>item</code> is contained in this collection.
      * @param {T} item The item to search for.
      * @return {boolean} <code>true</code> if the given <code>item</code> is contained in this collection.
      * @see Specified by {@link yfiles.collections.ICollection#contains}.
      */
      contains(item:T):boolean;
      /**
      * The index of the given item in the list.
      * @param {T} item The item to search for.
      * @return {number} The index of the given item in the list. <code>-1</code> if the item is not in the list.
      * @see Specified by {@link yfiles.collections.IList#indexOf}.
      */
      indexOf(item:T):number;
      /**
      * Inserts the given <code>item</code> at the given <code>index</code>.
      * @param {number} index The index to insert the item at.
      * @param {T} item The item to insert.
      * @see Specified by {@link yfiles.collections.IList#insert}.
      */
      insert(index:number,item:T):void;
      /**
      * Removes the item at the given index from the list.
      * @param {number} index The index of the item to remove.
      * @see Specified by {@link yfiles.collections.IList#removeAt}.
      */
      removeAt(index:number):void;
      /**
      * Gets or sets the item at the given index.
      * @param {number} index The index of the item to access.
      * @return {T} The item at the given index.
      * @see Specified by {@link yfiles.collections.IList#get}.
      */
      get(index:number):T;
      /**
      * Gets or sets the item at the given index.
      * @param {number} index The index of the item to access.
      * @return {T} The item at the given index.
      * @see Specified by {@link yfiles.collections.IList#get}.
      */
      set(index:number,value:T):void;
      /**
      * Gets an {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
      * This method exists for internal purposes mainly, if available the {@link yfiles.collections.IEnumerable#getEnumerator} should be used instead.
      * @return {yfiles.objectcollections.IEnumerator} The {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
      * @see Specified by {@link yfiles.objectcollections.IEnumerable#getObjectEnumerator}.
      */
      getObjectEnumerator():yfiles.objectcollections.IEnumerator;
    }
    var ReadOnlyCollection:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance which wraps the given list.
      * @param {yfiles.collections.IList.<T>} wrapped The list to wrap.
      */
      new <T>(wrapped:yfiles.collections.IList<T>):yfiles.collections.ReadOnlyCollection<T>;
    };
    /**
    * Provides a method to compare two objects of the same type.
    */
    export interface IComparer<T> extends Object{
      /**
      * Compares two objects of type T.
      * @param {T} x The first object.
      * @param {T} y The second object.
      * @return {number} <ul>
      * <li>-1: <code>x</code> is less than <code>y</code></li>
      * <li>0: <code>x</code> is equal to <code>y</code></li>
      * <li>1: <code>x</code> is greater than <code>y</code></li>
      * </ul>
      * @see Specified by {@link yfiles.collections.IComparer#compare}.
      */
      compare(x:T,y:T):number;
    }
    var IComparer:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Interface for collections which dispatch an {@link yfiles.collections.INotifyCollectionChanged#addCollectionChangedListener event} when the collection changes.
    */
    export interface INotifyCollectionChanged extends Object{
      /**
      * Dispatched when the collection changed.
      */
      addCollectionChangedListener(value:(sender:Object,e:yfiles.collections.NotifyCollectionChangedEventArgs)=> void):void;
      /**
      * Dispatched when the collection changed.
      */
      removeCollectionChangedListener(value:(sender:Object,e:yfiles.collections.NotifyCollectionChangedEventArgs)=> void):void;
    }
    var INotifyCollectionChanged:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * The data for an {@link yfiles.collections.INotifyCollectionChanged#addCollectionChangedListener CollectionChanged} event.
    */
    export interface NotifyCollectionChangedEventArgs extends yfiles.system.EventArgs{
      /**
      * The kind of change.
      */
      action:yfiles.collections.NotifyCollectionChangedAction;
      /**
      * A list of the changed items.
      */
      newItems:yfiles.objectcollections.IList;
      /**
      * A list of replaced, removed or moved items.
      */
      oldItems:yfiles.objectcollections.IList;
      /**
      * The starting index at which the change occurred.
      */
      newStartingIndex:number;
      /**
      * The starting index of the elements which were replaced, removed or moved.
      */
      oldStartingIndex:number;
    }
    var NotifyCollectionChangedEventArgs:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance.
      * @param {yfiles.collections.NotifyCollectionChangedAction} action The action which describes the change.
      */
      FromAction:{
        new (action:yfiles.collections.NotifyCollectionChangedAction):yfiles.collections.NotifyCollectionChangedEventArgs;
      };
      /**
      * Creates a new instance.
      * @param {yfiles.collections.NotifyCollectionChangedAction} action The action which describes the change.
      * @param {yfiles.objectcollections.IList} changedItems The changed items.
      */
      FromActionAndChangedItems:{
        new (action:yfiles.collections.NotifyCollectionChangedAction,changedItems:yfiles.objectcollections.IList):yfiles.collections.NotifyCollectionChangedEventArgs;
      };
      /**
      * Creates a new instance.
      * @param {yfiles.collections.NotifyCollectionChangedAction} action The action which describes the change.
      * @param {Object} obj The (only) object which was changed.
      */
      FromActionAndItem:{
        new (action:yfiles.collections.NotifyCollectionChangedAction,obj:Object):yfiles.collections.NotifyCollectionChangedEventArgs;
      };
      /**
      * Creates a new instance.
      * @param {yfiles.collections.NotifyCollectionChangedAction} action The action which describes the change.
      * @param {yfiles.objectcollections.IList} newItems The items which were changed.
      * @param {yfiles.objectcollections.IList} oldItems The items which were removed or replaced.
      */
      FromActionNewItemsAndOldItems:{
        new (action:yfiles.collections.NotifyCollectionChangedAction,newItems:yfiles.objectcollections.IList,oldItems:yfiles.objectcollections.IList):yfiles.collections.NotifyCollectionChangedEventArgs;
      };
      /**
      * Creates a new instance.
      * @param {yfiles.collections.NotifyCollectionChangedAction} action The action which describes the change.
      * @param {Object} o The (only) object which was changed.
      * @param {number} i The index at which the change occurred.
      */
      FromActionItemsAndIndex:{
        new (action:yfiles.collections.NotifyCollectionChangedAction,o:Object,i:number):yfiles.collections.NotifyCollectionChangedEventArgs;
      };
      /**
      * Creates a new instance.
      * @param {yfiles.collections.NotifyCollectionChangedAction} action The action which describes the change.
      * @param {Object} o1 The (only) object which was changed.
      * @param {Object} o2 The (only) object which was replaced or removed.
      */
      FromActionAndItems:{
        new (action:yfiles.collections.NotifyCollectionChangedAction,o1:Object,o2:Object):yfiles.collections.NotifyCollectionChangedEventArgs;
      };
      /**
      * Creates a new instance.
      * @param {yfiles.collections.NotifyCollectionChangedAction} action The action which describes the change.
      * @param {yfiles.objectcollections.IList} newItems The new items.
      * @param {yfiles.objectcollections.IList} oldItems The items which were removed or replaced.
      * @param {number} i The index at which the change started.
      */
      FromActionNewItemsOldItemsAndIndex:{
        new (action:yfiles.collections.NotifyCollectionChangedAction,newItems:yfiles.objectcollections.IList,oldItems:yfiles.objectcollections.IList,i:number):yfiles.collections.NotifyCollectionChangedEventArgs;
      };
      /**
      * Creates a new instance.
      * @param {yfiles.collections.NotifyCollectionChangedAction} action The action which describes the change.
      * @param {yfiles.objectcollections.IList} newItems The changed items.
      * @param {number} i1 The starting index after the change.
      * @param {number} i2 The starting index before the change.
      */
      FromActionNewItemsAndIndices:{
        new (action:yfiles.collections.NotifyCollectionChangedAction,newItems:yfiles.objectcollections.IList,i1:number,i2:number):yfiles.collections.NotifyCollectionChangedEventArgs;
      };
      /**
      * Creates a new instance.
      * @param {yfiles.collections.NotifyCollectionChangedAction} action The action which describes the change.
      * @param {Object} o The (only) object which was changed.
      * @param {number} i1 The index of the object after the change.
      * @param {number} i2 The index of the object before the change.
      */
      FromActionItemsAndIndices:{
        new (action:yfiles.collections.NotifyCollectionChangedAction,o:Object,i1:number,i2:number):yfiles.collections.NotifyCollectionChangedEventArgs;
      };
      /**
      * Creates a new instance.
      * @param {yfiles.collections.NotifyCollectionChangedAction} action The action which describes the change.
      * @param {Object} newItem The object after the change.
      * @param {Object} oldItem The object which was removed or replaced.
      * @param {number} i The index of the object which was changed.
      */
      FromActionNewItemOldItemAndIndex:{
        new (action:yfiles.collections.NotifyCollectionChangedAction,newItem:Object,oldItem:Object,i:number):yfiles.collections.NotifyCollectionChangedEventArgs;
      };
    };
    /**
    * Provides static helper methods which facilitate the handling of {@link yfiles.collections.IEnumerable enumerables}.
    */
    export interface EnumerableExtensions extends Object{
    }
    var EnumerableExtensions:{
      $class:yfiles.lang.Class;
      /**
      * Whether the given value is contained in the enumerable.
      * The {@link yfiles.collections.EqualityComparer#DEFAULT default equality comparer} is used to compare
      * the enumerable's contents with the given value.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to search.
      * @param {TSource} value The value to search for.
      * @return {boolean} <code>true</code> if the enumerable contains the given value.
      */
      enumeratorContains<TSource>(e:yfiles.collections.IEnumerable<TSource>,value:TSource):boolean;
      /**
      * Returns the element at the given <code>index</code> in the enumerable.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to search.
      * @param {number} index The index of the element to return.
      * @return {TSource} The element at the given <code>index</code>.
      * @throws {yfiles.system.ArgumentException} If the <code>index</code> is not within the enumerable's range.
      */
      elementAt<TSource>(e:yfiles.collections.IEnumerable<TSource>,index:number):TSource;
      /**
      * Iterates over the enumerable and invokes the action for each element passing the value as an argument.
      * @param {yfiles.collections.IEnumerable.<T>} e The enumerable to iterate over.
      * @param {function(T)} action The delegate to call.
      */
      forEach<T>(e:yfiles.collections.IEnumerable<T>,action:(obj:T)=> void):void;
      /**
      * Iterates over the enumerable and invokes the action for each element passing the value and index as arguments.
      * @param {yfiles.collections.IEnumerable.<T>} e The enumerable to iterate over.
      * @param {function(T, number)} action The delegate to call.
      */
      forEachWithIndex<T>(e:yfiles.collections.IEnumerable<T>,action:(arg1:T,arg2:number)=> void):void;
      /**
      * Returns the number of elements contained in the enumerable.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to count.
      * @return {number} The number of elements contained in the enumerable.
      */
      count<TSource>(e:yfiles.collections.IEnumerable<TSource>):number;
      /**
      * Returns the first element of the enumerable.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to return the first element for.
      * @return {TSource} The first element of the enumerable.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      * @throws {yfiles.system.InvalidOperationException} If the enumerable is empty.
      */
      getFirstElement<TSource>(e:yfiles.collections.IEnumerable<TSource>):TSource;
      /**
      * Returns the first element of the enumerable which matches a given filter.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to return the first element for.
      * @param {function(TSource):boolean} predicate A function with the signature <code>function(element):boolean</code> which returns
      * <code>true</code> if the given element should be returned
      * @return {TSource} The first matching element of the enumerable.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      * @throws {yfiles.system.InvalidOperationException} If the enumerable does not contain a matching element.
      */
      getFirstElementWithPredicate<TSource>(e:yfiles.collections.IEnumerable<TSource>,predicate:(arg:TSource)=>boolean):TSource;
      /**
      * Returns the first element of the enumerable or the default for the enumerable's element type if the enumerable is empty.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to return the first element for.
      * @return {TSource} The first element of the enumerable or the default value for <code>TSource</code>.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      */
      getFirstElementOrDefault<TSource>(e:yfiles.collections.IEnumerable<TSource>):TSource;
      /**
      * Returns the first element of the enumerable which matches a given filter 
      * or the default for the enumerable's element type if there is no such element.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to return the first element for.
      * @param {function(TSource):boolean} predicate A function with the signature <code>function(element):boolean</code> which returns
      * <code>true</code> if the given element should be returned
      * @return {TSource} The first element of the enumerable or the default value for <code>TSource</code>.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      */
      getFirstElementOrDefaultWithPredicate<TSource>(e:yfiles.collections.IEnumerable<TSource>,predicate:(arg:TSource)=>boolean):TSource;
      /**
      * Returns the last element of the enumerable or the default for the enumerable's element type if the enumerable is empty.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to return the last element for.
      * @return {TSource} The last element of the enumerable or the default value for <code>TSource</code>.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      */
      getLastElementOrDefault<TSource>(e:yfiles.collections.IEnumerable<TSource>):TSource;
      /**
      * Returns the last element of the enumerable.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to return the last element for.
      * @return {TSource} The last element of the enumerable.
      * @throws {yfiles.system.ArgumentNullException} If the given enumerable is <code>null</code>.
      * @throws {yfiles.system.InvalidOperationException} If the enumerable is empty.
      */
      getLastElement<TSource>(e:yfiles.collections.IEnumerable<TSource>):TSource;
      /**
      * Converts a untyped enumerable into an enumerable with the given type.
      * The source enumerable may contain elements which are not of the given type.
      * Those elements will not be contained in the returned enumerable.
      * @param {yfiles.objectcollections.IEnumerable} e The enumerable to convert.
      * @return {yfiles.collections.IEnumerable.<TSource>} A typed enumerable.
      */
      ofType<TSource>(type:yfiles.lang.Class,e:yfiles.objectcollections.IEnumerable):yfiles.collections.IEnumerable<TSource>;
      /**
      * Returns an enumerable which only contains elements of the source enumerable which match a given <code>predicate</code>.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The source enumerable.
      * @param {function(Object):boolean} predicate A function with the signature <code>function(element):boolean</code> which returns
      * <code>true</code> if the given element should be included in the resulting enumerable.
      * @return {yfiles.collections.IEnumerable.<TSource>} An enumerable which contains the elements of the source enumeration which match the given <code>predicate</code>.
      */
      where<TSource>(e:yfiles.collections.IEnumerable<TSource>,predicate:(arg:Object)=>boolean):yfiles.collections.IEnumerable<TSource>;
      /**
      * Creates a flattened view of a given enumerable using the given <code>selector</code> function which returns
      * an enumerable for each element of the source enumerable.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The source enumerable.
      * @param {function(TSource):yfiles.collections.IEnumerable.<TSource>} selector A function with the signature <code>function(element):IEnumerable</code> which returns
      * an enumerable for each element of the source enumerable.
      * @return {yfiles.collections.IEnumerable.<TSource>} A flattened view of the given enumerable. The enumerables which are returned by the <code>selector</code>
      * method for each element are concatenated in the result.
      */
      selectMany<TSource>(e:yfiles.collections.IEnumerable<TSource>,selector:(arg:TSource)=>yfiles.collections.IEnumerable<TSource>):yfiles.collections.IEnumerable<TSource>;
      /**
      * Creates an array with the values of the enumerable.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The source enumerable to create the array from.
      * @return {TSource[]} An array with the enumerable's elements.
      */
      toArray<TSource>(e:yfiles.collections.IEnumerable<TSource>):TSource[];
      /**
      * Creates a {@link yfiles.collections.List} with the values of the enumerable.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The source enumerable to create the {@link yfiles.collections.List} from.
      * @return {yfiles.collections.List.<TSource>} An {@link yfiles.collections.List} with the enumerable's elements.
      */
      toList<TSource>(e:yfiles.collections.IEnumerable<TSource>):yfiles.collections.List<TSource>;
      /**
      * Calculates the sum of the elements of the enumerable.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to calculate the sum for.
      * @param {function(TSource):number} selector A function with the signature <code>function(element):Number</code>
      * which returns a numeric value for the given element.
      * @return {number} The sum of the elements of the enumerable.
      */
      sum<TSource>(e:yfiles.collections.IEnumerable<TSource>,selector:(arg:TSource)=>number):number;
      /**
      * Casts the elements of the enumerable to the specified type and returns a typed {@link yfiles.collections.IEnumerable}.
      * This method is kept for compatibility reasons. 
      * As JavaScript does not require casting this method returns the original enumerable.
      * @param {yfiles.objectcollections.IEnumerable} source The enumerable to cast the elements.
      * @return {yfiles.collections.IEnumerable.<TResult>} This implementation returns the original enumerable.
      */
      cast<TResult>(source:yfiles.objectcollections.IEnumerable):yfiles.collections.IEnumerable<TResult>;
      /**
      * Whether the enumerable contains any elements.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to search.
      * @return {boolean}  Whether the enumerable contains any elements.
      * @throws {yfiles.system.ArgumentNullException} <code>e</code> is <code>null</code>.
      */
      notEmpty<TSource>(e:yfiles.collections.IEnumerable<TSource>):boolean;
      /**
      * Whether the enumerable contains any elements matching the given <code>predicate</code>.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to search.
      * @param {function(TSource):boolean} predicate A function with the signature <code>function(element):boolean</code>
      * which returns <code>true</code> if the element matches a condition.
      * @return {boolean}  Whether the enumerable contains any elements matching the given <code>predicate</code>.
      * @throws {yfiles.system.ArgumentNullException} <code>e</code> is <code>null</code>.
      * @throws {yfiles.system.ArgumentNullException} <code>predicate</code> is <code>null</code>.
      */
      any<TSource>(e:yfiles.collections.IEnumerable<TSource>,predicate:(arg:TSource)=>boolean):boolean;
      /**
      * Whether all elements of the enumerable match the given <code>predicate</code>.
      * @param {yfiles.collections.IEnumerable.<TSource>} e The enumerable to search.
      * @param {function(TSource):boolean} predicate A function with the signature <code>function(element):boolean</code>
      * which returns <code>true</code> if the element matches a condition.
      * @return {boolean}  Whether all elements of the enumerable match the given <code>predicate</code>.
      * @throws {yfiles.system.ArgumentNullException} <code>e</code> is <code>null</code>.
      * @throws {yfiles.system.ArgumentNullException} <code>predicate</code> is <code>null</code>.
      */
      every<TSource>(e:yfiles.collections.IEnumerable<TSource>,predicate:(arg:TSource)=>boolean):boolean;
      /**
      * Projects each element of the enumeration into a new element.
      * @param {yfiles.collections.IEnumerable.<TSource>} source The enumerable to create the projection for.
      * @param {function(TSource):TResult} selector A function with the signature <code>function(element):TResult</code>
      * which converts each element into a new element of the type <code>TResult</code>.
      * @return {yfiles.collections.IEnumerable.<TResult>} A projection of the original enumerable.
      */
      selectWithSelector<TSource,TResult>(source:yfiles.collections.IEnumerable<TSource>,selector:(arg:TSource)=>TResult):yfiles.collections.IEnumerable<TResult>;
      /**
      * Projects each element of the enumeration into a new element.
      * @param {yfiles.collections.IEnumerable.<TSource>} source The enumerable to create the projection for.
      * @param {function(TSource, number):TResult} selector A function with the signature <code>function(element, index):TResult</code>
      * which converts each element into a new element of the type <code>TResult</code> depending on the element's index.
      * @return {yfiles.collections.IEnumerable.<TResult>} A projection of the original enumerable.
      */
      select<TSource,TResult>(source:yfiles.collections.IEnumerable<TSource>,selector:(arg1:TSource,arg2:number)=>TResult):yfiles.collections.IEnumerable<TResult>;
      /**
      * Returns an enumerable which contains the elements of the original enumerable in reverse order.
      * @param {yfiles.collections.IEnumerable.<TSource>} source The enumerable to revert.
      * @return {yfiles.collections.IEnumerable.<TSource>} An enumerable which contains the elements of the original enumerable in reverse order.
      */
      reverse<TSource>(source:yfiles.collections.IEnumerable<TSource>):yfiles.collections.IEnumerable<TSource>;
      /**
      * Returns elements from an enumerable as long as the given <code>predicate</code> is <code>true</code>.
      * @param {yfiles.collections.IEnumerable.<TSource>} source The enumerable to search.
      * @param {function(TSource):boolean} predicate A function with the signature <code>function(element):boolean</code>
      * which returns <code>true</code> as long as the elements should be added to the returned enumerable.
      * @return {yfiles.collections.IEnumerable.<TSource>} A subset of the original enumerable.
      */
      takeWhile<TSource>(source:yfiles.collections.IEnumerable<TSource>,predicate:(arg:TSource)=>boolean):yfiles.collections.IEnumerable<TSource>;
      /**
      * Applies an <code>func</code> function over the enumerable's elements.
      * @param {yfiles.collections.IEnumerable.<TSource>} source The enumeration to accumulate.
      * @param {TAccumulate} seed The start value for the accumulator.
      * @param {function(TAccumulate, TSource):TAccumulate} func A function with the signature <code>function(seed,element):TAccumulate</code> which
      * "adds" (accumulates) a value depending on the element to the seed value and returns the result.
      * @return {TAccumulate} The final value of the accumulator.
      */
      aggregate<TSource,TAccumulate>(source:yfiles.collections.IEnumerable<TSource>,seed:TAccumulate,func:(arg1:TAccumulate,arg2:TSource)=>TAccumulate):TAccumulate;
    };
    /**
    * The default implementation for {@link yfiles.collections.IDictionary}.
    */
    export interface Dictionary<TKey,TValue> extends Object,yfiles.collections.IDictionary<TKey,TValue>,yfiles.collections.ICollection<yfiles.collections.KeyValuePair<TKey,TValue>>,yfiles.collections.IEnumerable<yfiles.collections.KeyValuePair<TKey,TValue>>,yfiles.objectcollections.IDictionary,yfiles.objectcollections.ICollection,yfiles.objectcollections.IEnumerable{
      /**
      * Removes the key/value pair which is represented by the given <code>key</code>.
      * @param {Object} key The key of the key/value pair to remove.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#removeWithKey}.
      */
      removeWithKey(key:Object):void;
      /**
      * Gets or sets the {@link Object} with the specified key.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#getObject}.
      */
      getObject(key:Object):Object;
      /**
      * Gets or sets the {@link Object} with the specified key.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#getObject}.
      */
      putObject(key:Object,value:Object):void;
      /**
      * Returns an enumerator that iterates through a collection.
      * @return {yfiles.collections.IEnumerator.<yfiles.collections.KeyValuePair.<TKey,TValue>>} An yfiles.system.IEnumerator object that can be used to iterate through the collection.
      * @see Specified by {@link yfiles.collections.IEnumerable#getEnumerator}.
      */
      getEnumerator():yfiles.collections.IEnumerator<yfiles.collections.KeyValuePair<TKey,TValue>>;
      /**
      * Returns an enumerator that iterates through a collection.
      * @return {yfiles.objectcollections.IDictionaryEnumerator} An yfiles.system.IEnumerator object that can be used to iterate through the collection.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#getDictionaryEnumerator}.
      */
      getDictionaryEnumerator():yfiles.objectcollections.IDictionaryEnumerator;
      /**
      * Returns an enumerator that iterates through a collection.
      * @return {yfiles.objectcollections.IEnumerator} An yfiles.system.IEnumerator object that can be used to iterate through the collection.
      * @see Specified by {@link yfiles.objectcollections.IEnumerable#getObjectEnumerator}.
      */
      getObjectEnumerator():yfiles.objectcollections.IEnumerator;
      /**
      * Copies the elements of this collection into the given <code>array</code> starting at the given <code>arrayIndex</code>.
      * @param {Object} array The array to copy the elements to.
      * @param {number} arrayIndex The index in the given array where the first element should be copied to.
      * @see Specified by {@link yfiles.objectcollections.ICollection#copyTo}.
      */
      copyTo(array:Object,index:number):void;
      /**
      * The number of elements in this collection.
      * @see Specified by {@link yfiles.collections.ICollection#count}.
      */
      count:number;
      /**
      * @see Specified by {@link yfiles.objectcollections.ICollection#syncRoot}.
      */
      syncRoot:Object;
      /**
      * @see Specified by {@link yfiles.objectcollections.ICollection#isSynchronized}.
      */
      isSynchronized:boolean;
      /**
      * Whether this collection is read-only.
      * @see Specified by {@link yfiles.collections.ICollection#isReadOnly}.
      */
      isReadOnly:boolean;
      /**
      * Whether this dictionary has a fixed size.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#isFixedSize}.
      */
      isFixedSize:boolean;
      /**
      * Copies all elements of this collection into the given array.
      * @param {T[]} array The array to copy the elements to.
      * @param {number} arrayIndex The index in the given array where the first element should be copied to.
      * @see Specified by {@link yfiles.collections.ICollection#copyToArrayAt}.
      */
      copyToArrayAt(array:yfiles.collections.KeyValuePair<TKey,TValue>[],arrayIndex:number):void;
      /**
      * Whether this dictionary's key collection contains the given value.
      * @param {Object} value The value to search for.
      * @return {boolean} <code>true</code> if this dictionary contains the given <code>value</code>.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#containsWithValue}.
      */
      containsWithValue(key:Object):boolean;
      /**
      * Adds the given <code>key</code> / <code>value</code> pair to this dictionary.
      * @param {Object} key The key to which the given value should be mapped.
      * @param {Object} value The value which should be mapped to the given key.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#addWithKeyAndValue}.
      */
      addWithKeyAndValue(key:Object,value:Object):void;
      /**
      * Removes all items from this collection.
      * @see Specified by {@link yfiles.collections.ICollection#clear}.
      */
      clear():void;
      /**
      * Removes the given <code>item</code> from this collection.
      * @param {T} item The item to remove.
      * @return {boolean} Whether the item was removed from the collection.
      * @see Specified by {@link yfiles.collections.ICollection#remove}.
      */
      remove(item:yfiles.collections.KeyValuePair<TKey,TValue>):boolean;
      /**
      * Adds the given <code>item</code> to the collection.
      * @param {T} item 
      * @see Specified by {@link yfiles.collections.ICollection#add}.
      */
      add(item:yfiles.collections.KeyValuePair<TKey,TValue>):void;
      /**
      * Whether the given <code>item</code> is contained in this collection.
      * @param {T} item The item to search for.
      * @return {boolean} <code>true</code> if the given <code>item</code> is contained in this collection.
      * @see Specified by {@link yfiles.collections.ICollection#contains}.
      */
      contains(item:yfiles.collections.KeyValuePair<TKey,TValue>):boolean;
      /**
      * Adds the given <code>key</code> / <code>value</code> pair to this dictionary.
      * @param {TKey} key The key to which the given value should be mapped.
      * @param {TValue} value The value which should be mapped to the given key.
      * @see Specified by {@link yfiles.collections.IDictionary#addKeyValue}.
      */
      addKeyValue(key:TKey,value:TValue):void;
      /**
      * Whether this dictionary's key collection contains the given key.
      * @param {TKey} key The key to search for.
      * @return {boolean} <code>true</code> if this dictionary contains the given <code>key</code>.
      * @see Specified by {@link yfiles.collections.IDictionary#containsKey}.
      */
      containsKey(key:TKey):boolean;
      /**
      * Whether this dictionary contains the given <code>value</code>.
      * @param {TValue} value The value to search for.
      * @return {boolean} <code>true</code> if this dictionary contains the given value.
      */
      containsValue(value:TValue):boolean;
      /**
      * Removes the key/value pair which is represented by the given <code>key</code>.
      * @param {TKey} key The key of the key/value pair to remove.
      * @return {boolean} <code>true</code> if a key/value pair with the given key was removed from this collection.
      * @see Specified by {@link yfiles.collections.IDictionary#removeKey}.
      */
      removeKey(key:TKey):boolean;
      /**
      * Tries to get the <code>value</code> of the key/value pair with the given <code>key</code>.
      * @param {TKey} key The key of the key/value pair to search for.
      * @param {TValue} value A reference to store the value in if a key/value pair with the given key can be found. If not, this
      * dictionary's default value is stored.
      * @return {boolean} <code>true</code> if a key/value pair with the given key can be found.
      * @see Specified by {@link yfiles.collections.IDictionary#tryGetValue}.
      */
      tryGetValue(key:TKey,value:{value:TValue;}):boolean;
      /**
      * A {@link yfiles.collections.ICollection} of the keys of this dictionary.
      * @see Specified by {@link yfiles.collections.IDictionary#keys}.
      */
      keys:yfiles.collections.ICollection<TKey>;
      /**
      * Gets or sets the value of the key/value pair with the given key.
      * Setter: if there is already a key/value pair with the given key in the dictionary its value will be overridden. If not
      * a new key/value pair will be added.
      * Getter: if there is no key/value pair with the given key in this dictionary an exception will be thrown.
      * @param {TKey} key 
      * @return {TValue} 
      * @throws {yfiles.system.KeyNotFoundException} (Getter only): The given <code>key</code> cannot be found in this dictionary.
      * @see Specified by {@link yfiles.collections.IDictionary#get}.
      */
      get(key:TKey):TValue;
      /**
      * Gets or sets the value of the key/value pair with the given key.
      * Setter: if there is already a key/value pair with the given key in the dictionary its value will be overridden. If not
      * a new key/value pair will be added.
      * Getter: if there is no key/value pair with the given key in this dictionary an exception will be thrown.
      * @param {TKey} key 
      * @return {TValue} 
      * @throws {yfiles.system.KeyNotFoundException} (Getter only): The given <code>key</code> cannot be found in this dictionary.
      * @see Specified by {@link yfiles.collections.IDictionary#get}.
      */
      put(key:TKey,value:TValue):void;
      /**
      * A {@link yfiles.collections.ICollection} of the values of this dictionary.
      * @see Specified by {@link yfiles.collections.IDictionary#values}.
      */
      values:yfiles.collections.ICollection<TValue>;
    }
    export module Dictionary{
      /**
      * The {@link yfiles.objectcollections.IDictionaryEnumerator} implementation for {@link yfiles.collections.Dictionary}.
      */
      export interface DictionaryEnumerator<TKey,TValue> extends Object,yfiles.objectcollections.IDictionaryEnumerator,yfiles.collections.IEnumerator<yfiles.collections.KeyValuePair<TKey,TValue>>{
        /**
        * Causes the implementor to free all resources.
        * @see Specified by {@link yfiles.system.IDisposable#dispose}.
        */
        dispose():void;
        /**
        * Moves this enumerator to the next element.
        * A newly created enumerator's {@link yfiles.objectcollections.IEnumerator#currentObject current position} is before the first element. Thus, this method
        * must be called before first access to the {@link yfiles.objectcollections.IEnumerator#currentObject} property. The same applies to the state after 
        * calling {@link yfiles.objectcollections.IEnumerator#reset}.
        * @return {boolean} <code>true</code> if the enumerator was moved to a valid position
        * @see Specified by {@link yfiles.objectcollections.IEnumerator#moveNext}.
        */
        moveNext():boolean;
        /**
        * Resets the enumerator to its starting state.
        * In other words: sets the current position before the first element.
        * @see Specified by {@link yfiles.objectcollections.IEnumerator#reset}.
        */
        reset():void;
        /**
        * Gets the element at the enumerator's current position.
        * This value is undefined if the enumerator is in initial state (after creation or {@link yfiles.collections.IEnumerator#reset}) or has been moved past the
        * end of the represented collection.
        * @see Specified by {@link yfiles.collections.IEnumerator#current}.
        */
        current:yfiles.collections.KeyValuePair<TKey,TValue>;
        /**
        * The key of the {@link yfiles.objectcollections.IEnumerator#currentObject current key/value pair}.
        * @see Specified by {@link yfiles.objectcollections.IDictionaryEnumerator#key}.
        */
        key:Object;
        /**
        * The value of the {@link yfiles.objectcollections.IEnumerator#currentObject current key/value pair}.
        * @see Specified by {@link yfiles.objectcollections.IDictionaryEnumerator#value}.
        */
        value:Object;
      }
      /**
      * The key {@link yfiles.collections.ICollection collection} of a {@link yfiles.collections.Dictionary}.
      */
      export interface DictionaryKeyCollection<TKey,TValue> extends Object,yfiles.collections.ICollection<TKey>{
        /**
        * Gets an {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance.
        * @return {yfiles.collections.IEnumerator.<T>} The {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance
        * @see Specified by {@link yfiles.collections.IEnumerable#getEnumerator}.
        */
        getEnumerator():yfiles.collections.IEnumerator<TKey>;
        /**
        * The number of elements in this collection.
        * @see Specified by {@link yfiles.collections.ICollection#count}.
        */
        count:number;
        /**
        * Whether this collection is read-only.
        * @see Specified by {@link yfiles.collections.ICollection#isReadOnly}.
        */
        isReadOnly:boolean;
        /**
        * Copies all elements of this collection into the given array.
        * @param {T[]} array The array to copy the elements to.
        * @param {number} arrayIndex The index in the given array where the first element should be copied to.
        * @see Specified by {@link yfiles.collections.ICollection#copyToArrayAt}.
        */
        copyToArrayAt(array:TKey[],arrayIndex:number):void;
        /**
        * Removes all items from this collection.
        * @see Specified by {@link yfiles.collections.ICollection#clear}.
        */
        clear():void;
        /**
        * Removes the given <code>item</code> from this collection.
        * @param {T} item The item to remove.
        * @return {boolean} Whether the item was removed from the collection.
        * @see Specified by {@link yfiles.collections.ICollection#remove}.
        */
        remove(item:TKey):boolean;
        /**
        * Adds the given <code>item</code> to the collection.
        * @param {T} item 
        * @see Specified by {@link yfiles.collections.ICollection#add}.
        */
        add(item:TKey):void;
        /**
        * Whether the given <code>item</code> is contained in this collection.
        * @param {T} item The item to search for.
        * @return {boolean} <code>true</code> if the given <code>item</code> is contained in this collection.
        * @see Specified by {@link yfiles.collections.ICollection#contains}.
        */
        contains(item:TKey):boolean;
        /**
        * Gets an {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
        * This method exists for internal purposes mainly, if available the {@link yfiles.collections.IEnumerable#getEnumerator} should be used instead.
        * @return {yfiles.objectcollections.IEnumerator} The {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
        * @see Specified by {@link yfiles.objectcollections.IEnumerable#getObjectEnumerator}.
        */
        getObjectEnumerator():yfiles.objectcollections.IEnumerator;
        /**
        * Gets an enumerator which iterates over the keys in this collection.
        * @return {yfiles.collections.Dictionary.DictionaryKeyEnumerator.<TKey,TValue>} An enumerator which iterates over the keys in this collection.
        */
        getKeyCollectionEnumerator():yfiles.collections.Dictionary.DictionaryKeyEnumerator<TKey,TValue>;
      }
      /**
      * An {@link yfiles.collections.IEnumerator} which iterates over the keys of a {@link yfiles.collections.Dictionary.DictionaryKeyCollection}.
      */
      export interface DictionaryKeyEnumerator<TKey,TValue> extends Object,yfiles.collections.IEnumerator<TKey>{
        /**
        * Causes the implementor to free all resources.
        * @see Specified by {@link yfiles.system.IDisposable#dispose}.
        */
        dispose():void;
        /**
        * Moves this enumerator to the next element.
        * A newly created enumerator's {@link yfiles.objectcollections.IEnumerator#currentObject current position} is before the first element. Thus, this method
        * must be called before first access to the {@link yfiles.objectcollections.IEnumerator#currentObject} property. The same applies to the state after 
        * calling {@link yfiles.objectcollections.IEnumerator#reset}.
        * @return {boolean} <code>true</code> if the enumerator was moved to a valid position
        * @see Specified by {@link yfiles.objectcollections.IEnumerator#moveNext}.
        */
        moveNext():boolean;
        /**
        * Resets the enumerator to its starting state.
        * In other words: sets the current position before the first element.
        * @see Specified by {@link yfiles.objectcollections.IEnumerator#reset}.
        */
        reset():void;
        /**
        * Gets the element at the enumerator's current position.
        * This value is undefined if the enumerator is in initial state (after creation or {@link yfiles.collections.IEnumerator#reset}) or has been moved past the
        * end of the represented collection.
        * @see Specified by {@link yfiles.collections.IEnumerator#current}.
        */
        current:TKey;
      }
      /**
      * A collection of the values of a {@link yfiles.collections.Dictionary}.
      */
      export interface DictionaryValueCollection<TKey,TValue> extends Object,yfiles.collections.ICollection<TValue>{
        /**
        * Gets an {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance.
        * @return {yfiles.collections.IEnumerator.<T>} The {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance
        * @see Specified by {@link yfiles.collections.IEnumerable#getEnumerator}.
        */
        getEnumerator():yfiles.collections.IEnumerator<TValue>;
        /**
        * The number of elements in this collection.
        * @see Specified by {@link yfiles.collections.ICollection#count}.
        */
        count:number;
        /**
        * Whether this collection is read-only.
        * @see Specified by {@link yfiles.collections.ICollection#isReadOnly}.
        */
        isReadOnly:boolean;
        /**
        * Copies all elements of this collection into the given array.
        * @param {T[]} array The array to copy the elements to.
        * @param {number} arrayIndex The index in the given array where the first element should be copied to.
        * @see Specified by {@link yfiles.collections.ICollection#copyToArrayAt}.
        */
        copyToArrayAt(array:TValue[],arrayIndex:number):void;
        /**
        * Removes all items from this collection.
        * @see Specified by {@link yfiles.collections.ICollection#clear}.
        */
        clear():void;
        /**
        * Removes the given <code>item</code> from this collection.
        * @param {T} item The item to remove.
        * @return {boolean} Whether the item was removed from the collection.
        * @see Specified by {@link yfiles.collections.ICollection#remove}.
        */
        remove(item:TValue):boolean;
        /**
        * Adds the given <code>item</code> to the collection.
        * @param {T} item 
        * @see Specified by {@link yfiles.collections.ICollection#add}.
        */
        add(item:TValue):void;
        /**
        * Whether the given <code>item</code> is contained in this collection.
        * @param {T} item The item to search for.
        * @return {boolean} <code>true</code> if the given <code>item</code> is contained in this collection.
        * @see Specified by {@link yfiles.collections.ICollection#contains}.
        */
        contains(item:TValue):boolean;
        /**
        * Gets an {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
        * This method exists for internal purposes mainly, if available the {@link yfiles.collections.IEnumerable#getEnumerator} should be used instead.
        * @return {yfiles.objectcollections.IEnumerator} The {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
        * @see Specified by {@link yfiles.objectcollections.IEnumerable#getObjectEnumerator}.
        */
        getObjectEnumerator():yfiles.objectcollections.IEnumerator;
        /**
        * Gets an enumerator which iterates over the values in this collection.
        * @return {yfiles.collections.Dictionary.DictionaryValueEnumerator.<TKey,TValue>} An enumerator which iterates over the values in this collection.
        */
        getValueCollectionEnumerator():yfiles.collections.Dictionary.DictionaryValueEnumerator<TKey,TValue>;
      }
      /**
      * An {@link yfiles.collections.IEnumerator} which iterates over the values of a {@link yfiles.collections.Dictionary.DictionaryValueCollection}.
      */
      export interface DictionaryValueEnumerator<TKey,TValue> extends Object,yfiles.collections.IEnumerator<TValue>{
        /**
        * Causes the implementor to free all resources.
        * @see Specified by {@link yfiles.system.IDisposable#dispose}.
        */
        dispose():void;
        /**
        * Moves this enumerator to the next element.
        * A newly created enumerator's {@link yfiles.objectcollections.IEnumerator#currentObject current position} is before the first element. Thus, this method
        * must be called before first access to the {@link yfiles.objectcollections.IEnumerator#currentObject} property. The same applies to the state after 
        * calling {@link yfiles.objectcollections.IEnumerator#reset}.
        * @return {boolean} <code>true</code> if the enumerator was moved to a valid position
        * @see Specified by {@link yfiles.objectcollections.IEnumerator#moveNext}.
        */
        moveNext():boolean;
        /**
        * Resets the enumerator to its starting state.
        * In other words: sets the current position before the first element.
        * @see Specified by {@link yfiles.objectcollections.IEnumerator#reset}.
        */
        reset():void;
        /**
        * Gets the element at the enumerator's current position.
        * This value is undefined if the enumerator is in initial state (after creation or {@link yfiles.collections.IEnumerator#reset}) or has been moved past the
        * end of the represented collection.
        * @see Specified by {@link yfiles.collections.IEnumerator#current}.
        */
        current:TValue;
        /**
        * The current value of this enumerator.
        */
        currentDictionaryObject:Object;
      }
    }
    var Dictionary:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance.
      */
      new <TKey,TValue>():yfiles.collections.Dictionary<TKey,TValue>;
      /**
      * Creates a new instance with the given initial capacity.
      * The actual capacity is ignored since it doesn't matter for this implementation.
      * @param {number} capacity The initial capacity of this dictionary.
      */
      WithCapacity:{
        new <TKey,TValue>(capacity:number):yfiles.collections.Dictionary<TKey,TValue>;
      };
      /**
      * Creates a new instance with the given {@link yfiles.collections.IEqualityComparer} to compare the keys.
      * @param {yfiles.collections.IEqualityComparer.<TKey>} equalityComparer The {@link yfiles.collections.IEqualityComparer} used to compare the keys.
      */
      WithEqualityComparer:{
        new <TKey,TValue>(equalityComparer:yfiles.collections.IEqualityComparer<TKey>):yfiles.collections.Dictionary<TKey,TValue>;
      };
      DictionaryEnumerator:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance for the given dictionary.
        * @param {yfiles.collections.Dictionary.<TKey,TValue>} dict The dictionary to iterate over.
        */
        new <TKey,TValue>(dict:yfiles.collections.Dictionary<TKey,TValue>):yfiles.collections.Dictionary<TKey,TValue>;
      };
      DictionaryKeyCollection:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance for the given dictionary.
        * @param {yfiles.collections.Dictionary.<TKey,TValue>} dict The dictionary to create this key collection for.
        */
        new <TKey,TValue>(dict:yfiles.collections.Dictionary<TKey,TValue>):yfiles.collections.Dictionary<TKey,TValue>;
      };
      DictionaryKeyEnumerator:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance which is backed by the given {@link yfiles.collections.Dictionary.DictionaryEnumerator}.
        * @param {yfiles.collections.Dictionary.DictionaryEnumerator.<TKey,TValue>} dict The {@link yfiles.collections.Dictionary.DictionaryEnumerator} which is used as backing enumerator.
        */
        new <TKey,TValue>(dict:yfiles.collections.Dictionary.DictionaryEnumerator<TKey,TValue>):yfiles.collections.Dictionary<TKey,TValue>;
      };
      DictionaryValueCollection:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance for the given dictionary.
        * @param {yfiles.collections.Dictionary.<TKey,TValue>} dict The dictionary to create this value collection for.
        */
        new <TKey,TValue>(dict:yfiles.collections.Dictionary<TKey,TValue>):yfiles.collections.Dictionary<TKey,TValue>;
      };
      DictionaryValueEnumerator:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance which is backed by the given {@link yfiles.collections.Dictionary.DictionaryEnumerator}.
        * @param {yfiles.collections.Dictionary.DictionaryEnumerator.<TKey,TValue>} dict The {@link yfiles.collections.Dictionary.DictionaryEnumerator} which is used to iterate over a dictionary's values.
        */
        new <TKey,TValue>(dict:yfiles.collections.Dictionary.DictionaryEnumerator<TKey,TValue>):yfiles.collections.Dictionary<TKey,TValue>;
      };
    };
    /**
    * A collection of value objects which are mapped to key objects and can be queried using their keys.
    * The keys must have a well defined <code>hashCode</code> method that must not change between registering a value for the key
    * and retrieving a value using the key.
    * Thus it is advisable to use stable, i.e. immutable, objects as the key.
    */
    export interface IDictionary<TKey,TValue> extends Object,yfiles.collections.ICollection<yfiles.collections.KeyValuePair<TKey,TValue>>{
      /**
      * Adds the given <code>key</code> / <code>value</code> pair to this dictionary.
      * @param {TKey} key The key to which the given value should be mapped.
      * @param {TValue} value The value which should be mapped to the given key.
      * @see Specified by {@link yfiles.collections.IDictionary#addKeyValue}.
      */
      addKeyValue(key:TKey,value:TValue):void;
      /**
      * Whether this dictionary's key collection contains the given key.
      * @param {TKey} key The key to search for.
      * @return {boolean} <code>true</code> if this dictionary contains the given <code>key</code>.
      * @see Specified by {@link yfiles.collections.IDictionary#containsKey}.
      */
      containsKey(key:TKey):boolean;
      /**
      * Removes the key/value pair which is represented by the given <code>key</code>.
      * @param {TKey} key The key of the key/value pair to remove.
      * @return {boolean} <code>true</code> if a key/value pair with the given key was removed from this collection.
      * @see Specified by {@link yfiles.collections.IDictionary#removeKey}.
      */
      removeKey(key:TKey):boolean;
      /**
      * Tries to get the <code>value</code> of the key/value pair with the given <code>key</code>.
      * @param {TKey} key The key of the key/value pair to search for.
      * @param {TValue} value A reference to store the value in if a key/value pair with the given key can be found. If not, this
      * dictionary's default value is stored.
      * @return {boolean} <code>true</code> if a key/value pair with the given key can be found.
      * @see Specified by {@link yfiles.collections.IDictionary#tryGetValue}.
      */
      tryGetValue(key:TKey,value:{value:TValue;}):boolean;
      /**
      * A {@link yfiles.collections.ICollection} of the keys of this dictionary.
      * @see Specified by {@link yfiles.collections.IDictionary#keys}.
      */
      keys:yfiles.collections.ICollection<TKey>;
      /**
      * Gets or sets the value of the key/value pair with the given key.
      * Setter: if there is already a key/value pair with the given key in the dictionary its value will be overridden. If not
      * a new key/value pair will be added.
      * Getter: if there is no key/value pair with the given key in this dictionary an exception will be thrown.
      * @param {TKey} key 
      * @return {TValue} 
      * @throws {yfiles.system.KeyNotFoundException} (Getter only): The given <code>key</code> cannot be found in this dictionary.
      * @see Specified by {@link yfiles.collections.IDictionary#get}.
      */
      get(key:TKey):TValue;
      /**
      * Gets or sets the value of the key/value pair with the given key.
      * Setter: if there is already a key/value pair with the given key in the dictionary its value will be overridden. If not
      * a new key/value pair will be added.
      * Getter: if there is no key/value pair with the given key in this dictionary an exception will be thrown.
      * @param {TKey} key 
      * @return {TValue} 
      * @throws {yfiles.system.KeyNotFoundException} (Getter only): The given <code>key</code> cannot be found in this dictionary.
      * @see Specified by {@link yfiles.collections.IDictionary#get}.
      */
      put(key:TKey,value:TValue):void;
      /**
      * A {@link yfiles.collections.ICollection} of the values of this dictionary.
      * @see Specified by {@link yfiles.collections.IDictionary#values}.
      */
      values:yfiles.collections.ICollection<TValue>;
    }
    var IDictionary:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Defines methods to manipulate a collection of objects with the same type.
    */
    export interface ICollection<T> extends Object,yfiles.collections.IEnumerable<T>{
      /**
      * The number of elements in this collection.
      * @see Specified by {@link yfiles.collections.ICollection#count}.
      */
      count:number;
      /**
      * Whether this collection is read-only.
      * @see Specified by {@link yfiles.collections.ICollection#isReadOnly}.
      */
      isReadOnly:boolean;
      /**
      * Copies all elements of this collection into the given array.
      * @param {T[]} array The array to copy the elements to.
      * @param {number} arrayIndex The index in the given array where the first element should be copied to.
      * @see Specified by {@link yfiles.collections.ICollection#copyToArrayAt}.
      */
      copyToArrayAt(array:T[],arrayIndex:number):void;
      /**
      * Removes all items from this collection.
      * @see Specified by {@link yfiles.collections.ICollection#clear}.
      */
      clear():void;
      /**
      * Removes the given <code>item</code> from this collection.
      * @param {T} item The item to remove.
      * @return {boolean} Whether the item was removed from the collection.
      * @see Specified by {@link yfiles.collections.ICollection#remove}.
      */
      remove(item:T):boolean;
      /**
      * Adds the given <code>item</code> to the collection.
      * @param {T} item 
      * @see Specified by {@link yfiles.collections.ICollection#add}.
      */
      add(item:T):void;
      /**
      * Whether the given <code>item</code> is contained in this collection.
      * @param {T} item The item to search for.
      * @return {boolean} <code>true</code> if the given <code>item</code> is contained in this collection.
      * @see Specified by {@link yfiles.collections.ICollection#contains}.
      */
      contains(item:T):boolean;
    }
    var ICollection:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
  }
  export module genealogy{
    /**
    * This class implements a layout algorithm for genealogical data (family trees).
    * <p>
    * To be suitable for this layouter the graphs have to be organized in the following way:
    * Individuals as well as their marriage or partnership are represented by nodes, in the following referred to as
    * INDI nodes for individuals and FAM nodes for family nodes, corresponding to the INDI and FAM entries in
    * Gedcom encoded genealogical data (GEDCOM is a widely used format to store genealogical data, see
    * http://www.phpgedview.net/ged551-5.pdf for the most recent specifications).
    * </p>
    * <p>
    * In order to determine whether a node represents an individual or a partnership, the data provider
    * {@link yfiles.genealogy.FamilyTreeLayouter#DP_KEY_FAMILY_TYPE} has to be registered, otherwise an {@link yfiles.system.ArgumentException} will be thrown.
    * That data provider should return:
    * <ul>
    * <li>{@link yfiles.genealogy.FamilyTreeLayouter#TYPE_MALE} for a node representing a male individual.</li>
    * <li>{@link yfiles.genealogy.FamilyTreeLayouter#TYPE_FEMALE} for a node representing a female individual.</li>
    * <li>{@link yfiles.genealogy.FamilyTreeLayouter#TYPE_FAMILY} for a node representing a family.</li>
    * </ul>
    * All other values will be interpreted as if the node represents an individual.
    * </p>
    * <p>
    * A FAM node is linked to the INDI nodes representing husband and wife by ingoing edges and to INDI nodes representing
    * the children by outgoing edges. Two nodes of the same type (INDI or FAM) which are linked directly together
    * will cause a {@link yfiles.algorithms.InvalidGraphStructureException} exception. A FAM node with more than two parents
    * will also cause a {@link yfiles.algorithms.InvalidGraphStructureException} exception.
    * </p>
    * The layout is calculated basically in two steps:
    * <ul>
    * <li>The families are laid out by the inner layouter in a compact way: INDI->FAM&lt;-INDI->FAM&lt;-INDI</li>
    * <li>The relation between these "family groups" and their children and other families are laid out by the top layouter</li>
    * </ul>
    * The top layouter can be accessed by {@link yfiles.genealogy.FamilyTreeLayouter#topLayouter} and {@link yfiles.genealogy.FamilyTreeLayouter#topLayouter}.
    * By default, an {@link yfiles.hierarchic.IncrementalHierarchicLayouter} is used.
    */
    export interface FamilyTreeLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * The layouter which is responsible for the layout between the family groups.
      * If no layouter is set,
      * a new instance of {@link yfiles.hierarchic.IncrementalHierarchicLayouter} is created.
      */
      topLayouter:yfiles.layout.ILayouter;
      /**
      * The (horizontal) space between two nodes representing members of the same family.
      */
      spacingBetweenFamilyMembers:number;
      /**
      * The offset by which a family node will be shifted down if its parents are not direct neighbours.
      */
      offsetForFamilyNodes:number;
      /**
      * Determines the treatment of individuals who have only children but no partners.
      * If set to true,
      * the family node will be placed centered below the individual node. Thus, a direct male inheritance line for
      * example will be depicted in a more obvious way.
      */
      partnerlessBelow:boolean;
      /**
      * Determines whether family/marriage nodes will be placed between the partners or below them.
      */
      familyNodesAlwaysBelow:boolean;
      /**
      * The vertical alignment of the individual nodes.
      * @throws {yfiles.system.ArgumentException} if the given value is not defined.
      */
      alignment:number;
      /**
      * Returns <code>true</code> if the given graph can be laid out by this algorithm.
      * Calling <code>doLayout</code>
      * with the given graph as it's argument will only succeed if this method returns <code>true</code>.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * The policy the individuals of a family will be sorted by their sex.
      * Default is no sorting ({@link yfiles.genealogy.FamilyMembersSortingPolicy#DO_NOT_SORT_BY_SEX}).
      */
      sortFamilyMembers:yfiles.genealogy.FamilyMembersSortingPolicy;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @param {yfiles.layout.LayoutGraph} graph The graph to run the layout on
      * @throws {yfiles.system.InvalidOperationException} 
      * If the data provider {@link yfiles.genealogy.FamilyTreeLayouter#DP_KEY_FAMILY_TYPE} is not registered
      * @throws {yfiles.algorithms.InvalidGraphStructureException} If a family node has more than two parents, or two nodes of the same type are linked together
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
    }
    var FamilyTreeLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Data provider key which defines a data provider for nodes which returns a String which defines the type of the
      * node as defined in {@link yfiles.genealogy.FamilyTreeLayouter#TYPE_FAMILY}, {@link yfiles.genealogy.FamilyTreeLayouter#TYPE_MALE}, {@link yfiles.genealogy.FamilyTreeLayouter#TYPE_FEMALE}.
      * Nodes for which <code>null</code> is returned will be treated like nodes which represent individuals.
      */
      DP_KEY_FAMILY_TYPE:string;
      /**
      * Returned by the DataProvider {@link yfiles.genealogy.FamilyTreeLayouter#DP_KEY_FAMILY_TYPE} for nodes which represent a family.
      */
      TYPE_FAMILY:string;
      /**
      * Returned by the DataProvider {@link yfiles.genealogy.FamilyTreeLayouter#DP_KEY_FAMILY_TYPE} for nodes which represent a male individual.
      */
      TYPE_MALE:string;
      /**
      * Returned by the DataProvider {@link yfiles.genealogy.FamilyTreeLayouter#DP_KEY_FAMILY_TYPE} for nodes which represent a female individual.
      */
      TYPE_FEMALE:string;
      /**
      * Creates a new instance of this.
      */
      new ():yfiles.genealogy.FamilyTreeLayouter;
    };
    export enum FamilyMembersSortingPolicy{
      /**
      * Disables sorting the individuals according to their sex.
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#sortFamilyMembers}
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#sortFamilyMembers}
      */
      DO_NOT_SORT_BY_SEX,
      /**
      * Places female individuals before their male siblings and partners if possible.
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#sortFamilyMembers}
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#sortFamilyMembers}
      */
      FEMALE_FIRST,
      /**
      * Places female individuals before their male siblings and partners.
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#sortFamilyMembers}
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#sortFamilyMembers}
      */
      FEMALE_ALWAYS_FIRST,
      /**
      * Places female individuals before their male siblings and partners if possible.
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#sortFamilyMembers}
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#sortFamilyMembers}
      */
      MALE_FIRST,
      /**
      * Places female individuals before their male siblings and partners.
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#sortFamilyMembers}
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#sortFamilyMembers}
      */
      MALE_ALWAYS_FIRST
    }
    export enum VerticalNodeAlignment{
      /**
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#alignment}
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#alignment}
      */
      TOP,
      /**
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#alignment}
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#alignment}
      */
      CENTER,
      /**
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#alignment}
      * @see {@link yfiles.genealogy.FamilyTreeLayouter#alignment}
      */
      BOTTOM
    }
  }
  export module hierarchic{
    /**
    * This class implements the second phase of the Sugiyama algorithm.
    * It minimizes the crossings in the diagram by using either the
    * barycentric or median heuristic.
    */
    export interface ClassicLayerSequencer extends Object,yfiles.hierarchic.ILayerSequencer{
      /**
      * Specifies whether or not the transposition heuristic should
      * be used.
      * Activating this heuristic can reduce the overall
      * number of edge crossings. On the other hand its activation
      * increases running time.
      * By default the transposition rule is active.
      */
      useTransposition:boolean;
      /**
      * The currently set weight heuristic.
      * By default {@link yfiles.hierarchic.WeightHeuristic#BARYCENTER} is set.
      */
      weightHeuristic:yfiles.hierarchic.WeightHeuristic;
      /**
      * Specifies whether or not to remove false crossings.
      * A false crossing is a crossing
      * between two edges that share a common terminal node.
      * By default this feature is active.
      */
      removeFalseCrossings:boolean;
      /**
      * The proposed maximal duration for the calculation of the sequence.
      */
      maximalDuration:number;
      /**
      * The number of edge crossings that were
      * produced by this sequencer the last time it was
      * applied to a graph.
      * <b>Precondition:</b> 
      * Method {@link yfiles.hierarchic.ClassicLayerSequencer#getLayers}
      * must have been called before.
      */
      recentCrossingNumber:number;
      /**
      * Tries to adopt/copy the settings of the given LayerSequencer to this sequencer.
      */
      adoptValues(otherSequencer:yfiles.hierarchic.ILayerSequencer):void;
      /**
      * Calculates the sequence of nodes within each layer.
      * @param {yfiles.layout.LayoutGraph} g the graph being acted upon
      * @param {yfiles.algorithms.INodeMap} layerID 
      * provides for each node an integral number signifying the layer
      * of that node. The first layer has the number 0.
      * @param {number} maxLayer the number of different layers
      * @return {yfiles.algorithms.NodeList[]} 
      * an array of length maxLayer containing node lists. Each node list
      * contains the nodes of a corresponding layer. The order of the nodes
      * within each node list represents the sequence of the nodes within their layer.
      * @see Specified by {@link yfiles.hierarchic.ILayerSequencer#getLayers}.
      */
      getLayers(g:yfiles.layout.LayoutGraph,layerMap:yfiles.algorithms.INodeMap,maxLayer:number):yfiles.algorithms.NodeList[];
      /**
      * Specifies whether or not the layerer will preserve the groupings of
      * nodes between each layer.
      * Preserving groupings means nodes having the same integer group number will
      * be placed directly next to each other within each layer.
      * <p>
      * Defaults to <code>false</code>.
      * </p>
      */
      usingGroups:boolean;
      /**
      * The number of randomized rounds this algorithm will try
      * if there was no optimal solution.
      */
      randomizationRounds:number;
    }
    var ClassicLayerSequencer:{
      $class:yfiles.lang.Class;
      /**
      * This is the key, which must be used to register the DataProvider
      * which contains the mappings between nodes and group ids.
      * Group ids
      * are integer objects, containing unique group numbers or null, if the
      * node belongs to no specific group.
      */
      GROUP_DP_KEY:Object;
      /**
      * Instantiates a new layer sequencer.
      */
      new ():yfiles.hierarchic.ClassicLayerSequencer;
    };
    /**
    * Layerer that uses a breadth first search to assign layers to the nodes.
    * The nodes of the first layer can be freely chosen (see {@link yfiles.hierarchic.BFSLayerer#CORE_NODES_DP_KEY}).
    * The nodes belonging to a subsequent layer are determined as follows:
    * Add all yet unassigned nodes to the new layer that are connected to nodes
    * already assigned.
    * As a consequence all connected nodes will be at most one layer apart.
    * Also, edges between nodes that belong to the same layer are possible.
    */
    export interface BFSLayerer extends Object,yfiles.hierarchic.ILayerer,yfiles.hierarchic.incremental.ILayerer{
      /**
      * This method assigns the nodes in the graph to layers.
      * <b>Postcondition:</b> Forall (v,w) in E: layer(v) &lt; layer(w)
      * @param {yfiles.layout.LayoutGraph} graph the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the layers are stored
      * @param {yfiles.algorithms.EdgeList} reversedEdges here the edges are stored which had been reversed.
      * @return {number} the number of layers
      * @see Specified by {@link yfiles.hierarchic.ILayerer#assignNodeLayer}.
      */
      assignNodeLayer(graph:yfiles.layout.LayoutGraph,layer:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList):number;
      /**
      * This method assigns all nodes in the graph to layers and registers them
      * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
      * In order to create new layers, the factory
      * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
      * @param {yfiles.layout.LayoutGraph} graph 
      * the graph that contains the nodes that should be distributed
      * into the layers
      * @param {yfiles.hierarchic.incremental.ILayers} layers 
      * the object that will be filled with the results of the
      * calculation
      * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
      * LayoutDataProvider that can be used to query information about
      * the nodes - note that positional information
      * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
      * be available at any time.
      * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
      * @see {@link yfiles.hierarchic.incremental.ILayer#add}
      * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
      */
      assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
    }
    var BFSLayerer:{
      $class:yfiles.lang.Class;
      /**
      * The data provider key used to look up the core nodes
      * of the bfs layering.
      * The BFSLayerer will try to retrieve a
      * data provider from the graph to be layered with this key.
      * The looked up data provider should provide boolean values
      * for the nodes of that graph. The boolean value signals
      * whether a node is to be placed in the first layer or not.
      * If the are no nodes marked as core nodes then nodes with
      * indegree 0 are considered to be core nodes.
      */
      CORE_NODES_DP_KEY:Object;
      new ():yfiles.hierarchic.BFSLayerer;
    };
    /**
    * This class is an extended variant of the HierarchicLayouter class.
    * It is capable of laying out nested groups of nodes as well as the group nodes
    * themselves. The grouping information is provided through
    * DataProvider instances, which are registered with the LayoutGraph instance.
    * The layout is being calculated recursively. The size of the group nodes is determined
    * by the area occupied by the children of the group node.
    * Here is a sample output of the algorithm.
    * <center><img src="doc-files/y.layout.hierarchic.HierarchicGroupLayouter.example-grouped.gif" border="1"/></center>
    */
    export interface HierarchicGroupLayouter extends yfiles.hierarchic.HierarchicLayouter{
      /**
      * The associated <code>Grouping</code> instance.
      */
      grouping:yfiles.layout.GraphGrouping;
      /**
      * Returns <code>true</code>..
      * @see Overrides {@link yfiles.hierarchic.HierarchicLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Layouts the given graph.
      * @see Overrides {@link yfiles.hierarchic.HierarchicLayouter#doLayoutCore}
      */
      doLayoutCore(g:yfiles.layout.LayoutGraph):void;
      /**
      * Layouts the children of root recursively.
      * @param {yfiles.algorithms.Node} root The current root node (parent, invisible during layout)
      * @param {yfiles.algorithms.NodeList} levelNodes The nodes to be laid out
      * @return {yfiles.algorithms.Rectangle2D} the bounding box of the layout
      */
      layoutLevel(root:yfiles.algorithms.Node,levelNodes:yfiles.algorithms.NodeList,buildGraphsOnly:boolean):yfiles.algorithms.Rectangle2D;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The <code>LayerSequencer</code>, which is responsible for the second phase
      * of the algorithm.
      */
      layerSequencer:yfiles.hierarchic.ILayerSequencer;
      /**
      * The <code>Layerer</code>, which is responsible for the first phase
      * of the algorithm.
      */
      layerer:yfiles.hierarchic.ILayerer;
      /**
      * The current GroupBoundsCalculator instance.
      * By specifying an instance of the GroupBoundsCalculator interface one can
      * control the sizes of the group nodes. For every group of nodes which is in it's
      * open state the instance will be asked to calculate the bounds for the given
      * child nodes. The resulting size will be used during the ongoing layout.
      */
      groupBoundsCalculator:yfiles.layout.IGroupBoundsCalculator;
      /**
      * The drawer which is responsible for the third phase of the algorithm.
      * A drawer is responsible for the layout style of
      * this layouter.
      * @see Overrides {@link yfiles.hierarchic.HierarchicLayouter#drawer}
      */
      drawer:yfiles.hierarchic.IDrawer;
      /**
      * The currently set layout style or <code>-1</code>
      * if the style cannot be
      * determined.
      * Possible values are
      * {@link yfiles.hierarchic.LayoutStyle#POLYLINE}, {@link yfiles.hierarchic.LayoutStyle#LINEAR_SEGMENTS}, {@link yfiles.hierarchic.LayoutStyle#MEDIAN_SIMPLEX},
      * {@link yfiles.hierarchic.LayoutStyle#SIMPLEX}, {@link yfiles.hierarchic.LayoutStyle#PENDULUM},
      * and {@link yfiles.hierarchic.LayoutStyle#TREE}.
      * The default is set to {@link yfiles.hierarchic.LayoutStyle#LINEAR_SEGMENTS}
      */
      layoutStyle:yfiles.hierarchic.LayoutStyle;
      /**
      * The currently set layering strategy.
      * This layouter assigns the nodes to separate layers. The nodes within each layer will be
      * placed on the same horizontal line.
      * The layers will be arranged vertically starting with the small-numbered layers.
      * The rank of a node is the number of the layer it belongs to.
      * An important layering strategy for the hierarchic layout style is called <i>Hierarchical Layering</i>.
      * A hierarchical layering tries to assign nodes to layers in a way that as much as possible
      * edges of the graph will point to the main layout direction, i.e. the start nodes of the edges will
      * have a smaller rank than the corresponding end nodes. Also, a hierarchical layering
      * will never put two connected nodes in the same layer.
      * By default the layering strategy {@link yfiles.hierarchic.LayeringStrategy#HIERARCHICAL_TIGHT_TREE} is set.
      */
      layeringStrategy:yfiles.hierarchic.LayeringStrategy;
      /**
      * The property strongPortsScalingActive.
      * This property determines whether strong port constraints at group nodes
      * should be interpreted as coordinates, that should be scaled to the same
      * amount as the sizes of the group nodes vary.
      * The default value is <code>true</code>.
      */
      strongPortsScalingActive:boolean;
      /**
      * Determines the order of the nodes within their layers.
      */
      getLayerSequence(g:yfiles.layout.LayoutGraph,LayerKey:yfiles.algorithms.INodeMap,maxLayer:number):yfiles.algorithms.NodeList[];
      /**
      * The current strategy for the node sequencing.
      */
      globalSequencingActive:boolean;
    }
    var HierarchicGroupLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of HierarchicGroupLayouter.
      */
      new ():yfiles.hierarchic.HierarchicGroupLayouter;
    };
    /**
    * This class implements a layout algorithm for drawing directed graphs
    * in a hierarchic way.
    * The algorithm places nodes in different horizontal layers,
    * in such a way that most edges in the graph run from top
    * to bottom.
    * Here is a sample output of the algorithm using top to bottom
    * orientation and {@link yfiles.hierarchic.LayoutStyle#PENDULUM} layout style.
    * <center><img src="doc-files/y.layout.hierarchic.HierarchicLayouter.gif" border="1"/></center>
    * HierarchicLayouter can handle port constraints.
    * See classes {@link yfiles.layout.PortConstraint} and {@link yfiles.layout.PortConstraintKeys} on how
    * to setup port constraint information for this algorithm.
    * HierarchicLayouter can consider edge label data when laying out a graph.
    * That means that the layout of edge labels will be part of the resulting
    * layout and the layout of nodes and edges is chosen in such a way that the
    * edge labels do not conflict with the rest of the layout.
    * See classes {@link yfiles.layout.LabelLayoutData},
    * {@link yfiles.layout.LabelLayoutKeys} and {@link yfiles.layout.LabelLayoutTranslator} on how
    * to setup the integrated edge labeling algorithm.
    */
    export interface HierarchicLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * The routing style being used.
      * Possible values are
      * {@link yfiles.hierarchic.RoutingStyle#POLYLINE} and {@link yfiles.hierarchic.RoutingStyle#ORTHOGONAL}.
      * By default {@link yfiles.hierarchic.RoutingStyle#POLYLINE} is set.
      */
      routingStyle:yfiles.hierarchic.RoutingStyle;
      /**
      * Specifies whether the algorithm tries to optimize PortConstraints,
      * that are either {@link yfiles.layout.PortSide#ANY} or <code>null</code>.
      * <p>
      * Default is <code>false</code>.
      * </p>
      */
      optimizePortConstraints:boolean;
      /**
      * Specifies whether the algorithm tries to optimize the routing of
      * same layer edges whose PortConstraints don't impose the routing.
      * Default is <code>true</code>.
      */
      optimizeSameLayerEdgeRouting:boolean;
      /**
      * The currently set layout style or <code>-1</code>
      * if the style cannot be
      * determined.
      * Possible values are
      * {@link yfiles.hierarchic.LayoutStyle#POLYLINE}, {@link yfiles.hierarchic.LayoutStyle#LINEAR_SEGMENTS}, {@link yfiles.hierarchic.LayoutStyle#MEDIAN_SIMPLEX},
      * {@link yfiles.hierarchic.LayoutStyle#SIMPLEX}, {@link yfiles.hierarchic.LayoutStyle#PENDULUM},
      * and {@link yfiles.hierarchic.LayoutStyle#TREE}.
      * The default is set to {@link yfiles.hierarchic.LayoutStyle#LINEAR_SEGMENTS}
      */
      layoutStyle:yfiles.hierarchic.LayoutStyle;
      /**
      * The currently set layering strategy.
      * This layouter assigns the nodes to separate layers. The nodes within each layer will be
      * placed on the same horizontal line.
      * The layers will be arranged vertically starting with the small-numbered layers.
      * The rank of a node is the number of the layer it belongs to.
      * An important layering strategy for the hierarchic layout style is called <i>Hierarchical Layering</i>.
      * A hierarchical layering tries to assign nodes to layers in a way that as much as possible
      * edges of the graph will point to the main layout direction, i.e. the start nodes of the edges will
      * have a smaller rank than the corresponding end nodes. Also, a hierarchical layering
      * will never put two connected nodes in the same layer.
      * By default the layering strategy {@link yfiles.hierarchic.LayeringStrategy#HIERARCHICAL_TIGHT_TREE} is set.
      */
      layeringStrategy:yfiles.hierarchic.LayeringStrategy;
      /**
      * The <code>Layerer</code>, which is responsible for the first phase
      * of the algorithm.
      */
      layerer:yfiles.hierarchic.ILayerer;
      /**
      * The <code>LayerSequencer</code>, which is responsible for the second phase
      * of the algorithm.
      */
      layerSequencer:yfiles.hierarchic.ILayerSequencer;
      /**
      * The <code>Drawer</code>, which is responsible for the third phase of
      * the algorithm.
      * The <code>Drawer</code> is responsible for the layout style of
      * this layouter.
      */
      drawer:yfiles.hierarchic.IDrawer;
      /**
      * The minimal distance between two nodes in the same layer.
      */
      minimalNodeDistance:number;
      /**
      * The minimal distance between edges that run in parallel.
      */
      minimalEdgeDistance:number;
      /**
      * The minimal distance between two layers.
      */
      minimalLayerDistance:number;
      /**
      * The minimal length of first and last edge segments
      * for edge routing.
      * This will be used for orthogonal
      * edge routing, self-loops, same layer edges and bus connectors.
      */
      minimalFirstSegmentLength:number;
      /**
      * Specifies whether or not false crossings should be removed from the layout.
      * A false crossing is a crossing between two edges that connect
      * to the same upper or lower node.
      */
      removeFalseCrossings:boolean;
      /**
      * A time limit for the algorithm in milliseconds.
      */
      maximalDuration:number;
      /**
      * The limit, when bends are removed and a straight line is drawn
      * instead.
      */
      bendReductionThreshold:number;
      /**
      * Always returns true.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Layout the given graph.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(g:yfiles.layout.LayoutGraph):void;
      /**
      * Determines the order of the nodes within their layers.
      */
      getLayerSequence(g:yfiles.layout.LayoutGraph,LayerKey:yfiles.algorithms.INodeMap,maxLayer:number):yfiles.algorithms.NodeList[];
      /**
      * The cookie for the memento support of the hierarchic layout algorithm.
      * If there was no memento support registered with this instance before,
      * this call will instantiate the memento support, otherwise the existing
      * instance will be returned.
      */
      mementoSupport:yfiles.hierarchic.IMementoSupport;
      /**
      * Disposes the memento support if it is existent, i.e.
      * if it has been queried
      * before by <code>getMementoSupport()</code>
      */
      disposeMementoSupport():void;
    }
    var HierarchicLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Instantiates a new HierarchicLayouter.
      */
      new ():yfiles.hierarchic.HierarchicLayouter;
    };
    export enum AlgorithmPhase{
      /**
      * Constant describing the first phase of the HierarchicLayouter algorithm.
      */
      LAYERING,
      /**
      * Constant describing the second phase of the HierarchicLayouter algorithm.
      */
      SEQUENCING
    }
    export enum RankingPolicy{
      /**
      * Ranking policy specifier. Nodes do not get re-ranked after
      * the initial topological layering step.
      */
      NO_RERANKING,
      /**
      * Ranking policy specifier. Nodes get re-ranked by an
      * inexpensive downshift rule.
      */
      DOWN_SHIFT,
      /**
      * Ranking policy specifier. Nodes get re-ranked by 
      * finding a spanning tree that contains only tight
      * (length 1) edges.
      */
      TIGHT_TREE
    }
    /**
    * This layerer implementation layers the nodes by given layer IDs.
    * The layer IDs are given by a DataProvider that returns the integral
    * layer ID of each node in the graph.
    */
    export interface GivenLayersLayerer extends Object,yfiles.hierarchic.ILayerer,yfiles.hierarchic.incremental.ILayerer{
      /**
      * Convenience method which removes empty layers and ensures that the smallest layer has value 0.
      * @param {yfiles.algorithms.IDataProvider} layerId provides the current layer ids for nodes in <code>g</code>
      * @param {yfiles.algorithms.IDataAcceptor} normalizedLayerId accepts the new layer ids that result after normalization.
      * @return {number} The amount of layers left after removing all empty layers.
      */
      normalize(g:yfiles.algorithms.Graph,layerId:yfiles.algorithms.IDataProvider,normalizedLayerId:yfiles.algorithms.IDataAcceptor):number;
      /**
      * Assigns layers to the graph that were given by the
      * DataProvider <code>g.getDataProvider(LAYER_ID_KEY)</code>.
      * The returned layerMap will be  a normalized variant of
      * the user given data provider. A normalized variant has
      * no empty layers and a minimum layerID 0.
      * @see Specified by {@link yfiles.hierarchic.ILayerer#assignNodeLayer}.
      */
      assignNodeLayer(g:yfiles.layout.LayoutGraph,layerMap:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList):number;
      /**
      * This method assigns all nodes in the graph to layers and registers them
      * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
      * In order to create new layers, the factory
      * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
      * @param {yfiles.layout.LayoutGraph} graph 
      * the graph that contains the nodes that should be distributed
      * into the layers
      * @param {yfiles.hierarchic.incremental.ILayers} layers 
      * the object that will be filled with the results of the
      * calculation
      * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
      * LayoutDataProvider that can be used to query information about
      * the nodes - note that positional information
      * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
      * be available at any time.
      * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
      * @see {@link yfiles.hierarchic.incremental.ILayer#add}
      * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
      */
      assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
    }
    var GivenLayersLayerer:{
      $class:yfiles.lang.Class;
      /**
      * The key used by this class to query a graph for a
      * DataProvider that yields the layerID for each node in the
      * graph.
      */
      LAYER_ID_DP_KEY:Object;
    };
    /**
    * This is the interface to the node layering phase of the hierarchic layouter.
    * Implementations of this class must partition the nodes of the input graph
    * in hierarchic layers.
    * Implementing Classes:
    * {@link yfiles.hierarchic.AsIsLayerer},
    * {@link yfiles.hierarchic.BFSLayerer},
    * {@link yfiles.hierarchic.ConstraintLayerer},
    * {@link yfiles.hierarchic.GivenLayersLayerer},
    * {@link yfiles.hierarchic.TopologicalLayerer},
    * {@link yfiles.hierarchic.WeightedLayerer}
    */
    export interface ILayerer extends Object{
      /**
      * This method assigns the nodes in the graph to layers.
      * @param {yfiles.layout.LayoutGraph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the layers are stored
      * @param {yfiles.algorithms.EdgeList} reversedEdges here the edges are stored which had been reversed.
      * @return {number} the number of layers
      * @see Specified by {@link yfiles.hierarchic.ILayerer#assignNodeLayer}.
      */
      assignNodeLayer(g:yfiles.layout.LayoutGraph,layer:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList):number;
    }
    var ILayerer:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Classes implementing this interface calculate the order of nodes within
    * the different layers that the graph has been partitioned into.
    */
    export interface ILayerSequencer extends Object{
      /**
      * Calculates the sequence of nodes within each layer.
      * @param {yfiles.layout.LayoutGraph} g the graph being acted upon
      * @param {yfiles.algorithms.INodeMap} layerID 
      * provides for each node an integral number signifying the layer
      * of that node. The first layer has the number 0.
      * @param {number} maxLayer the number of different layers
      * @return {yfiles.algorithms.NodeList[]} 
      * an array of length maxLayer containing node lists. Each node list
      * contains the nodes of a corresponding layer. The order of the nodes
      * within each node list represents the sequence of the nodes within their layer.
      * @see Specified by {@link yfiles.hierarchic.ILayerSequencer#getLayers}.
      */
      getLayers(g:yfiles.layout.LayoutGraph,layerID:yfiles.algorithms.INodeMap,maxLayer:number):yfiles.algorithms.NodeList[];
    }
    var ILayerSequencer:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This interface is a Cookie for the HierarchicLayouter's memento support.
    */
    export interface IMementoSupport extends Object{
      /**
      * Creates a memento which can be held by the user, before using the support,
      * a valid memento Object has to be set using the corresponding setter method.
      * @see Specified by {@link yfiles.hierarchic.IMementoSupport#createMemento}.
      */
      createMemento():Object;
      /**
      * The currently active memento Object.
      * @see Specified by {@link yfiles.hierarchic.IMementoSupport#memento}.
      */
      memento:Object;
      /**
      * Sets the mode for each phase of the algorithm.
      * <code>true</code> makes the
      * algorithm use the
      * values stored in the memento from a previous run, whereas <code>false</code>
      * makes the algorithm store the information in the memento after the next run.
      * @see Specified by {@link yfiles.hierarchic.IMementoSupport#setMementoMode}.
      */
      setMementoMode(phase:yfiles.hierarchic.AlgorithmPhase,useMemento:boolean):void;
      /**
      * Retrieves the current mode previously set by setMementoMode(byte, boolean)
      * for the given phase of the algorithm.
      * @see Specified by {@link yfiles.hierarchic.IMementoSupport#getMementoMode}.
      */
      getMementoMode(phase:yfiles.hierarchic.AlgorithmPhase):boolean;
    }
    var IMementoSupport:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Interface for the third phase of the Sugiyama algorithm.
    * It assigns the coordinates to the nodes according to the defined
    * range.
    */
    export interface IDrawer extends Object{
      /**
      * This method assigns the coordinates to the nodes.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#assignCoordinates}.
      */
      assignCoordinates(g:yfiles.layout.LayoutGraph,layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
      /**
      * Gives the drawer the opportunity to distinguish between dummy nodes
      * and real ones.
      * dummy stores the original edge for each dummy node or
      * <code>null</code> for real nodes.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#dummyMap}.
      */
      dummyMap:yfiles.algorithms.INodeMap;
      /**
      * The minimal distance between two nodes in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalNodeDistance}.
      */
      minimalNodeDistance:number;
      /**
      * The minimal distance between two edges in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalEdgeDistance}.
      */
      minimalEdgeDistance:number;
      /**
      * The minimal distance between two edges sharing source/target (aka multi-edges) in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalMultiEdgeDistance}.
      */
      minimalMultiEdgeDistance:number;
      /**
      * The minimal distance between two layers.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalLayerDistance}.
      */
      minimalLayerDistance:number;
    }
    var IDrawer:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    export interface DrawerKeys extends Object{
    }
    var DrawerKeys:{
      $class:yfiles.lang.Class;
      /**
      * The key used to look up a data provider that,
      * if present, must provide a double value for each node in
      * the graph.
      * The provided value is an additional overlap-free
      * border added to the left side of the associated node.
      * Drawer implementations may ignore the data provided.
      */
      NODE_BORDER_LEFT:Object;
      /**
      * The key used to look up a data provider that,
      * if present, must provide a double value for each node in
      * the graph.
      * The provided value is an additional overlap-free
      * border added to the right side of the associated node.
      * Drawer implementations may ignore the data provided.
      */
      NODE_BORDER_RIGHT:Object;
      /**
      * The key used to look up a data provider that,
      * if present, must provide a double value for each node in
      * the graph.
      * The provided value is an additional overlap-free
      * border added to the top side of the associated node.
      * Drawer implementations may ignore the data provided.
      */
      NODE_BORDER_TOP:Object;
      /**
      * The key used to look up a data provider that,
      * if present, must provide a double value for each node in
      * the graph.
      * The provided value is an additional overlap-free
      * border added to the bottom side of the associated node.
      * Drawer implementations may ignore the data provided.
      */
      NODE_BORDER_BOTTOM:Object;
      /**
      * The key used to look up a data provider that,
      * if present, must provide a double value for each node in
      * the graph.
      * The provided value specifies the minimum distance
      * between the right border of the node and the left border of its right-hand
      * neighbor in the layer.
      * If a data provider with this key is registered with the input graph then the 
      * distance values set by the methods {@link yfiles.hierarchic.IDrawer#minimalNodeDistance},
      * {@link yfiles.hierarchic.IDrawer#minimalEdgeDistance} and {@link yfiles.hierarchic.IDrawer#minimalMultiEdgeDistance}
      * will be ignored.
      *  
      * Drawer implementations may ignore the data provided.
      */
      NODE_DISTANCE:Object;
    };
    /**
    * Helper that reverses edges that are oriented in the wrong direction.
    */
    export interface EdgeReverser extends Object{
      /**
      * Reverses the edges contained ion the given edge list.
      * @param {yfiles.algorithms.Graph} g the graph containing the edges in edgeList
      * @param {yfiles.algorithms.EdgeList} edgeList contains to be reversed edges.
      */
      reverseEdges(g:yfiles.algorithms.Graph,edgeList:yfiles.algorithms.EdgeList):void;
    }
    var EdgeReverser:{
      $class:yfiles.lang.Class;
      /**
      * Reverses edges in the given graph whose source node has a
      * larger layer ID than the target node.
      * @param {yfiles.algorithms.Graph} g target graph
      * @param {yfiles.algorithms.INodeMap} layerMap node map that contains a layer ID for each node
      * @return {yfiles.algorithms.EdgeList} a list of edges that have been reversed
      */
      reverseUpwardEdges(g:yfiles.algorithms.Graph,layerMap:yfiles.algorithms.INodeMap):yfiles.algorithms.EdgeList;
    };
    export enum WeightHeuristic{
      /**
      * Weight assignment heuristic specifier. A node position within a layer
      * will be determined by the barycenter of its 
      * successor (downward pass) and  predecessor (upward pass) nodes.
      */
      BARYCENTER,
      /**
      * Weight assignment heuristic specifier. A node position within a layer
      * will be determined by the median position of its 
      * successor (downward pass) and  predecessor (upward pass) nodes.
      */
      MEDIAN
    }
    /**
    * Layerer implementation that uses relative and absolute layering constraints.
    * <p> This layerer can use two sets of
    * constraints: <ul> <li>Absolute constraints, i.e. place nodes at the top or bottom layer</li> <li>Relative
    * constraints, i.e. place a node above, below or in the same layer as another node</li> </ul> Constraints for a given
    * graph can be created with means of a {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory} instance, which should be created
    * with {@link yfiles.hierarchic.ConstraintLayerer#createConstraintFactory} for a given graph instance. </p>
    */
    export interface ConstraintLayerer extends Object,yfiles.hierarchic.ILayerer,yfiles.hierarchic.incremental.ILayerer{
      /**
      * The core layerer for this layerer instance.
      * The ConstraintLayerer tries to create a layering for the
      * nodes and edges that have no constraints that resembles the layering that would be created by the coreLayerer. This
      * works the better the less constraints exist. Ideally, the constrained nodes are just embedded into the layering
      * created by the coreLayerer. By default, an instance of {@link yfiles.hierarchic.TopologicalLayerer} is used.
      */
      coreLayerer:yfiles.hierarchic.ILayerer;
      /**
      * Specifies whether same layer edges can be created by this layerer instance.
      * This only concerns edges between nodes
      * that have no hard constraints that will force a same layer edge (i.e. a same layer constraint).
      * <p>
      * Default value is <code>false</code>.
      * </p>
      */
      allowSameLayerEdges:boolean;
      /**
      * This method assigns the nodes in the graph to layers.
      * @param {yfiles.layout.LayoutGraph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the layers are stored
      * @param {yfiles.algorithms.EdgeList} reversedEdges here the edges are stored which had been reversed.
      * @return {number} the number of layers
      * @throws {yfiles.system.ArgumentException} if any strong constraints are inconsistent
      * @see Specified by {@link yfiles.hierarchic.ILayerer#assignNodeLayer}.
      */
      assignNodeLayer(g:yfiles.layout.LayoutGraph,layer:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList):number;
      /**
      * Checks if the current set of strong constraints is consistent (i.e.
      * has no cycles)
      * @throws {yfiles.system.ArgumentException} if the constraint network is inconsistent
      */
      checkConstraints():void;
      /**
      * This method assigns all nodes in the graph to layers and registers them
      * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
      * In order to create new layers, the factory
      * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
      * @param {yfiles.layout.LayoutGraph} graph 
      * the graph that contains the nodes that should be distributed
      * into the layers
      * @param {yfiles.hierarchic.incremental.ILayers} layers 
      * the object that will be filled with the results of the
      * calculation
      * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
      * LayoutDataProvider that can be used to query information about
      * the nodes - note that positional information
      * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
      * be available at any time.
      * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
      * @see {@link yfiles.hierarchic.incremental.ILayer#add}
      * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
      */
      assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
    }
    export module ConstraintLayerer{
      /**
      * Interface specification for classes that can create suitable constraints for a {@link yfiles.hierarchic.ConstraintLayerer} instance.
      * If you manually register a DataProvider under {@link yfiles.layout.LayouterKeys#NODE_ID_DP_KEY}
      * on the graph, you must use the corresponding node ids stored in this DataProvider as arguments for
      * all methods that create a constraint. Otherwise, you can just use the node instances themselves.
      */
      export interface IConstraintFactory extends Object{
        /**
        * A token that allows to bind a constraint factory to a graph instance after creation.
        * This method should only be used if the constraint factory is not bound to a graph instance initially. It allows
        * to bind the ConstraintFactory to a graph instance after creation. Please see the factory methods that create
        * instances of this interface for a description.
        * @see {@link yfiles.hierarchic.ConstraintLayerer#createConstraintFactory}
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#memento}.
        */
        memento:Object;
        /**
        * Disposes the ConstraintFactory.
        * <p> This method should be called when the factory is not needed anymore, i.e.
        * after the layout has been calculated. Calling this method also clears all constraints. </p>
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#dispose}.
        */
        dispose():void;
        /**
        * Add a constraint that forces the node with id with id <code>below</code> to lie below the node with id <code>reference</code>.
        * @param {Object} referenceId the id of the reference node
        * @param {Object} belowId the id of the node that should lie below
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#addPlaceNodeBelowConstraint}.
        */
        addPlaceNodeBelowConstraint(referenceId:Object,belowId:Object):void;
        /**
        * Add a constraint that forces the node with id <code>below</code> to lie at least <code>minDistance</code> layers below
        * the node with id <code>reference</code>.
        * The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
        * layer difference may be smaller than <code>minDistance</code>
        * @param {Object} referenceId the id of the reference node
        * @param {Object} belowId the id of the node that should lie below
        * @param {number} minDistance the minimal layer distance between the node and its reference node
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#addPlaceNodeBelowConstraintWithMinDistance}.
        */
        addPlaceNodeBelowConstraintWithMinDistance(referenceId:Object,belowId:Object,minDistance:number):void;
        /**
        * Add a constraint that forces the node with id <code>below</code> to lie at least <code>minDistance</code> layers below
        * the node with id <code>reference</code> with a given weight penalty for larger layer differences.
        * The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
        * layer difference may be smaller than <code>minDistance</code>
        * @param {Object} referenceId the id of the reference node
        * @param {Object} belowId the id of the node that should lie below
        * @param {number} minDistance the minimal layer distance between the node and its reference node
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#addPlaceNodeBelowConstraintWithMinDistanceAndWeight}.
        */
        addPlaceNodeBelowConstraintWithMinDistanceAndWeight(referenceId:Object,belowId:Object,minDistance:number,weight:number):void;
        /**
        * Add a constraint that forces the node <code>above</code> to lie above the node <code>reference</code>.
        * @param {Object} referenceId the id of the reference node
        * @param {Object} aboveId the id of the node that should lie above
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#addPlaceNodeAboveConstraint}.
        */
        addPlaceNodeAboveConstraint(referenceId:Object,aboveId:Object):void;
        /**
        * Add a constraint that forces the node with id <code>above</code> to lie at least <code>minDistance</code> layers above
        * the node with id <code>reference</code>.
        * The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
        * layer difference may be smaller than <code>minDistance</code>
        * @param {Object} referenceId the id of the reference node
        * @param {Object} aboveId the id of the node that should lie above
        * @param {number} minDistance the minimal layer distance between the node and its reference node
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#addPlaceNodeAboveConstraintWithMinDistance}.
        */
        addPlaceNodeAboveConstraintWithMinDistance(referenceId:Object,aboveId:Object,minDistance:number):void;
        /**
        * Add a constraint that forces the node  with id <code>above</code> to lie at least <code>minDistance</code> layers above
        * the node  with id <code>reference</code> with a given weight penalty for larger  layer differences.
        * The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
        * layer difference may be smaller than <code>minDistance</code>
        * @param {Object} referenceId the id of the reference node
        * @param {Object} aboveId the id of the node that should lie above
        * @param {number} minDistance the minimal layer distance between the node and its reference node
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#addPlaceNodeAboveConstraintWithMinDistanceAndWeight}.
        */
        addPlaceNodeAboveConstraintWithMinDistanceAndWeight(referenceId:Object,aboveId:Object,minDistance:number,weight:number):void;
        /**
        * Add a constraint that forces the node with id <code>sameLayer</code> to lie in the same layer as the node with id
        * <code>reference</code>.
        * @param {Object} referenceId the id of the reference node
        * @param {Object} sameLayerId the id of the node that should lie in the same layer
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#addPlaceNodeInSameLayerConstraint}.
        */
        addPlaceNodeInSameLayerConstraint(referenceId:Object,sameLayerId:Object):void;
        /**
        * Add a constraint that places a node in the topmost layer.
        * @param {Object} nodeId the id of the node that should lie at the top
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#addPlaceNodeAtTopConstraint}.
        */
        addPlaceNodeAtTopConstraint(nodeId:Object):void;
        /**
        * Add a constraint that places a node in the bottom layer.
        * @param {Object} nodeId the id of the node that should lie at the bottom
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#addPlaceNodeAtBottomConstraint}.
        */
        addPlaceNodeAtBottomConstraint(nodeId:Object):void;
        /**
        * Clears all constraints for a given node.
        * @param {Object} nodeId the id of the node for which all constraints should be cleared
        * @see Specified by {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#removeConstraints}.
        */
        removeConstraints(nodeId:Object):void;
      }
    }
    var ConstraintLayerer:{
      $class:yfiles.lang.Class;
      /**
      * <code>DataProvider</code> key to store the constraints.
      */
      LAYER_CONSTRAINTS_MEMENTO_DP_KEY:Object;
      WithCoreLayerer:{
        new (coreLayerer:yfiles.hierarchic.ILayerer):yfiles.hierarchic.ConstraintLayerer;
      };
      new ():yfiles.hierarchic.ConstraintLayerer;
      /**
      * DataProvider key for additional edge weights of type <code>int</code>.
      * The Layerer tries to keep edges with higher weights short.
      */
      EDGE_WEIGHTS_DP_KEY:string;
      /**
      * Create an instance of {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory} that is suitable for this
      * layerer implementation.
      * The ConstraintFactory instance is usually bound to the graph instance <code>g</code>, i.e. if the input graph for the
      * layerer changes, a new ConstraintFactory instance must be retrieved. This instance can be used to create
      * constraints for this graph instance.
      * @param {yfiles.algorithms.Graph} g the current graph for the layerer
      * @return {yfiles.hierarchic.ConstraintLayerer.IConstraintFactory} a ConstraintFactory bound to this graph.
      * @see {@link yfiles.hierarchic.ConstraintLayerer.IConstraintFactory#memento}
      * @see {@link yfiles.hierarchic.ConstraintLayerer#LAYER_CONSTRAINTS_MEMENTO_DP_KEY}
      */
      createConstraintFactory(g:yfiles.algorithms.Graph):yfiles.hierarchic.ConstraintLayerer.IConstraintFactory;
    };
    export enum ComponentArrangementPolicy{
      /**
      * Component arrangement constant that can be used in {@link yfiles.hierarchic.IncrementalHierarchicLayouter#componentArrangementPolicy}.
      * If the graph consists of multiple components this constant specifies that, after layering the single components with
      * the core layerer, the components will all be merged such that an 1:1 aspect ratio is fulfilled best.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#componentArrangementPolicy}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#componentArrangementPolicy}
      */
      COMPACT,
      /**
      * Component arrangement constant that can be used in {@link yfiles.hierarchic.IncrementalHierarchicLayouter#componentArrangementPolicy}.
      * If the graph consists of multiple components this constant specifies that, after layering the single components with
      * the core layerer, the components are aligned with their topmost layer.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#componentArrangementPolicy}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#componentArrangementPolicy}
      */
      TOPMOST
    }
    export enum LayoutMode{
      /**
      * Layout mode constant that can be used in {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}.
      * This constant sets the layout algorithm to incremental mode, i.e.
      * fixed elements will be handled by the <code>fixedElementsSequencer</code>
      * and <code>fixedElementsLayerer</code> and elements marked for incremental
      * layout will be added to the drawing later.
      * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createLayerIncrementallyHint}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fixedElementsSequencer}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fixedElementsLayerer}
      */
      INCREMENTAL,
      /**
      * Layout mode constant that can be used in {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}.
      * This constant sets the layout algorithm to "from scratch mode", i.e.
      * the algorithm will recompute the layout from scratch.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fromScratchSequencer}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fromScratchLayerer}
      */
      FROM_SCRATCH
    }
    export enum GroupAlignmentPolicy{
      /**
      * Group layering alignment strategy specifier. If recursive group layering is enabled, groups and normal nodes that occupy
      * the same layer are top aligned with respect to their inner layers.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#groupAlignmentPolicy}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#recursiveGroupLayering}
      */
      TOP,
      /**
      * Group layering alignment strategy specifier. If recursive group layering is enabled, groups and normal nodes that occupy
      * the same layer are center aligned with respect to their inner layers.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#groupAlignmentPolicy}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#recursiveGroupLayering}
      */
      CENTER,
      /**
      * Group layering alignment strategy specifier. If recursive group layering is enabled, groups and normal nodes that occupy
      * the same layer are bottom aligned with respect to their inner layers.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#groupAlignmentPolicy}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#recursiveGroupLayering}
      */
      BOTTOM
    }
    export enum LayoutStyle{
      /**
      * Layout style specifier. Draws the edges in a way
      * that nodes are balanced nicely and the number
      * of bends on an edge is kept small.
      * Note that this layout style is more time consuming than most of the
      * other ones.
      */
      PENDULUM,
      /**
      * Layout style specifier. Draws the edges in a way
      * that at most two bends are used per edge unless two edges cross.
      */
      LINEAR_SEGMENTS,
      /**
      * Layout style specifier. Draws the edges in a polyline
      * fashion. The layout tends to be very compact but the
      * number of edge bends may be high.
      */
      POLYLINE,
      /**
      * Layout style specifier. Gives nice layouts if the
      * graph is a tree.
      */
      TREE,
      /**
      * Layout style specifier. Gives tight layouts with rather few bends.
      */
      SIMPLEX,
      /**
      * Layout style specifier. Similar to SIMPLEX but more symmetric for the cost
      * of a few more bends.
      */
      MEDIAN_SIMPLEX
    }
    export enum RoutingStyle{
      /**
      * Edge routing style specifier. Routes the edges as polylines.
      */
      POLYLINE,
      /**
      * Edge routing style specifier. Routes the edges orthogonally, i.e.
      * all edge segments are either vertically or horizontally aligned.
      */
      ORTHOGONAL
    }
    export enum LayeringStrategy{
      /**
      * Layering strategy specifier. A simple hierarchical layering variant.
      * All nodes with indegree zero will be assigned to the topmost layer of the layout.
      * The number of separate layers will be as small as possible.
      * @see {@link yfiles.hierarchic.HierarchicLayouter#layeringStrategy}
      */
      HIERARCHICAL_TOPMOST,
      /**
      * Layering strategy specifier. An optimal hierarchical layering strategy.
      * The layer distance of an edge is the absolute difference between the layer numbers 
      * of its source and target node.  
      * Layer assignment will be done in such a way that the overall sum of the layer distances 
      * of all edges in the layout is minimal.
      * @see {@link yfiles.hierarchic.HierarchicLayouter#layeringStrategy}
      */
      HIERARCHICAL_OPTIMAL,
      /**
      * Layering strategy specifier.  A heuristic that approximates the ranking done by
      * {@link yfiles.hierarchic.LayeringStrategy#HIERARCHICAL_OPTIMAL}.
      * @see {@link yfiles.hierarchic.HierarchicLayouter#layeringStrategy}
      */
      HIERARCHICAL_TIGHT_TREE,
      /**
      * Layering strategy specifier. A fast heuristic that improves the 
      * the ranking done by {@link yfiles.hierarchic.LayeringStrategy#HIERARCHICAL_TOPMOST} by down shifting 
      * some nodes in the layering. The quality is usually worse than the 
      * one produced by <i>Tight Tree Heuristic</i>.
      * @see {@link yfiles.hierarchic.HierarchicLayouter#layeringStrategy}
      */
      HIERARCHICAL_DOWNSHIFT,
      /**
      * Layering strategy specifier. 
      * Layering based on a breadth first search (bfs). 
      * All edges will span at most one layer in
      * the resulting drawing. Edges between nodes that belong to the same layer are possible.
      * The nodes that will be placed in the first layer can be provided by a 
      * data provider bound to the input graph using the key {@link yfiles.hierarchic.BFSLayerer#CORE_NODES_DP_KEY}.
      * If this data provider is not given, then nodes that have no incoming edges are placed 
      * in the first layer.
      * @see {@link yfiles.hierarchic.HierarchicLayouter#layeringStrategy}
      */
      BFS,
      /**
      * Layering strategy specifier. A layer assignment strategy 
      * that uses the initial y-coordinates of the nodes
      * (x-coordinates when the layout orientation is horizontal) 
      * to determine a node layering. It tries to find a layering that is similar to the 
      * one in the input graph. When this layering strategy is used, the layouter
      * may place nodes in the same layer, even though they are connected by an edge.
      * These inner layer edges are always routed in an orthogonal style.
      * @see {@link yfiles.hierarchic.HierarchicLayouter#layeringStrategy}
      */
      FROM_SKETCH,
      /**
      * Layering strategy specifier. The ranks of the nodes will be given by the user.
      * The node ranks must be provided by a data provider bound to the input graph
      * using the key {@link yfiles.hierarchic.GivenLayersLayerer#LAYER_ID_DP_KEY}. Like 
      * {@link yfiles.hierarchic.LayeringStrategy#FROM_SKETCH} this layering allows inner layer edges.
      * @see {@link yfiles.hierarchic.HierarchicLayouter#layeringStrategy}
      */
      USER_DEFINED,
      /**
      * Dummy layering strategy specifier. Returned by
      * {@link yfiles.hierarchic.HierarchicLayouter#layeringStrategy} if the current strategy
      * is not known.
      */
      UNKNOWN
    }
    /**
    * This layerer implementation assigns layers by analyzing already existing
    * node coordinates.
    * Nodes whose bounding boxes intersect a common y-coordinate
    * are assigned to the same layer.
    */
    export interface AsIsLayerer extends Object,yfiles.hierarchic.ILayerer,yfiles.hierarchic.incremental.ILayerer{
      /**
      * The scaling factor that is used to scale the nodes' height.
      * Nodes are being scaled from their center.
      * This can be used for more fuzzy layering.
      * The default is <code>1.0d</code> which results in no scaling.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified value is less than
      * <code>0</code>.
      */
      nodeScalingFactor:number;
      /**
      * The maximum size of a node that is used to calculate layer overlaps.
      * This can be used for more fuzzy layering.
      * The default is <code>Double.MAX_VALUE</code> which results in no
      * restriction being set.
      * @see {@link yfiles.hierarchic.AsIsLayerer#nodeScalingFactor}
      * @see {@link yfiles.hierarchic.AsIsLayerer#nodeHalo}
      * @see {@link yfiles.hierarchic.AsIsLayerer#nodeScalingFactor}
      * @see {@link yfiles.hierarchic.AsIsLayerer#nodeHalo}
      * @throws {yfiles.system.ArgumentException} 
      * if the specified value is less than
      * <code>0</code>.
      */
      maximumNodeSize:number;
      /**
      * The minimum size of a node that is used to calculate layer overlaps.
      * This can be used for more fuzzy layering.
      * The default is <code>0.0d</code> which results in no
      * restriction being set.
      * @see {@link yfiles.hierarchic.AsIsLayerer#nodeScalingFactor}
      * @see {@link yfiles.hierarchic.AsIsLayerer#nodeHalo}
      * @see {@link yfiles.hierarchic.AsIsLayerer#nodeScalingFactor}
      * @see {@link yfiles.hierarchic.AsIsLayerer#nodeHalo}
      * @throws {yfiles.system.ArgumentException} 
      * if the specified value is less than
      * <code>0</code>.
      */
      minimumNodeSize:number;
      /**
      * The size of the halo around a node or the insets respectively that are
      * used to calculate layer overlaps.
      * <b>Setter:</b>This can be used for more fuzzy layering.
      * <b>Getter:</b>The default is <code>0.0d</code> which results in no modification
      */
      nodeHalo:number;
      /**
      * This method assigns the nodes in the graph to layers.
      * @param {yfiles.layout.LayoutGraph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the layers are stored
      * @param {yfiles.algorithms.EdgeList} reversedEdges here the edges are stored which had been reversed.
      * @return {number} the number of layers
      * @see Specified by {@link yfiles.hierarchic.ILayerer#assignNodeLayer}.
      */
      assignNodeLayer(g:yfiles.layout.LayoutGraph,layerMap:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList):number;
      /**
      * Callback used to calculate the upper (min) value of a node.
      */
      getMin(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):number;
      /**
      * Callback used to calculate the lower (max) value of a node.
      */
      getMax(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):number;
      /**
      * This method assigns all nodes in the graph to layers and registers them
      * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
      * In order to create new layers, the factory
      * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
      * @param {yfiles.layout.LayoutGraph} graph 
      * the graph that contains the nodes that should be distributed
      * into the layers
      * @param {yfiles.hierarchic.incremental.ILayers} layers 
      * the object that will be filled with the results of the
      * calculation
      * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
      * LayoutDataProvider that can be used to query information about
      * the nodes - note that positional information
      * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
      * be available at any time.
      * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
      * @see {@link yfiles.hierarchic.incremental.ILayer#add}
      * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
      */
      assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
    }
    var AsIsLayerer:{
      $class:yfiles.lang.Class;
      new ():yfiles.hierarchic.AsIsLayerer;
    };
    /**
    * This class can be used to wrap {@link yfiles.hierarchic.IDrawer} implementations.
    * It modifies the {@link yfiles.hierarchic.DrawerKeys#NODE_BORDER_LEFT} and
    * {@link yfiles.hierarchic.DrawerKeys#NODE_BORDER_RIGHT} DataProvider instances and delegates the
    * actual drawing to the inner drawer.
    * Actual space requirements are calculated in {@link yfiles.hierarchic.NodeLabelSpaceDrawer#getHaloSpace}.
    * This implementation uses the maximum left and right label overlaps as the halo values.
    * Note that this will only work with Drawer implementations that respect the values
    * provided through the DataProviders, e.g. MedianLinearSegmentsDrawer and SimplexDrawer.
    * <b>
    * This implementation uses {@link yfiles.layout.INodeLabelLayout}s and can therefor not be
    * used with layout orientations other than top to bottom.
    * </b>
    */
    export interface NodeLabelSpaceDrawer extends Object,yfiles.hierarchic.IDrawer{
      /**
      * This method assigns the coordinates to the nodes.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#assignCoordinates}.
      */
      assignCoordinates(g:yfiles.layout.LayoutGraph,layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
      /**
      * Calculates the horizontal space requirements for the given node.
      * This implementation uses the maximum left and right label overlaps as the halo values.
      * @param {yfiles.algorithms.Node} node The node to calculate the halo for.
      * @param {boolean} left Whether to calculate the left (<code>true</code>) or right (<code>false</code>) halo.
      * @return {number} The additional space needed by the given node at the given side.
      */
      getHaloSpace(node:yfiles.algorithms.Node,left:boolean):number;
      /**
      * Gives the drawer the opportunity to distinguish between dummy nodes
      * and real ones.
      * dummy stores the original edge for each dummy node or
      * <code>null</code> for real nodes.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#dummyMap}.
      */
      dummyMap:yfiles.algorithms.INodeMap;
      /**
      * The minimal distance between two edges in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalEdgeDistance}.
      */
      minimalEdgeDistance:number;
      /**
      * The minimal distance between two layers.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalLayerDistance}.
      */
      minimalLayerDistance:number;
      /**
      * The minimal distance between two edges sharing source/target (aka multi-edges) in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalMultiEdgeDistance}.
      */
      minimalMultiEdgeDistance:number;
      /**
      * The minimal distance between two nodes in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalNodeDistance}.
      */
      minimalNodeDistance:number;
    }
    var NodeLabelSpaceDrawer:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of NodeLabelSpaceDrawer.
      */
      new (inner:yfiles.hierarchic.IDrawer):yfiles.hierarchic.NodeLabelSpaceDrawer;
    };
    /**
    * Drawer based on rank-assignment.
    * The drawer works only with integer values and rounds double values to
    * integers.
    */
    export interface SimplexDrawer extends yfiles.hierarchic.AbstractDrawer{
      /**
      * The straightening factor.
      * Higher values will result in longer straight line routings.
      */
      straighteningFactor:number;
      /**
      * The time limit (in milliseconds) set for the algorithm.
      * Note that restricting the maximal duration may result in a worse layout quality.
      * Furthermore, the real runtime may exceed the maximal duration since the algorithm
      * still have to find a valid solution.
      */
      maximalDuration:number;
      /**
      * Assigns the coordinates to the nodes based on simplex-rank assignment.
      * @param {yfiles.algorithms.NodeList[]} layerLists The nodes in each layer.
      * @param {yfiles.algorithms.IDataProvider} layerID Provides the layer ID for nodes.
      * @see Overrides {@link yfiles.hierarchic.AbstractDrawer#assignCoordinatesToNodes}
      */
      assignCoordinatesToNodes(layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
      /**
      * Returns the overall edge cost of the result.
      * @param {yfiles.algorithms.INodeMap} result The result to calculate the cost for.
      * @param {yfiles.algorithms.IEdgeMap} weight Provides the edge weights.
      * @param {yfiles.algorithms.IEdgeMap} minLength Provides the min length for edges.
      * @return {number} The total cost given the parameters.
      */
      getCost(graph:yfiles.algorithms.Graph,result:yfiles.algorithms.INodeMap,weight:yfiles.algorithms.IEdgeMap,minLength:yfiles.algorithms.IEdgeMap):number;
    }
    var SimplexDrawer:{
      $class:yfiles.lang.Class;
      new ():yfiles.hierarchic.SimplexDrawer;
      /**
      * Returns whether the given node is a dummy node.
      */
      isDummy(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):boolean;
    };
    /**
    * This class can be used to improve the results of different drawers.
    * It is designed as a wrapper to another drawer (especially SimplexDrawer).
    * It will insert additional dummy nodes for each node that has an even number of
    * incoming edges or outgoing edges. Dummy nodes will be inserted in the neighbor
    * layer at the center of the other edges' opposite nodes.
    */
    export interface MedianDrawerWrapper extends Object,yfiles.hierarchic.IDrawer{
      /**
      * the delegate.
      */
      drawerDelegate:yfiles.hierarchic.IDrawer;
      /**
      * the dummyMap.
      */
      dummy:yfiles.algorithms.INodeMap;
      /**
      * This method assigns the coordinates to the nodes.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#assignCoordinates}.
      */
      assignCoordinates(g:yfiles.layout.LayoutGraph,layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
      /**
      * Gives the drawer the opportunity to distinguish between dummy nodes
      * and real ones.
      * dummy stores the original edge for each dummy node or
      * <code>null</code> for real nodes.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#dummyMap}.
      */
      dummyMap:yfiles.algorithms.INodeMap;
      /**
      * The minimal distance between two edges in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalEdgeDistance}.
      */
      minimalEdgeDistance:number;
      /**
      * The minimal distance between two layers.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalLayerDistance}.
      */
      minimalLayerDistance:number;
      /**
      * The minimal distance between two edges sharing source/target (aka multi-edges) in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalMultiEdgeDistance}.
      */
      minimalMultiEdgeDistance:number;
      /**
      * The minimal distance between two nodes in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalNodeDistance}.
      */
      minimalNodeDistance:number;
      /**
      * Called as a hook before the actual drawing is performed by the delegate.
      */
      preprocess(g:yfiles.layout.LayoutGraph,layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.INodeMap):void;
      /**
      * Called as a hook after the actual drawing is performed by the delegate.
      */
      postprocess(g:yfiles.layout.LayoutGraph,layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.INodeMap):void;
      /**
      * The drawer to which the actual drawing will be delegated.
      */
      delegate:yfiles.hierarchic.IDrawer;
    }
    var MedianDrawerWrapper:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of MedianDrawerWrapper using the delegate to
      * perform the core work.
      */
      new (drawerDelegate:yfiles.hierarchic.IDrawer):yfiles.hierarchic.MedianDrawerWrapper;
    };
    /**
    * This class implements the third phase of the hierarchic layout algorithm.
    * Edges are represented as polylines with at most two bends.
    * The algorithm has linear running time and is based on the article [BK01]:
    * U. Brandes and B. Koepf, Fast and Simple Horizontal Coordinate Assignment,
    * Proceedings of 9th Symposium of Graph Drawing, LNCS, 2001.
    */
    export interface MedianLinearSegmentDrawer extends yfiles.hierarchic.AbstractDrawer{
      /**
      * Performs coordinate assignment.
      * @see Overrides {@link yfiles.hierarchic.AbstractDrawer#assignCoordinatesToNodes}
      */
      assignCoordinatesToNodes(layerLists:yfiles.algorithms.NodeList[],_layerID:yfiles.algorithms.IDataProvider):void;
      /**
      * Initializes data structures for all runs.
      */
      init(g:yfiles.algorithms.Graph,layerLists:yfiles.algorithms.NodeList[]):void;
      /**
      * Initializes data structures for one basic step.
      * @param {number[]} x the array where the coordinates will be stored.
      */
      reinit(g:yfiles.algorithms.Graph,x:number[]):void;
      /**
      * Calculates vertical alignment.
      * This method corresponds to Algorithm 2 in [BK01].
      * @param {yfiles.layout.LayoutGraph} g the graph for which the layout is calculated.
      * @param {yfiles.algorithms.NodeList[]} layerLists the list of layers.
      */
      verticalAlignment(g:yfiles.layout.LayoutGraph,layerLists:yfiles.algorithms.NodeList[]):void;
      /**
      * Calculate coordinates.
      * This method corresponds to Algorithm 3 in [BK01].
      * @param {yfiles.layout.LayoutGraph} g the graph for which the layout is calculated.
      * @param {number[]} x the array where the result is stored.
      */
      horizontalCompaction(g:yfiles.layout.LayoutGraph,x:number[],layerLists:yfiles.algorithms.NodeList[]):void;
      /**
      * Writes the calculated x values in the layout graph.
      */
      propagateCoordinates(g:yfiles.layout.LayoutGraph):void;
      /**
      * Frees held resources.
      * @see Overrides {@link yfiles.hierarchic.AbstractDrawer#dispose}
      */
      dispose():void;
    }
    var MedianLinearSegmentDrawer:{
      $class:yfiles.lang.Class;
      new ():yfiles.hierarchic.MedianLinearSegmentDrawer;
      /**
      * Mark type 1 conflicts.
      * This method corresponds to Algorithm 1 in [BK01].
      * @param {yfiles.algorithms.NodeList[]} layerLists the list of layers.
      * @param {yfiles.algorithms.IEdgeMap} conflictMark used to mark the conflicting edges.
      * @param {yfiles.algorithms.INodeMap} dummyMap 
      * map which returns <code>true</code> for bends,
      * <code>false</code> otherwise.
      * @param {number[]} pos 
      * is indexed by the index method of node and returns the rank of
      * a node inside the layer which contains the node.
      */
      markConflicts(layerLists:yfiles.algorithms.NodeList[],conflictMark:yfiles.algorithms.IEdgeMap,dummyMap:yfiles.algorithms.INodeMap,pos:number[]):void;
    };
    /**
    * This class implements the third phase of the Sugiyama layout algorithm
    * as described in "Visualisierungstechniken fuer den Compilerbau" (Georg Sander)
    * mixed with techniques as described in "A technique for drawing directed graphs"
    * (Gansner et al).
    */
    export interface PendularDrawer extends yfiles.hierarchic.AbstractDrawer{
      /**
      * map that maps the right node for each node in a layer or <code>null</code> if it is the rightmost.
      */
      right:yfiles.algorithms.INodeMap;
      /**
      * map that maps the left node for each node in a layer or <code>null</code> if it is the leftmost.
      */
      left:yfiles.algorithms.INodeMap;
      /**
      * used to initialize internal structures such as <code>NodeMap right</code> and
      * <code>NodeMap left</code> <code>bendGridWidth</code> and <code>nodeGridWidth</code>.
      * Note that the NodeMaps do not yet contain any values unless you call initializePositions()
      */
      initStructures():void;
      /**
      * This is the main loop of this layout algorithm.
      * For now it does the following loop:
      * <ul>
      * <li> for each round do
      * <ul>
      * <li>top down phase, i.e. calling partitionLayer(layerList[i] , -1)
      * and shakePartition(partition,-1) for each layer in top down order</li>
      * <li>bottom up phase, i.e. calling partitionLayer(layerList[i] , -1)
      * and shakePartition(partition,-1) for each layer in bottom up order</li>
      * <li>criss cross phase, i.e. calling partitionLayer(layerList[i] , 0)
      * and shakePartition(partition,0) for each layer in top down order</li>
      * <li>performing minNode</li>
      * </ul></li>
      * <li> minPath phase, i.e. calling findChains() and minPath(chains)</li>
      * </ul>
      * Subclasses that wish to override this function to implement different behaviour should
      * implement a call to initStructures() and
      * initializePositions(layerLists) before using the provided methods.
      * After the work is done, they should call disposeStructures(g).
      * @param {yfiles.algorithms.NodeList[]} layerLists 
      * a list of all the nodes for each layer, to determine
      * their relative positions
      * @see Overrides {@link yfiles.hierarchic.AbstractDrawer#assignCoordinatesToNodes}
      */
      assignCoordinatesToNodes(layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
      /**
      * Cleans up previously allocated structures, that were constructed by a call to
      * <code>initStructures</code>.
      * @see {@link yfiles.hierarchic.PendularDrawer#initStructures}
      */
      disposeStructures():void;
      /**
      * Performs the minPath phase.
      * It tries to straighten the chains given by a list of NodeLists, by sequentially assigning the same
      * x- coordinate to as many adjacent nodes of each chain as possible, not violating the constraints and
      * not changing coordinates of nodes in the neighborhood of each segment
      * @see {@link yfiles.hierarchic.PendularDrawer#findChains}
      * @param {yfiles.algorithms.YList} segments a list of NodeList each containing a chain of nodes
      * @return {boolean} <code>true</code> iff there was a change in any coordinate of the graph
      */
      minPath(segments:yfiles.algorithms.YList):boolean;
      /**
      * Finds chains of nodes, i.e.
      * maximum number of adjacent nodes (real ones and dummy nodes) have
      * indegree and outdegree 1.
      * @see {@link yfiles.hierarchic.PendularDrawer#minPath}
      * @return {yfiles.algorithms.YList} a list of NodeLists containing each more than 1 nodes
      */
      findChains():yfiles.algorithms.YList;
      /**
      * Helper method for use in <code>minPath</code>.
      * It will assign the same x-coordinate to all the nodes
      * given the first and the last cell in NodeList.
      * Note that this method does not double-check whether the given
      * range is valid for all nodes.
      * @param {yfiles.algorithms.ListCell} firstCell 
      * this determines the first Node in a NodeList
      * which should be assigned a new x-coordinate
      * @param {yfiles.algorithms.ListCell} lastCell 
      * this determines the last Node in a NodeList
      * (which must be same List as the one for firstCell) which should
      * be assigned a new x-coordinate
      * @param {number[]} range 
      * an interval providing information of the legal range,
      * the Nodes x-coordinates could be set to.
      * The values can can be smaller than (-Double.MAX_VALUE) for the left
      * border and greater than Double.MAX_VALUE for the right one
      * @see {@link yfiles.hierarchic.PendularDrawer#minPath}
      * @return {boolean} 
      * <code>true</code> iff this method has done any change to the graphs
      * coordinates
      */
      straightenPath(firstCell:yfiles.algorithms.ListCell,lastCell:yfiles.algorithms.ListCell,range:number[]):boolean;
      /**
      * Helper method that determines whether a node is a so-called segment node.
      * @param {yfiles.algorithms.Node} n the Node
      * @return {boolean} 
      * <code>true</code> iff (inDegree == 1 &amp;&amp; outDegree &lt; 2) ||
      * (outDegree == 1 &amp;&amp; inDegree &lt; 2)
      */
      isSegmentNode(n:yfiles.algorithms.Node):boolean;
      /**
      * Performs the minNode phase.
      * It uses a queue, which is initially filled with all nodes in the
      * layout graph.
      * For each Node n that is popped off the queue it performs a call to
      * <ul>
      * <li>force = getPendulumForce(n, n.edges) </li>
      * <li>force = verifyMovement(n,force)</li>
      * <li>move(n, force)</li>
      * </ul>
      * If the node has changed its x-coordinate all its neighbors are requeued,
      * if not already in the queue.
      */
      minNode():void;
      /**
      * Shakes a given partition of a Layer, i.e.
      * it calculates the forces for
      * each part of the partition
      * and applies them if possible.
      * It uses the functionality of these methods:
      * <ul>
      * <li>getPendulumForce(NodeCursor, int direction)</li>
      * <li>verifyMovement(Node, double force)</li>
      * <li>move(NodeCursor, double force)</li>
      * </ul>
      * @see {@link yfiles.hierarchic.PendularDrawer#partitionLayer}
      * @see {@link yfiles.hierarchic.PendularDrawer#getPendulumForce}
      * @param {yfiles.algorithms.YList} partition 
      * a List of NodeLists each containing at least one node
      * belonging to a single layer
      * @param {number} direction 
      * -1 if nodes in higher layers should be used to calculate
      * the forces, 1 if nodes in lower layers should be used, 0 if both
      * surrounding layers should be used
      */
      shakePartition(partition:yfiles.algorithms.YList,direction:number):void;
      /**
      * Partitions a layer given by its NodeList by calculating the forces
      * according to the given direction.
      * This one is intended for use with the shakePartition() method.
      * @see {@link yfiles.hierarchic.PendularDrawer#getPendulumForce}
      * @see {@link yfiles.hierarchic.PendularDrawer#touches}
      * @see {@link yfiles.hierarchic.PendularDrawer#shakePartition}
      * @param {yfiles.algorithms.NodeList} layer the layer which shall be partitioned
      * @param {number} direction 
      * -1 if nodes in higher layers should be used to calculate
      * the forces, 1 if nodes in lower layers
      * should be used, 0 if both surrounding layers should be used
      * @return {yfiles.algorithms.YList} 
      * a list of NodeLists each containing adjacent nodes in that layer,
      * which can be treated as a single unit when moving
      */
      partitionLayer(layer:yfiles.algorithms.NodeList,direction:number):yfiles.algorithms.YList;
      layoutGraph:yfiles.layout.LayoutGraph;
      /**
      * Helper method which calculates the force that all nodes given by
      * EdgeCursor apply to v.
      * The force is calculated by the sum of the weighted differences of the
      * x-coordinates.
      * @see {@link yfiles.hierarchic.PendularDrawer#getEdgeWeight}
      * @param {yfiles.algorithms.Node} v the node for which the force will be calculated
      * @param {yfiles.algorithms.IEdgeCursor} ec 
      * the EdgeCursor which determines which edges should be
      * considered in the calculation
      * @return {number} 
      * a force, i.e. a signed value, which (if added to the x-coordinate
      * of v) would minimize the force on v if applied.
      */
      getPendulumForceForNode(v:yfiles.algorithms.Node,ec:yfiles.algorithms.IEdgeCursor):number;
      /**
      * Helper method which checks whether two adjacent nodes on a layer touch
      * each other, i.e.
      * their
      * distance is smaller than getMinimalLayerDistance(v1, ...)
      * @param {yfiles.algorithms.Node} v1 one node
      * @param {yfiles.algorithms.Node} v2 another node
      * @return {boolean} 
      * <code>true</code> iff their distance is smaller than
      * getMinimalLayerDistance+EPSILON
      * @see {@link yfiles.hierarchic.PendularDrawer#getMinimalLayerDistance}
      */
      touches(v1:yfiles.algorithms.Node,v2:yfiles.algorithms.Node):boolean;
      /**
      * Assures that if distance was applied to the n's x-coordinate no given constraint gets broken.
      * It makes extensive use of getMinimalLayerDistance(v1, ...)
      * @param {yfiles.algorithms.Node} n the node to be moved
      * @param {number} distance the distance which shall be verified
      * @return {number} the distance which can be applied to n without breaking any constraint
      * @see {@link yfiles.hierarchic.PendularDrawer#getMinimalLayerDistance}
      */
      verifyMovement(n:yfiles.algorithms.Node,distance:number):number;
      /**
      * Helper method which calculates the force acting on all nodes given by the cursor.
      * The force is calculated by the sum of the results of calls to getPendulumForce(Node, int)
      * divided by the number of the nodes.
      * @param {yfiles.algorithms.ICursor} cursor the nodes for which the force will be calculated
      * @return {number} 
      * a force, i.e. a signed value, which, if applied to the nodes in cursor, would minimize
      * the force acting on them.
      * @param {number} direction 
      * -1 if nodes in higher layers should be used to calculate the forces, 1 if nodes
      * in lower layers should be used, 0 if both surrounding layers should be used
      */
      getPendulumForce(cursor:yfiles.algorithms.ICursor,direction:number):number;
      /**
      * Helper method which moves a given node by a given amount
      * if the useGrid is set to true, this method will snap the new node position to the
      * appropriate grid, i.e.
      * it decides whether to use nodeGridWith or bendGridWith
      * @param {yfiles.algorithms.Node} n the node
      * @param {number} distance the distance that shall be added to the nodes x-coordinate
      */
      moveNode(n:yfiles.algorithms.Node,distance:number):void;
      /**
      * Helper method which moves the nodes provided by the Cursor nodes by the given amount.
      * This one in turn calls move(Node,double) to delegate its work.
      * @see {@link yfiles.hierarchic.PendularDrawer#moveNode}
      * @param {yfiles.algorithms.ICursor} nodes the nodes
      * @param {number} distance the distance that shall be added to the nodes x-coordinate
      */
      move(nodes:yfiles.algorithms.ICursor,distance:number):void;
      /**
      * Calculates the value of the function this algorithm should minimize.
      * @return {number} a positive value.
      */
      getZ():number;
      /**
      * Returns a non-negative value for each Edge e.
      * In this implementation edges between two real nodes result in an edge weight of 1.
      * Edges between one dummy and one real node result in an edge weight of
      * <code>segmentEndFactor * 1</code>.
      * Edges between two dummy nodes get an edge weight of <code>segmentFactor * 1</code>.
      * One could implement edge weights by supplying an <code>EdgeMap</code> mapping a non-negative
      * numeric value for each edge.
      * @param {yfiles.algorithms.Edge} e the edge
      * @return {number} a non-negative value
      */
      getEdgeWeight(e:yfiles.algorithms.Edge):number;
      /**
      * Calculates the highest or lowest x-coordinate the Node n can be assigned to, without breaking
      * the constraints.
      * @param {yfiles.algorithms.Node} n the node
      * @param {boolean} toLeft 
      * <code>true</code> if the minimum x-coordinate shall be calculated;
      * <code>false</code> for the maximum x-coordinate
      * @return {number} the maximum/minimum extent of the node's center x-coordinate
      */
      getMaximumExtent(n:yfiles.algorithms.Node,toLeft:boolean):number;
      /**
      * Returns the minimum distance between two Nodes on the same layer according to
      * getMinimalNodeDistance(), getMinimalEdgeDistance() and getMinimalMultiEdgeDistance().
      * @see {@link yfiles.hierarchic.AbstractDrawer#minimalMultiEdgeDistance}
      * @see {@link yfiles.hierarchic.AbstractDrawer#minimalNodeDistance}
      * @see {@link yfiles.hierarchic.AbstractDrawer#minimalEdgeDistance}
      * @param {yfiles.algorithms.Node} n the node
      * @param {boolean} toLeft 
      * <code>true</code> if the minimum x-coordinate shall be calculated;
      * <code>false</code> for the maximum x-coordinate
      * @return {number} the maximum/minimum extent of the node's center x-coordinate
      */
      getMinimalLayerDistance(n:yfiles.algorithms.Node,toLeft:boolean):number;
      /**
      * Helper method which initializes the positions of the nodes in all layers.
      * This method respects getMinimalLayerDistance(Node,boolean)
      * and compacts the graph to the leftmost position (0)
      * @param {yfiles.algorithms.NodeList[]} layerList an array of NodeLists each corresponding to a single layer
      */
      initializePositions(layerList:yfiles.algorithms.NodeList[]):void;
    }
    var PendularDrawer:{
      $class:yfiles.lang.Class;
      /**
      * empty constructor, does nothing.
      */
      new ():yfiles.hierarchic.PendularDrawer;
    };
    /**
    * This class is an implementation of the third phase of the
    * Sugiyama algorithm, which represents edges by  polylines.
    */
    export interface PolylineDrawer extends yfiles.hierarchic.AbstractDrawer{
      /**
      * Overwrite this method to assign the final coordinates to the
      * objects of he graph.
      */
      assignCoordinatesToNodes(layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
    }
    var PolylineDrawer:{
      $class:yfiles.lang.Class;
      new ():yfiles.hierarchic.PolylineDrawer;
    };
    /**
    * This class assigns port coordinates to the edges of a graph.
    */
    export interface PortAssignment extends Object{
    }
    var PortAssignment:{
      $class:yfiles.lang.Class;
      /**
      * Assigns port coordinates to the edges.
      * It is assumed that all incoming edges
      * of a node connect at the top side of that node and that all outgoing edges
      * of a node leave at the bottom side of that node.
      * Port assignment will be such that the ports will be spread evenly
      * at top and bottom sides of the nodes. Ports will be assigned such that
      * no unnecessary edge crossings will be introduced.
      * @param {yfiles.layout.LayoutGraph} g graph whose edges need port assignment
      * @param {yfiles.algorithms.NodeList[]} layers the layering of g
      * @param {yfiles.algorithms.IDataProvider} dummyMark 
      * provides boolean data about whether a node
      * is a dummy node or not.
      */
      assignPortsForLayers(g:yfiles.layout.LayoutGraph,layers:yfiles.algorithms.NodeList[],dummyMark:yfiles.algorithms.IDataProvider):void;
      /**
      * Assigns port coordinates to the edges.
      * It is assumed that all incoming edges
      * of a node connect at the top side of that node and that all outgoing edges
      * of a node leave at the bottom side of that node.
      * Port assignment will be such that the ports will be spread evenly
      * at top and bottom sides of the nodes. Ports will be assigned according to
      * the given Comparators.
      * @param {yfiles.layout.LayoutGraph} g graph whose edges need port assignment
      * @param {yfiles.algorithms.IDataProvider} dummyMark 
      * provides boolean data about whether a node
      * is a dummy node or not.
      * @param {yfiles.objectcollections.IComparer} inComp A Comparator that defines an ordering for edges. This comparator is used for ordering the edges entering a node.
      * @param {yfiles.objectcollections.IComparer} outComp A Comparator that defines an ordering for edges. This comparator is used for ordering the edges leaving a node
      */
      assignPorts(g:yfiles.layout.LayoutGraph,dummyMark:yfiles.algorithms.IDataProvider,inComp:yfiles.objectcollections.IComparer,outComp:yfiles.objectcollections.IComparer):void;
    };
    /**
    * This class is a variant of the classic {@link yfiles.hierarchic.HierarchicLayouter}
    * implementation.
    * It serves as a facade to {@link yfiles.hierarchic.incremental.HierarchicLayouter}.
    * <p>
    * Instances can be used to simply create hierarchic layouts from scratch or add
    * new elements to the existing sketch drawing incrementally.
    * In order to add elements incrementally to the current sketch or let the algorithm
    * optimize certain elements in the current sketch, set its mode to
    * {@link yfiles.hierarchic.LayoutMode#INCREMENTAL} and
    * add a {@link yfiles.algorithms.IDataProvider} (e.g. use {@link yfiles.algorithms.Maps#createHashedDataMap}) using the
    * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#INCREMENTAL_HINTS_DP_KEY} DataProvider key to the graph and associate the marks
    * obtained from the {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory} with the elements to be
    * added incrementally. </p>
    * <p>
    * Many settings of the layout can be controlled using the {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor}
    * and {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor} instances. The ones that are used during the
    * layout run can be obtained from {@link yfiles.hierarchic.IncrementalHierarchicLayouter#edgeLayoutDescriptor} and
    * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#nodeLayoutDescriptor} respectively. 
    * If at the time of the invocation DataProvider instances are bound to the graph
    * using either the {@link yfiles.hierarchic.incremental.HierarchicLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY} or
    * {@link yfiles.hierarchic.incremental.HierarchicLayouter#NODE_LAYOUT_DESCRIPTOR_DP_KEY} keys, they will be wrapped
    * and whenever they do not provide values the ones set in this instance will be used as fall-back values.
    * </p>
    * <p>
    * IncrementalHierarchicLayouter supports two approaches to connect edges on a specific side or even an exact location
    * to a node. {@link yfiles.layout.PortConstraint}s define a single constraint for the ports of an edge. To realize more
    * complex port restrictions, several {@link yfiles.layout.PortCandidate}s or {@link yfiles.layout.PortCandidateSet}s can be
    * assigned to edges or
    * nodes. If an edge with registered <code>PortCandidate</code>s connects to nodes with <code>PortCandidateSet</code>s,
    * the layouter will try to match both collections to find an appropriate port. In case there is no matching port
    * candidate, a <code>PortCandidate</code> specified for the edge is preferred.
    * Since their simultaneous existence at the same node may be ambiguous, it is not recommended to use a combination of
    * <code>PortConstraint</code>s and <code>PortCandidate</code>s in the same layout.
    * </p>
    * <p>
    * Here is a sample layout output:
    * </p>
    * <p>
    * <center><img src="doc-files/y.layout.hierarchic.incremental.IncrementalHierarchicLayouter.general.gif" border="1"/></center>
    * </p>
    * <p>
    * The following example shows the result of an incremental layout with lots of port constraints
    * (For clarity colored layers have been added to the diagram):
    * </p>
    * <p>
    * <center><img src="doc-files/y.layout.hierarchic.incremental.IncrementalHierarchicLayouter.ports1.gif" border="1"/></center>
    * </p>
    * <p>
    * The last example shows the result of a layout run that considered swim lanes.
    * Nodes with the same label have been placed into the same swim lane. Swim lanes
    * have been ordered in ascending order of the label names.
    * (For clarity lines have been added to the diagram that depict the bounds of the
    * swim lanes):
    * </p>
    * <p>
    * <center><img src="doc-files/y.layout.hierarchic.incremental.IncrementalHierarchicLayouter.swimlaneex1.gif" border="1"/></center>
    * </p>
    * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
    * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#INCREMENTAL_HINTS_DP_KEY}
    * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#createIncrementalHintsFactory}
    * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter}
    */
    export interface IncrementalHierarchicLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * The group layer alignment strategy used for recursive group layering.
      * <p>
      * Default value is {@link yfiles.hierarchic.GroupAlignmentPolicy#CENTER}.
      * </p>
      * @see {@link yfiles.hierarchic.GroupAlignmentPolicy#TOP}
      * @see {@link yfiles.hierarchic.GroupAlignmentPolicy#CENTER}
      * @see {@link yfiles.hierarchic.GroupAlignmentPolicy#BOTTOM}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#recursiveGroupLayering}
      * @see {@link yfiles.hierarchic.GroupAlignmentPolicy#TOP}
      * @see {@link yfiles.hierarchic.GroupAlignmentPolicy#CENTER}
      * @see {@link yfiles.hierarchic.GroupAlignmentPolicy#BOTTOM}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#recursiveGroupLayering}
      */
      groupAlignmentPolicy:yfiles.hierarchic.GroupAlignmentPolicy;
      /**
      * Specifies whether layer compaction for recursive group layering is active.
      * If set to <code>true</code>, the recursive layering is compacted, i.e. node
      * ranks are decreased if possible without reversing edge directions.
      * This differs from non-recursive layering, where groups are ignored completely.
      * The resulting layering tries to keep the layer span of a group node minimal,
      * while minimizing the overall vertical space.
      * <p>
      * By default, this feature is disabled.
      * </p>
      * <p>
      * <b>Note:</b>
      * This feature works best when a instance of
      * {@link yfiles.hierarchic.TopologicalLayerer} is used for layer assignment.
      * If this feature is enabled, an alignment policy that is set with
      * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#groupAlignmentPolicy} is ignored.
      * </p>
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#recursiveGroupLayering}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#recursiveGroupLayering}
      */
      compactGroups:boolean;
      /**
      * The policy that is used to arrange connected components.
      * <p>
      * Defaults to {@link yfiles.hierarchic.ComponentArrangementPolicy#TOPMOST}.
      * </p>
      * @throws {yfiles.system.ArgumentException} 
      * if the specified policy does not match
      * one component arrangement policy constants.
      */
      componentArrangementPolicy:yfiles.hierarchic.ComponentArrangementPolicy;
      /**
      * The time limit (in milliseconds) set for the layout algorithm.
      * <p>
      * The layout algorithm takes also into consideration the time limits of the default
      * {@link yfiles.hierarchic.incremental.ILayerer}, {@link yfiles.hierarchic.incremental.ISequencer} and {@link yfiles.hierarchic.incremental.INodePlacer} instances (if any)
      * and will try to not exceed the given values.
      * </p>
      * <p>
      * Note that restricting the maximal duration may result in a worse layout quality.
      * Furthermore, the actual runtime may exceed the maximal duration since the layout algorithm
      * still has to find a valid solution.
      * </p>
      */
      maximalDuration:number;
      /**
      * Specifies whether groups are respected during the layering stage.
      * <p>
      * If set to <code>true</code> (and {@link yfiles.hierarchic.IncrementalHierarchicLayouter#compactGroups group compaction} is not enabled), groups are layered recursively, i.e.
      * <ul>
      * <li>nodes in the same group always occupy adjacent layers</li>
      * <li>layer intervals spanned by different group nodes are either disjoint or are nested</li>
      * </ul>
      * If this feature is disabled, group information is ignored for the layering step.
      * If the graph is flat, this setting is ignored.
      * </p>
      * <p>
      * By default, this feature is enabled.
      * </p>
      */
      recursiveGroupLayering:boolean;
      /**
      * The equidistant spacing between the horizontal and vertical grid lines.
      * <p>
      * By default no grid is specified (spacing is &lt;= 0).
      * </p>
      * <p>
      * Note that the grid feature doesn't work together with exact (layer/sequence) coordinate hints
      * (see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory}).
      * </p>
      */
      gridSpacing:number;
      /**
      * Specifies whether or not ComponentLayouter is enabled.
      * By default it is disabled.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#componentLayouterEnabled}
      */
      componentLayouterEnabled:boolean;
      /**
      * Whether or not backloop routing should be applied.
      * Note that port constraints and port candidates are still considered.
      */
      backloopRouting:boolean;
      /**
      * Determines whether or not selfloops should be routed like backloops when backloop routing is enabled.
      * That means, if there aren't any port constraints the selfloop will start at the bottom of the node and end at the
      * top of it.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#backloopRouting}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#backloopRouting}
      */
      backloopRoutingForSelfloops:boolean;
      /**
      * Whether or not automatic edge grouping should be applied.
      * The automatic edge grouping tries to group a high number of edges without
      * changing the semantic of the graph, i.e., it groups edges either at a common source node or a common target node.
      * Edge groupings often allow more compact layouts since grouped edges are routed in a bus-style manner.
      * Note: Edges are only grouped at their source (target) node if they do not have a port constraint/port candidates at this node.
      * Furthermore, edges cannot be grouped at a node with specified port candidates (see class {@link yfiles.layout.PortCandidateSet}).
      * User specified edge groups are not considered.
      */
      automaticEdgeGrouping:boolean;
      /**
      * Specifies whether or not edges should be routed orthogonally.
      * Specifies value <code>true</code>
      * signals that all resulting edge paths will be composed of vertical and horizontal segments, only.
      * Default is <code>false</code>.
      * Note that this is a convenience method delegates to
      * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#edgeLayoutDescriptor}.{@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor#orthogonallyRouted}.
      */
      orthogonalRouting:boolean;
      /**
      * Specifies whether integrated edge labeling is enabled.
      * This method is a convenience method that checks if the
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter}
      * is of type {@link yfiles.layout.LabelLayoutTranslator} and
      * {@link yfiles.layout.LabelLayoutTranslator#translateEdgeLabels} returns
      * <code>true</code>.
      * The default is <code>false</code>.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current label layouter is not of type
      * {@link yfiles.layout.LabelLayoutTranslator}.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current label layouter is not of type
      * {@link yfiles.layout.LabelLayoutTranslator}.
      */
      integratedEdgeLabeling:boolean;
      /**
      * Specifies whether or not node labels are taken into account when calculating
      * node positions (thereby preventing possible node/node label or
      * node label/node label overlaps).
      * <b>Setter:</b>This method is a convenience method that assures that the
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter}
      * is of type {@link yfiles.layout.LabelLayoutTranslator} and
      * {@link yfiles.layout.LabelLayoutTranslator#translateNodeLabels} is set
      * to <code>true</code>.
      * Note that setting this option may overwrite the currently set label layouter. Hence, to combine this option with
      * a generic edge labeling algorithm, the generic labeling has to be applied in an additional step after calculating the layout.
      * <b>Getter:</b>This method is a convenience method checks whether the
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter}
      * is of type {@link yfiles.layout.LabelLayoutTranslator} and
      * {@link yfiles.layout.LabelLayoutTranslator#translateNodeLabels} returns
      * <code>true</code>.
      * The default is <code>false</code>.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current label layouter is not of type
      * {@link yfiles.layout.LabelLayoutTranslator}.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current label layouter is not of type
      * {@link yfiles.layout.LabelLayoutTranslator}.
      */
      considerNodeLabels:boolean;
      /**
      * The minimum distance between two adjacent layers.
      * The default is <code>20.0d</code>.
      */
      minimumLayerDistance:number;
      /**
      * The minimum distance between two adjacent nodes in one layer.
      * <b>Setter:</b>See {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#minimumDistance} for related settings.
      * <b>Getter:</b>The default is <code>30.0d</code>.
      */
      nodeToNodeDistance:number;
      /**
      * The minimum distance between two adjacent nodes in one layer.
      * <b>Setter:</b>See {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#minimumDistance} and
      * {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor#minimumDistance} for related settings.
      * <b>Getter:</b>The default is <code>15.0d</code>.
      */
      nodeToEdgeDistance:number;
      /**
      * The minimum distance between two adjacent edges in one layer.
      * See {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor#minimumDistance} for related settings.
      */
      edgeToEdgeDistance:number;
      /**
      * The{@link yfiles.hierarchic.incremental.DefaultDrawingDistanceCalculator} that is registered
      * with the layout algorithm by default.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current instance returned
      * by {@link yfiles.hierarchic.incremental.HierarchicLayouter#drawingDistanceCalculator}
      * is not an instance of <code>DefaultDrawingDistanceCalculator</code>.
      */
      defaultDrawingDistanceCalculator:yfiles.hierarchic.incremental.DefaultDrawingDistanceCalculator;
      /**
      * Factory method that creates the internally used {@link yfiles.hierarchic.incremental.HierarchicLayouter}
      * instance.
      * @return {yfiles.hierarchic.incremental.HierarchicLayouter} <code>new y.layout.hierarchic.incremental.HierarchicLayouter()</code>
      */
      createHierarchicLayouter():yfiles.hierarchic.incremental.HierarchicLayouter;
      /**
      * The internally used
      * {@link yfiles.hierarchic.incremental.HierarchicLayouter} instance.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#createHierarchicLayouter}
      */
      hierarchicLayouter:yfiles.hierarchic.incremental.HierarchicLayouter;
      /**
      * The currently set layering strategy for the
      * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fromScratchLayerer  from scratch} layering.
      * The layouter assigns the nodes to separate layers. The nodes within each layer will be
      * placed on the same horizontal layer.
      * The layers will be arranged vertically starting with the small-numbered layers.
      * The rank of a node is the number of the layer it belongs to.
      * An important layering strategy for the hierarchic layout style is called <i>Hierarchical Layering</i>.
      * A hierarchical layering tries to assign nodes to layers in a way that as much as possible
      * edges of the graph will point to the main layout direction, i.e. the start nodes of the edges will
      * have a smaller rank than the corresponding end nodes. Also, a hierarchical layering
      * will never put two connected nodes in the same layer.
      * By default the layering strategy {@link yfiles.hierarchic.LayeringStrategy#HIERARCHICAL_OPTIMAL} is set.
      * This method wraps the internal implementations into a {@link yfiles.hierarchic.incremental.MultiComponentLayerer}
      * instance so that it is possible to specify the behavior of the algorithm if the
      * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#componentLayouterEnabled  component layouter} is disabled.
      */
      fromScratchLayeringStrategy:yfiles.hierarchic.LayeringStrategy;
      /**
      * Determines whether this layouter can perform the core layout on the given
      * graph.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Performs the actual layout using the currently set mode.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#configureCoreLayout}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#unconfigureCoreLayout}
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(g:yfiles.layout.LayoutGraph):void;
      /**
      * The{@link yfiles.layout.CanonicMultiStageLayouter#orientationLayouter  orientation layouter}'s mirror mask.
      */
      mirrorMask:number;
      /**
      * Called before the actual layout is performed.
      * Overwrite this to manually reconfigure the instance.
      * If {@link yfiles.layout.PortCandidateSet#NODE_DP_KEY} is registered with the layout graph and
      * there is no {@link yfiles.hierarchic.incremental.HierarchicLayouter#portConstraintOptimizer}
      * registered, {@link yfiles.hierarchic.incremental.PCListOptimizer} will be temporarily configured with the instance.
      * @param {yfiles.layout.LayoutGraph} graph the graph to be laid out
      * @param {yfiles.hierarchic.incremental.HierarchicLayouter} ihl the instance used for the core layout.
      */
      configureCoreLayout(graph:yfiles.layout.LayoutGraph,ihl:yfiles.hierarchic.incremental.HierarchicLayouter):void;
      /**
      * Called after the actual layout is performed.
      * Overwrite this to manually unconfigure the instance.
      * If {@link yfiles.layout.PortCandidateSet#NODE_DP_KEY} is registered with the layout graph and
      * {@link yfiles.hierarchic.incremental.PCListOptimizer} was registered with the instance during
      * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#configureCoreLayout}
      * it will be removed by this method.
      * @param {yfiles.layout.LayoutGraph} graph the graph to be laid out
      * @param {yfiles.hierarchic.incremental.HierarchicLayouter} ihl the instance used for the core layout.
      */
      unconfigureCoreLayout(graph:yfiles.layout.LayoutGraph,ihl:yfiles.hierarchic.incremental.HierarchicLayouter):void;
      /**
      * Returns a {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory} instance that must be used
      * to obtain marks that can be associated with elements in the graph that
      * will be laid out incrementally.
      * Use this factory and a {@link yfiles.algorithms.IDataProvider} that is bound to the graph
      * using the {@link yfiles.hierarchic.IncrementalHierarchicLayouter#INCREMENTAL_HINTS_DP_KEY} DataProvider key to associate
      * appropriate hints with the elements in the graph that should be laid out
      * incrementally by the algorithm.
      * @return {yfiles.hierarchic.incremental.IIncrementalHintsFactory} the factory
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createIncrementalHintsFactory}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#INCREMENTAL_HINTS_DP_KEY}
      * @see {@link yfiles.algorithms.Graph#addDataProvider}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @see {@link yfiles.hierarchic.LayoutMode#INCREMENTAL}
      */
      createIncrementalHintsFactory():yfiles.hierarchic.incremental.IIncrementalHintsFactory;
      /**
      * Returns a {@link yfiles.hierarchic.incremental.ISequenceConstraintFactory}
      * instance that can be used to specify sequence constraints for the given
      * graph.
      * For these sequence constraints to have any effect, the
      * {@link yfiles.hierarchic.incremental.ISequencer} used to determine the
      * in-layer node order (<em>sequence</em>) has to support constraints. Both,
      * {@link yfiles.hierarchic.incremental.DefaultLayerSequencer DefaultLayerSequencer}
      * and the incremental sequencer used internally support sequence constraints.
      * <p>
      * <b>Note:</b>
      * <code>SequenceConstraintFactory</code> instances have to be
      * {@link yfiles.hierarchic.incremental.ISequenceConstraintFactory#dispose  disposed}
      * after use. Disposing the factory will also remove all constraints
      * previously specified for the factory's associated graph.
      * Creating sequence constraints with a disposed factory will throw an <code>IllegalStateException</code>.
      * </p>
      * <p>
      * Creating a new constraint factory for a graph will render all previously
      * created factories (including any constraints specified) for that graph
      * useless. Therefore a new constraint factory should only be created after
      * previously used factories have been properly disposed.
      * </p>
      * @param {yfiles.layout.LayoutGraph} graph 
      * @return {yfiles.hierarchic.incremental.ISequenceConstraintFactory} A SequenceConstraintFactory instance for use with the given graph.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fromScratchSequencer}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fixedElementsSequencer}
      */
      createSequenceConstraintFactoryForLayoutGraph(graph:yfiles.layout.LayoutGraph):yfiles.hierarchic.incremental.ISequenceConstraintFactory;
      /**
      * Returns a {@link yfiles.hierarchic.incremental.ILayerConstraintFactory}
      * instance that can be used to specify layer constraints for the given
      * graph.
      * <p>
      * <b>Note:</b>
      * <code>LayerConstraintFactory</code> instances have to be
      * {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#dispose  disposed}
      * after use. Disposing the factory will also remove all constraints
      * previously specified for the factory's associated graph.
      * Creating layering constraints with a disposed factory will throw an <code>IllegalStateException</code>.
      * </p>
      * <p>
      * Creating a new constraint factory for a graph will render all previously
      * created factories (including any constraints specified) for that graph
      * useless. Therefore a new constraint factory should only be created after
      * previously used factories have been properly disposed.
      * </p>
      * @param {yfiles.algorithms.Graph} graph the given graph.
      * @return {yfiles.hierarchic.incremental.ILayerConstraintFactory} A LayerConstraintFactory instance for use with the given graph.
      */
      createLayerConstraintFactory(graph:yfiles.algorithms.Graph):yfiles.hierarchic.incremental.ILayerConstraintFactory;
      /**
      * The{@link yfiles.hierarchic.incremental.ILayerer} instance that is used to obtain the layering
      * for the nodes if the layouter is set to {@link yfiles.hierarchic.LayoutMode#FROM_SCRATCH}.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      */
      fromScratchLayerer:yfiles.hierarchic.incremental.ILayerer;
      /**
      * The{@link yfiles.hierarchic.incremental.ISequencer} instance that is used to calculate the node
      * sequence if the layouter is set to {@link yfiles.hierarchic.LayoutMode#FROM_SCRATCH}.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fromScratchLayerer}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      */
      fromScratchSequencer:yfiles.hierarchic.incremental.ISequencer;
      /**
      * The{@link yfiles.hierarchic.incremental.INodePlacer} instance that will be used to calculated the
      * final node placement of the layout.
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      */
      nodePlacer:yfiles.hierarchic.incremental.INodePlacer;
      /**
      * The{@link yfiles.hierarchic.incremental.ILayerer} instance that is used to obtain the layering
      * for those nodes that are not marked to be laid out incrementally
      * if the layouter is set to {@link yfiles.hierarchic.LayoutMode#INCREMENTAL}.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      */
      fixedElementsLayerer:yfiles.hierarchic.incremental.ILayerer;
      /**
      * The{@link yfiles.hierarchic.incremental.ISequencer} instance that is used to calculated the sequence
      * of the nodes that are not marked to be laid out incrementally
      * if the layouter is set to {@link yfiles.hierarchic.LayoutMode#INCREMENTAL}.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      */
      fixedElementsSequencer:yfiles.hierarchic.incremental.ISequencer;
      /**
      * The layout mode this layouter is currently in.
      * Depending on the mode the layout algorithm will use different
      * {@link yfiles.hierarchic.incremental.ILayerer} and {@link yfiles.hierarchic.incremental.ISequencer} implementations. 
      * Currently supported modes are:
      * <ul>
      * <li>{@link yfiles.hierarchic.LayoutMode#INCREMENTAL}</li>
      * <li>{@link yfiles.hierarchic.LayoutMode#FROM_SCRATCH}</li>
      * </ul>
      * Defaults to {@link yfiles.hierarchic.LayoutMode#FROM_SCRATCH}.
      * @throws {yfiles.system.ArgumentException} if the mode is unknown
      */
      layoutMode:yfiles.hierarchic.LayoutMode;
      /**
      * Factory method that creates the default EdgeLayoutDescriptor.
      * @return {yfiles.hierarchic.incremental.EdgeLayoutDescriptor} a new EdgeLayoutDescriptor (<code>new EdgeLayoutDescriptor()</code>)
      */
      createEdgeLayoutDescriptor():yfiles.hierarchic.incremental.EdgeLayoutDescriptor;
      /**
      * The <code>EdgeLayoutDescriptor</code> instance used for all those
      * edges, that do not have a specific layout descriptor assigned.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#createEdgeLayoutDescriptor}
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      */
      edgeLayoutDescriptor:yfiles.hierarchic.incremental.EdgeLayoutDescriptor;
      /**
      * Factory method that creates the default NodeLayoutDescriptor.
      * @return {yfiles.hierarchic.incremental.NodeLayoutDescriptor} a new NodeLayoutDescriptor (<code>new NodeLayoutDescriptor()</code>)
      */
      createNodeLayoutDescriptor():yfiles.hierarchic.incremental.NodeLayoutDescriptor;
      /**
      * The <code>NodeLayoutDescriptor</code> instance used for all those
      * nodes, that do not have a specific layout descriptor assigned.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#NODE_LAYOUT_DESCRIPTOR_DP_KEY}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#createNodeLayoutDescriptor}
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#NODE_LAYOUT_DESCRIPTOR_DP_KEY}
      */
      nodeLayoutDescriptor:yfiles.hierarchic.incremental.NodeLayoutDescriptor;
    }
    var IncrementalHierarchicLayouter:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to store the priority (integer values) for "critical" edges.
      * The layouter tries to vertically align each node pair that is connected by a critical edge (integer value > 0).
      * This feature can for example be utilized to highlight different edge paths that are relevant for a user. Conflicts
      * between different critical edges are always resolved in favor of the higher priority.
      * <p>
      * Note: "critical" edges of aligned nodes are always placed at the center port.
      * Hence, the edge distribution is no longer uniform.
      * </p>
      * <p>
      * Note: "critical" edges do no affect the result of the crossing minimization
      * ({@link yfiles.hierarchic.incremental.ISequencer}) phase. Hence, there may be crossings between two "critical" edges.
      * </p>
      */
      CRITICAL_EDGE_DP_KEY:Object;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to store incremental layout hints
      * that can be retrieved from the {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory}
      * which itself can be obtained from the
      * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#createIncrementalHintsFactory} method.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#INCREMENTAL_HINTS_DP_KEY}
      */
      INCREMENTAL_HINTS_DP_KEY:Object;
      /**
      * Used for publishing the final layering information.
      * If the {@link yfiles.algorithms.IDataProvider} associated to this key is also a
      * {@link yfiles.algorithms.IDataAcceptor}, the integer layer id of each node is stored
      * using the acceptor's {@link yfiles.algorithms.IDataAcceptor#setInt  setInt}
      * method.
      * Otherwise, the provider's values should be of type
      * {@link yfiles.hierarchic.incremental.IIntValueHolder} and the value holder's
      * {@link yfiles.hierarchic.incremental.IIntValueHolder#value  setValue}
      * method is used to store the integer layer ids of each node.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#LAYER_VALUE_HOLDER_DP_KEY}
      */
      LAYER_VALUE_HOLDER_DP_KEY:Object;
      /**
      * Used for publishing the final sequencing information.
      * If the {@link yfiles.algorithms.IDataProvider} associated to this key is also a
      * {@link yfiles.algorithms.IDataAcceptor}, the sequence order number of each node is
      * stored using the acceptor's
      * {@link yfiles.algorithms.IDataAcceptor#setInt  setInt} method.
      * Otherwise, the provider's values should be of type
      * {@link yfiles.hierarchic.incremental.IIntValueHolder} and the value holder's
      * {@link yfiles.hierarchic.incremental.IIntValueHolder#value  setValue}
      * method is used to store the sequence order number of each node.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#SEQUENCE_VALUE_HOLDER_DP_KEY}
      */
      SEQUENCE_VALUE_HOLDER_DP_KEY:Object;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to store {@link yfiles.hierarchic.incremental.SwimLaneDescriptor}
      * instances for each node in the graph.
      * If this key is present during the layout.
      * The layout algorithm will arrange nodes in swim lanes. The information about the
      * swim lanes is finally written back into the descriptor instances.
      * Instances can be shared among multiple nodes in the same lane, but don't have to be shared.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#SWIMLANE_DESCRIPTOR_DP_KEY}
      */
      SWIMLANE_DESCRIPTOR_DP_KEY:Object;
      /**
      * Creates a new IncrementalHierarchicLayouter instance which is
      * set to {@link yfiles.hierarchic.LayoutMode#FROM_SCRATCH} initially.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#layoutMode}
      */
      new ():yfiles.hierarchic.IncrementalHierarchicLayouter;
      /**
      * {@link yfiles.algorithms.IDataProvider} key to store the constraint graph for sequence constraints.
      * <code>DataProvider</code> key to store the constraint graph.
      * A <code>v1 before v2</code> constraint is represented as an edge
      * between the representatives of <code>v1</code> and <code>v2</code>
      * in the constraint graph.
      */
      SEQUENCE_CONSTRAINTS_MEMENTO_DP_KEY:Object;
    };
    /**
    * This class can be used to simply wrap another Drawer implementation.
    * It will rearrange nodes within each layer so that they are aligned with
    * respect to a given alignment point, that is provided on a per node basis,
    * which is provided by a registered
    * DataProvider instance that may provide doubles that
    * are interpreted as relative
    * coordinates to the center of the node.
    */
    export interface AlignmentDrawer extends Object,yfiles.hierarchic.IDrawer{
      /**
      * Modifies the given drawing by modifying the y-coordinates only.
      */
      alignNodes(graph:yfiles.layout.LayoutGraph,lists:yfiles.algorithms.NodeList[]):void;
      /**
      * This method assigns the coordinates to the nodes.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#assignCoordinates}.
      */
      assignCoordinates(g:yfiles.layout.LayoutGraph,layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
      /**
      * Gives the drawer the opportunity to distinguish between dummy nodes
      * and real ones.
      * dummy stores the original edge for each dummy node or
      * <code>null</code> for real nodes.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#dummyMap}.
      */
      dummyMap:yfiles.algorithms.INodeMap;
      /**
      * The minimal distance between two edges in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalEdgeDistance}.
      */
      minimalEdgeDistance:number;
      /**
      * The minimal distance between two layers.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalLayerDistance}.
      */
      minimalLayerDistance:number;
      /**
      * The minimal distance between two edges sharing source/target (aka multi-edges) in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalMultiEdgeDistance}.
      */
      minimalMultiEdgeDistance:number;
      /**
      * The minimal distance between two nodes in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalNodeDistance}.
      */
      minimalNodeDistance:number;
    }
    export module AlignmentDrawer{
      /**
      * Simple utility class that can be registered with the graph to be laid out.
      * Instances of this class will make all nodes top-aligned (for top to bottom layouts).
      */
      export interface TopAlignmentDataProvider extends yfiles.algorithms.DataProviderAdapter{
        /**
        * Returns a double value associated with the given data holder.
        * This method may throw an UnsupportedOperationException.
        * @see Specified by {@link yfiles.algorithms.IDataProvider#getDouble}.
        */
        getDouble(dataHolder:Object):number;
      }
      /**
      * Simple utility class that can be registered with the graph to be laid out.
      * Instances of this class will make all nodes left-aligned (for left to right layouts).
      */
      export interface LeftAlignmentDataProvider extends yfiles.algorithms.DataProviderAdapter{
        /**
        * Returns a double value associated with the given data holder.
        * This method may throw an UnsupportedOperationException.
        * @see Specified by {@link yfiles.algorithms.IDataProvider#getDouble}.
        */
        getDouble(dataHolder:Object):number;
      }
      /**
      * Simple utility class that can be registered with the graph to be laid out.
      * Instances of this class will make all nodes right-aligned (for left to right layouts).
      */
      export interface RightAlignmentDataProvider extends yfiles.algorithms.DataProviderAdapter{
        /**
        * Returns a double value associated with the given data holder.
        * This method may throw an UnsupportedOperationException.
        * @see Specified by {@link yfiles.algorithms.IDataProvider#getDouble}.
        */
        getDouble(dataHolder:Object):number;
      }
      /**
      * Simple utility class that can be registered with the graph to be laid out.
      * Instances of this class will make all nodes bottom-aligned  (for top to bottom layouts).
      */
      export interface BottomAlignmentDataProvider extends yfiles.algorithms.DataProviderAdapter{
        /**
        * Returns a double value associated with the given data holder.
        * This method may throw an UnsupportedOperationException.
        * @see Specified by {@link yfiles.algorithms.IDataProvider#getDouble}.
        */
        getDouble(dataHolder:Object):number;
      }
    }
    var AlignmentDrawer:{
      $class:yfiles.lang.Class;
      /**
      * The DataProvider key used for the DataProvider instance that provides for
      * each node a double depicting the center anchored offset to the
      * alignment point.
      */
      NODE_ALIGNMENT_POINT_DP_KEY:Object;
      /**
      * Creates a new AlignmentDrawer using the given drawer as the actual drawer.
      */
      new (inner:yfiles.hierarchic.IDrawer):yfiles.hierarchic.AlignmentDrawer;
      TopAlignmentDataProvider:{
        $class:yfiles.lang.Class;
        new ():yfiles.hierarchic.AlignmentDrawer;
      };
      LeftAlignmentDataProvider:{
        $class:yfiles.lang.Class;
        new ():yfiles.hierarchic.AlignmentDrawer;
      };
      RightAlignmentDataProvider:{
        $class:yfiles.lang.Class;
        new ():yfiles.hierarchic.AlignmentDrawer;
      };
      BottomAlignmentDataProvider:{
        $class:yfiles.lang.Class;
        new ():yfiles.hierarchic.AlignmentDrawer;
      };
    };
    /**
    * Abstract base class for the third phase of the Sugiyama algorithm.
    * It assigns the coordinates to the nodes according to the defined
    * ranks.
    * It provides methods to assign the Y-Coordinates to the nodes.
    */
    export interface AbstractDrawer extends Object,yfiles.hierarchic.IDrawer{
      /**
      * The minimal distance between two nodes in the same layer.
      */
      minimalNodeDistanceF:number;
      /**
      * The minimal distance between two layers.
      */
      minimalLayerDistanceF:number;
      /**
      * The minimal distance between two edges in the same layer.
      */
      minimalEdgeDistanceF:number;
      /**
      * The minimal distance between two edges sharing source/target in the same layer.
      */
      minimalMultiEdgeDistanceF:number;
      /**
      * See {@link yfiles.hierarchic.AbstractDrawer#dummyMap}.
      */
      dummyMapF:yfiles.algorithms.INodeMap;
      /**
      * The key to the data provider, which stores the length of the edges.
      */
      edgeLengthKeyF:Object;
      /**
      * The graph bound to this drawer instance.
      */
      graphF:yfiles.layout.LayoutGraph;
      /**
      * Stores the minimal distance between the right border of a node and
      * the left border of its right hand side neighbor in a layer.
      */
      distanceToNextNodeF:yfiles.algorithms.INodeMap;
      /**
      * The minimal distance between two edges in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalEdgeDistance}.
      */
      minimalEdgeDistance:number;
      /**
      * The minimal distance between two edges sharing source/target in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalMultiEdgeDistance}.
      */
      minimalMultiEdgeDistance:number;
      /**
      * The minimal distance between two nodes in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalNodeDistance}.
      */
      minimalNodeDistance:number;
      /**
      * The minimal distance between two layers.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalLayerDistance}.
      */
      minimalLayerDistance:number;
      /**
      * Gives the drawer the opportunity to distinguish between dummy nodes
      * and real ones.
      * dummy stores the original edge for each dummy node or
      * <code>null</code> for real nodes.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#dummyMap}.
      */
      dummyMap:yfiles.algorithms.INodeMap;
      /**
      * The key to the data provider, which stores the length of the edges.
      * Remark: Edges, which are split in the first phase do no longer supply
      * lengths. This should not be to critical as they span at least
      * two layers and are so hopefully long enough.
      */
      edgeLengthKey:Object;
      /**
      * Assign the y coordinates to the nodes respecting the minimal
      * layer distance.
      */
      assignYCoordsWithNodeList(graph:yfiles.layout.LayoutGraph,layerLists:yfiles.algorithms.NodeList[]):void;
      /**
      * Assign the y coordinates to the nodes respecting the minimal
      * layer distance.
      */
      assignYCoords(graph:yfiles.layout.LayoutGraph,layers:yfiles.algorithms.INodeCursor[]):void;
      /**
      * Binds the specified graph to this drawer and
      * calls the abstract method
      * {@link yfiles.hierarchic.AbstractDrawer#assignCoordinatesToNodes}.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#assignCoordinates}.
      */
      assignCoordinates(g:yfiles.layout.LayoutGraph,layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
      /**
      * Overwrite this method to assign the final coordinates to the
      * objects of he graph.
      */
      assignCoordinatesToNodes(layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
      /**
      * Returns the border obeying left x-coordinate of the given node.
      */
      getLeftX(v:yfiles.algorithms.Node):number;
      /**
      * Returns the border obeying right x-coordinate of the given node.
      */
      getRightX(v:yfiles.algorithms.Node):number;
      /**
      * Returns the border obeying top y-coordinate of the given node.
      */
      getTopY(v:yfiles.algorithms.Node):number;
      /**
      * Returns the border obeying bottom y-coordinate of the given node.
      */
      getBottomY(v:yfiles.algorithms.Node):number;
      /**
      * Returns the border obeying full width of the given node.
      */
      getFullWidth(v:yfiles.algorithms.Node):number;
      /**
      * Returns the border obeying full height of the given node.
      */
      getFullHeight(v:yfiles.algorithms.Node):number;
      /**
      * Returns the width of the left border of the given node.
      */
      getLeftBorder(v:yfiles.algorithms.Node):number;
      /**
      * Returns the width of the right border of the given node.
      */
      getRightBorder(v:yfiles.algorithms.Node):number;
      /**
      * Returns the height of the top border of the given node.
      */
      getTopBorder(v:yfiles.algorithms.Node):number;
      /**
      * Returns the height of the bottom border of the given node.
      */
      getBottomBorder(v:yfiles.algorithms.Node):number;
      /**
      * Returns the width of the border-obeying left half of the node,.
      */
      getLeftHalf(v:yfiles.algorithms.Node):number;
      /**
      * Returns the width of the border-obeying right half of the node,.
      */
      getRightHalf(v:yfiles.algorithms.Node):number;
      /**
      * Returns the height of the border-obeying top half of the node,.
      */
      getTopHalf(v:yfiles.algorithms.Node):number;
      /**
      * Returns the height of the border-obeying bottom half of the node,.
      */
      getBottomHalf(v:yfiles.algorithms.Node):number;
      /**
      * Initializes the minimal distances between the right border of a node
      * and the left border of its right hand side neighbor in a layer.
      * @see {@link yfiles.hierarchic.AbstractDrawer#getDistanceToNextNode}
      * @see {@link yfiles.hierarchic.AbstractDrawer#distanceToNextNodeF}
      */
      initializeDistancesToNextNode(layerLists:yfiles.algorithms.NodeList[]):void;
      /**
      * Returns the minimal distance between the right border of the given node and
      * the left border of its right hand side neighbor in the layer.
      * Node minimal node distances are constructed by using
      * the values provided by the data providers that are registered
      * with the input graph
      * under the keys {@link yfiles.hierarchic.DrawerKeys#NODE_DISTANCE}, {@link yfiles.hierarchic.DrawerKeys#NODE_BORDER_LEFT}
      * and {@link yfiles.hierarchic.DrawerKeys#NODE_BORDER_RIGHT}.
      */
      getDistanceToNextNode(v:yfiles.algorithms.Node):number;
      /**
      * Frees allocated resources after the drawer is finished.
      */
      dispose():void;
    }
    var AbstractDrawer:{
      $class:yfiles.lang.Class;
    };
    /**
    * This class implements the first phase of the hierarchic layouter.
    * It first makes the directed graph acyclic.
    * Then it assigns the layers such that edge weights are respected
    * A weight defines a minimal distance between the two end points of
    * an edge.
    */
    export interface WeightedLayerer extends Object,yfiles.hierarchic.ILayerer,yfiles.hierarchic.incremental.ILayerer{
      /**
      * Provides the edge weights.
      */
      weight:yfiles.algorithms.IDataProvider;
      /**
      * The key to access the weights.
      */
      key:Object;
      /**
      * <code>true</code> if the edges that need to be reversed are
      * determined using an edge weight based heuristic
      * and <code>false</code> if a Depth First Search based approach should be
      * used.
      * The weight based approach may result in fewer reversed edges
      * (especially for cases with many multi edges) whereas the DFS based
      * approach is likely to be faster.
      * <p>
      * By default, the DFS based approach is used.
      * </p>
      */
      weightedCycleRemoval:boolean;
      /**
      * The time limit (in milliseconds) set for the algorithm.
      * Note that restricting the maximal duration may result in a worse layout quality.
      * Furthermore, the real runtime may exceed the maximal duration since the algorithm
      * still have to find a valid solution.
      */
      maximalDuration:number;
      /**
      * This method assigns the nodes in the graph to layers.
      * <b>Postcondition:</b> Forall (v,w) in E: layer(v) &lt; layer(w)
      * @param {yfiles.layout.LayoutGraph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the layers are stored
      * @param {yfiles.algorithms.EdgeList} reversedEdges here the edges are stored which had been reversed.
      * @return {number} the number of layers
      * @see Specified by {@link yfiles.hierarchic.ILayerer#assignNodeLayer}.
      */
      assignNodeLayer(g:yfiles.layout.LayoutGraph,layer:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList):number;
      /**
      * This method assigns the nodes in the graph to layers.
      * <b>Postcondition:</b> Forall (v,w) in E: layer(v) &lt; layer(w)
      * @param {yfiles.layout.LayoutGraph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the layers are stored
      * @param {yfiles.algorithms.EdgeList} reversedEdges here the edges are stored which had been reversed.
      * @return {number} the number of layers
      */
      assignNodeLayerWithDataProvider(g:yfiles.layout.LayoutGraph,layer:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList,w:yfiles.algorithms.IDataProvider):number;
      /**
      * Returns the edge weight of the specified edge for use with the weight
      * based cycle removal heuristic.
      * <p>
      * By default, all edges are considered to have weight <code>1.0</code>.
      * </p>
      * @param {yfiles.algorithms.Edge} edge the edge whose weight is returned.
      * @return {number} the edge weight of the specified edge.
      * @see {@link yfiles.hierarchic.WeightedLayerer#weightedCycleRemoval}
      * @see {@link yfiles.hierarchic.WeightedLayerer#weightedCycleRemoval}
      */
      getWeight(edge:yfiles.algorithms.Edge):number;
      /**
      * This method assigns the nodes in the graph to layers.
      * <b>Postcondition:</b> Forall (v,w) in E: layer(v) &lt; layer(w)
      * @param {yfiles.algorithms.Graph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the layers are stored
      * @param {yfiles.algorithms.EdgeList} reversedEdges here the edges are stored which had been reversed.
      * @return {number} the number of layers
      */
      assignNodeLayerForAlgorithmsGraph(g:yfiles.algorithms.Graph,layer:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList,w:yfiles.algorithms.IDataProvider):number;
      /**
      * Uses dfs to remove cycles from the graph.
      */
      makeDFSAcyclic(g:yfiles.layout.LayoutGraph,reversedEdges:yfiles.algorithms.EdgeList):void;
      /**
      * Uses dfs to remove cycles from the graph.
      */
      makeDFSAcyclicForAlgorithmsGraph(g:yfiles.algorithms.Graph,reversedEdges:yfiles.algorithms.EdgeList):void;
      /**
      * Assigns the layers to the nodes.
      */
      assignLayersToMap(g:yfiles.algorithms.Graph,layer:yfiles.algorithms.INodeMap):number;
      /**
      * Assign the layers to the nodes.
      */
      assignLayersFast(g:yfiles.algorithms.Graph,layer:yfiles.algorithms.INodeMap):number;
      /**
      * Pushes the nodes down, drawings seems then to be nicer.
      */
      downShiftNodes(g:yfiles.algorithms.Graph,LayerKey:yfiles.algorithms.INodeMap,maxLayer:number):void;
      /**
      * This method assigns all nodes in the graph to layers and registers them
      * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
      * In order to create new layers, the factory
      * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
      * @param {yfiles.layout.LayoutGraph} graph 
      * the graph that contains the nodes that should be distributed
      * into the layers
      * @param {yfiles.hierarchic.incremental.ILayers} layers 
      * the object that will be filled with the results of the
      * calculation
      * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
      * LayoutDataProvider that can be used to query information about
      * the nodes - note that positional information
      * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
      * be available at any time.
      * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
      * @see {@link yfiles.hierarchic.incremental.ILayer#add}
      * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
      */
      assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
    }
    var WeightedLayerer:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new weighted layerer.
      */
      new ():yfiles.hierarchic.WeightedLayerer;
      /**
      * Creates a new weighted layerer.
      * @param {Object} k the key to access the weights.
      */
      ForKey:{
        new (k:Object):yfiles.hierarchic.WeightedLayerer;
      };
    };
    /**
    * This class implements the third phase of the hierarchic layout algorithm for trees.
    * If the input graph is not a tree,
    * an alternative drawer is invoked.
    */
    export interface TreeDrawer extends yfiles.hierarchic.AbstractDrawer{
      /**
      * The minimal distance between two edges in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalEdgeDistance}.
      */
      minimalEdgeDistance:number;
      /**
      * The minimal distance between two edges sharing source/target (aka multi-edges) in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalMultiEdgeDistance}.
      */
      minimalMultiEdgeDistance:number;
      /**
      * The minimal distance between two nodes in the same layer.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalNodeDistance}.
      */
      minimalNodeDistance:number;
      /**
      * The minimal distance between two layers.
      * @see Specified by {@link yfiles.hierarchic.IDrawer#minimalLayerDistance}.
      */
      minimalLayerDistance:number;
      /**
      * The drawer, which is called when graph is not a tree.
      */
      alternativeDrawer:yfiles.hierarchic.IDrawer;
      /**
      * Overwrite this method to assign the final coordinates to the
      * objects of he graph.
      */
      assignCoordinatesToNodes(layerLists:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
    }
    var TreeDrawer:{
      $class:yfiles.lang.Class;
      new ():yfiles.hierarchic.TreeDrawer;
    };
    /**
    * This class implements the first phase of the Sugiyama algorithm.
    * It uses topological sorting to assign layers to the nodes.
    */
    export interface TopologicalLayerer extends Object,yfiles.hierarchic.ILayerer,yfiles.hierarchic.incremental.ILayerer{
      /**
      * The currently active ranking policy within
      * this layerer.
      * By default {@link yfiles.hierarchic.RankingPolicy#NO_RERANKING} is set.
      */
      rankingPolicy:yfiles.hierarchic.RankingPolicy;
      /**
      * This method assigns the nodes in the graph to layers.
      * <b>Postcondition:</b> Forall (v,w) in E: layer(v) &lt; layer(w)
      * @param {yfiles.layout.LayoutGraph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the layers are stored
      * @param {yfiles.algorithms.EdgeList} reversedEdges here the edges are stored which had been reversed.
      * @return {number} the number of layers
      * @see Specified by {@link yfiles.hierarchic.ILayerer#assignNodeLayer}.
      */
      assignNodeLayer(g:yfiles.layout.LayoutGraph,layer:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList):number;
      /**
      * This method assigns all nodes in the graph to layers and registers them
      * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
      * In order to create new layers, the factory
      * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
      * @param {yfiles.layout.LayoutGraph} graph 
      * the graph that contains the nodes that should be distributed
      * into the layers
      * @param {yfiles.hierarchic.incremental.ILayers} layers 
      * the object that will be filled with the results of the
      * calculation
      * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
      * LayoutDataProvider that can be used to query information about
      * the nodes - note that positional information
      * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
      * be available at any time.
      * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
      * @see {@link yfiles.hierarchic.incremental.ILayer#add}
      * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
      */
      assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
    }
    var TopologicalLayerer:{
      $class:yfiles.lang.Class;
      new ():yfiles.hierarchic.TopologicalLayerer;
    };
    /**
    * Still experimental.
    * @deprecated For internal use only. Might be changed or removed in the future.
    */
    export interface LeanLayersLayerer extends Object,yfiles.hierarchic.ILayerer,yfiles.hierarchic.incremental.ILayerer{
      useEnhancedDistribution:boolean;
      preferredLayerWidth:number;
      startFromSketch:boolean;
      /**
      * This method assigns the nodes in the graph to layers.
      * @param {yfiles.layout.LayoutGraph} g the graph for which the layers are determined.
      * @param {yfiles.algorithms.INodeMap} layer here the layers are stored
      * @param {yfiles.algorithms.EdgeList} reversedEdges here the edges are stored which had been reversed.
      * @return {number} the number of layers
      * @see Specified by {@link yfiles.hierarchic.ILayerer#assignNodeLayer}.
      */
      assignNodeLayer(g:yfiles.layout.LayoutGraph,layer:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList):number;
      assignNodeLayerForGivenLayers(graph:yfiles.layout.LayoutGraph,layerMap:yfiles.algorithms.INodeMap,reversedEdges:yfiles.algorithms.EdgeList,useGivenLayers:boolean):number;
      /**
      * This method assigns all nodes in the graph to layers and registers them
      * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
      * In order to create new layers, the factory
      * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
      * @param {yfiles.layout.LayoutGraph} graph 
      * the graph that contains the nodes that should be distributed
      * into the layers
      * @param {yfiles.hierarchic.incremental.ILayers} layers 
      * the object that will be filled with the results of the
      * calculation
      * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
      * LayoutDataProvider that can be used to query information about
      * the nodes - note that positional information
      * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
      * be available at any time.
      * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
      * @see {@link yfiles.hierarchic.incremental.ILayer#add}
      * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
      */
      assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
    }
    var LeanLayersLayerer:{
      $class:yfiles.lang.Class;
    };
    /**
    * This class implements the third phase of the Sugiyama layout algorithm.
    * Edges are represented as poly-lines with at most two bends.
    */
    export interface LinearSegmentsDrawer extends yfiles.hierarchic.AbstractDrawer{
      /**
      * Overwrite this method to assign the final coordinates to the
      * objects of he graph.
      */
      assignCoordinatesToNodes(layers:yfiles.algorithms.NodeList[],layerID:yfiles.algorithms.IDataProvider):void;
    }
    var LinearSegmentsDrawer:{
      $class:yfiles.lang.Class;
      new ():yfiles.hierarchic.LinearSegmentsDrawer;
    };
    export module incremental{
      /**
      * This interface serves as a callback for {@link yfiles.hierarchic.incremental.HierarchicLayouter} after the layering and sequencing phases.
      * Implementations of this interface may modify the port constraints ({@link yfiles.layout.PortConstraint}) information
      * via {@link yfiles.hierarchic.incremental.IItemFactory#setTemporaryPortConstraint}.
      */
      export interface IPortConstraintOptimizer extends Object{
        /**
        * Called after the layering information has been determined.
        * This method can be used to assign
        * new temporary port constraints for the next phases of the algorithm.
        * @see {@link yfiles.hierarchic.incremental.IItemFactory#setTemporaryPortConstraint}
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on
        * @param {yfiles.hierarchic.incremental.ILayers} layers the layering information
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the implementation which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData} instances
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory to set the temporary port constraints with
        * @see Specified by {@link yfiles.hierarchic.incremental.IPortConstraintOptimizer#optimizeAfterLayering}.
        */
        optimizeAfterLayering(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
        /**
        * Called after the sequence of the nodes has been determined.
        * This method can be used to assign
        * new temporary port constraints for the next phases of the algorithm.
        * @see {@link yfiles.hierarchic.incremental.IItemFactory#setTemporaryPortConstraint}
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on
        * @param {yfiles.hierarchic.incremental.ILayers} layers the layering information
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the implementation which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData} instances
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory to set the temporary port constraints with
        * @see Specified by {@link yfiles.hierarchic.incremental.IPortConstraintOptimizer#optimizeAfterSequencing}.
        */
        optimizeAfterSequencing(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
      }
      var IPortConstraintOptimizer:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Adapter class that uses a {@link yfiles.algorithms.IDataMap}, {@link yfiles.algorithms.INodeMap}, or {@link yfiles.algorithms.IEdgeMap}
      * implementation and wraps it as a {@link yfiles.algorithms.IDataProvider} that provides
      * {@link yfiles.hierarchic.incremental.IIntValueHolder} instances for each element.
      * See {@link yfiles.hierarchic.incremental.HierarchicLayouter#LAYER_VALUE_HOLDER_DP_KEY} for a typical use case
      * of this class.
      */
      export interface IntValueHolderAdapter extends Object,yfiles.algorithms.IDataProvider{
        /**
        * Returns an object value associated with the given data holder.
        * This method may throw an UnsupportedOperationException.
        * @see Specified by {@link yfiles.algorithms.IDataProvider#get}.
        */
        get(dataHolder:Object):Object;
        /**
        * Returns a boolean value associated with the given data holder.
        * This method may throw an UnsupportedOperationException.
        * @see Specified by {@link yfiles.algorithms.IDataProvider#getBool}.
        */
        getBool(dataHolder:Object):boolean;
        /**
        * Returns a double value associated with the given data holder.
        * This method may throw an UnsupportedOperationException.
        * @see Specified by {@link yfiles.algorithms.IDataProvider#getDouble}.
        */
        getDouble(dataHolder:Object):number;
        /**
        * Returns an integer value associated with the given data holder.
        * This method may throw an UnsupportedOperationException.
        * @see Specified by {@link yfiles.algorithms.IDataProvider#getInt}.
        */
        getInt(dataHolder:Object):number;
      }
      var IntValueHolderAdapter:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of IntValueHolderAdapter using a DataMap.
        */
        FromDataMap:{
          new (map:yfiles.algorithms.IDataMap):yfiles.hierarchic.incremental.IntValueHolderAdapter;
        };
        /**
        * Creates a new instance of IntValueHolderAdapter using a NodeMap.
        */
        FromNodeMap:{
          new (map:yfiles.algorithms.INodeMap):yfiles.hierarchic.incremental.IntValueHolderAdapter;
        };
        /**
        * Creates a new instance of IntValueHolderAdapter using an EdgeMap.
        */
        FromEdgeMap:{
          new (map:yfiles.algorithms.IEdgeMap):yfiles.hierarchic.incremental.IntValueHolderAdapter;
        };
        /**
        * Creates a new instance of IntValueHolderAdapter using a pair
        * of DataAcceptor and DataProvider instances for storage and retrieval.
        */
        FromDataAcceptorAndDataProvider:{
          new (acc:yfiles.algorithms.IDataAcceptor,dp:yfiles.algorithms.IDataProvider):yfiles.hierarchic.incremental.IntValueHolderAdapter;
        };
      };
      /**
      * Interface used by {@link yfiles.hierarchic.incremental.HierarchicLayouter} during the layout.
      * Instances of this class are responsible for assigning port coordinates to
      * the adjacent edges of each node in the graph.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter}
      */
      export interface IPortAllocator extends Object{
        /**
        * Called by {@link yfiles.hierarchic.incremental.HierarchicLayouter} before the actual node placing takes
        * place (phase three).
        * This method must assign each edge in the graph a source port and target
        * port coordinate pair.
        * @param {yfiles.layout.LayoutGraph} graph the graph which contains all the elements
        * @param {yfiles.hierarchic.incremental.ILayers} layers the layers object that contains the elements in the layering
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider that can be queried for the {@link yfiles.hierarchic.incremental.INodeData}
        * and {@link yfiles.hierarchic.incremental.IEdgeData} instances
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory 
        * the ItemFactory that can be used to temporarily modify
        * the graph instance
        * @see Specified by {@link yfiles.hierarchic.incremental.IPortAllocator#assignPorts}.
        */
        assignPorts(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
      }
      var IPortAllocator:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * This interface is used by {@link yfiles.hierarchic.incremental.HierarchicLayouter} to calculate the node
      * orders of nodes within the layers in a {@link yfiles.hierarchic.incremental.ILayers} object.
      * Implementations are used during the second phase of the hierarchic layout
      * process.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#sequencer}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fixedElementsSequencer}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fromScratchSequencer}
      */
      export interface ISequencer extends Object{
        /**
        * Called by {@link yfiles.hierarchic.incremental.HierarchicLayouter} during the second phase.
        * Calculates a sequence of the nodes in <code>layers</code> and finally
        * writes back the calculated sequence using the {@link yfiles.hierarchic.incremental.ILayer#setNodeOrder}
        * method.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements from <code>layers</code>
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layer implementation that holds the Layers for sequencing
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider that provides the necessary {@link yfiles.hierarchic.incremental.INodeData}
        * and {@link yfiles.hierarchic.incremental.IEdgeData}
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory 
        * an ItemFactory implementation that can be used to modify the
        * graph consistently
        * @see Specified by {@link yfiles.hierarchic.incremental.ISequencer#sequenceNodeLayers}.
        */
        sequenceNodeLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
      }
      var ISequencer:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Wrapper Layerer implementation that delegates the actual layering to a
      * delegate Layerer.
      * If the graph consists of multiple components, they will
      * be identified and sorted and each of the components will be layered separately
      * using the delegate Layerer instance. After that they will all be merged
      * in order using the specified {@link yfiles.hierarchic.incremental.ILayeredComponentsMerger} instance.
      */
      export interface MultiComponentLayerer extends Object,yfiles.hierarchic.incremental.ILayerer{
        /**
        * This method assigns all nodes in the graph to layers and registers them
        * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
        * In order to create new layers, the factory
        * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains the nodes that should be distributed
        * into the layers
        * @param {yfiles.hierarchic.incremental.ILayers} layers 
        * the object that will be filled with the results of the
        * calculation
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * LayoutDataProvider that can be used to query information about
        * the nodes - note that positional information
        * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
        * be available at any time.
        * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
        * @see {@link yfiles.hierarchic.incremental.ILayer#add}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
        */
        assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * Callback method that is called during {@link yfiles.hierarchic.incremental.MultiComponentLayerer#assignLayers}.
        * It is responsible for sorting an array consisting of {@link yfiles.algorithms.NodeList}s, each
        * containing nodes that belong to a different component. By default this method
        * uses the {@link yfiles.hierarchic.incremental.MultiComponentLayerer#componentComparator  ComponentComparator} to sort the list
        * or does nothing if that instance is <code>null</code>.
        * @param {yfiles.algorithms.NodeList[]} nodeLists 
        * the array of NodeLists each containing all nodes that belong
        * to the same component
        * @param {yfiles.algorithms.IDataProvider} componentIndexProvider 
        * a DataProvider that can be used to query the
        * nodes' component indices via {@link yfiles.algorithms.IDataProvider#getInt} and/or
        * {@link yfiles.algorithms.IDataProvider#get}.
        */
        sort(nodeLists:yfiles.algorithms.NodeList[],componentIndexProvider:yfiles.algorithms.IDataProvider):void;
        /**
        * The Layerer instance that is used for delegation.
        * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
        */
        singleComponentLayerer:yfiles.hierarchic.incremental.ILayerer;
        /**
        * The merger.
        * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
        */
        merger:yfiles.hierarchic.incremental.ILayeredComponentsMerger;
        /**
        * The current component Comparator or <code>null</code>.
        */
        componentComparator:yfiles.objectcollections.IComparer;
      }
      var MultiComponentLayerer:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of MultiComponentLayerer using the given
        * delegate and a new instance of {@link yfiles.hierarchic.incremental.DefaultLayeredComponentsMerger}
        * as the merger and no component comparator.
        */
        new (singleComponentLayerer:yfiles.hierarchic.incremental.ILayerer):yfiles.hierarchic.incremental.MultiComponentLayerer;
        /**
        * Creates a new instance of MultiComponentLayerer using the given
        * delegates.
        */
        WithMergerAndComparer:{
          new (singleComponentLayerer:yfiles.hierarchic.incremental.ILayerer,merger:yfiles.hierarchic.incremental.ILayeredComponentsMerger,componentComparator:yfiles.objectcollections.IComparer):yfiles.hierarchic.incremental.MultiComponentLayerer;
        };
      };
      /**
      * Factory that consistently creates and destroys helper structures in the
      * graph during layout.
      * An implementation of this interface is provided by the {@link yfiles.hierarchic.incremental.HierarchicLayouter}
      * during the layout for the different sub modules.
      * It is mainly for internal use.
      */
      export interface IItemFactory extends Object{
        /**
        * Inserts an edge group node layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#insertGroupNodeLayer}.
        */
        insertGroupNodeLayer(source:boolean,index:number):yfiles.hierarchic.incremental.ILayer;
        /**
        * Inserts a layer for label nodes group node layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#insertLabelNodeLayer}.
        */
        insertLabelNodeLayer(source:boolean,index:number):yfiles.hierarchic.incremental.ILayer;
        /**
        * Destroys a previously created label layer.
        * @param {yfiles.hierarchic.incremental.ILayer} layer the layer to destroy
        * @param {boolean} useInEdges 
        * whether the incoming edges should be used
        * as the resulting edges
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#destroyLabelNodeLayer}.
        */
        destroyLabelNodeLayer(layer:yfiles.hierarchic.incremental.ILayer,useInEdges:boolean):void;
        /**
        * Inserts a same layer edge or an edge that may span multiple layers into the
        * data structure.
        * Returns the list of edges that has been created if this edge
        * spans multiple layers.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#insertEdge}.
        */
        insertEdge(edge:yfiles.algorithms.Edge):yfiles.algorithms.EdgeList;
        /**
        * Registers an edge as a same layer edge appropriately into all data structures.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#registerSameLayerEdge}.
        */
        registerSameLayerEdge(edge:yfiles.algorithms.Edge):void;
        /**
        * Converts a node to a label node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#convertToLabelNode}.
        */
        convertToLabelNode(dummyNode:yfiles.algorithms.Node):void;
        /**
        * Reverts a label node to the previous kind of node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#unconvertToLabelNode}.
        */
        unconvertToLabelNode(labelNode:yfiles.algorithms.Node):void;
        /**
        * Creates a proxy node for an edge during the drawing phase,
        * changing the edge to end/start at the proxy.
        * @return {yfiles.algorithms.Node} the proxy
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createProxyNode}.
        */
        createProxyNode(edge:yfiles.algorithms.Edge,source:boolean):yfiles.algorithms.Node;
        /**
        * Creates a proxy node for an edge during the drawing phase,
        * changing the edge to end/start at the proxy.
        * @return {yfiles.algorithms.Node} the proxy
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createProxyNodeWithEdgeSourceAndLaneDescriptor}.
        */
        createProxyNodeWithEdgeSourceAndLaneDescriptor(edge:yfiles.algorithms.Edge,source:boolean,laneDescriptor:yfiles.hierarchic.incremental.SwimLaneDescriptor):yfiles.algorithms.Node;
        /**
        * Destroys a proxy node that has been created using
        * {@link yfiles.hierarchic.incremental.IItemFactory#createProxyNode} for the drawing phase.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#destroyProxyNode}.
        */
        destroyProxyNode(proxyNode:yfiles.algorithms.Node):yfiles.algorithms.Edge;
        /**
        * Creates a proxy node for a same layer edge during the drawing phase that
        * ends at the side of a node.
        * @return {yfiles.algorithms.Node} the proxy
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createSameLayerSideProxy}.
        */
        createSameLayerSideProxy(inLayer:yfiles.hierarchic.incremental.ILayer,forNode:yfiles.algorithms.Node,edge:yfiles.algorithms.Edge):yfiles.algorithms.Node;
        /**
        * Creates a proxy node for a same layer edge during the drawing phase that
        * ends at the side of a node.
        * @return {yfiles.algorithms.Node} the proxy
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createSameLayerSideProxyWithDescriptor}.
        */
        createSameLayerSideProxyWithDescriptor(inLayer:yfiles.hierarchic.incremental.ILayer,forNode:yfiles.algorithms.Node,edge:yfiles.algorithms.Edge,sld:yfiles.hierarchic.incremental.SwimLaneDescriptor):yfiles.algorithms.Node;
        /**
        * Destroys a proxy node that has been created using.
        * {@link yfiles.hierarchic.incremental.IItemFactory#createProxyNode} for the drawing phase
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#destroySameLayerSideProxy}.
        */
        destroySameLayerSideProxy(proxyNode:yfiles.algorithms.Node):void;
        /**
        * Creates an edge group node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createEdgeGroupNode}.
        */
        createEdgeGroupNode(layer:yfiles.hierarchic.incremental.ILayer,groupId:Object):yfiles.algorithms.Node;
        /**
        * Creates a bend node in the layer for the given edge.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createBendNode}.
        */
        createBendNode(layer:yfiles.hierarchic.incremental.ILayer,edge:yfiles.algorithms.Edge):yfiles.algorithms.Node;
        /**
        * Creates a bend node in the layer for the given edge and assigns it to the given lane descriptor.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createBendNodeForDescriptor}.
        */
        createBendNodeForDescriptor(layer:yfiles.hierarchic.incremental.ILayer,edge:yfiles.algorithms.Edge,laneDescriptor:yfiles.hierarchic.incremental.SwimLaneDescriptor):yfiles.algorithms.Node;
        /**
        * Creates a spacer node for the drawing phase using the given bounds.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createDistanceNode}.
        */
        createDistanceNode(layer:yfiles.hierarchic.incremental.ILayer,size:yfiles.algorithms.Rectangle2D.Double,edges:yfiles.algorithms.Edge[]):yfiles.algorithms.Node;
        /**
        * Destroys a previously created spacer node for the drawing phase.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#destroyDistanceNode}.
        */
        destroyDistanceNode(distanceNode:yfiles.algorithms.Node):void;
        /**
        * Creates a dummy edge using the given data.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createDummyEdge}.
        */
        createDummyEdge(newSource:yfiles.algorithms.Node,newTarget:yfiles.algorithms.Node,oldEdge:yfiles.algorithms.Edge,sourceEnd:boolean,targetEnd:boolean):yfiles.algorithms.Edge;
        /**
        * Creates a reversed dummy edge using the given data.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createReverseDummyEdge}.
        */
        createReverseDummyEdge(newSource:yfiles.algorithms.Node,newTarget:yfiles.algorithms.Node,oldEdge:yfiles.algorithms.Edge,sourceEnd:boolean,targetEnd:boolean):yfiles.algorithms.Edge;
        /**
        * Creates a redirected edge to replace an edge connected to a group node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createRedirectedGroupEdge}.
        */
        createRedirectedGroupEdge(newSource:yfiles.algorithms.Node,newTarget:yfiles.algorithms.Node,groupEdge:yfiles.algorithms.Edge):yfiles.algorithms.Edge;
        /**
        * Creates a group node connector edge between two group nodes.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createGroupNodeConnectorEdge}.
        */
        createGroupNodeConnectorEdge(gn1:yfiles.algorithms.Node,gn2:yfiles.algorithms.Node,representative:yfiles.algorithms.Edge):yfiles.algorithms.Edge;
        /**
        * Creates a same layer proxy node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createSameLayerProxy}.
        */
        createSameLayerProxy(layer:yfiles.hierarchic.incremental.ILayer,edge:yfiles.algorithms.Edge,toProxy:yfiles.algorithms.Node):yfiles.algorithms.Edge;
        /**
        * Destroy a previously created same layer edge proxy.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#destroySameLayerProxy}.
        */
        destroySameLayerProxy(edge:yfiles.algorithms.Edge):yfiles.algorithms.Edge;
        /**
        * Creates a same layer switch proxy (switching between two same layer edges on two different sides
        * of the layer).
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createSameLayerSwitchProxy}.
        */
        createSameLayerSwitchProxy(layer:yfiles.hierarchic.incremental.ILayer,edge:yfiles.algorithms.Edge):yfiles.algorithms.Node;
        /**
        * Destroys a previously generated same layer switch proxy.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#destroySameLayerSwitchProxy}.
        */
        destroySameLayerSwitchProxy(node:yfiles.algorithms.Node):yfiles.algorithms.Edge;
        /**
        * Creates node data for a normal node and associates it with the node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createNormalNodeData}.
        */
        createNormalNodeData(node:yfiles.algorithms.Node):yfiles.hierarchic.incremental.INodeData;
        /**
        * Creates proxy node data for a proxy node and associates it with the node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createProxyNodeData}.
        */
        createProxyNodeData(node:yfiles.algorithms.Node,proxy:yfiles.algorithms.Node,edge:yfiles.algorithms.Edge):yfiles.hierarchic.incremental.INodeData;
        /**
        * Creates bend node data for a bend node and associates it with the node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createBendNodeData}.
        */
        createBendNodeData(node:yfiles.algorithms.Node,edge:yfiles.algorithms.Edge):yfiles.hierarchic.incremental.INodeData;
        /**
        * Creates bend node data for a bend node and associates it with the node.
        * The bend is assigned to the given laneDescriptor
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createBendNodeDataForDescriptor}.
        */
        createBendNodeDataForDescriptor(node:yfiles.algorithms.Node,edge:yfiles.algorithms.Edge,laneDescriptor:yfiles.hierarchic.incremental.SwimLaneDescriptor):yfiles.hierarchic.incremental.INodeData;
        /**
        * Creates an edge group node data for an edge group node and associates it with the node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createEdgeGroupNodeData}.
        */
        createEdgeGroupNodeData(node:yfiles.algorithms.Node,groupId:Object,source:boolean):yfiles.hierarchic.incremental.INodeData;
        /**
        * Creates a group boundary node for a group node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createGroupBorderNode}.
        */
        createGroupBorderNode(groupNode:yfiles.algorithms.Node,layer:yfiles.hierarchic.incremental.ILayer,type:number):yfiles.algorithms.Node;
        /**
        * Create a dummy node for the group layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createGroupLayerDummyNode}.
        */
        createGroupLayerDummyNode():yfiles.algorithms.Node;
        /**
        * Creates edge data for a normal edge and associates it with the edge.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createNormalEdgeData}.
        */
        createNormalEdgeData(edge:yfiles.algorithms.Edge):yfiles.hierarchic.incremental.IEdgeData;
        /**
        * Creates edge data for a same layer edge and associates it with the edge.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createSameLayerEdgeData}.
        */
        createSameLayerEdgeData(edge:yfiles.algorithms.Edge):yfiles.hierarchic.incremental.IEdgeData;
        /**
        * Creates edge data for a self loop edge and associates it with the edge.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createSelfLoopEdgeData}.
        */
        createSelfLoopEdgeData(edge:yfiles.algorithms.Edge):yfiles.hierarchic.incremental.IEdgeData;
        /**
        * Converts a normal edge to a {@link yfiles.hierarchic.incremental.EdgeDataType#DIRECT_SAME_LAYER_EDGE}.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#setDirectlyConnectSameLayerEdge}.
        */
        setDirectlyConnectSameLayerEdge(sameLayerEdge:yfiles.algorithms.Edge):void;
        /**
        * Sets a port constraint for an edge at the given side.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#setTemporaryPortConstraint}.
        */
        setTemporaryPortConstraint(edge:yfiles.algorithms.Edge,source:boolean,pc:yfiles.layout.PortConstraint):yfiles.hierarchic.incremental.IEdgeData;
        /**
        * Sets a edge group constraint for an edge.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#setTemporaryEdgeGroups}.
        */
        setTemporaryEdgeGroups(edge:yfiles.algorithms.Edge,sgId:Object,tgId:Object):yfiles.hierarchic.incremental.IEdgeData;
        /**
        * Creates an edge that connects two group border nodes.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createGroupBorderEdge}.
        */
        createGroupBorderEdge(source:yfiles.algorithms.Node,target:yfiles.algorithms.Node):yfiles.algorithms.Edge;
        /**
        * Create a dummy edge that mimics a connector to a group node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IItemFactory#createConnectorProxyForGroup}.
        */
        createConnectorProxyForGroup(groupNode:yfiles.algorithms.Node,groupId:Object,layer:yfiles.hierarchic.incremental.ILayer,e:yfiles.algorithms.Edge):yfiles.algorithms.Node;
      }
      var IItemFactory:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Factory interface for {@link yfiles.hierarchic.IncrementalHierarchicLayouter}.
      * Use this factory to obtain hints that will be interpreted by the layouter if
      * they are bound to a DataProvider instance that is registered with the LayoutGraph
      * using the {@link yfiles.hierarchic.IncrementalHierarchicLayouter#INCREMENTAL_HINTS_DP_KEY}
      * key.
      * An instance of a class implementing this interface can be obtained through
      * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#createIncrementalHintsFactory}.
      */
      export interface IIncrementalHintsFactory extends Object{
        /**
        * Creates a hint object for a node that should be inserted incrementally
        * during the layering phase.
        * This will place the node in a suitable layer,
        * thus possibly creating new layers.
        * Neighbors of this node may be marked as to be laid out incrementally, too.
        * This makes it possible to incrementally add whole subgraphs to the current
        * layout.
        * @param {Object} forNodeId 
        * the node to be layered and sequenced incrementally together
        * with its adjacent edges and possibly marked neighboring nodes.
        * @return {Object} 
        * an Object that can be interpreted by {@link yfiles.hierarchic.incremental.HierarchicLayouter}
        * @see Specified by {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createLayerIncrementallyHint}.
        */
        createLayerIncrementallyHint(forNodeId:Object):Object;
        /**
        * Creates a hint object for a node or edge that should be inserted incrementally
        * during the sequencing phase.
        * This will prevent the layering from being changed.
        * The node will be placed into an already existing layer that is determined
        * by the {@link yfiles.hierarchic.incremental.HierarchicLayouter#layerer} implementation, i.e. "from sketch".
        * Adjacent edges will automatically be rerouted optimally.
        * @param {Object} forItemId the node or edge to be sequenced/inserted incrementally.
        * @return {Object} 
        * an Object that can be interpreted by {@link yfiles.hierarchic.incremental.HierarchicLayouter}
        * @see Specified by {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createSequenceIncrementallyHint}.
        */
        createSequenceIncrementallyHint(forItemId:Object):Object;
        /**
        * Creates a hint object for a group node that should be inserted incrementally during the layering phase.
        * The group will be placed on a suitable position. The descendants of the group
        * may be associated with hints created by method {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createLayerIncrementallyHint},
        * {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createSequenceIncrementallyHint} or this method (if the descendant is an inner group).
        * All hints of the group's descendants are interpreted relative to the group node. Descendants without hints
        * keep their relative ordering within the group node (but not with elements outside the group).
        * The position of groups without incremental hint depends on the position of their descendants
        * (i.e., the group is not interpreted as fixed - it is simply ignored).
        * <p>
        * Note: Descendants of incremental groups must not be associated with exact coordinate hints (see method
        * {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactCoordinatesHint}, {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactSequenceCoordinatesHint} and
        * {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactLayerCoordinatesHint}).
        * </p>
        * @param {Object} forItemId the group node.
        * @return {Object} 
        * an Object that can be interpreted by {@link yfiles.hierarchic.incremental.HierarchicLayouter}
        * @see Specified by {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createIncrementalGroupHint}.
        */
        createIncrementalGroupHint(forItemId:Object):Object;
        /**
        * Creates a hint object for a node that should be inserted incrementally
        * into the graph at its exact current position.
        * The node will be placed into an already existing layer that is determined
        * by the {@link yfiles.hierarchic.incremental.HierarchicLayouter#layerer  layerer}
        * implementation. The position within its layer
        * will be determined by its current position.
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactSequenceCoordinatesHint}
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactLayerCoordinatesHint}
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#exactPlacementEnforced}
        * @param {Object} forNodeId the node to be placed at its exact current position.
        * @return {Object} 
        * an Object that can be interpreted by {@link yfiles.hierarchic.incremental.HierarchicLayouter}
        * @see Specified by {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactCoordinatesHint}.
        */
        createUseExactCoordinatesHint(forNodeId:Object):Object;
        /**
        * Creates a hint object for a node that should be inserted incrementally
        * into the graph at its exact current layer position.
        * The node will be placed into an already existing layer that is determined
        * by the {@link yfiles.hierarchic.incremental.HierarchicLayouter#layerer  layerer}
        * at the position that it occupies initially. The position within its layer
        * will be determined by the {@link yfiles.hierarchic.incremental.INodePlacer}.
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactCoordinatesHint}
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactSequenceCoordinatesHint}
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#exactPlacementEnforced}
        * @param {Object} forNodeId the node to be placed at its exact current layer position.
        * @return {Object} 
        * an Object that can be interpreted by {@link yfiles.hierarchic.incremental.HierarchicLayouter}
        * @see Specified by {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactLayerCoordinatesHint}.
        */
        createUseExactLayerCoordinatesHint(forNodeId:Object):Object;
        /**
        * Creates a hint object for a node that should be inserted incrementally
        * into the graph at its exact current sequence position.
        * The node will be placed into an already existing layer that is determined
        * by the {@link yfiles.hierarchic.incremental.HierarchicLayouter#layerer  layerer}
        * at the position that is deemed best for its layer. The position within the sequence of its layer
        * will be determined by its current coordinates.
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactCoordinatesHint}
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactLayerCoordinatesHint}
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#exactPlacementEnforced}
        * @param {Object} forNodeId the node to be placed at its exact current sequence position.
        * @return {Object} 
        * an Object that can be interpreted by {@link yfiles.hierarchic.incremental.HierarchicLayouter}
        * @see Specified by {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactSequenceCoordinatesHint}.
        */
        createUseExactSequenceCoordinatesHint(forNodeId:Object):Object;
      }
      var IIncrementalHintsFactory:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Container class that manages multiple {@link yfiles.hierarchic.incremental.ILayer} instances.
      * {@link yfiles.hierarchic.incremental.HierarchicLayouter} creates instances of this class and passes them
      * to the instances that handle the various subtasks of the layout process during
      * automatic layout. Method {@link yfiles.hierarchic.incremental.ILayers#createInstance} can be used like a factory
      * method to obtain temporary <code>Layers</code> instances.
      * @see {@link yfiles.hierarchic.incremental.ILayer}
      */
      export interface ILayers extends Object{
        /**
        * Returns the number of layers in this instance.
        * @return {number} the number of layers
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayers#size}.
        */
        size():number;
        /**
        * Returns a layer by index.
        * @param {number} i the zero-based index
        * @return {yfiles.hierarchic.incremental.ILayer} the layer at the given index
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayers#getLayer}.
        */
        getLayer(i:number):yfiles.hierarchic.incremental.ILayer;
        /**
        * Creates, inserts and returns a layer of a given type.
        * @param {yfiles.hierarchic.incremental.LayerType} type 
        * a type constant as defined in the {@link yfiles.hierarchic.incremental.ILayer} interface
        * @param {number} position the position where this layer will be inserted
        * @return {yfiles.hierarchic.incremental.ILayer} a newly created read-to-use layer instance
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayers#insert}.
        */
        insert(type:yfiles.hierarchic.incremental.LayerType,position:number):yfiles.hierarchic.incremental.ILayer;
        /**
        * Removes a layer by index.
        * @param {number} index the zero-based index of the layer
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayers#remove}.
        */
        remove(index:number):void;
        /**
        * Creates a new and empty Layers instance that can be used on the same graph
        * instance for temporary results.
        * @return {yfiles.hierarchic.incremental.ILayers} 
        * an instance of the same type as the current instance. It will be
        * empty initially.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayers#createInstance}.
        */
        createInstance():yfiles.hierarchic.incremental.ILayers;
      }
      var ILayers:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * This interface is used by classes that are capable of generating a layer
      * assignment.
      * Layer assignment takes place during the first part of the
      * algorithm in hierarchic layout algorithms.
      * Each node in the graph is assigned to a layer.
      * The {@link yfiles.hierarchic.incremental.OldLayererWrapper} class can be used to wrap existing implementations
      * of the {@link yfiles.hierarchic.ILayerer ILayerer} interface
      * from the <code>y.layout.hierarchic</code> package.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#layerer}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fixedElementsLayerer}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#fromScratchLayerer}
      */
      export interface ILayerer extends Object{
        /**
        * This method assigns all nodes in the graph to layers and registers them
        * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
        * In order to create new layers, the factory
        * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains the nodes that should be distributed
        * into the layers
        * @param {yfiles.hierarchic.incremental.ILayers} layers 
        * the object that will be filled with the results of the
        * calculation
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * LayoutDataProvider that can be used to query information about
        * the nodes - note that positional information
        * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
        * be available at any time.
        * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
        * @see {@link yfiles.hierarchic.incremental.ILayer#add}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
        */
        assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
      }
      var ILayerer:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Merges two {@link yfiles.hierarchic.incremental.ILayers} instances, whose nodes reside in the same graph.
      * Implementations of this interface may provide different strategies for merging.
      */
      export interface ILayeredComponentsMerger extends Object{
        /**
        * All nodes in srcLayers and targetLayers are part of graph at the moment of
        * invocation.
        * The state of srcLayers is discarded after this call and need not
        * be updated to reflect the changes. targetLayers must be updated accordingly.
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains the nodes in <code>srcLayers</code> and
        * <code>targetLayers</code>.
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query the layer indices
        * @param {yfiles.hierarchic.incremental.ILayers} srcLayers 
        * the Layers implementation that contains the layers that
        * will be merged into <code>targetLayers</code>
        * @param {yfiles.hierarchic.incremental.ILayers} targetLayers 
        * the Layers that will be modified to contain the resulting
        * layering
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayeredComponentsMerger#merge}.
        */
        merge(graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,srcLayers:yfiles.hierarchic.incremental.ILayers,targetLayers:yfiles.hierarchic.incremental.ILayers):void;
      }
      var ILayeredComponentsMerger:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Describes a single layer in a hierarchical drawing
      * with all its nodes and associated same layer edges.
      * A layer has a type and an index.
      * @see {@link yfiles.hierarchic.incremental.ILayers}
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter}
      * @see {@link yfiles.hierarchic.incremental.ILayerer}
      */
      export interface ILayer extends Object{
        /**
        * Adds a newly created node to this layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayer#add}.
        */
        add(node:yfiles.algorithms.Node):void;
        /**
        * Adds a same layer edge to this layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayer#addSameLayerEdge}.
        */
        addSameLayerEdge(edge:yfiles.algorithms.Edge):void;
        /**
        * All same layer edges in this layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayer#sameLayerEdges}.
        */
        sameLayerEdges:yfiles.algorithms.YList;
        /**
        * Removes a node from this layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayer#removeNode}.
        */
        removeNode(node:yfiles.algorithms.Node):void;
        /**
        * Removes the current layer from the Layers structure.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayer#remove}.
        */
        remove():void;
        /**
        * The nodes in this layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayer#list}.
        */
        list:yfiles.algorithms.NodeList;
        /**
        * Adjusts the order of the nodes in this list according to the given order.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayer#setNodeOrder}.
        */
        setNodeOrder(list:yfiles.algorithms.YList):void;
        /**
        * The main type of this layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayer#type}.
        */
        type:yfiles.hierarchic.incremental.LayerType;
        /**
        * The index of this layer in the list of all layers.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayer#index}.
        */
        index:number;
        /**
        * The{@link yfiles.layout.RowDescriptor} associated with this layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayer#row}.
        */
        row:yfiles.layout.RowDescriptor;
      }
      var ILayer:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Multi-purpose node descriptor for each node in the graph during the
      * hierarchic layout used internally by the algorithm implementations.
      * Instances of this interface can be obtained during the layout from instances
      * of the {@link yfiles.hierarchic.incremental.ILayoutDataProvider} interface.
      * NodeData typically carries a node's type and depending on the type an
      * optional {@link yfiles.hierarchic.incremental.INodeData#associatedEdge  associated Edge } and
      * {@link yfiles.hierarchic.incremental.INodeData#associatedNode  associated Node }. Optionally they may carry
      * a geometric description of the Node's borders and descriptors for various
      * aspects of the layout.
      */
      export interface INodeData extends Object{
        /**
        * The group node this node belongs to.
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#groupNode}.
        */
        groupNode:yfiles.algorithms.Node;
        /**
        * Returns a borderline for the given side which is treated as if the node's position
        * was at (0,0).
        * Clients may modify this instance but should always reset it to the
        * original position, since this is a shared instance.
        * May return <code>null</code> to indicate that the borderline can be determined
        * through the node's NodeLayout
        * @param {number} side 
        * the index of the side where <code>0</code> means top, <code>1</code>
        * means right, <code>2</code> means bottom, and <code>3</code> means left.
        * @return {yfiles.algorithms.BorderLine} a BorderLine instance if the node was at (0,0) or <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.INodeData#createBorderLine}
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#getNormalizedBorderLine}.
        */
        getNormalizedBorderLine(side:number):yfiles.algorithms.BorderLine;
        /**
        * Creates, stores, and returns a BorderLine for the given side or returns the currently
        * set BorderLine if it already exists.
        * Not every type of node supports this operation.
        * {@link yfiles.hierarchic.incremental.NodeDataType#NORMAL} supports borderlines.
        * @param {number} side 
        * the side as defined in {@link yfiles.hierarchic.incremental.INodeData#getNormalizedBorderLine}
        * @param {yfiles.layout.INodeLayout} nl 
        * the NodeLayout of the current node, the initial Borderline will
        * be initialize from this instance
        * @throws {yfiles.system.NotSupportedException} 
        * if this type of node does not support node
        * borders
        * @see {@link yfiles.hierarchic.incremental.INodeData#getNormalizedBorderLine}
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#createBorderLine}.
        */
        createBorderLine(side:number,nl:yfiles.layout.INodeLayout):yfiles.algorithms.BorderLine;
        /**
        * The first same layer edge ListCell of all same layer edges.
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#firstSameLayerEdgeCell}.
        */
        firstSameLayerEdgeCell:yfiles.algorithms.ListCell;
        /**
        * Returns the number of same layer edges that are associated with this node.
        * @return {number} the number
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#sameLayerEdgeCount}.
        */
        sameLayerEdgeCount():number;
        /**
        * The type constant for this node.
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#type}.
        */
        type:yfiles.hierarchic.incremental.NodeDataType;
        /**
        * Group id of this node if it is a bus group node.
        * @see {@link yfiles.hierarchic.incremental.NodeDataType#SOURCE_GROUP_NODE}
        * @see {@link yfiles.hierarchic.incremental.NodeDataType#TARGET_GROUP_NODE}
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#groupId}.
        */
        groupId:Object;
        /**
        * The associated node (in case of e.g.
        * backloop proxy and side proxy)
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#associatedNode}.
        */
        associatedNode:yfiles.algorithms.Node;
        /**
        * The associated edge (in case of e.g.
        * bend or same layer center node)
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#associatedEdge}.
        */
        associatedEdge:yfiles.algorithms.Edge;
        /**
        * The layer index this node resides in.
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#layer}.
        */
        layer:number;
        /**
        * The current position of this node in its layer.
        * Note: this may not always be up to date depending on which phase the layout
        * algorithm is currently in
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#position}.
        */
        position:number;
        /**
        * The parent group node if any.
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#parentGroupNode}.
        */
        parentGroupNode:yfiles.algorithms.Node;
        /**
        * The inner layers of this group node.
        * If this node is of type {@link yfiles.hierarchic.incremental.NodeDataType#GROUP}, this method returns the
        * {@link yfiles.hierarchic.incremental.ILayers} object that describes the layering in the subgraph.
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#groupLayers}.
        */
        groupLayers:yfiles.hierarchic.incremental.ILayers;
        /**
        * The hint of the incremental mode of this node if this node is of type{@link yfiles.hierarchic.incremental.NodeDataType#NORMAL}
        * and a corresponding hint has been set via the {@link yfiles.hierarchic.incremental.HierarchicLayouter#INCREMENTAL_HINTS_DP_KEY}
        * DataProvider.
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#incrementalHint}.
        */
        incrementalHint:yfiles.hierarchic.incremental.HierarchicLayouter.IncrementalHint;
        /**
        * The <code>NodeLayoutDescriptor</code> instance that was initially
        * bound to this node or <code>null</code>.
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#nodeLayoutDescriptor}.
        */
        nodeLayoutDescriptor:yfiles.hierarchic.incremental.NodeLayoutDescriptor;
        /**
        * The <code>SwimLaneDescriptor</code> instance that was initially
        * bound to this node or <code>null</code>.
        * @see Specified by {@link yfiles.hierarchic.incremental.INodeData#swimLaneDescriptor}.
        */
        swimLaneDescriptor:yfiles.hierarchic.incremental.SwimLaneDescriptor;
      }
      var INodeData:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Responsible for the x (sequence) and preliminary y coordinate assignments of
      * a drawing.
      * Implementations of this interface are used during the last phases of the algorithm
      * of the {@link yfiles.hierarchic.incremental.HierarchicLayouter}. They determine preliminary y coordinates
      * (which may be adjusted during the final edge routing) and the x coordinates
      * of all the elements that are part of the graph during the node placement phase.
      * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer}
      * @see {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator}
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter}
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#nodePlacer}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#nodePlacer}
      */
      export interface INodePlacer extends Object{
        /**
        * Invoked by {@link yfiles.hierarchic.incremental.HierarchicLayouter} before the ports get assigned.
        * This method is used to assign preliminary y coordinates for each layer.
        * The distance between two layers will be adjusted later by the edge routing
        * algorithm. This method is responsible for assigning the relative positions
        * of the nodes within each layer.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} layoutDataProvider 
        * the LayoutDataProvider that contains information about
        * the elements
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers that shall be calculated by this method
        * @see Specified by {@link yfiles.hierarchic.incremental.INodePlacer#assignLayerCoordinates}.
        */
        assignLayerCoordinates(graph:yfiles.layout.LayoutGraph,layoutDataProvider:yfiles.hierarchic.incremental.ILayoutDataProvider,layers:yfiles.hierarchic.incremental.ILayers):void;
        /**
        * Invoked by {@link yfiles.hierarchic.incremental.HierarchicLayouter} to determine the resulting x coordinates.
        * This method is invoked after all ports have been assigned their final relative
        * coordinates and nodes have been given relative coordinates within each layer.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} layoutDataProvider 
        * the LayoutDataProvider that contains information about
        * the elements
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers that shall be calculated by this method
        * @param {yfiles.hierarchic.incremental.IDrawingDistanceCalculator} drawingDistanceCalculator 
        * an instance that can be queried to determine
        * the minimum distance between each pair of nodes in the graph
        * @see Specified by {@link yfiles.hierarchic.incremental.INodePlacer#assignSequenceCoordinates}.
        */
        assignSequenceCoordinates(graph:yfiles.layout.LayoutGraph,layoutDataProvider:yfiles.hierarchic.incremental.ILayoutDataProvider,layers:yfiles.hierarchic.incremental.ILayers,drawingDistanceCalculator:yfiles.hierarchic.incremental.IDrawingDistanceCalculator):void;
      }
      var INodePlacer:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Interface for retrieving {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData} instances
      * for elements in the current layout graph.
      * Instances of this interface are provided by {@link yfiles.hierarchic.incremental.HierarchicLayouter} for
      * instances implementing subtasks during the layout.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter}
      */
      export interface ILayoutDataProvider extends Object{
        /**
        * Returns the associated {@link yfiles.hierarchic.incremental.INodeData} instance.
        * @param {yfiles.algorithms.Node} node the node for which the data will be returned
        * @return {yfiles.hierarchic.incremental.INodeData} the instance
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayoutDataProvider#getNodeData}.
        */
        getNodeData(node:yfiles.algorithms.Node):yfiles.hierarchic.incremental.INodeData;
        /**
        * Returns the associated {@link yfiles.hierarchic.incremental.IEdgeData} instance.
        * @param {yfiles.algorithms.Edge} edge the edge for which the data will be returned
        * @return {yfiles.hierarchic.incremental.IEdgeData} the instance
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayoutDataProvider#getEdgeData}.
        */
        getEdgeData(edge:yfiles.algorithms.Edge):yfiles.hierarchic.incremental.IEdgeData;
      }
      var ILayoutDataProvider:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * NodePlacer implementation based on {@link yfiles.algorithms.RankAssignments  rank-assignment}.
      * The drawer works with integer values and rounds double values to
      * integers using sophisticated quantizing.
      */
      export interface SimplexNodePlacer extends Object,yfiles.hierarchic.incremental.INodePlacer{
        /**
        * Specifies whether or not nodes should be placed in a more compact style with respect to layout width.
        * If enabled, the algorithm may place the nodes of a layer in a stacked style (horizontally interleaving), i.e.,
        * it splits the layer into an upper and lower sublayer and places adjacent nodes into different sublayers if
        * this reduces the width of the layer.
        * Note that enabling this option increases the required layout height.
        * By default this option is disabled.
        * Note that this option does not work with customized {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator}s,
        * see {@link yfiles.hierarchic.incremental.HierarchicLayouter#drawingDistanceCalculator}.
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#minimumSublayerDistance}
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#assignNodesToSublayer}
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#minimumSublayerDistance}
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#assignNodesToSublayer}
        */
        nodeCompaction:boolean;
        /**
        * The minimum distance between the upper and lower sublayer (see{@link yfiles.hierarchic.incremental.SimplexNodePlacer#nodeCompaction}).
        * Note that this option is only considered if the node compaction is enabled.
        * Furthermore, a too small distance value may prevent adjacent nodes from being placed in a stacked style
        * (horizontally interleaving) because the vertical distance between these nodes must be larger or equal to the value
        * specified by {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#minimumDistance}.
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#nodeCompaction}
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#nodeCompaction}
        */
        minimumSublayerDistance:number;
        /**
        * Specifies whether or not labels should be placed in a more compact style.
        * If this option is enabled the algorithm
        * tries to place adjacent label elements in a stacked style, i.e., horizontally interleaving.
        * By default this option is disabled.
        * Note that this option does not work with customized {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator}s,
        * see {@link yfiles.hierarchic.incremental.HierarchicLayouter#drawingDistanceCalculator}.
        */
        labelCompaction:boolean;
        /**
        * Specifies whether or not an optimization step should be applied that tries to further reduce the number of bends.
        * By default this option is enabled.
        * Note: using this option may increase runtime. If the runtime exceeds the maximal duration
        * (see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#maximalDuration}) the number of bends is not reduced.
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#maximalDuration}
        */
        bendReductionEnabled:boolean;
        /**
        * Specifies whether this instance tries to create a maximally compact horizontal layout at the cost of more bends.
        * <p>
        * For best results, {@link yfiles.hierarchic.incremental.SimplexNodePlacer#breakLongSegments} and {@link yfiles.hierarchic.incremental.SimplexNodePlacer#labelCompaction} should also be enabled.
        * </p>
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#labelCompaction}
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#breakLongSegments}
        */
        horizontalCompaction:boolean;
        /**
        * Specifies whether a postprocessing step should be applied that tries to remove some bends.
        * Note that this option is only considered if option {@link yfiles.hierarchic.incremental.SimplexNodePlacer#baryCenterMode}
        * and {@link yfiles.hierarchic.incremental.SimplexNodePlacer#nodeCompaction} are both disabled.
        * Furthermore, enabling edge straightening may violate some minimum distances specified by the user
        * and the edge distribution is no longer uniform.
        * <p>
        * The default is <code>false</code>.
        * </p>
        */
        straightenEdges:boolean;
        /**
        * The strategy that is used to control the horizontal compactness
        * of group nodes.
        * @see {@link yfiles.hierarchic.incremental.GroupCompactionPolicy#MAXIMAL}
        * @see {@link yfiles.hierarchic.incremental.GroupCompactionPolicy#NONE}
        * @see {@link yfiles.hierarchic.incremental.GroupCompactionPolicy#MAXIMAL}
        * @see {@link yfiles.hierarchic.incremental.GroupCompactionPolicy#NONE}
        */
        groupCompactionStrategy:yfiles.hierarchic.incremental.GroupCompactionPolicy;
        /**
        * Specifies whether this instance should enforce the placement of nodes at
        * their exact current position, even if this violates minimum distance
        * constraints.
        * <p>
        * The default is <code>true</code>.
        * </p>
        */
        exactPlacementEnforced:boolean;
        /**
        * Specifies whether this instance tries to use the coordinates given from the current sketch for
        * the determination of the layer coordinates.
        */
        fromSketchLayerAssignment:boolean;
        /**
        * The time limit (in milliseconds) set for the algorithm.
        * Note that restricting the maximal duration may result in a worse layout quality.
        * Furthermore, the real runtime may exceed the maximal duration since the algorithm
        * still have to find a valid solution.
        */
        maximalDuration:number;
        /**
        * The relative weight of edges crossing a swim lane relative to edges that stay
        * in their lane.
        * <p>
        * A value of <code>0.0d</code> will effectively make the algorithm
        * ignore edges crossing a swim lane border.
        * </p>
        * <p>
        * Defaults to <code>0.0d</code>.
        * </p>
        */
        swimLaneCrossingWeight:number;
        /**
        * Specifies whether or not to use the barycenter drawing mode.
        * If this mode is enabled the resulting drawing is likely to have more bends
        * but may be more symmetric.
        * <p>
        * By default this mode is turned off.
        * </p>
        */
        baryCenterMode:boolean;
        /**
        * Invoked by {@link yfiles.hierarchic.incremental.HierarchicLayouter} before the ports get assigned.
        * This method is used to assign preliminary y coordinates for each layer.
        * The distance between two layers will be adjusted later by the edge routing
        * algorithm. This method is responsible for assigning the relative positions
        * of the nodes within each layer.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} layoutDataProvider 
        * the LayoutDataProvider that contains information about
        * the elements
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers that shall be calculated by this method
        * @see Specified by {@link yfiles.hierarchic.incremental.INodePlacer#assignLayerCoordinates}.
        */
        assignLayerCoordinates(graph:yfiles.layout.LayoutGraph,layoutDataProvider:yfiles.hierarchic.incremental.ILayoutDataProvider,layers:yfiles.hierarchic.incremental.ILayers):void;
        /**
        * If option {@link yfiles.hierarchic.incremental.SimplexNodePlacer#nodeCompaction} is enabled, this method is called to assign the nodes
        * of a layer to the corresponding upper/lower sublayer.
        * @param {yfiles.algorithms.NodeList} layerNodes 
        * list that contains all normal nodes (see {@link yfiles.hierarchic.incremental.NodeDataType#NORMAL}) of a layer.
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider instance.
        * @param {yfiles.layout.LayoutGraph} graph the graph instance.
        * @param {yfiles.algorithms.INodeMap} lowerSublayer 
        * NodeMap whose {@link yfiles.algorithms.INodeMap#getBool} method has to return <code>true</code>
        * for each node that should be placed in the lower sublayer (values are set by this method).
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer#nodeCompaction}
        */
        assignNodesToSublayer(layerNodes:yfiles.algorithms.NodeList,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,graph:yfiles.layout.LayoutGraph,lowerSublayer:yfiles.algorithms.INodeMap):void;
        /**
        * Callback used by both {@link yfiles.hierarchic.incremental.SimplexNodePlacer#assignLayerCoordinates}
        * and {@link yfiles.hierarchic.incremental.SimplexNodePlacer#assignSequenceCoordinates}
        * to determine whether the given node should be treated as a node with fixed (given) coordinates.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the node
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} provider the current LayoutDataProvider
        * @param {yfiles.algorithms.Node} node the node
        * @param {boolean} inLayer 
        * whether the nodes' layer coordinate is queried or the sequence coordinate.
        * Iff <code>inLayer</code> is <code>true</code> this method is called from within the
        * {@link yfiles.hierarchic.incremental.SimplexNodePlacer#assignLayerCoordinates}
        * method
        * @return {boolean} whether the node should be treated as fixed
        */
        isFixedNode(graph:yfiles.layout.LayoutGraph,provider:yfiles.hierarchic.incremental.ILayoutDataProvider,node:yfiles.algorithms.Node,inLayer:boolean):boolean;
        /**
        * Callback method used by {@link yfiles.hierarchic.incremental.SimplexNodePlacer#assignLayerCoordinates}
        * to determine the minimum height of a layer.
        */
        getMinimumLayerHeight(graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,layer:yfiles.hierarchic.incremental.ILayer):number;
        /**
        * Callback method used by {@link yfiles.hierarchic.incremental.SimplexNodePlacer#assignLayerCoordinates}
        * to determine the alignment of the node inside the layer.
        */
        getLayerAlignment(graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,node:yfiles.algorithms.Node,layerIndex:number,minLayerHeight:number):number;
        /**
        * Invoked by {@link yfiles.hierarchic.incremental.HierarchicLayouter} to determine the resulting x coordinates.
        * This method is invoked after all ports have been assigned their final relative
        * coordinates and nodes have been given relative coordinates within each layer.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} layoutDataProvider 
        * the LayoutDataProvider that contains information about
        * the elements
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers that shall be calculated by this method
        * @param {yfiles.hierarchic.incremental.IDrawingDistanceCalculator} drawingDistanceCalculator 
        * an instance that can be queried to determine
        * the minimum distance between each pair of nodes in the graph
        * @see Specified by {@link yfiles.hierarchic.incremental.INodePlacer#assignSequenceCoordinates}.
        */
        assignSequenceCoordinates(graph:yfiles.layout.LayoutGraph,layoutDataProvider:yfiles.hierarchic.incremental.ILayoutDataProvider,layers:yfiles.hierarchic.incremental.ILayers,drawingDistanceCalculator:yfiles.hierarchic.incremental.IDrawingDistanceCalculator):void;
        /**
        * Determines the minimum allowed distance between two nodes in a given layer.
        * @see {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator}
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the nodes
        * @param {yfiles.hierarchic.incremental.ILayer} layer the layer that contains the nodes
        * @param {yfiles.algorithms.Node} predNode the node to the left of the other one, may be <code>null</code> to indicate a border line
        * @param {yfiles.algorithms.Node} succ the node to the right of the other one, may be <code>null</code> to indicate a border line
        * @return {number} the minimum distance allowed between those two nodes ( >=0 )
        */
        getMinDistance(graph:yfiles.layout.LayoutGraph,layer:yfiles.hierarchic.incremental.ILayer,predNode:yfiles.algorithms.Node,succ:yfiles.algorithms.Node):number;
        /**
        * Specifies whether this instance may break long edge segments in favor of a more compact layout.
        */
        breakLongSegments:boolean;
      }
      var SimplexNodePlacer:{
        $class:yfiles.lang.Class;
        new ():yfiles.hierarchic.incremental.SimplexNodePlacer;
      };
      /**
      * Inserts nodes incrementally into an existing layer structure, without destroying
      * the latter.
      * Nodes are inserted such that the length of backwards pointing edges
      * is minimized (not their number!). The method implemented will insert new layers
      * into the current layering if necessary at locally optimal positions.
      */
      export interface TopologicalIncrementalLayerer extends Object,yfiles.hierarchic.incremental.ILayerer{
        /**
        * Calculates an optimal layering for incremental nodes.
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph containing all nodes in layers and all nodes in incrementalNodes as
        * well as the respective edges.
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers structure containing all nodes but the incremental ones.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
        */
        assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * The{@link yfiles.hierarchic.incremental.ILayerer} instance used for the layering of separate
        * components.
        * Default is an instance of {@link yfiles.hierarchic.incremental.OldLayererWrapper} wrapping a
        * {@link yfiles.hierarchic.WeightedLayerer}.
        */
        separateComponentsLayerer:yfiles.hierarchic.incremental.ILayerer;
        /**
        * The{@link yfiles.hierarchic.incremental.ILayeredComponentsMerger} instance that will be used to
        * merge the layers of separate components into the current layering.
        * Default is {@link yfiles.hierarchic.incremental.DefaultLayeredComponentsMerger}
        */
        layeredComponentsMerger:yfiles.hierarchic.incremental.ILayeredComponentsMerger;
      }
      var TopologicalIncrementalLayerer:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of IncrementalLayerer.
        */
        new ():yfiles.hierarchic.incremental.TopologicalIncrementalLayerer;
      };
      /**
      * This layout stage can be used to automatically assign {@link yfiles.hierarchic.incremental.SwimLaneDescriptor}
      * instances to nodes using the {@link yfiles.hierarchic.IncrementalHierarchicLayouter#SWIMLANE_DESCRIPTOR_DP_KEY}
      * by treating top-level group nodes as swimlanes.
      * This stage will modify the hierarchy by removing the top level group nodes and assign corresponding
      * descriptors to the remaining nodes. After running the core layout, the nodes will be arranged to function as swim
      * lanes. This class allows for using the current coordinates of the group nodes
      * to {@link yfiles.hierarchic.incremental.TopLevelGroupToSwimlaneStage#orderSwimlanesFromSketch  arrange the swim lanes from sketch}.
      * Also the {@link yfiles.hierarchic.incremental.TopLevelGroupToSwimlaneStage#spacing  spacing} between swim lanes may be specified.
      * This stage can be {@link yfiles.layout.CanonicMultiStageLayouter#appendStage  appended}
      * to the {@link yfiles.hierarchic.IncrementalHierarchicLayouter}.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter}
      * @see {@link yfiles.hierarchic.incremental.SwimLaneDescriptor}
      * @see {@link yfiles.layout.GroupingKeys}
      */
      export interface TopLevelGroupToSwimlaneStage extends yfiles.layout.AbstractLayoutStage{
        /**
        * Determines the spacing between the lanes.
        * The default is <code>0.0d</code>.
        */
        spacing:number;
        /**
        * Determines whether the order of the swimlanes should be read from the current sketch.
        * The default is <code>false</code>.
        */
        orderSwimlanesFromSketch:boolean;
        /**
        * Returns <code>true</code> iff the given graph can be laid
        * out by this algorithm.
        * Calling <code>doLayout</code> with
        * the given graph as its argument will only success if
        * this method returns <code>true</code>.
        * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
        */
        canLayout(graph:yfiles.layout.LayoutGraph):boolean;
        /**
        * Main layout routine that assigns new layout information to the given graph.
        * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
        */
        doLayout(graph:yfiles.layout.LayoutGraph):void;
      }
      var TopLevelGroupToSwimlaneStage:{
        $class:yfiles.lang.Class;
        new ():yfiles.hierarchic.incremental.TopLevelGroupToSwimlaneStage;
      };
      /**
      * This class is used by {@link yfiles.hierarchic.incremental.HierarchicLayouter} during the various
      * phases to associate swim lanes with each node.
      * Each node should be associated with a SwimLaneDescriptor instance;
      * nodes in the same lane may share one instance.
      * The results of the calculation of the geometry of the swim lanes will be placed
      * into the instances of this class after the layout.
      * It can be bound to the layout algorithm using the
      * {@link yfiles.hierarchic.incremental.HierarchicLayouter#SWIMLANE_DESCRIPTOR_DP_KEY} {@link yfiles.algorithms.IDataProvider} key.
      * This class is designed as a class to allow for future additions of new getter
      * methods.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#SWIMLANE_DESCRIPTOR_DP_KEY}
      */
      export interface SwimLaneDescriptor extends Object,yfiles.lang.IObjectComparable,yfiles.algorithms.Comparators.IPartialOrder{
        /**
        * Specifies whether the index of this swim lane is fixed or whether
        * the algorithm should try to find the best possible position.
        * <b>Getter:</b>The default is <code>true</code>
        * <b>Setter:</b><p>
        * For all swim lanes where this property is set to <code>true</code>, the relative ordering given by the client objects
        * is preserved. The remaining swim lanes may be resorted so that the overall edge lengths are minimized.
        * </p>
        * <p>
        * By default, this feature is enabled. </p>
        */
        indexFixed:boolean;
        /**
        * The client object.
        * @throws {yfiles.system.ArgumentException} 
        * if there is currently no comparator set and
        * the specified object is not a {@link yfiles.lang.IObjectComparable} instance.
        * @see {@link yfiles.hierarchic.incremental.SwimLaneDescriptor#comparator}
        * @see {@link yfiles.hierarchic.incremental.SwimLaneDescriptor#comparator}
        */
        clientObject:Object;
        /**
        * The tightness factor of the lane.
        * <b>Setter:</b>The greater the value the
        * more will the lane to be forced to be of its minimal possible width.
        * A value of <code>0.0d</code> will disable compression of the lane.
        * A value of <code>1.0d</code> will try to force the lane to be of
        * its {@link yfiles.hierarchic.incremental.SwimLaneDescriptor#minimumLaneWidth  minimum width}.
        * <b>Getter:</b>The default is <code>0.0d</code>.
        * @throws {yfiles.system.ArgumentException} if tightness is out of the valid range
        */
        laneTightness:number;
        /**
        * The comparator that is used for sorting the lanes.
        * @throws {yfiles.system.ArgumentNullException} 
        * if the specified comparator is
        * <code>null</code>.
        */
        comparator:yfiles.objectcollections.IComparer;
        /**
        * The minimum lane width.
        * The default is <code>0.0d</code>.
        * @throws {yfiles.system.ArgumentException} 
        * if the specified value is less than
        * <code>0</code>.
        */
        minimumLaneWidth:number;
        /**
        * The left lane insets where no element
        * will lie in the resulting drawing.
        * The default is <code>0.0d</code>.
        * @throws {yfiles.system.ArgumentException} 
        * if the specified value is less than
        * <code>0</code>.
        */
        leftLaneInset:number;
        /**
        * The right lane insets where no element
        * will lie in the resulting drawing.
        * The default is <code>0.0d</code>.
        * @throws {yfiles.system.ArgumentException} 
        * if the specified value is less than
        * <code>0</code>.
        */
        rightLaneInset:number;
        /**
        * The computed position (smaller coordinate) of the lane
        * after the layout has been calculated.
        */
        computedLanePosition:number;
        /**
        * The computed width of the lane
        * after the layout has been calculated.
        */
        computedLaneWidth:number;
        /**
        * The computed zero-based index of the lane
        * after the layout has been calculated.
        */
        computedLaneIndex:number;
        /**
        * Implements the Comparable interface using the {@link yfiles.hierarchic.incremental.SwimLaneDescriptor#comparator} and
        * {@link yfiles.hierarchic.incremental.SwimLaneDescriptor#clientObject} fields.
        * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
        */
        compareToObject(o:Object):number;
      }
      var SwimLaneDescriptor:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new swim lane descriptor with an associated client object.
        * @param {yfiles.lang.IObjectComparable} clientObject 
        * an object provided by the client that will be used
        * for determining the order of the lanes.
        * @throws {yfiles.system.ArgumentNullException} 
        * if the specified client object is
        * <code>null</code>.
        */
        new (clientObject:yfiles.lang.IObjectComparable):yfiles.hierarchic.incremental.SwimLaneDescriptor;
        /**
        * Creates a new swim lane descriptor using the given
        * client object and comparator.
        * @param {Object} clientObject a client object used for sorting the lanes
        * @param {yfiles.objectcollections.IComparer} cmp a Comparator used for comparing the client objects.
        * @throws {yfiles.system.ArgumentNullException} 
        * if the specified client object is
        * <code>null</code> or the specified comparator is <code>null</code> but the
        * specified client object is not a {@link yfiles.lang.IObjectComparable} instance.
        */
        WithComparer:{
          new (clientObject:Object,cmp:yfiles.objectcollections.IComparer):yfiles.hierarchic.incremental.SwimLaneDescriptor;
        };
      };
      /**
      * This implementation returns the minimum distances for each kind of node pair
      * based on their type as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
      */
      export interface TypeBasedDrawingDistanceCalculator extends Object,yfiles.hierarchic.incremental.IDrawingDistanceCalculator{
        /**
        * Main interface method.
        * Queried by {@link yfiles.hierarchic.incremental.INodePlacer} instances to determine
        * the minimum distances between elements in one layer. Note that either of the Node
        * arguments may be <code>null</code>. In that case only the border of the non-<code>null</code>
        * node should be considered.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the nodes
        * @param {yfiles.hierarchic.incremental.ILayer} layer the layer object that contains the nodes
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query information
        * @param {yfiles.algorithms.Node} left 
        * the left one of the two nodes whose
        * minimum distance is to be determined or <code>null</code> if only the left border of the right node is
        * of interest.
        * @param {yfiles.algorithms.Node} right 
        * the right one of the two nodes whose
        * minimum distance is to be determined or <code>null</code> if only the right border of the left node is
        * of interest.
        * @see Specified by {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#getMinDistance}.
        */
        getMinDistance(graph:yfiles.layout.LayoutGraph,layer:yfiles.hierarchic.incremental.ILayer,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,left:yfiles.algorithms.Node,right:yfiles.algorithms.Node):number;
        /**
        * Specifies whether or not the compaction option is enabled.
        * If it is enabled adjacent layer elements may be placed
        * in a stacked style (i.e., horizontally interleaving). By default this option is disabled.
        */
        compaction:boolean;
        /**
        * The distance between nodes.
        */
        node2NodeDistance:number;
        /**
        * The distance between nodes and edges.
        */
        node2EdgeDistance:number;
        /**
        * The distance between edges.
        */
        edge2EdgeDistance:number;
        /**
        * Called to dispose internal data structures.
        * Implementations should
        * release internally held data structures here.
        * @see {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#initialize}
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains all elements that are used during
        * the node placement
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers object that was used
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that was used to query information
        * @see Specified by {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#dispose}.
        */
        dispose(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * Called to initialize internal data structures.
        * Implementations may
        * cache lengthy calculations in the initialization phase.
        * It is guaranteed that the graph will not be changed during subsequent
        * calls to {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#getMinDistance}.
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains all elements that are used during
        * the node placement
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers object that will be used during subsequent calls
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query information
        * @see {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#dispose}
        * @see Specified by {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#initialize}.
        */
        initialize(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * The minimum length of the first and last segment of an edge.
        */
        minimumFirstSegmentLength:number;
      }
      var TypeBasedDrawingDistanceCalculator:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of TypeBasedDrawingDistanceCalculator.
        */
        new ():yfiles.hierarchic.incremental.TypeBasedDrawingDistanceCalculator;
      };
      /**
      * This class is used by {@link yfiles.hierarchic.incremental.HierarchicLayouter} during the various
      * phases to determine the drawing details of the graph's nodes.
      * Note: not all of these values will be used for all kinds of nodes and
      * any kind of algorithm used.
      * This class is designed as a class to allow for future additions of new getter
      * methods.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#NODE_LAYOUT_DESCRIPTOR_DP_KEY}
      * @see {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor}
      */
      export interface NodeLayoutDescriptor extends Object{
        /**
        * Sets the port border gap ratio for the port distribution at the given
        * side.
        * @param {number} side the side
        * @param {number} ratio the new ratio
        */
        setPortBorderGapRatio(side:number,ratio:number):void;
        /**
        * The port border gap ratio for the port distribution on all sides of
        * the node.
        * @see {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#setPortBorderGapRatio}
        */
        portBorderGapRatios:number;
        /**
        * Returns the port border gap ratio for the port distribution at the given
        * side.
        * Default is <code>0.5d</code> for all sides.
        * @param {number} side the 0-based clockwise side index for top-to-bottom layouts
        * @return {number} the ratio
        */
        getPortBorderGapRatio(side:number):number;
        /**
        * The alignment of the node within its layer
        * Default is <code>0.5d</code> which results in center-aligned nodes.
        * A value of <code>0.0d</code> means nodes are aligned at the top of the layer
        * (for top-down drawing). A value of <code>0.5d</code> results in center-aligned nodes
        * and <code>1.0d</code> leads to bottom-aligned nodes.
        * @throws {yfiles.system.ArgumentException} if the alignment is not within [0.0d .. 1.0d]
        */
        layerAlignment:number;
        /**
        * The mode that determines the consideration of node labels during the
        * layout.
        * This can be one of {@link yfiles.hierarchic.incremental.NodeLabelMode#NEVER},
        * {@link yfiles.hierarchic.incremental.NodeLabelMode#CONSIDER_FOR_SELF_LOOPS},
        * {@link yfiles.hierarchic.incremental.NodeLabelMode#CONSIDER_FOR_DRAWING}, or
        * {@link yfiles.hierarchic.incremental.NodeLabelMode#CONSIDER_FOR_ROUTING}.
        * <b>Setter:</b>Note that in order to get this feature working the algorithm must be provided
        * information about the layout of the node labels. If
        * {@link yfiles.hierarchic.IncrementalHierarchicLayouter} is used for the layout
        * the {@link yfiles.hierarchic.IncrementalHierarchicLayouter#considerNodeLabels}
        * should be set to <code>true</code>. Otherwise one has to assure that
        * e.g. via an instanceof {@link yfiles.layout.LabelLayoutTranslator} the algorithm
        * receives the appropriate information.
        * The mode constant can be one of {@link yfiles.hierarchic.incremental.NodeLabelMode#NEVER},
        * {@link yfiles.hierarchic.incremental.NodeLabelMode#CONSIDER_FOR_SELF_LOOPS},
        * {@link yfiles.hierarchic.incremental.NodeLabelMode#CONSIDER_FOR_DRAWING}, or
        * {@link yfiles.hierarchic.incremental.NodeLabelMode#CONSIDER_FOR_ROUTING}.
        * <b>Getter:</b>
        * The default is {@link yfiles.hierarchic.incremental.NodeLabelMode#CONSIDER_FOR_DRAWING}.
        * @throws {yfiles.system.ArgumentException} if the constant is unknown.
        * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#considerNodeLabels}
        * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter#considerNodeLabels}
        */
        nodeLabelMode:yfiles.hierarchic.incremental.NodeLabelMode;
        /**
        * The minimum height of the layer this node will be assigned to.
        * Note, that this will only affect the drawing if different
        * {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#layerAlignment  layerAlignments} are present.
        */
        minimumLayerHeight:number;
        /**
        * The <i>preferred</i> minimum distance of the node to obstacles.
        * Default is <code>5.0d</code>.
        */
        minimumDistance:number;
        /**
        * A reference point relative to the center of the node which will be placed on a grid coordinate.
        * By default the reference point is {@link yfiles.algorithms.YPoint#ORIGIN} and the nodes' center is placed on the grid.
        * <p>
        * The grid reference point will only be considered if there actually is a
        * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#gridSpacing  grid}.
        * </p>
        */
        gridReference:yfiles.algorithms.YPoint;
        /**
        * The assignment strategy which is used to distribute the ports on the node borders.
        * <p>
        * Note that the port assignments {@link yfiles.hierarchic.incremental.PortAssignmentMode#DEFAULT}, {@link yfiles.hierarchic.incremental.PortAssignmentMode#ON_GRID} and
        * {@link yfiles.hierarchic.incremental.PortAssignmentMode#ON_SUBGRID} are currently only supported in
        * {@link yfiles.hierarchic.incremental.DefaultPortAllocator}. A custom implementation of
        * {@link yfiles.hierarchic.incremental.IPortAllocator} will have to handle these assignments itself or will
        * replace them with its own behavior.
        * </p>
        * <p>
        * Note that if no grid is specified
        * ({@link yfiles.hierarchic.IncrementalHierarchicLayouter#gridSpacing  grid spacing} is smaller or
        * equal to 0), assignment <code>PORT_ASSIGNMENT_DEFAULT</code> is used.
        * </p>
        * <p>
        * By default {@link yfiles.hierarchic.incremental.PortAssignmentMode#DEFAULT} is used.
        * </p>
        */
        portAssignment:yfiles.hierarchic.incremental.PortAssignmentMode;
      }
      var NodeLayoutDescriptor:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of a NodeLayoutDescriptor using the
        * default values.
        */
        new ():yfiles.hierarchic.incremental.NodeLayoutDescriptor;
      };
      /**
      * Wraps a {@link yfiles.hierarchic.ILayerer} implementation from the <code>y.layout.hierarchic</code>
      * package to behave like a {@link yfiles.hierarchic.incremental.ILayerer} implementation from the
      * <code>y.layout.hierarchic.incremental</code> package.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#layerer}
      */
      export interface OldLayererWrapper extends Object,yfiles.hierarchic.incremental.ILayerer{
        /**
        * This method assigns all nodes in the graph to layers and registers them
        * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
        * In order to create new layers, the factory
        * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains the nodes that should be distributed
        * into the layers
        * @param {yfiles.hierarchic.incremental.ILayers} layers 
        * the object that will be filled with the results of the
        * calculation
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * LayoutDataProvider that can be used to query information about
        * the nodes - note that positional information
        * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
        * be available at any time.
        * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
        * @see {@link yfiles.hierarchic.incremental.ILayer#add}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
        */
        assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * The <code>y.layout.hierarchic.Layerer</code>
        * instance that is used for delegation.
        * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
        */
        oldLayerer:yfiles.hierarchic.ILayerer;
      }
      var OldLayererWrapper:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of OldLayererWrapper, wrapping the given layerer.
        * @param {yfiles.hierarchic.ILayerer} oldLayerer the old layerer implementation
        */
        new (oldLayerer:yfiles.hierarchic.ILayerer):yfiles.hierarchic.incremental.OldLayererWrapper;
      };
      /**
      * This class is used by {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor}
      * to specify the routing style for different edge types.
      * @see {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor#routingStyle}
      */
      export interface RoutingStyle extends Object{
        /**
        * The routing style for back-loops.
        * This style is used for routing u-turns of common edges (i.e., edges that are neither self-loops nor same layer edges).
        * A u-turn is a non-monotonic part of the edge route that is required for reversed edges if option {@link yfiles.hierarchic.IncrementalHierarchicLayouter#backloopRouting} is enabled
        * or in some other scenarios with port constraints/candidates.
        * Possible values are {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#OCTILINEAR}, {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#ORTHOGONAL} and {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#POLYLINE}.
        */
        backloopRoutingStyle:yfiles.hierarchic.incremental.EdgeRoutingStyle;
        /**
        * The routing style for grouped edges at the common segments.
        * More precisely, grouped edges are routed
        * in bus-style (i.e., the paths of the edges will share a common edge segment) and this option allows to specify
        * the routing style at the bus.
        * Possible values are {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#OCTILINEAR}, {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#ORTHOGONAL} and {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#POLYLINE}.
        */
        edgeGroupRoutingStyle:yfiles.hierarchic.incremental.EdgeRoutingStyle;
        /**
        * The default routing style.
        * This style is used for edges or part of edges
        * for which no other routing style applies.
        * Possible values are {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#OCTILINEAR}, {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#ORTHOGONAL} and {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#POLYLINE}.
        */
        defaultEdgeRoutingStyle:yfiles.hierarchic.incremental.EdgeRoutingStyle;
        /**
        * The routing style for same layer edges (i.e., edges whose source/target are assigned to the same layer).
        * Possible values are {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#OCTILINEAR}, {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#ORTHOGONAL} and {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#POLYLINE}.
        */
        sameLayerEdgeRoutingStyle:yfiles.hierarchic.incremental.EdgeRoutingStyle;
        /**
        * The routing style for self-loops.
        * Possible values are {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#OCTILINEAR}, {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#ORTHOGONAL} and {@link yfiles.hierarchic.incremental.EdgeRoutingStyle#POLYLINE}.
        */
        selfloopRoutingStyle:yfiles.hierarchic.incremental.EdgeRoutingStyle;
      }
      var RoutingStyle:{
        $class:yfiles.lang.Class;
        /**
        * Sets the routing style for each edge type to the specified value.
        * @param {yfiles.hierarchic.incremental.EdgeRoutingStyle} routingStyle the routing style.
        */
        new (routingStyle:yfiles.hierarchic.incremental.EdgeRoutingStyle):yfiles.hierarchic.incremental.RoutingStyle;
      };
      /**
      * This class can be used to calculate bend points for orthogonally routed
      * self loops.
      * It is used during the layout phase of {@link yfiles.hierarchic.incremental.HierarchicLayouter}, but
      * can be used as a stand-alone tool.
      */
      export interface SelfloopCalculator extends Object{
        /**
        * Calculates all self loops at the given node the given graph.
        * The current port positions will be used to determine the start and end ports.
        * The DataProvider instances can be used to specify the direction of first
        * and last segments.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the node
        * @param {yfiles.algorithms.Node} node the node whose self loops will be routed
        * @param {yfiles.algorithms.IDataProvider} spc 
        * a DataProvider that contains {@link yfiles.layout.PortConstraint} information
        * for the source ports of the edges
        * @param {yfiles.algorithms.IDataProvider} tpc 
        * a DataProvider that contains {@link yfiles.layout.PortConstraint} information
        * for the target ports of the edges
        */
        calculateSelfLoops(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node,spc:yfiles.algorithms.IDataProvider,tpc:yfiles.algorithms.IDataProvider):void;
        /**
        * Convenience method that calculates a list of self-loops that belong to a given node.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the node
        * @param {yfiles.algorithms.Node} node the node whose self loops will be routed
        * @param {yfiles.algorithms.YList} selfLoops 
        * a list of {@link yfiles.algorithms.Edge}s that will be routed
        * @param {yfiles.algorithms.IDataProvider} spc 
        * a DataProvider that contains {@link yfiles.layout.PortConstraint} information
        * for the source ports of the edges
        * @param {yfiles.algorithms.IDataProvider} tpc 
        * a DataProvider that contains {@link yfiles.layout.PortConstraint} information
        * for the target ports of the edges
        */
        calculateSelfLoopsForEdgeList(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node,selfLoops:yfiles.algorithms.YList,spc:yfiles.algorithms.IDataProvider,tpc:yfiles.algorithms.IDataProvider):void;
        /**
        * Returns the minimum length for the first segment of an edge.
        * The value is fetched from the corresponding data provider.
        */
        getMinimumFirstSegmentLength(graph:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):number;
        /**
        * Returns whether or not the given edge is octilinear.
        * The value is fetched from the corresponding data provider.
        */
        isOctilinearEdge(graph:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):boolean;
        /**
        * Returns the minimum octilinear segment length for the given edge.
        * The value is fetched from the corresponding data provider.
        */
        getMinimumOctilinearSegmentLength(graph:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):number;
        /**
        * Returns the minimum length for the last segment of an edge.
        * The value is fetched from the corresponding data provider.
        */
        getMinimumLastSegmentLength(graph:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):number;
        /**
        * Returns the minimum length between two edges.
        * The value is fetched from the corresponding data provider.
        */
        getMinimumDistance(graph:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):number;
        /**
        * Returns the minimum length between two nodes.
        * The value is fetched from the corresponding data provider.
        */
        getMinimumNodeDistance(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):number;
      }
      var SelfloopCalculator:{
        $class:yfiles.lang.Class;
        /**
        * A key used for a {@link yfiles.algorithms.IDataProvider} bound to the graph that
        * yields for each node a minimum distance to the self loop edges.
        */
        MINIMUM_NODE_DISTANCE_DP_KEY:Object;
        /**
        * A key used for a {@link yfiles.algorithms.IDataProvider} bound to the graph that
        * returns for each edge whether or not it is octilinear.
        */
        IS_OCTILINEAR_DP_KEY:Object;
        /**
        * A key used for a {@link yfiles.algorithms.IDataProvider} bound to the graph that
        * yields for each octilinear edge a minimum length of its octilinear segments.
        */
        MINIMUM_OCTILINEAR_SEGMENT_LENGTH_DP_KEY:Object;
        /**
        * A key used for a {@link yfiles.algorithms.IDataProvider} bound to the graph that
        * yields for each edge a minimum length of its first segment.
        */
        MINIMUM_FIRST_SEGMENT_LENGTH_DP_KEY:Object;
        /**
        * A key used for a {@link yfiles.algorithms.IDataProvider} bound to the graph that
        * yields for each edge a minimum length of its last segment.
        */
        MINIMUM_LAST_SEGMENT_LENGTH_DP_KEY:Object;
        /**
        * A key used for a {@link yfiles.algorithms.IDataProvider} bound to the graph that
        * yields for each edge a minimum distance to the next edge or node side.
        */
        MINIMUM_EDGE_DISTANCE_DP_KEY:Object;
        /**
        * Creates a new instance of SelfloopCalculator using the given
        * parameters for minimum first segment length and minimum distance between
        * each pair of edges.
        * @param {number} minFirstSegmentLength 
        * the minimum length of the first and last segment
        * of an orthogonally routed self loop
        * @param {number} minEdgeDistance the minimum distance between a pair of self loops
        */
        new (minFirstSegmentLength:number,minEdgeDistance:number):yfiles.hierarchic.incremental.SelfloopCalculator;
      };
      /**
      * Layout stage that is used for handling a given partition grid structure ({@link yfiles.layout.PartitionGrid}) that is
      * attached to a graph with DataProvider {@link yfiles.layout.PartitionGrid#PARTITION_GRID_DP_KEY}.
      * Note: the IncrementalHierarchicLayouter automatically uses this stage if required.
      * @see {@link yfiles.layout.PartitionGrid}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter}
      */
      export interface PartitionGridLayoutStage extends yfiles.layout.AbstractLayoutStage{
        /**
        * Returns <code>true</code> iff the given graph can be laid
        * out by this algorithm.
        * Calling <code>doLayout</code> with
        * the given graph as its argument will only success if
        * this method returns <code>true</code>.
        * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
        */
        canLayout(graph:yfiles.layout.LayoutGraph):boolean;
        /**
        * Main layout routine that assigns new layout information to the given graph.
        * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
        */
        doLayout(graph:yfiles.layout.LayoutGraph):void;
      }
      var PartitionGridLayoutStage:{
        $class:yfiles.lang.Class;
        new ():yfiles.hierarchic.incremental.PartitionGridLayoutStage;
      };
      /**
      * This class is an implementation of the {@link yfiles.hierarchic.incremental.IPortConstraintOptimizer} interface which can be registered
      * with the {@link yfiles.hierarchic.incremental.HierarchicLayouter} instance using it's
      * {@link yfiles.hierarchic.incremental.HierarchicLayouter#portConstraintOptimizer} method.
      * It will query the graph's DataProvider repository for
      * the {@link yfiles.layout.PortCandidate#SOURCE_PC_LIST_DP_KEY} and {@link yfiles.layout.PortCandidate#TARGET_PC_LIST_DP_KEY}
      * keys and expects them to hold {@link yfiles.algorithms.ICollection} instances of {@link yfiles.layout.PortCandidate}s for each edge.
      * Additionally it will query the DataProvider associated with {@link yfiles.layout.PortCandidateSet#NODE_DP_KEY} and expects
      * {@link yfiles.layout.PortCandidateSet} instances associated with each node in the input graph.
      * This implementation will then <b>try</b> to assign each edge one of the PortCandidates without creating too many
      * crossings or violating the cost constraints for each PortCandidate.
      */
      export interface PCListOptimizer extends yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer{
        /**
        * Determines whether this implementation should use a deterministic algorithm to assign the PortCandidates.
        */
        deterministic:boolean;
        /**
        * The penalty cost that is associated with each backloop.
        * The default value is <code>1.0d</code>.
        */
        backloopPenalty:number;
        /**
        * The penalty cost that is associated with each generated crossing that would be generated
        * if a given combination of PortCandidates would be chosen.
        * The default value is <code>10.0d</code>.
        */
        crossingPenalty:number;
        /**
        * The penalty cost that is associated with each edge being assigned to a port which has no
        * capacity left.
        * The default value is <code>100.0d</code>.
        * @see {@link yfiles.layout.PortCandidateSet.IEntry#connections}
        */
        overUsagePenalty:number;
        /**
        * Called after the layering information has been determined.
        * This method can be used to assign
        * new temporary port constraints for the next phases of the algorithm.
        * @see {@link yfiles.hierarchic.incremental.IItemFactory#setTemporaryPortConstraint}
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on
        * @param {yfiles.hierarchic.incremental.ILayers} layers the layering information
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the implementation which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData} instances
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory to set the temporary port constraints with
        * @see Specified by {@link yfiles.hierarchic.incremental.IPortConstraintOptimizer#optimizeAfterLayering}.
        */
        optimizeAfterLayering(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
        /**
        * Returns the data provider that provides the port candidate sets for nodes.
        * @param {yfiles.layout.LayoutGraph} graph The graph that stores the data provider
        */
        getPortCandidateSetDataProvider(graph:yfiles.layout.LayoutGraph):yfiles.algorithms.IDataProvider;
        /**
        * Called after the sequence of the nodes has been determined.
        * This method can be used to assign
        * new temporary port constraints for the next phases of the algorithm.
        * @see {@link yfiles.hierarchic.incremental.IItemFactory#setTemporaryPortConstraint}
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on
        * @param {yfiles.hierarchic.incremental.ILayers} layers the layering information
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the implementation which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData} instances
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory to set the temporary port constraints with
        * @see Specified by {@link yfiles.hierarchic.incremental.IPortConstraintOptimizer#optimizeAfterSequencing}.
        */
        optimizeAfterSequencing(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
        /**
        * Called after the sequence of the nodes has been determined to assign new temporary port constraints to each
        * original node.
        * Note that, in this phase, it's not allowed to create back-loops, that is, in-edges must not connect to the south
        * side and out-edges must not connect to the north side.
        * @param {yfiles.algorithms.Node} node the original node to set temporary port constraints at.
        * @param {yfiles.objectcollections.IComparer} inEdgeOrder 
        * a {@link yfiles.algorithms.Comparators.IPartialOrder} which defines the preferred ordering of the in-edges from left to right.
        * Note: to sort collections according to a PartialOrder, an appropriate method like {@link yfiles.algorithms.Comparators#sortListWithComparer} or {@link yfiles.algorithms.YList#sort} must be used.
        * @param {yfiles.objectcollections.IComparer} outEdgeOrder 
        * a {@link yfiles.algorithms.Comparators.IPartialOrder} which defines the preferred ordering of the out-edges from left to
        * right. Note: to sort collections according to a PartialOrder, an appropriate method like {@link yfiles.algorithms.Comparators#sortListWithComparer} or {@link yfiles.algorithms.YList#sort} must be used.
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on.
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData}.
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory which can set the temporary port constraints.
        * @see {@link yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer#optimizeAfterSequencing}
        */
        optimizeAfterSequencingForSingleNode(node:yfiles.algorithms.Node,inEdgeOrder:yfiles.objectcollections.IComparer,outEdgeOrder:yfiles.objectcollections.IComparer,graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
      }
      var PCListOptimizer:{
        $class:yfiles.lang.Class;
        new ():yfiles.hierarchic.incremental.PCListOptimizer;
      };
      /**
      * A default {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator} implementation that is used
      * by {@link yfiles.hierarchic.incremental.HierarchicLayouter} to configure the {@link yfiles.hierarchic.incremental.INodePlacer}.
      */
      export interface DefaultDrawingDistanceCalculator extends Object,yfiles.hierarchic.incremental.IDrawingDistanceCalculator{
        /**
        * Called to initialize internal data structures.
        * Implementations may
        * cache lengthy calculations in the initialization phase.
        * It is guaranteed that the graph will not be changed during subsequent
        * calls to {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#getMinDistance}.
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains all elements that are used during
        * the node placement
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers object that will be used during subsequent calls
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query information
        * @see {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#dispose}
        * @see Specified by {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#initialize}.
        */
        initialize(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * Called to dispose internal data structures.
        * Implementations should
        * release internally held data structures here.
        * @see {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#initialize}
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains all elements that are used during
        * the node placement
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers object that was used
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that was used to query information
        * @see Specified by {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#dispose}.
        */
        dispose(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * Specifies whether or not an adaptive minimum edge distance should be used.
        * If this option is enabled the minimum distance between two adjacent edges is the minimum of the set
        * minimum edge distance and the distance of the edges' source/target points.
        * By default this option is enabled.
        */
        useAdaptiveMinEdgeDistance:boolean;
        /**
        * Specifies whether or not the compaction option is enabled.
        * If it is enabled adjacent layer elements
        * may be placed in a stacked style (i.e., horizontally interleaving).
        * By default this option is disabled.
        */
        compaction:boolean;
        /**
        * Main interface method.
        * Queried by {@link yfiles.hierarchic.incremental.INodePlacer} instances to determine
        * the minimum distances between elements in one layer. Note that either of the Node
        * arguments may be <code>null</code>. In that case only the border of the non-<code>null</code>
        * node should be considered.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the nodes
        * @param {yfiles.hierarchic.incremental.ILayer} layer the layer object that contains the nodes
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query information
        * @param {yfiles.algorithms.Node} left 
        * the left one of the two nodes whose
        * minimum distance is to be determined or <code>null</code> if only the left border of the right node is
        * of interest.
        * @param {yfiles.algorithms.Node} right 
        * the right one of the two nodes whose
        * minimum distance is to be determined or <code>null</code> if only the right border of the left node is
        * of interest.
        * @see Specified by {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#getMinDistance}.
        */
        getMinDistance(graph:yfiles.layout.LayoutGraph,layer:yfiles.hierarchic.incremental.ILayer,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,left:yfiles.algorithms.Node,right:yfiles.algorithms.Node):number;
        /**
        * The minimum distance between two nodes.
        * Default is <code>30.0d</code>.
        */
        node2NodeDistance:number;
        /**
        * The minimum distance between a node and an (non-adjacent) edge.
        * Default is <code>15.0d</code>.
        */
        node2EdgeDistance:number;
        /**
        * The minimum distance between two edges.
        * Default is <code>20.0d</code>.
        */
        edge2EdgeDistance:number;
        /**
        * Specifies whether the optimized minimum distance calculation for swim lane layouts
        * is enabled.
        * If set to <code>true</code> this instance will report <code>0.0d</code>
        * as the minimum distance between two nodes if they belong to different swim
        * lanes. This avoids unwanted feedback between different swim lanes during
        * node placement.
        */
        optimizeSwimLaneDistances:boolean;
      }
      var DefaultDrawingDistanceCalculator:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of DefaultDrawingDistanceCalculator
        * with default settings.
        */
        new ():yfiles.hierarchic.incremental.DefaultDrawingDistanceCalculator;
      };
      /**
      * A default implementation of a {@link yfiles.hierarchic.incremental.ILayeredComponentsMerger} that provides
      * simple default behaviors.
      * Instances of this class are used internally
      * by {@link yfiles.hierarchic.incremental.HierarchicLayouter} and {@link yfiles.hierarchic.incremental.MultiComponentLayerer} e.g.
      */
      export interface DefaultLayeredComponentsMerger extends Object,yfiles.hierarchic.incremental.ILayeredComponentsMerger{
        /**
        * The current policy constant.
        */
        policy:yfiles.hierarchic.incremental.MergingPolicy;
        /**
        * All nodes in srcLayers and targetLayers are part of graph at the moment of
        * invocation.
        * The state of srcLayers is discarded after this call and need not
        * be updated to reflect the changes. targetLayers must be updated accordingly.
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains the nodes in <code>srcLayers</code> and
        * <code>targetLayers</code>.
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query the layer indices
        * @param {yfiles.hierarchic.incremental.ILayers} srcLayers 
        * the Layers implementation that contains the layers that
        * will be merged into <code>targetLayers</code>
        * @param {yfiles.hierarchic.incremental.ILayers} targetLayers 
        * the Layers that will be modified to contain the resulting
        * layering
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayeredComponentsMerger#merge}.
        */
        merge(graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,srcLayers:yfiles.hierarchic.incremental.ILayers,targetLayers:yfiles.hierarchic.incremental.ILayers):void;
      }
      var DefaultLayeredComponentsMerger:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of DefaultLayeredComponentsMerger
        * with default policy ({@link yfiles.hierarchic.incremental.MergingPolicy#ADD_RIGHT_TOP_ALIGNED}).
        */
        new ():yfiles.hierarchic.incremental.DefaultLayeredComponentsMerger;
        /**
        * Creates a new instance of DefaultLayeredComponentsMerger
        * using the given policy constant.
        */
        WithPolicy:{
          new (policy:yfiles.hierarchic.incremental.MergingPolicy):yfiles.hierarchic.incremental.DefaultLayeredComponentsMerger;
        };
      };
      /**
      * Layerer implementation that observes relative and absolute layering constraints defined by the layering constraint
      * factory {@link yfiles.hierarchic.incremental.ILayerConstraintFactory}.
      * For a given graph instance, this factory can be created with method
      * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#createLayerConstraintFactory}.
      * The Layerer can be used for both common layering and layering of incremental nodes.
      * Note: This layerer is always used automatically if the graph instance has constraints created with the layering
      * constraint factory.
      * @see {@link yfiles.hierarchic.incremental.ILayerConstraintFactory}
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter}
      */
      export interface ConstraintIncrementalLayerer extends Object,yfiles.hierarchic.incremental.ILayerer{
        /**
        * Specifies whether same layer edges can be created by this layerer instance.
        * <p>
        * This only concerns edges between nodes that have no hard constraints that
        * will force a same layer edge (i.e. a same layer constraint).
        * </p><p>
        * Default value is <code>false</code>.
        * </p>
        */
        allowSameLayerEdges:boolean;
        /**
        * Calculates a layering for the given graph.
        * @param {yfiles.layout.LayoutGraph} g the graph containing all nodes and edges.
        * @param {yfiles.hierarchic.incremental.ILayers} layers 
        * a structure that is filled by the layerer. If the layerer is used for layering incremental nodes,
        * the layers structure already have to contain all non-incremental nodes.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
        */
        assignLayers(g:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * Checks if the current set of strong constraints is consistent (i.e.
        * has no cycles)
        * @throws {yfiles.system.ArgumentException} if the constraint network is inconsistent
        */
        checkConstraints():void;
      }
      var ConstraintIncrementalLayerer:{
        $class:yfiles.lang.Class;
        /**
        * DataProvider key for additional edge weights of type <code>int</code>.
        * <p>
        * The Layerer tries to keep edges with higher weights short.
        * </p>
        */
        EDGE_WEIGHTS_DP_KEY:string;
        new (coreLayerer:yfiles.hierarchic.incremental.ILayerer):yfiles.hierarchic.incremental.ConstraintIncrementalLayerer;
      };
      /**
      * This class implements the second phase of the Sugiyama algorithm.
      * It minimizes the crossings in the diagram by using either the
      * barycentric or median heuristic.
      */
      export interface DefaultLayerSequencer extends Object,yfiles.hierarchic.incremental.ISequencer{
        /**
        * Specifies whether or not the transposition crossing minimization heuristic
        * should be used.
        * Activating this heuristic can reduce the overall
        * number of edge crossings. On the other hand its activation
        * increases running time.
        * By default the transposition rule is active.
        */
        transpositionEnabled:boolean;
        /**
        * Specifies whether or not the group transposition heuristic should
        * be used.
        * Activating this heuristic can reduce the overall
        * number of edge crossings in grouped graphs. On the other hand its activation
        * increases running time.
        * By default the transposition rule is not active.
        */
        groupTranspositionEnabled:boolean;
        /**
        * The currently set weight heuristic.
        * By default {@link yfiles.hierarchic.WeightHeuristic#BARYCENTER} is set.
        * @throws {yfiles.system.ArgumentException} if the constant is unknown
        */
        weightHeuristic:yfiles.hierarchic.WeightHeuristic;
        /**
        * The proposed maximal duration for the calculation of the sequence.
        * The default is <code>10000</code>
        */
        maximalDuration:number;
        /**
        * The number of randomized rounds this algorithm will try
        * if there was no optimal solution.
        */
        randomizationRounds:number;
        /**
        * Called by {@link yfiles.hierarchic.incremental.HierarchicLayouter} during the second phase.
        * Calculates a sequence of the nodes in <code>layers</code> and finally
        * writes back the calculated sequence using the {@link yfiles.hierarchic.incremental.ILayer#setNodeOrder}
        * method.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements from <code>layers</code>
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layer implementation that holds the Layers for sequencing
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider that provides the necessary {@link yfiles.hierarchic.incremental.INodeData}
        * and {@link yfiles.hierarchic.incremental.IEdgeData}
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory 
        * an ItemFactory implementation that can be used to modify the
        * graph consistently
        * @see Specified by {@link yfiles.hierarchic.incremental.ISequencer#sequenceNodeLayers}.
        */
        sequenceNodeLayers(graph:yfiles.layout.LayoutGraph,glayers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
      }
      var DefaultLayerSequencer:{
        $class:yfiles.lang.Class;
        /**
        * Initializes a new instance of the DefaultLayerSequencer class.
        */
        new ():yfiles.hierarchic.incremental.DefaultLayerSequencer;
      };
      /**
      * Default implementation of the PortAllocator interface.
      */
      export interface DefaultPortAllocator extends Object,yfiles.hierarchic.incremental.IPortAllocator{
        /**
        * Assigns the port positions for the drawer.
        * Assigns {@link yfiles.layout.PortSide#ANY} ports to appropriate sides.
        * Assigns {@link yfiles.layout.PortConstraint#strong  weak} ports to appropriate positions between strong ones
        * @param {yfiles.layout.LayoutGraph} graph the graph
        * @param {yfiles.hierarchic.incremental.ILayers} layers the layering
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query information
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the ItemFactory that can be used for temporarily altering the graph
        * @see Specified by {@link yfiles.hierarchic.incremental.IPortAllocator#assignPorts}.
        */
        assignPorts(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
        /**
        * Callback method used to determine the port border gap for each node and
        * side.
        * @param {yfiles.layout.LayoutGraph} graph the graph
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query information from
        * @param {yfiles.algorithms.Node} node the node
        * @param {number} sideIndex the zero based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)
        * @param {number} sideLength the width/height of the side
        * @param {number} edgeCount the number of edges/port that connect to this side
        * @return {number} the absolute gap to be used on both sides of the ports
        * @see {@link yfiles.hierarchic.incremental.DefaultPortAllocator#getPortDistanceDelta}
        */
        getPortBorderGap(graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,node:yfiles.algorithms.Node,sideIndex:number,sideLength:number,edgeCount:number):number;
        /**
        * Callback method used to determine the distance between two adjacent ports.
        * @param {yfiles.layout.LayoutGraph} graph the graph
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query information from
        * @param {yfiles.algorithms.Node} node the node
        * @param {number} sideIndex the zero based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)
        * @param {number} sideLength the width/height of the side
        * @param {number} edgeCount the number of edges/port that connect to this side
        * @param {number} portBorderGap the previously calculated port border gap
        * @return {number} the absolute distance to be used between two adjacent ports
        */
        getPortDistanceDelta(graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,node:yfiles.algorithms.Node,sideIndex:number,sideLength:number,edgeCount:number,portBorderGap:number):number;
        /**
        * Callback method used to determine the port border gap ratio.
        * See {@link yfiles.hierarchic.incremental.DefaultPortAllocator#defaultPortBorderGapRatio} for an explanation.
        * This implementation returns the same value as {@link yfiles.hierarchic.incremental.DefaultPortAllocator#defaultPortBorderGapRatio} does.
        * @param {yfiles.layout.LayoutGraph} graph the graph
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query information from
        * @param {yfiles.algorithms.Node} node the node
        * @param {number} sideIndex the zero based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)
        * @param {number} sideLength the width/height of the side
        * @param {number} edgeCount the number of edges/port that connect to this side
        * @return {number} the ratio
        */
        getPortBorderGapRatio(graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,node:yfiles.algorithms.Node,sideIndex:number,sideLength:number,edgeCount:number):number;
        /**
        * The default port to border gap ratio.
        * This ratio determines the gap between a corner of the node and the first
        * assigned port. A value of <code>0.0d</code> results in ports being
        * placed directly on the corner of the node (if there is more than one port).
        * The default value of <code>0.5d</code> results in ports being distributed
        * along the side of the node so that the distance between the corner of the node
        * and the first port is half as wide as the distance between two adjacent ports.
        * A value of <code>Double.POSITIVE_INFINITY</code> results in all ports being
        * centered at the side in one point.
        */
        defaultPortBorderGapRatio:number;
      }
      var DefaultPortAllocator:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of DefaultPortAllocator with default settings.
        * @see {@link yfiles.hierarchic.incremental.DefaultPortAllocator#defaultPortBorderGapRatio}
        */
        new ():yfiles.hierarchic.incremental.DefaultPortAllocator;
      };
      /**
      * Interface specification for classes that can create layering constraints.
      * If you manually register a DataProvider under {@link yfiles.layout.LayouterKeys#NODE_ID_DP_KEY} on the graph, you must use the
      * corresponding node ids stored in this DataProvider as arguments for all methods that create a constraint. Otherwise,
      * you can just use the node instances themselves.
      */
      export interface ILayerConstraintFactory extends Object{
        /**
        * A token that allows to bind a constraint factory to a graph instance after creation.
        * This method should only be used if the constraint factory is not bound to a graph instance initially. It allows to
        * bind the ConstraintFactory to a graph instance after creation. Please see the factory methods that create
        * instances of this interface for a description.
        * @see {@link yfiles.hierarchic.ConstraintLayerer.createConstraintFactory(yfiles.algorithms.Graph)}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#memento}.
        */
        memento:Object;
        /**
        * Disposes the ConstraintFactory.
        * <p> This method should be called when the factory is not needed anymore, i.e.
        * after the layout has been calculated. Calling this method also clears all constraints. </p>
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#dispose}.
        */
        dispose():void;
        /**
        * Add a constraint that forces the node with id with id <code>below</code> to lie below the node with id
        * <code>reference</code>.
        * @param {Object} referenceId the id of the reference node
        * @param {Object} belowId the id of the node that should lie below
        * @return {yfiles.hierarchic.incremental.ILayerConstraint} a LayerConstraint object that represents the constraint.
        * @see {@link yfiles.hierarchic.incremental.ILayerConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#addPlaceNodeBelowConstraint}.
        */
        addPlaceNodeBelowConstraint(referenceId:Object,belowId:Object):yfiles.hierarchic.incremental.ILayerConstraint;
        /**
        * Add a constraint that forces the node with id <code>below</code> to lie at least <code>minDistance</code> layers
        * below the node with id <code>reference</code>.
        * The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
        * layer difference may be smaller than <code>minDistance</code>
        * @param {Object} referenceId the id of the reference node
        * @param {Object} belowId the id of the node that should lie below
        * @param {number} minDistance the minimal layer distance between the node and its reference node
        * @return {yfiles.hierarchic.incremental.ILayerConstraint} a LayerConstraint object that represents the constraint.
        * @see {@link yfiles.hierarchic.incremental.ILayerConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#addPlaceNodeBelowConstraintWithMinDistance}.
        */
        addPlaceNodeBelowConstraintWithMinDistance(referenceId:Object,belowId:Object,minDistance:number):yfiles.hierarchic.incremental.ILayerConstraint;
        /**
        * Add a constraint that forces the node with id <code>below</code> to lie at least <code>minDistance</code> layers
        * below the node with id <code>reference</code> with a given weight penalty for larger layer differences.
        * The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
        * layer difference may be smaller than <code>minDistance</code>
        * @param {Object} referenceId the id of the reference node
        * @param {Object} belowId the id of the node that should lie below
        * @param {number} minDistance the minimal layer distance between the node and its reference node
        * @param {number} weight the weight penalty for larger layer differences
        * @return {yfiles.hierarchic.incremental.ILayerConstraint} a LayerConstraint object that represents the constraint.
        * @see {@link yfiles.hierarchic.incremental.ILayerConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#addPlaceNodeBelowConstraintWithMinDistanceAndWeight}.
        */
        addPlaceNodeBelowConstraintWithMinDistanceAndWeight(referenceId:Object,belowId:Object,minDistance:number,weight:number):yfiles.hierarchic.incremental.ILayerConstraint;
        /**
        * Add a constraint that forces the node <code>above</code> to lie above the node <code>reference</code>.
        * @param {Object} referenceId the id of the reference node
        * @param {Object} aboveId the id of the node that should lie above
        * @return {yfiles.hierarchic.incremental.ILayerConstraint} a LayerConstraint object that represents the constraint.
        * @see {@link yfiles.hierarchic.incremental.ILayerConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#addPlaceNodeAboveConstraint}.
        */
        addPlaceNodeAboveConstraint(referenceId:Object,aboveId:Object):yfiles.hierarchic.incremental.ILayerConstraint;
        /**
        * Add a constraint that forces the node with id <code>above</code> to lie at least <code>minDistance</code> layers
        * above the node with id <code>reference</code>.
        * The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
        * layer difference may be smaller than <code>minDistance</code>
        * @param {Object} referenceId the id of the reference node
        * @param {Object} aboveId the id of the node that should lie above
        * @param {number} minDistance the minimal layer distance between the node and its reference node
        * @return {yfiles.hierarchic.incremental.ILayerConstraint} a LayerConstraint object that represents the constraint.
        * @see {@link yfiles.hierarchic.incremental.ILayerConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#addPlaceNodeAboveConstraintWithMinDistance}.
        */
        addPlaceNodeAboveConstraintWithMinDistance(referenceId:Object,aboveId:Object,minDistance:number):yfiles.hierarchic.incremental.ILayerConstraint;
        /**
        * Add a constraint that forces the node  with id <code>above</code> to lie at least <code>minDistance</code> layers
        * above the node  with id <code>reference</code> with a given weight penalty for larger  layer differences.
        * The minimum distance includes potentially empty layers that are removed by the layerer. In that case, the actual
        * layer difference may be smaller than <code>minDistance</code>
        * @param {Object} referenceId the id of the reference node
        * @param {Object} aboveId the id of the node that should lie above
        * @param {number} minDistance the minimal layer distance between the node and its reference node
        * @param {number} weight the weight penalty for larger layer differences
        * @return {yfiles.hierarchic.incremental.ILayerConstraint} a LayerConstraint object that represents the constraint.
        * @see {@link yfiles.hierarchic.incremental.ILayerConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#addPlaceNodeAboveConstraintWithMinDistanceAndWeight}.
        */
        addPlaceNodeAboveConstraintWithMinDistanceAndWeight(referenceId:Object,aboveId:Object,minDistance:number,weight:number):yfiles.hierarchic.incremental.ILayerConstraint;
        /**
        * Add a constraint that forces the node with id <code>sameLayer</code> to lie in the same layer as the node with id
        * <code>reference</code>.
        * @param {Object} referenceId the id of the reference node
        * @param {Object} sameLayerId the id of the node that should lie in the same layer
        * @return {yfiles.hierarchic.incremental.ILayerConstraint} a LayerConstraint object that represents the constraint.
        * @see {@link yfiles.hierarchic.incremental.ILayerConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#addPlaceNodeInSameLayerConstraint}.
        */
        addPlaceNodeInSameLayerConstraint(referenceId:Object,sameLayerId:Object):yfiles.hierarchic.incremental.ILayerConstraint;
        /**
        * Add a constraint that places a node in the topmost layer.
        * @param {Object} nodeId the id of the node that should lie at the top
        * @return {yfiles.hierarchic.incremental.ILayerConstraint} a LayerConstraint object that represents the constraint.
        * @see {@link yfiles.hierarchic.incremental.ILayerConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#addPlaceNodeAtTopConstraint}.
        */
        addPlaceNodeAtTopConstraint(nodeId:Object):yfiles.hierarchic.incremental.ILayerConstraint;
        /**
        * Add a constraint that places a node in the bottom layer.
        * @param {Object} nodeId the id of the node that should lie at the bottom
        * @return {yfiles.hierarchic.incremental.ILayerConstraint} a LayerConstraint object that represents the constraint.
        * @see {@link yfiles.hierarchic.incremental.ILayerConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#addPlaceNodeAtBottomConstraint}.
        */
        addPlaceNodeAtBottomConstraint(nodeId:Object):yfiles.hierarchic.incremental.ILayerConstraint;
        /**
        * Clears all constraints for a given node.
        * @param {Object} nodeId the id of the node for which all constraints should be cleared
        * @see {@link yfiles.hierarchic.incremental.ILayerConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraintFactory#removeConstraints}.
        */
        removeConstraints(nodeId:Object):void;
      }
      var ILayerConstraintFactory:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * This class represents a layering constraint.
      * Such constraints can be given as additional input to the .
      * @see {@link yfiles.hierarchic.incremental.ILayerConstraintFactory}
      */
      export interface ILayerConstraint extends Object{
        /**
        * The priority of a constraint.
        * This value is used for resolving conflicting constraints.
        * A constraint with a higher priority (int value) is more likely to be considered.
        * The lowest (and default) priority is 1.
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerConstraint#priority}.
        */
        priority:number;
      }
      var ILayerConstraint:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Used by  to write back layering information.
      */
      export interface IIntValueHolder extends Object{
        /**
        * The value of the current context.
        * @see Specified by {@link yfiles.hierarchic.incremental.IIntValueHolder#value}.
        */
        value:number;
        /**
        * Returns whether the current context provides a value.
        * @return {boolean} whether meaningful value can be queried from the current context.
        * @see Specified by {@link yfiles.hierarchic.incremental.IIntValueHolder#providesValue}.
        */
        providesValue():boolean;
      }
      var IIntValueHolder:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Specifies the general contract for factory classes that can be used
      * to associate sequence constraints to a graph.
      * Sequence constraints
      * affect the per layer sequence calculated in hierarchical layouts.
      * <p>
      * A <code>SequenceConstraintFactory</code> has to be
      * {@link yfiles.hierarchic.incremental.ISequenceConstraintFactory#dispose  disposed} after use. Disposing the factory will also remove
      * all constraints previously specified for the factory's associated graph.
      * </p>
      * Notes:
      * <ul>
      * <li>Sequence constraints can't be used together with swimlanes currently.</li>
      * <li>Sequence constraints that are specified for a group child node will be applied to the parent node instead</li>
      * <li>If you manually register a DataProvider under {@link yfiles.layout.LayouterKeys#NODE_ID_DP_KEY}
      * on the graph, you must use the corresponding node ids stored in this DataProvider as arguments for
      * all methods that create a constraint. Otherwise, you can just use the node instances themselves.</li>
      * </ul>
      */
      export interface ISequenceConstraintFactory extends Object{
        /**
        * A token that allows to bind a constraint factory to a graph instance after creation.
        * This method should only be used if the constraint factory is not bound to a graph instance initially. It allows
        * to bind the ConstraintFactory to a graph instance after creation. Please see the factory methods that create
        * instances of this interface for a description.
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter.createSequenceConstraintFactory(yfiles.algorithms.Graph)}
        * @see Specified by {@link yfiles.hierarchic.incremental.ISequenceConstraintFactory#memento}.
        */
        memento:Object;
        /**
        * Disposes the SequenceConstraintFactory.
        * <p>
        * This method should be called when the factory is not needed anymore, i.e.
        * after the layout has been calculated.
        * Calling this method also clears all constraints.
        * </p>
        * @see Specified by {@link yfiles.hierarchic.incremental.ISequenceConstraintFactory#dispose}.
        */
        dispose():void;
        /**
        * Add a constraint that forces the node with id <code>before</code> to lie before
        * the node with id <code>reference</code>.
        * @param {Object} referenceId the id of the reference node
        * @param {Object} beforeId the id of the node that should be placed before the reference
        * @see Specified by {@link yfiles.hierarchic.incremental.ISequenceConstraintFactory#addPlaceNodeBeforeConstraint}.
        */
        addPlaceNodeBeforeConstraint(referenceId:Object,beforeId:Object):void;
        /**
        * Add a constraint that forces the node with id <code>after</code> to lie after
        * the node with id <code>reference</code>.
        * @param {Object} referenceId the id of the reference node
        * @param {Object} afterId the id of the node that should be placed after the reference
        * @see Specified by {@link yfiles.hierarchic.incremental.ISequenceConstraintFactory#addPlaceNodeAfterConstraint}.
        */
        addPlaceNodeAfterConstraint(referenceId:Object,afterId:Object):void;
        /**
        * Add a constraint that places a node at the start of the sequence.
        * @param {Object} nodeId the id of the node that should be placed at the start
        * @see Specified by {@link yfiles.hierarchic.incremental.ISequenceConstraintFactory#addPlaceNodeAtHeadConstraint}.
        */
        addPlaceNodeAtHeadConstraint(nodeId:Object):void;
        /**
        * Add a constraint that places a node at the end of the sequence.
        * @param {Object} nodeId the id of the node that should be placed at the end
        * @see Specified by {@link yfiles.hierarchic.incremental.ISequenceConstraintFactory#addPlaceNodeAtTailConstraint}.
        */
        addPlaceNodeAtTailConstraint(nodeId:Object):void;
      }
      var ISequenceConstraintFactory:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      export interface LayerConstraintFactoryCompanion extends Object{
      }
      var LayerConstraintFactoryCompanion:{
        $class:yfiles.lang.Class;
        /**
        * <code>DataProvider</code> key to store the constraints.
        */
        LAYER_CONSTRAINTS_MEMENTO_DP_KEY:Object;
      };
      /**
      * Sequencer implementation that returns a sequencing that
      * corresponds to the current drawing.
      */
      export interface AsIsSequencer extends Object,yfiles.hierarchic.incremental.ISequencer{
        /**
        * Called by {@link yfiles.hierarchic.incremental.HierarchicLayouter} during the second phase.
        * Calculates a sequence of the nodes in <code>layers</code> and finally
        * writes back the calculated sequence using the {@link yfiles.hierarchic.incremental.ILayer#setNodeOrder}
        * method.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements from <code>layers</code>
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layer implementation that holds the Layers for sequencing
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider that provides the necessary {@link yfiles.hierarchic.incremental.INodeData}
        * and {@link yfiles.hierarchic.incremental.IEdgeData}
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory 
        * an ItemFactory implementation that can be used to modify the
        * graph consistently
        * @see Specified by {@link yfiles.hierarchic.incremental.ISequencer#sequenceNodeLayers}.
        */
        sequenceNodeLayers(g:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
      }
      var AsIsSequencer:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new AsIsSequencer.
        */
        new ():yfiles.hierarchic.incremental.AsIsSequencer;
      };
      /**
      * Wrapper Layerer implementation that delegates the actual layering to a
      * delegate Layerer.
      * If the graph consists of multiple components, they will
      * be identified and each of the components will be layered separately
      * using the delegate Layerer instance. After that they will all be merged
      * such that the desired aspect ratio is fulfilled best.
      * Note that for grouped graphs the desired aspect ratio is also considered for each group node separately.
      * @see {@link yfiles.hierarchic.incremental.AspectRatioComponentLayerer#desiredAspectRatio}
      * @see {@link yfiles.hierarchic.incremental.MultiComponentLayerer}
      */
      export interface AspectRatioComponentLayerer extends Object,yfiles.hierarchic.incremental.ILayerer{
        /**
        * The Layerer instance that is used for delegation.
        * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
        */
        singleComponentLayerer:yfiles.hierarchic.incremental.ILayerer;
        /**
        * Specifies whether the node size should be considered.
        * If this option is disabled, all nodes are considered to be of equal size.
        * Hence, the given aspect ratio specifies the ratio between the number of nodes within a layer and the overall number of layers.
        * The default value is true.
        */
        considerNodeSize:boolean;
        /**
        * The desired aspect ratio.
        * If the graph consists of multiple components, they will
        * be identified and each of the components will be layered separately
        * using the delegate Layerer instance. After that they will all be merged
        * such that the desired aspect ratio is fulfilled best.
        * Note that for grouped graphs the desired aspect ratio is also considered for each group node separately.
        */
        desiredAspectRatio:number;
        /**
        * This method assigns all nodes in the graph to layers and registers them
        * in the {@link yfiles.hierarchic.incremental.ILayers} instance.
        * In order to create new layers, the factory
        * method {@link yfiles.hierarchic.incremental.ILayers#insert} must be used.
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains the nodes that should be distributed
        * into the layers
        * @param {yfiles.hierarchic.incremental.ILayers} layers 
        * the object that will be filled with the results of the
        * calculation
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * LayoutDataProvider that can be used to query information about
        * the nodes - note that positional information
        * (see {@link yfiles.hierarchic.incremental.INodeData#position} and {@link yfiles.hierarchic.incremental.INodeData#layer}) cannot
        * be available at any time.
        * @see {@link yfiles.hierarchic.incremental.ILayers#insert}
        * @see {@link yfiles.hierarchic.incremental.ILayer#add}
        * @see Specified by {@link yfiles.hierarchic.incremental.ILayerer#assignLayers}.
        */
        assignLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
      }
      var AspectRatioComponentLayerer:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of AspectRatioComponentLayerer using the given
        * delegate.
        */
        new (singleComponentLayerer:yfiles.hierarchic.incremental.ILayerer):yfiles.hierarchic.incremental.AspectRatioComponentLayerer;
      };
      /**
      * A partial implementation of the {@link yfiles.hierarchic.incremental.IPortConstraintOptimizer} interface to minimize the effort required to modify
      * the port assignment after the sequencing phase.
      * In this class, the
      * {@link yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer#optimizeAfterSequencing callback method invoked after sequencing} temporarily restores all
      * same layer edges which, otherwise, wouldn't be present in the layout graph at this time of the algorithm, then
      * invokes the hook in which the custom port assignment should be done, and finally takes care to restore the original
      * state of the layout graph by removing the temporary edges.
      */
      export interface AbstractPortConstraintOptimizer extends Object,yfiles.hierarchic.incremental.IPortConstraintOptimizer{
        /**
        * The mirror mask that defines which orientations should be mirrored.
        * Setting a layout orientation can be
        * seen as rotating the graph 90, 180 or 270 degrees. Afterwards the graph can be mirrored at the x-Axis (for
        * horizontal layout orientations) or y-Axis (for vertical layout orientations). Which directions are mirrored can be
        * defined by the given mask.
        * By default a mirror mask is set, where {@link yfiles.layout.LayoutOrientation#BOTTOM_TO_TOP} will be mirrored at the
        * y-Axis.
        * @see {@link yfiles.layout.MirrorMask#BOTTOM_TO_TOP}
        * @see {@link yfiles.layout.MirrorMask#LEFT_TO_RIGHT}
        * @see {@link yfiles.layout.MirrorMask#RIGHT_TO_LEFT}
        * @see {@link yfiles.layout.MirrorMask#TOP_TO_BOTTOM}
        * @see {@link yfiles.layout.MirrorMask#BOTTOM_TO_TOP}
        * @see {@link yfiles.layout.MirrorMask#LEFT_TO_RIGHT}
        * @see {@link yfiles.layout.MirrorMask#RIGHT_TO_LEFT}
        * @see {@link yfiles.layout.MirrorMask#TOP_TO_BOTTOM}
        */
        mirrorMask:yfiles.layout.MirrorMask;
        /**
        * The currently set layout orientation for this class.
        * This setting is necessary to correctly interpret the values
        * provided in the {@link yfiles.layout.PortCandidate}s since the {@link yfiles.layout.OrientationLayouter} cannot automatically
        * adjust these values.
        * @see {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation}
        */
        layoutOrientation:yfiles.layout.LayoutOrientation;
        /**
        * Called after the layering information has been determined.
        * This method can be used to assign new temporary port
        * constraints for the next phases of the algorithm. In this phase, it is possible to create back-loops by assigning
        * in-edges to the south side or out-edges to the north side, respectively.
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on
        * @param {yfiles.hierarchic.incremental.ILayers} layers the layering information
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the implementation which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData} instances
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory to set the temporary port constraints with
        * @see {@link yfiles.hierarchic.incremental.IItemFactory#setTemporaryPortConstraint}
        * @see Specified by {@link yfiles.hierarchic.incremental.IPortConstraintOptimizer#optimizeAfterLayering}.
        */
        optimizeAfterLayering(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
        /**
        * Called after the sequence of the nodes has been determined to assign new temporary port constraints.
        * This method
        * {@link yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer#insertSameLayerStructures  inserts the same layer strucutres}, invokes
        * {@link yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer#optimizeAfterSequencingForSingleNode  the hook}
        * in which the custom port assignment should be done, and finally takes care to {@link yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer#removeSameLayerStructures restore the original state} of the layout graph by removing the temporary edges.
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on.
        * @param {yfiles.hierarchic.incremental.ILayers} layers the layering information.
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData}.
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory which can set the temporary port constraints.
        * @see Specified by {@link yfiles.hierarchic.incremental.IPortConstraintOptimizer#optimizeAfterSequencing}.
        */
        optimizeAfterSequencing(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
        /**
        * Called after the sequence of the nodes has been determined to assign new temporary port constraints to all nodes.
        * This method invokes
        * {@link yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer#optimizeAfterSequencingForSingleNode}
        * for every node of the original layout graph, and omits the nodes of the same layer structures.
        * Note that, in this phase, it's not allowed to create back-loops, that is, in-edges must not connect to the south
        * side and out-edges must not connect to the north side.
        * @param {yfiles.objectcollections.IComparer} inEdgeOrder 
        * a {@link yfiles.algorithms.Comparators.IPartialOrder} which defines the preferred ordering of the in-edges from left to right.
        * Note: to sort collections according to a PartialOrder, an appropriate method like {@link yfiles.algorithms.Comparators#sortListWithComparer} or {@link yfiles.algorithms.YList#sort} must be used.
        * @param {yfiles.objectcollections.IComparer} outEdgeOrder 
        * a {@link yfiles.algorithms.Comparators.IPartialOrder} which defines the preferred ordering of the out-edges from left to
        * right. Note: to sort collections according to a PartialOrder, an appropriate method like {@link yfiles.algorithms.Comparators#sortListWithComparer} or {@link yfiles.algorithms.YList#sort} must be used.
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on.
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData}.
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory which can set the temporary port constraints.
        * @see {@link yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer#optimizeAfterSequencing}
        */
        optimizeAfterSequencingForAllNodes(inEdgeOrder:yfiles.objectcollections.IComparer,outEdgeOrder:yfiles.objectcollections.IComparer,graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
        /**
        * Called after the sequence of the nodes has been determined to assign new temporary port constraints to each
        * original node.
        * Note that, in this phase, it's not allowed to create back-loops, that is, in-edges must not connect to the south
        * side and out-edges must not connect to the north side.
        * @param {yfiles.algorithms.Node} node the original node to set temporary port constraints at.
        * @param {yfiles.objectcollections.IComparer} inEdgeOrder 
        * a {@link yfiles.algorithms.Comparators.IPartialOrder} which defines the preferred ordering of the in-edges from left to right.
        * Note: to sort collections according to a PartialOrder, an appropriate method like {@link yfiles.algorithms.Comparators#sortListWithComparer} or {@link yfiles.algorithms.YList#sort} must be used.
        * @param {yfiles.objectcollections.IComparer} outEdgeOrder 
        * a {@link yfiles.algorithms.Comparators.IPartialOrder} which defines the preferred ordering of the out-edges from left to
        * right. Note: to sort collections according to a PartialOrder, an appropriate method like {@link yfiles.algorithms.Comparators#sortListWithComparer} or {@link yfiles.algorithms.YList#sort} must be used.
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on.
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData}.
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory which can set the temporary port constraints.
        * @see {@link yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer#optimizeAfterSequencing}
        */
        optimizeAfterSequencingForSingleNode(node:yfiles.algorithms.Node,inEdgeOrder:yfiles.objectcollections.IComparer,outEdgeOrder:yfiles.objectcollections.IComparer,graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
        /**
        * Inserts a same layer edge structure for each same layer edge of the original graph.
        * Note that, in this phase of the layout,
        * the graph does not contain any same layer edges. The structure for a same layer edge <code>(s,t)</code> consists of
        * a temporary node <code>w</code> and the edges <code>(s,w)</code> and <code>(t,w)</code>.
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on.
        * @param {yfiles.hierarchic.incremental.ILayers} layers the layering information.
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData}.
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory which can set the temporary port constraints.
        * @see {@link yfiles.hierarchic.incremental.IItemFactory#setTemporaryPortConstraint}
        */
        insertSameLayerStructures(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer.SameLayerData;
        /**
        * Removes the same layer edge structure created in {@link yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer#insertSameLayerStructures}.
        * @param {yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer.SameLayerData} sameLayerData the information about the same layer structures.
        * @param {yfiles.layout.LayoutGraph} graph the graph to work on.
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider which provides access to the {@link yfiles.hierarchic.incremental.INodeData} and {@link yfiles.hierarchic.incremental.IEdgeData}.
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the factory which can set the temporary port constraints.
        * @see {@link yfiles.hierarchic.incremental.IItemFactory#setTemporaryPortConstraint}
        */
        removeSameLayerStructures(sameLayerData:yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer.SameLayerData,graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
      }
      export module AbstractPortConstraintOptimizer{
        /**
        * Provides information about the same layer structures created by class {@link yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer}.
        */
        export interface SameLayerData extends Object{
          /**
          * Adds a new dummy node and associates it with the given original (same layer) edge.
          * @param {yfiles.algorithms.Node} sameLayerDummy a dummy node.
          * @param {yfiles.algorithms.Edge} originalEdge the original (same layer) edge associated to the sameLayerDummy.
          */
          addDummyNode(sameLayerDummy:yfiles.algorithms.Node,originalEdge:yfiles.algorithms.Edge):void;
          /**
          * All dummy nodes.
          */
          dummyNodes:yfiles.algorithms.NodeList;
          /**
          * Returns the original (same layer) edge associated with the given dummy node.
          * @param {yfiles.algorithms.Node} sameLayerDummy a dummy node.
          * @return {yfiles.algorithms.Edge} the original (same layer) edge associated with the given dummy node.
          */
          getOriginalEdge(sameLayerDummy:yfiles.algorithms.Node):yfiles.algorithms.Edge;
        }
      }
      var AbstractPortConstraintOptimizer:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new AbstractPortConstraintOptimizer.
        */
        new ():yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer;
        SameLayerData:{
          $class:yfiles.lang.Class;
          /**
          * Creates a new SameLayerData.
          */
          new ():yfiles.hierarchic.incremental.AbstractPortConstraintOptimizer;
        };
      };
      /**
      * This class can be used to create hierarchical layouts of graphs.
      * It has built-in support for incrementally adding elements to a previously
      * calculated layout or optimizing existing elements
      * of a previously calculated layout.
      * In order to customize this layout algorithm, modify the
      * {@link yfiles.hierarchic.incremental.HierarchicLayouter#layerer  Layerer}, {@link yfiles.hierarchic.incremental.HierarchicLayouter#sequencer  Sequencer},
      * {@link yfiles.hierarchic.incremental.HierarchicLayouter#portAllocator  PortAllocator},
      * {@link yfiles.hierarchic.incremental.HierarchicLayouter#drawingDistanceCalculator  DrawingDistanceCalculator}, and
      * {@link yfiles.hierarchic.incremental.HierarchicLayouter#nodePlacer  NodePlacer} instances.
      * Use the {@link yfiles.hierarchic.incremental.HierarchicLayouter#INCREMENTAL_HINTS_DP_KEY} {@link yfiles.algorithms.IDataProvider} key to
      * associate incremental hints with the elements in the graph.
      * Incremental Hints can be obtained from the
      * {@link yfiles.hierarchic.incremental.HierarchicLayouter#createIncrementalHintsFactory  IncrementalHintsFactory}.
      * They are used by the algorithm to determine which elements in the graph
      * have to be inserted/updated incrementally.
      * This layout algorithm respects {@link yfiles.layout.PortConstraint}s, that are bound to
      * the graph using the {@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY} and
      * {@link yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY} as well as
      * {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY} and
      * {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY} DataProviders that can be used
      * to create bus-like edge routings.
      * Fine-grained configuration of the layout style
      * is supported via DataProviders that are bound to the graph using the
      * {@link yfiles.hierarchic.incremental.HierarchicLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY} and {@link yfiles.hierarchic.incremental.HierarchicLayouter#NODE_LAYOUT_DESCRIPTOR_DP_KEY}
      * DataProvider keys.
      * They can be used to associate {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor} and
      * {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor} instances with each element in the graph. These
      * may be shared.
      * This algorithm sets a {@link yfiles.layout.LabelLayoutTranslator} instance as the current
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter} and configures it so that
      * the node labels are passed to by setting {@link yfiles.layout.LabelLayoutTranslator#translateNodeLabels}
      * to <code>true</code>.
      * In order to enable integrated edge labeling of this algorithm, make sure
      * {@link yfiles.layout.LabelLayoutTranslator} is registered and edge labels are being translated
      * and written back after the layout.
      * This algorithm also support swimlane style drawings. This can be enabled by
      * associating {@link yfiles.hierarchic.incremental.SwimLaneDescriptor} instances with the nodes in the graph
      * using the {@link yfiles.hierarchic.incremental.HierarchicLayouter#SWIMLANE_DESCRIPTOR_DP_KEY} DataProvider key.
      * Moreover, this algorithm supports sequence constraints. These constraints
      * can be specified using a {@link yfiles.hierarchic.incremental.ISequenceConstraintFactory}.
      * @see {@link yfiles.hierarchic.IncrementalHierarchicLayouter}
      * @see {@link yfiles.hierarchic.incremental.ILayerer}
      * @see {@link yfiles.hierarchic.incremental.ISequencer}
      * @see {@link yfiles.hierarchic.incremental.IPortAllocator}
      * @see {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator}
      * @see {@link yfiles.hierarchic.incremental.INodePlacer}
      */
      export interface HierarchicLayouter extends yfiles.layout.CanonicMultiStageLayouter{
        /**
        * Factory method for the
        * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter}
        * used by this layouter.
        * In order to use the the integrated node label awareness feature one has to
        * use an {@link yfiles.layout.LabelLayoutTranslator} instance with
        * {@link yfiles.layout.LabelLayoutTranslator#translateNodeLabels}
        * set to <code>true</code>. 
        * Likewise in order to make use of the integrated edge labeling
        * {@link yfiles.layout.LabelLayoutTranslator#translateEdgeLabels} must
        * be set to <code>true</code> and
        * {@link yfiles.layout.LabelLayoutTranslator#writeBackEdgeLabels} must
        * be set to <code>true</code> also (which is the default).
        * @return {yfiles.layout.ILayoutStage} 
        * a new <code>LabelLayoutTranslator</code> with node translation enabled
        * and "node label write back" disabled.
        */
        createLabelLayouter():yfiles.layout.ILayoutStage;
        /**
        * Factory method that is called lazily upon first usage.
        * @return {yfiles.hierarchic.incremental.ILayerer} a default implementation (<code>new MultiComponentLayerer(new OldLayererWrapper(new WeightedLayerer()))</code>)
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#layerer}
        * @see {@link yfiles.hierarchic.incremental.MultiComponentLayerer}
        * @see {@link yfiles.hierarchic.incremental.OldLayererWrapper}
        * @see {@link yfiles.hierarchic.WeightedLayerer}
        */
        createLayerer():yfiles.hierarchic.incremental.ILayerer;
        /**
        * Specifies whether or not ComponentLayouter is enabled.
        * By default it is disabled.
        * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#componentLayouterEnabled}
        */
        componentLayouterEnabled:boolean;
        /**
        * The time limit (in milliseconds) set for the layout algorithm.
        * Note that restricting the maximal duration may result in a worse layout quality.
        * Furthermore, the real runtime may exceed the maximal duration since the layout algorithm
        * still have to find a valid solution.
        */
        maximalDuration:number;
        /**
        * Factory method that is called lazily upon first usage.
        * @return {yfiles.hierarchic.incremental.ISequencer} a default implementation (<code>new DefaultLayerSequencer()</code>)
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#sequencer}
        * @see {@link yfiles.hierarchic.incremental.DefaultLayerSequencer}
        */
        createSequencer():yfiles.hierarchic.incremental.ISequencer;
        /**
        * Factory method that is called lazily upon first usage.
        * @return {yfiles.hierarchic.incremental.IDrawingDistanceCalculator} a default implementation (<code>new DefaultDrawingDistanceCalculator()</code>)
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#drawingDistanceCalculator}
        */
        createDrawingDistanceCalculator():yfiles.hierarchic.incremental.IDrawingDistanceCalculator;
        /**
        * Factory method that is called lazily upon first usage.
        * @return {yfiles.hierarchic.incremental.IPortAllocator} a default implementation (<code>new DefaultPortAllocator()</code>)
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#portAllocator}
        */
        createPortAllocator():yfiles.hierarchic.incremental.IPortAllocator;
        /**
        * Factory method that is called lazily upon first usage.
        * @return {yfiles.hierarchic.incremental.IPortConstraintOptimizer} <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#portConstraintOptimizer}
        */
        createPortConstraintOptimizer():yfiles.hierarchic.incremental.IPortConstraintOptimizer;
        /**
        * Factory method that is called lazily upon first usage.
        * @return {yfiles.hierarchic.incremental.INodePlacer} a default implementation (<code>new SimplexNodePlacer</code>)
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#nodePlacer}
        * @see {@link yfiles.hierarchic.incremental.SimplexNodePlacer}
        */
        createNodePlacer():yfiles.hierarchic.incremental.INodePlacer;
        /**
        * The current Layerer instance.
        * For the default see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createLayerer}.
        * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createLayerer}
        */
        layerer:yfiles.hierarchic.incremental.ILayerer;
        /**
        * The current Sequencer instance.
        * For the default see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createSequencer}.
        * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createSequencer}
        */
        sequencer:yfiles.hierarchic.incremental.ISequencer;
        /**
        * The current NodePlacer instance.
        * For the default see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createNodePlacer}.
        * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createNodePlacer}
        */
        nodePlacer:yfiles.hierarchic.incremental.INodePlacer;
        /**
        * The current PortAllocator instance.
        * For the default see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createPortAllocator}.
        * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createPortAllocator}
        */
        portAllocator:yfiles.hierarchic.incremental.IPortAllocator;
        /**
        * The current PortConstraintOptimizer instance.
        * For the default see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createPortConstraintOptimizer}.
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createPortConstraintOptimizer}
        */
        portConstraintOptimizer:yfiles.hierarchic.incremental.IPortConstraintOptimizer;
        /**
        * The current DrawingDistanceCalculator instance.
        * For the default see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createDrawingDistanceCalculator}.
        * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createDrawingDistanceCalculator}
        */
        drawingDistanceCalculator:yfiles.hierarchic.incremental.IDrawingDistanceCalculator;
        /**
        * The equidistant spacing between the horizontal and vertical grid lines.
        * <p>
        * By default no grid is specified (spacing is &lt;= 0).
        * </p>
        */
        gridSpacing:number;
        /**
        * Always returns true.
        * @param {yfiles.layout.LayoutGraph} graph the graph to check
        * @return {boolean} <code>true</code>
        * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
        */
        canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
        /**
        * Provides access to implementation specific
        * properties of the algorithms used.
        * Used for internal purposes.
        * @param {Object} key the key to a property
        * @return {Object} the associated value or <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#setAlgorithmProperty}
        */
        getAlgorithmProperty(key:Object):Object;
        /**
        * Provides access to implementation specific
        * properties of the algorithms used internally.
        * Used for internal purposes.
        * @param {Object} key the key to a property
        * @param {Object} value the value to associate with the key
        */
        setAlgorithmProperty(key:Object,value:Object):void;
        /**
        * Layouts the given graph.
        * @param {yfiles.layout.LayoutGraph} graph the graph to layout
        * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
        */
        doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
        /**
        * Factory method that is called during {@link yfiles.hierarchic.incremental.HierarchicLayouter#doLayoutCore}.
        * @param {yfiles.layout.LayoutGraph} graph the graph to obtain the grouping information from.
        * @return {yfiles.layout.GraphGrouping} a Grouping or <code>null</code> if there is no grouping information associated with the graph.
        */
        createGrouping(graph:yfiles.layout.LayoutGraph):yfiles.layout.GraphGrouping;
        /**
        * Callback method that is called during {@link yfiles.hierarchic.incremental.HierarchicLayouter#doLayoutCore}.
        * This method returns a DataProvider that holds the incremental hint information.
        * @param {yfiles.layout.LayoutGraph} graph the graph to obtain the information from.
        * @return {yfiles.algorithms.IDataProvider} a DataProvider instance or <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#INCREMENTAL_HINTS_DP_KEY}
        */
        getIncrementalHints(graph:yfiles.layout.LayoutGraph):yfiles.algorithms.IDataProvider;
        /**
        * Callback method that is called during {@link yfiles.hierarchic.incremental.HierarchicLayouter#doLayoutCore}.
        * This method returns a DataProvider that holds the EdgeLayoutDescriptor information.
        * @param {yfiles.layout.LayoutGraph} graph the graph to obtain the information from.
        * @return {yfiles.algorithms.IDataProvider} a DataProvider instance or <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor}
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
        */
        getEdgeLayoutDescriptors(graph:yfiles.layout.LayoutGraph):yfiles.algorithms.IDataProvider;
        /**
        * Callback method that is called during {@link yfiles.hierarchic.incremental.HierarchicLayouter#doLayoutCore}.
        * This method returns a DataProvider that holds the NodeLayoutDescriptor information.
        * @param {yfiles.layout.LayoutGraph} graph the graph to obtain the information from.
        * @return {yfiles.algorithms.IDataProvider} a DataProvider instance or <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor}
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#NODE_LAYOUT_DESCRIPTOR_DP_KEY}
        */
        getNodeLayoutDescriptors(graph:yfiles.layout.LayoutGraph):yfiles.algorithms.IDataProvider;
        /**
        * Callback method that is called during {@link yfiles.hierarchic.incremental.HierarchicLayouter#doLayoutCore}.
        * This method returns a DataProvider that holds the SwimLaneDescriptor information.
        * @param {yfiles.layout.LayoutGraph} graph the graph to obtain the information from.
        * @return {yfiles.algorithms.IDataProvider} a DataProvider instance or <code>null</code>
        * @see {@link yfiles.hierarchic.incremental.SwimLaneDescriptor}
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#SWIMLANE_DESCRIPTOR_DP_KEY}
        */
        getSwimLaneDescriptors(graph:yfiles.layout.LayoutGraph):yfiles.algorithms.IDataProvider;
        /**
        * Callback method that is called during {@link yfiles.hierarchic.incremental.HierarchicLayouter#doLayoutCore}.
        * This method creates the {@link yfiles.hierarchic.incremental.INodeData}
        * and {@link yfiles.hierarchic.incremental.IEdgeData} instances and binds them to the elements using the itemFactory.
        * @param {yfiles.layout.LayoutGraph} g the graph to obtain the grouping information from.
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory the ItemFactory to use
        */
        createItemData(g:yfiles.layout.LayoutGraph,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
        /**
        * Factory method that is called during {@link yfiles.hierarchic.incremental.HierarchicLayouter#doLayoutCore}.
        * @return {yfiles.hierarchic.incremental.ISequencer} a Sequencer implementation that can sequence subgraphs incrementally.
        */
        createSubgraphLayerSequencer():yfiles.hierarchic.incremental.ISequencer;
        /**
        * Factory method that is called during {@link yfiles.hierarchic.incremental.HierarchicLayouter#doLayoutCore}.
        * Creates an appropriate Layers implementation using the LayoutDataProvider
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp provides the layout data
        * @return {yfiles.hierarchic.incremental.ILayers} a Layers implementation
        */
        createLayers(ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):yfiles.hierarchic.incremental.ILayers;
        /**
        * Factory method that is called during {@link yfiles.hierarchic.incremental.HierarchicLayouter#doLayoutCore}.
        * Creates an appropriate IncrementalLayerer implementation
        * @return {yfiles.hierarchic.incremental.ILayerer} an implementation
        */
        createIncrementalLayerer():yfiles.hierarchic.incremental.ILayerer;
        /**
        * Factory method that is called during {@link yfiles.hierarchic.incremental.HierarchicLayouter#doLayoutCore}.
        * Creates an appropriate EdgeReverser implementation
        * @return {yfiles.hierarchic.incremental.IEdgeReverser} an implementation
        */
        createEdgeReverser():yfiles.hierarchic.incremental.IEdgeReverser;
        /**
        * Callback method that publishes the layering information.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers implementation to get the layering information from
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#LAYER_VALUE_HOLDER_DP_KEY}
        */
        publishLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers):void;
        /**
        * Callback method that publishes the sequencing information.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers implementation to get the layering information from
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the {@link yfiles.hierarchic.incremental.ILayoutDataProvider} to get the node information from
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#SEQUENCE_VALUE_HOLDER_DP_KEY}
        */
        publishSequences(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * Removes bends from the edges which are obviously not necessary.
        * This method removes bends from the graph that are collinear.
        * @param {yfiles.layout.LayoutGraph} graph the graph to obtain the edges from
        */
        reduceBendCount(graph:yfiles.layout.LayoutGraph):void;
        /**
        * Returns an {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory} implementation that can be used to obtain hint objects that can be
        * associated with nodes and edges in the graph prior to the invocation of the layout algorithm using an appropriate
        * {@link yfiles.algorithms.IDataProvider} implementation and the {@link yfiles.hierarchic.incremental.HierarchicLayouter#INCREMENTAL_HINTS_DP_KEY} DataProvider key.
        * @return {yfiles.hierarchic.incremental.IIncrementalHintsFactory} an instance that can be used with this layouter instance
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#INCREMENTAL_HINTS_DP_KEY}
        */
        createIncrementalHintsFactory():yfiles.hierarchic.incremental.IIncrementalHintsFactory;
        createSequenceConstraintFactory(graph:yfiles.algorithms.Graph):yfiles.hierarchic.incremental.ISequenceConstraintFactory;
        createLayerConstraintFactory(graph:yfiles.algorithms.Graph):yfiles.hierarchic.incremental.ILayerConstraintFactory;
      }
      export module HierarchicLayouter{
        /**
        * Hint objects used internally by {@link yfiles.hierarchic.incremental.HierarchicLayouter  this} layout algorithm implementation.
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory}
        * @see {@link yfiles.hierarchic.incremental.INodeData#incrementalHint}
        */
        export interface IncrementalHint extends Object{
          /**
          * The type constant for this hint.
          */
          type:yfiles.hierarchic.incremental.IncrementalHintType;
        }
      }
      var HierarchicLayouter:{
        $class:yfiles.lang.Class;
        /**
        * {@link yfiles.algorithms.IDataProvider} key used to retrieve incremental layout hint
        * objects for nodes and edges that have been set using the {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory}
        * which itself can be obtained from the
        * {@link yfiles.hierarchic.incremental.HierarchicLayouter#createIncrementalHintsFactory} method.
        * Note that HierarchicLayouter uses the registered {@link yfiles.algorithms.IDataProvider} to get layout hint objects as well for
        * nodes as for edges so neither {@link yfiles.algorithms.Graph#createNodeMap} nor {@link yfiles.algorithms.Graph#createEdgeMap}
        * may be used to create this provider.
        */
        INCREMENTAL_HINTS_DP_KEY:Object;
        /**
        * {@link yfiles.algorithms.IDataProvider} key used to retrieve {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor}
        * instances for each edge in the graph.
        * Different settings will affect the
        * routing of the edges during the layout.
        * @see {@link yfiles.hierarchic.incremental.IEdgeData#edgeLayoutDescriptor}
        */
        EDGE_LAYOUT_DESCRIPTOR_DP_KEY:Object;
        /**
        * {@link yfiles.algorithms.IDataProvider} key used to retrieve {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor}
        * instances for each node in the graph.
        * Different settings will affect node
        * placement and port assignment during the layout.
        * @see {@link yfiles.hierarchic.incremental.INodeData#nodeLayoutDescriptor}
        */
        NODE_LAYOUT_DESCRIPTOR_DP_KEY:Object;
        /**
        * {@link yfiles.algorithms.IDataProvider} key used to store {@link yfiles.hierarchic.incremental.SwimLaneDescriptor}
        * instances for each node in the graph.
        * If this key is present during the layout.
        * The layout algorithm will arrange nodes in swim lanes. The information about the
        * swim lanes is finally written back into the descriptor instances.
        * Instances can be shared among multiple nodes in the same lane, but don't have to be shared.
        * @see {@link yfiles.hierarchic.incremental.SwimLaneDescriptor}
        * @see {@link yfiles.hierarchic.incremental.INodeData#swimLaneDescriptor}
        */
        SWIMLANE_DESCRIPTOR_DP_KEY:Object;
        /**
        * Used for publishing the final layering information.
        * If the {@link yfiles.algorithms.IDataProvider} associated to this key is also a
        * {@link yfiles.algorithms.IDataAcceptor}, the integer layer id of each node is stored using
        * the acceptor's {@link yfiles.algorithms.IDataAcceptor#setInt  setInt} method.
        * Otherwise, the provider's values should be of type
        * {@link yfiles.hierarchic.incremental.IIntValueHolder} and the value holder's
        * {@link yfiles.hierarchic.incremental.IIntValueHolder#value  setValue} method is used to store the
        * integer layer ids of each node.
        */
        LAYER_VALUE_HOLDER_DP_KEY:Object;
        /**
        * Used for publishing the final sequencing information.
        * If the {@link yfiles.algorithms.IDataProvider} associated to this key is also a
        * {@link yfiles.algorithms.IDataAcceptor}, the sequence order number of each node is stored
        * using the acceptor's {@link yfiles.algorithms.IDataAcceptor#setInt  setInt}
        * method.
        * Otherwise, the provider's values should be of type
        * {@link yfiles.hierarchic.incremental.IIntValueHolder} and the value holder's
        * {@link yfiles.hierarchic.incremental.IIntValueHolder#value  setValue} method is used to store the
        * sequence order number of each node.
        */
        SEQUENCE_VALUE_HOLDER_DP_KEY:Object;
        /**
        * DataProvider key used to hold boolean values for each node in the graph that indicate whether
        * the node has to be added incrementally.
        * This key is used by the incremental versions of {@link yfiles.hierarchic.incremental.ILayerer}, such as
        * {@link yfiles.hierarchic.incremental.TopologicalIncrementalLayerer} to determine which nodes need to be
        * inserted incrementally, as well as the {@link yfiles.hierarchic.incremental.ISequencer} implementation
        * that determines incrementally sequenced nodes.
        */
        INCREMENTAL_NODES_DP_KEY:Object;
        /**
        * Creates a new instance of HierarchicLayouter with default settings.
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createLayerer}
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createIncrementalLayerer}
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createSequencer}
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createDrawingDistanceCalculator}
        * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#createNodePlacer}
        */
        new ():yfiles.hierarchic.incremental.HierarchicLayouter;
        IncrementalHint:{
          $class:yfiles.lang.Class;
          /**
          * Convenience singleton instance of type {@link yfiles.hierarchic.incremental.IncrementalHintType#NONE}.
          */
          NONE:yfiles.hierarchic.incremental.HierarchicLayouter.IncrementalHint;
        };
      };
      /**
      * Helper class that is used to manage hierarchically grouped graphs.
      */
      export interface GroupingSupport extends Object{
        /**
        * Hides the group nodes and adjacent edges from the graph.
        */
        hideGroupNodes():void;
        /**
        * Unhides all previously hidden group nodes and adjacent edges.
        */
        unhideGroupNodes():void;
        minimumGroupDistance:number;
        assignEdgeGroupNodesToGroups(layers:yfiles.hierarchic.incremental.ILayers):void;
        removeEdgeGroupAssignment(layers:yfiles.hierarchic.incremental.ILayers):void;
        /**
        * Returns whether or not the given node is a non-empty group node.
        */
        isGroupNode(node:yfiles.algorithms.Node):boolean;
        assignLabelNodesToGroups(layers:yfiles.hierarchic.incremental.ILayers,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
        /**
        * Specifies whether or not groupingSupport is active.
        * All return values of the methods of this
        * class will be invalid if groupingSupport is inactive.
        */
        active:boolean;
        /**
        * Visits all descendants of the given group node.
        */
        visitDecendants(groupNode:yfiles.algorithms.Node,visitor:yfiles.hierarchic.incremental.GroupingSupport.IVisitor):void;
        /**
        * Returns all direct and indirect children of the given group node.
        */
        getDecendants(groupNode:yfiles.algorithms.Node):yfiles.algorithms.NodeList;
        /**
        * Returns the direct children of the given group node.
        */
        getChildren(groupNode:yfiles.algorithms.Node):yfiles.algorithms.NodeList;
        /**
        * Returns the parent group node of the given node, or <code>null</code> if the given node is a top-level node.
        */
        getParentNode(node:yfiles.algorithms.Node):yfiles.algorithms.Node;
        /**
        * Returns whether or not the given node is a direct or indirect child of the given group node.
        */
        isDescendant(node:yfiles.algorithms.Node,groupNode:yfiles.algorithms.Node):boolean;
      }
      export module GroupingSupport{
        /**
        * Visitor interface that can be used to traverse the descendants of a group node.
        */
        export interface IVisitor extends Object{
          visit(node:yfiles.algorithms.Node,parentNode:yfiles.algorithms.Node):void;
        }
      }
      var GroupingSupport:{
        $class:yfiles.lang.Class;
      };
      /**
      * Interface for implementations that perform their work after the first phase.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter}
      */
      export interface IEdgeReverser extends Object{
        /**
        * Called at the beginning of the layout algorithm.
        * This method should reverse all edges which point into the wrong direction.
        * I.e. if the layer index of the source node is greater than the layer index
        * of the target node.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider that can be queried to receive the
        * layering information
        * @see {@link yfiles.hierarchic.incremental.ILayoutDataProvider#getNodeData}
        * @see {@link yfiles.hierarchic.incremental.INodeData#layer}
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeReverser#normalizeEdges}.
        */
        normalizeEdges(graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * May be called by the incremental parts of the layout algorithm.
        * This method should reverse the given edge which points into the wrong direction.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider that can be queried to receive the
        * layering information
        * @param {yfiles.algorithms.Edge} edge the edge to reverse
        * @see {@link yfiles.hierarchic.incremental.ILayoutDataProvider#getNodeData}
        * @see {@link yfiles.hierarchic.incremental.INodeData#layer}
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeReverser#reverse}.
        */
        reverse(graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,edge:yfiles.algorithms.Edge):void;
        /**
        * Called at the end of the layout algorithm.
        * This method should reverse all
        * edges which have been marked as reversed.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider that can be queried to receive the
        * layering information
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeReverser#restoreEdgeDirections}.
        */
        restoreEdgeDirections(graph:yfiles.layout.LayoutGraph,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
      }
      var IEdgeReverser:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Multi-purpose edge descriptor for each edge in the graph during the layout.
      * Used by {@link yfiles.hierarchic.incremental.HierarchicLayouter} during all stages to keep the state of
      * the edges.
      */
      export interface IEdgeData extends Object{
        /**
        * The type constant of the edge.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#type}.
        */
        type:yfiles.hierarchic.incremental.EdgeDataType;
        /**
        * A possibly associated node.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#associatedNode}.
        */
        associatedNode:yfiles.algorithms.Node;
        /**
        * A possibly associated edge.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#associatedEdge}.
        */
        associatedEdge:yfiles.algorithms.Edge;
        /**
        * The current source port constraint.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#spc}.
        */
        spc:yfiles.layout.PortConstraint;
        /**
        * The Collection of{@link yfiles.layout.PortCandidate}s for the
        * source port as obtained from the DataProvider bound to the graph via
        * the {@link yfiles.layout.PortCandidate#SOURCE_PC_LIST_DP_KEY} data provider key
        * bound to the original edge.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#sourceCandidates}.
        */
        sourceCandidates:yfiles.algorithms.ICollection;
        /**
        * The current target port constraint.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#tpc}.
        */
        tpc:yfiles.layout.PortConstraint;
        /**
        * The Collection of{@link yfiles.layout.PortCandidate}s for the
        * source port as obtained from the DataProvider bound to the graph via
        * the {@link yfiles.layout.PortCandidate#TARGET_PC_LIST_DP_KEY} data provider key
        * bound to the original edge.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#targetCandidates}.
        */
        targetCandidates:yfiles.algorithms.ICollection;
        /**
        * The source group id object if any.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#sourceGroup}.
        */
        sourceGroup:Object;
        /**
        * The target group id object if any.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#targetGroup}.
        */
        targetGroup:Object;
        /**
        * The group that is represented by this edge.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#group}.
        */
        group:Object;
        /**
        * Specifies whether the edge has been reversed.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#reversed}.
        */
        reversed:boolean;
        /**
        * Specifies whether the edge is an upper same layer edge
        * (in case it is a same layer edge).
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#upperSameLayerEdge}.
        */
        upperSameLayerEdge:boolean;
        /**
        * The EdgeLayoutDescriptor instance that was initially bound to this edge
        * or <code>null</code>.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#edgeLayoutDescriptor}.
        */
        edgeLayoutDescriptor:yfiles.hierarchic.incremental.EdgeLayoutDescriptor;
        /**
        * Specifies whether this edge should be an upper same layer edge if it is a
        * same layer edge and it can be freely determined whether it should
        * be routed above or below the layer.
        * @see Specified by {@link yfiles.hierarchic.incremental.IEdgeData#fallbackUpperSameLayerEdge}.
        */
        fallbackUpperSameLayerEdge:boolean;
      }
      var IEdgeData:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Interface for a helper class used by {@link yfiles.hierarchic.incremental.HierarchicLayouter} during
      * the node placement phase.
      * {@link yfiles.hierarchic.incremental.INodePlacer} uses instances that implement
      * this interface to determine the minimum distances between elements in one layer.
      * The default implementation used in the {@link yfiles.hierarchic.incremental.HierarchicLayouter} is
      * {@link yfiles.hierarchic.incremental.DefaultDrawingDistanceCalculator}.
      */
      export interface IDrawingDistanceCalculator extends Object{
        /**
        * Called to initialize internal data structures.
        * Implementations may
        * cache lengthy calculations in the initialization phase.
        * It is guaranteed that the graph will not be changed during subsequent
        * calls to {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#getMinDistance}.
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains all elements that are used during
        * the node placement
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers object that will be used during subsequent calls
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query information
        * @see {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#dispose}
        * @see Specified by {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#initialize}.
        */
        initialize(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
        /**
        * Main interface method.
        * Queried by {@link yfiles.hierarchic.incremental.INodePlacer} instances to determine
        * the minimum distances between elements in one layer. Note that either of the Node
        * arguments may be <code>null</code>. In that case only the border of the non-<code>null</code>
        * node should be considered.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the nodes
        * @param {yfiles.hierarchic.incremental.ILayer} layer the layer object that contains the nodes
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that can be used to query information
        * @param {yfiles.algorithms.Node} left 
        * the left one of the two nodes whose
        * minimum distance is to be determined or <code>null</code> if only the left border of the right node is
        * of interest.
        * @param {yfiles.algorithms.Node} right 
        * the right one of the two nodes whose
        * minimum distance is to be determined or <code>null</code> if only the right border of the left node is
        * of interest.
        * @see Specified by {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#getMinDistance}.
        */
        getMinDistance(graph:yfiles.layout.LayoutGraph,layer:yfiles.hierarchic.incremental.ILayer,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,left:yfiles.algorithms.Node,right:yfiles.algorithms.Node):number;
        /**
        * Called to dispose internal data structures.
        * Implementations should
        * release internally held data structures here.
        * @see {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#initialize}
        * @param {yfiles.layout.LayoutGraph} graph 
        * the graph that contains all elements that are used during
        * the node placement
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layers object that was used
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp the LayoutDataProvider that was used to query information
        * @see Specified by {@link yfiles.hierarchic.incremental.IDrawingDistanceCalculator#dispose}.
        */
        dispose(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider):void;
      }
      var IDrawingDistanceCalculator:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * This LayerSequencer implementation returns a sequencing that satisfies
      * a comparator constraint.
      */
      export interface GivenSequenceSequencer extends Object,yfiles.hierarchic.incremental.ISequencer{
        /**
        * The comparator used by this <code>GivenSequenceSequencer</code>.
        */
        sequenceComparator:yfiles.objectcollections.IComparer;
        /**
        * Called by {@link yfiles.hierarchic.incremental.HierarchicLayouter} during the second phase.
        * Calculates a sequence of the nodes in <code>layers</code> and finally
        * writes back the calculated sequence using the {@link yfiles.hierarchic.incremental.ILayer#setNodeOrder}
        * method.
        * @param {yfiles.layout.LayoutGraph} graph the graph that contains the elements from <code>layers</code>
        * @param {yfiles.hierarchic.incremental.ILayers} layers the Layer implementation that holds the Layers for sequencing
        * @param {yfiles.hierarchic.incremental.ILayoutDataProvider} ldp 
        * the LayoutDataProvider that provides the necessary {@link yfiles.hierarchic.incremental.INodeData}
        * and {@link yfiles.hierarchic.incremental.IEdgeData}
        * @param {yfiles.hierarchic.incremental.IItemFactory} itemFactory 
        * an ItemFactory implementation that can be used to modify the
        * graph consistently
        * @see Specified by {@link yfiles.hierarchic.incremental.ISequencer#sequenceNodeLayers}.
        */
        sequenceNodeLayers(graph:yfiles.layout.LayoutGraph,layers:yfiles.hierarchic.incremental.ILayers,ldp:yfiles.hierarchic.incremental.ILayoutDataProvider,itemFactory:yfiles.hierarchic.incremental.IItemFactory):void;
      }
      var GivenSequenceSequencer:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of GivenSequenceSequencer.
        */
        new ():yfiles.hierarchic.incremental.GivenSequenceSequencer;
        /**
        * Creates a new instance of GivenSequenceSequencer using the specified
        * comparator for the sequencing.
        */
        WithComparer:{
          new (c:yfiles.objectcollections.IComparer):yfiles.hierarchic.incremental.GivenSequenceSequencer;
        };
      };
      export enum MergingPolicy{
        /**
        * Constant for merging policy.
        * This policy adds new layers from the source layering below the 
        * layers in the target layering.
        */
        ADD_BELOW,
        /**
        * Constant for merging policy.
        * This policy adds new layers from the source layering above the 
        * layers in the target layering.
        */
        ADD_ABOVE,
        /**
        * Constant for merging policy.
        * This policy adds new layers from the source layering to the right of
        * the layers in the target layering. 
        * Both layerings will be top aligned before the merge.
        */
        ADD_RIGHT_TOP_ALIGNED,
        /**
        * Constant for merging policy.
        * This policy adds new layers from the source layering to the right of
        * the layers in the target layering. 
        * Both layerings will be bottom aligned before the merge.
        */
        ADD_RIGHT_BOTTOM_ALIGNED,
        /**
        * Constant for merging policy.
        * This policy adds new layers from the source layering to the right of
        * the layers in the target layering. 
        * Both layerings will be center aligned before the merge.
        */
        ADD_RIGHT_CENTER_ALIGNED,
        /**
        * Constant for merging policy.
        * This policy adds new layers from the source layering to the left of
        * the layers in the target layering. 
        * Both layerings will be top aligned before the merge.
        */
        ADD_LEFT_TOP_ALIGNED,
        /**
        * Constant for merging policy.
        * This policy adds new layers from the source layering to the left of
        * the layers in the target layering. 
        * Both layerings will be bottom aligned before the merge.
        */
        ADD_LEFT_BOTTOM_ALIGNED,
        /**
        * Constant for merging policy.
        * This policy adds new layers from the source layering to the left of
        * the layers in the target layering. 
        * Both layerings will be center aligned before the merge.
        */
        ADD_LEFT_CENTER_ALIGNED
      }
      export enum EdgeDataType{
        /**
        * Describes a normal edge.
        */
        NORMAL,
        /**
        * Describes an edge that connects to a source group node.
        */
        SOURCE_GROUP_NODE_CONNECTOR,
        /**
        * Describes an edge that connects to a target group node.
        */
        TARGET_GROUP_NODE_CONNECTOR,
        /**
        * Describes an edge that connects two group nodes.
        */
        GROUP_NODE_INTERCONNECTOR,
        /**
        * Describes a same layer edge that connects two neighbouring nodes directly.
        */
        DIRECT_SAME_LAYER_EDGE,
        /**
        * Describes a same layer edge that connects two neighbouring nodes directly.
        */
        NON_DIRECT_SAME_LAYER_EDGE,
        /**
        * Describes an edge that connects group border nodes in adjacent layers.
        */
        BORDER_EDGE,
        /**
        * Describes an edge that has been added temporarily to replace an edge connected to a group node.
        */
        REDIRECTED_GROUP_EDGE
      }
      export enum IncrementalHintType{
        /**
        * Type specifier that is used as a dummy. This hint actually tells the algorithm that the corresponding
        * element should not be treated as an incrementally added element.
        */
        NONE,
        /**
        * Type specifier that is used for nodes that shall be inserted into the drawing incrementally
        * during the layering phase.
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createLayerIncrementallyHint}
        */
        LAYER_INCREMENTALLY,
        /**
        * Type specifier that is used for nodes and edges that shall be inserted into the drawing incrementally
        * during the sequencing phase.
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createSequenceIncrementallyHint}
        */
        SEQUENCE_INCREMENTALLY,
        /**
        * Type specifier that is used for groups that shall be inserted into the drawing incrementally
        * during the layering phase.
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createIncrementalGroupHint}
        */
        INCREMENTAL_GROUP,
        /**
        * Type specifier that is used for nodes that shall be placed into the drawing from sketch using the exact current
        * coordinates for both the position within the layer and the position in the sequence.
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactCoordinatesHint}
        * @see {@link yfiles.hierarchic.incremental.IncrementalHintType#PLACE_USING_EXACT_LAYER_COORDINATES}
        * @see {@link yfiles.hierarchic.incremental.IncrementalHintType#PLACE_USING_EXACT_SEQUENCE_COORDINATES}
        */
        PLACE_USING_EXACT_COORDINATES,
        /**
        * Type specifier that is used for nodes that shall be placed into the drawing from sketch using
        * the exact current coordinates for the position within the
        * sequence in the layer.
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactSequenceCoordinatesHint}
        */
        PLACE_USING_EXACT_SEQUENCE_COORDINATES,
        /**
        * Type specifier that is used for nodes that shall be placed into the drawing from sketch using
        * the exact current coordinates for the position within the layer.
        * @see {@link yfiles.hierarchic.incremental.IIncrementalHintsFactory#createUseExactLayerCoordinatesHint}
        */
        PLACE_USING_EXACT_LAYER_COORDINATES
      }
      /**
      * This class is used by {@link yfiles.hierarchic.incremental.HierarchicLayouter} during the various
      * phases to determine the routing details of the graph's edges.
      * Note: not all of these values will be used for all kinds of edges and
      * any kind of algorithm.
      * This class is designed as a class to allow for future additions of new getter
      * methods.
      * @see {@link yfiles.hierarchic.incremental.HierarchicLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      * @see {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor}
      */
      export interface EdgeLayoutDescriptor extends Object{
        /**
        * The minimum length of the first segment (at the source).
        * If the value is <code>0.0d</code> the first segment does not need to be
        * orthogonal.
        * Default is <code>10.0d</code>.
        */
        minimumFirstSegmentLength:number;
        /**
        * The minimum length of the last segment (at the target).
        * If the value is <code>0.0d</code> the last segment does not need to be
        * orthogonal.
        * Default is <code>15.0d</code>.
        */
        minimumLastSegmentLength:number;
        /**
        * The minimum length of the edge.
        * If this is used for polyline routing, it describes the minimum vertical length
        * of the mid segment (the one that may be routed non-orthogonally).
        * If it is used for orthogonal routing it describes the minimum length for the whole edge.
        * Default is <code>20.0d</code>.
        */
        minimumLength:number;
        /**
        * The <i>preferred</i> minimum distance of the edge to obstacles.
        * Default is <code>10.0d</code>.
        */
        minimumDistance:number;
        /**
        * The minimum slope this edge's mid-segments should have if the edge
        * is routed polygonal in vertical layouts.
        * <p>
        * Default is <code>0.3d</code>.
        * </p>
        */
        minimumSlope:number;
        /**
        * Specifies whether source port optimization is enabled, i.e.
        * whether
        * the algorithm should try to find a better source {@link yfiles.layout.PortConstraint}
        * if the current constraint is <code>null</code> or {@link yfiles.layout.PortSide#ANY}.
        * Default is <code>false</code>, which will result in ports being placed at the side of
        * the node which lies closest to the target of the edge in terms of layering.
        */
        sourcePortOptimizationEnabled:boolean;
        /**
        * Specifies whether target port optimization is enabled, i.e.
        * whether
        * the algorithm should try to find a better target {@link yfiles.layout.PortConstraint}
        * if the current constraint is <code>null</code> or {@link yfiles.layout.PortSide#ANY}.
        * Default is <code>false</code>, which will result in ports being placed at the side of
        * the node which lies closest to the source of the edge in terms of layering.
        */
        targetPortOptimizationEnabled:boolean;
        /**
        * Determines whether this edge should be routed orthogonally.
        * Default is <code>false</code>.
        * This does not affect the routing of bus-like structures.
        */
        orthogonallyRouted:boolean;
        /**
        * The routing style for this edge.
        * @see {@link yfiles.hierarchic.incremental.RoutingStyle}
        * @see {@link yfiles.hierarchic.incremental.RoutingStyle}
        */
        routingStyle:yfiles.hierarchic.incremental.RoutingStyle;
        /**
        * The minimum length of octilinear segments for this edge.
        * Note: the layout algorithm cannot always maintain the specified minimum length.
        * <p>
        * Default is <code>20.0d</code>.
        * </p>
        * @see {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor#routingStyle}
        * @see {@link yfiles.hierarchic.incremental.EdgeLayoutDescriptor#routingStyle}
        */
        minOctilinearSegmentLength:number;
      }
      var EdgeLayoutDescriptor:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of an EdgeLayoutDescriptor using the
        * default values.
        */
        new ():yfiles.hierarchic.incremental.EdgeLayoutDescriptor;
      };
      export enum PortAssignmentMode{
        /**
        * Port assignment specifier that describes the default port assignment strategy of
        * {@link yfiles.hierarchic.IncrementalHierarchicLayouter}. The ports are distributed evenly at the border of the
        * node.
        */
        DEFAULT,
        /**
        * Port assignment specifier that describes a port assignment strategy which places all edges on grid lines.
        * If there are not enough grid lines for each port, ports may overlap.
        * In case there is no grid line available at the side of a node, the ports are placed centered at that side.
        * <p>
        * Note that this port assignment can only be used if the
        * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#gridSpacing  grid spacing} is greater than 0.
        * </p>
        */
        ON_GRID,
        /**
        * Port assignment specifier that describes a port assignment strategy which places all edges on grid lines
        * or subgrid lines. If there are not enough grid lines for each port, the grid gets subdivided with subgrid lines
        * until each edge has space for its port.
        * <p>
        * Note that this port assignment can only be used if the
        * {@link yfiles.hierarchic.IncrementalHierarchicLayouter#gridSpacing  grid spacing} is greater than 0.
        * </p>
        */
        ON_SUBGRID
      }
      export enum GroupCompactionPolicy{
        /**
        * Compaction strategy specifier for use with {@link yfiles.hierarchic.incremental.SimplexNodePlacer#groupCompactionStrategy}.
        * This specifies no horizontal group compaction, i.e. group node contents will occupy nearly the same horizontal positions as when not grouped at all.
        */
        NONE,
        /**
        * Compaction strategy specifier for use with {@link yfiles.hierarchic.incremental.SimplexNodePlacer#groupCompactionStrategy}.
        * This specifies maximal horizontal group compaction, i.e. the node placer will try to minimize the horizontally occupied space for a group node.
        */
        MAXIMAL
      }
      export enum EdgeRoutingStyle{
        /**
        * Routing style constant.
        * This constant specifies that the route should be orthogonal, i.e., the route only consists of
        * vertical and horizontal segments.
        */
        ORTHOGONAL,
        /**
        * Routing style constant.
        * This constant specifies that the route should be octilinear, i.e., the route consists of
        * vertical and horizontal segments as well as segments with slope -1 and 1.
        */
        OCTILINEAR,
        /**
        * Routing style constant.
        * This constant specifies that the route should be polyline.
        */
        POLYLINE
      }
      export enum LayerType{
        /**
        * Describes a normal layer consisting mainly of normal nodes.
        */
        NORMAL,
        /**
        * Describes a layer consisting mainly of label nodes or dummy nodes.
        */
        LABEL,
        /**
        * Describes a layer consisting of source group nodes and dummy nodes.
        */
        SOURCE_GROUP_NODES,
        /**
        * Describes a layer consisting of target group nodes and dummy nodes.
        */
        TARGET_GROUP_NODES
      }
      export enum NodeLabelMode{
        /**
        * Byte constant used by {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#nodeLabelMode} and 
        * {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#nodeLabelMode}. This mode prevents node labels from being
        * considered during the layout at all.
        */
        NEVER,
        /**
        * Byte constant used by {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#nodeLabelMode} and 
        * {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#nodeLabelMode}. This mode makes the algorithm consider
        * node labels for self-loops, node placement, and routing.
        */
        CONSIDER_FOR_SELF_LOOPS,
        /**
        * Byte constant used by {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#nodeLabelMode} and 
        * {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#nodeLabelMode}. This mode makes the algorithm consider
        * node labels for node placement and routing but not for self loops.
        */
        CONSIDER_FOR_DRAWING,
        /**
        * Byte constant used by {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#nodeLabelMode} and 
        * {@link yfiles.hierarchic.incremental.NodeLayoutDescriptor#nodeLabelMode}. This mode makes the algorithm consider
        * node labels during routing only.
        */
        CONSIDER_FOR_ROUTING
      }
      export enum NodeDataType{
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A normal node - may have any degree, any size and any number of connected
        * same layer edges.
        */
        NORMAL,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A bend node - has degree 2, small size and no same layer edges.
        */
        BEND,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A side proxy node in case port constraints are used for the drawing phase 
        * - has degree 1, small size and no same layer edges.
        * The associated node is the node this node is the proxy of.
        */
        SIDE_PROXY,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A side proxy node for drawing same layer edges - has degree 0, small size 
        * and one same layer edge.
        * The associated node is the node this node is the proxy of.
        * The associated edge is the same layer edge this node is the proxy of.
        */
        SAME_LAYER_SIDE_PROXY,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A label node for drawing - has degree 2, size of the labels and no same layer edges.
        * The borders of this node describe the layout of the labels
        */
        LABEL,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A group node if nested graph layouts are calculated. 
        * Carries additional {@link yfiles.hierarchic.incremental.ILayers} information.
        * @see {@link yfiles.hierarchic.incremental.INodeData#groupLayers}
        */
        GROUP,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A source group node for bus edges. This node serves as a dummy node
        * in a {@link yfiles.hierarchic.incremental.LayerType#SOURCE_GROUP_NODES} layer.
        * @see {@link yfiles.hierarchic.incremental.INodeData#groupId}
        */
        SOURCE_GROUP_NODE,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A target group node for bus edges. This node serves as a dummy node
        * in a {@link yfiles.hierarchic.incremental.LayerType#TARGET_GROUP_NODES} layer.
        * @see {@link yfiles.hierarchic.incremental.INodeData#groupId}
        */
        TARGET_GROUP_NODE,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A backloop proxy that belongs to the source of an edge
        * - has degree 2, small size and exactly one same layer edge
        */
        SOURCE_BACKLOOP_PROXY,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A backloop proxy that belongs to the target of an edge
        * - has degree 2, small size and exactly one same layer edge
        */
        TARGET_BACKLOOP_PROXY,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A same layer edge crossing dummy node - has degree 2, 
        * small size and exactly two same layer edges. 
        * Is used to mark the crossing of the layer if source and target port
        * are at opposite layer sides.
        */
        SAME_LAYER_CENTER_NODE,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A node used for the drawing phase to keep the distance between two nodes.
        */
        DISTANCE_NODE,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A node used for the drawing phase to mark the beginning of a node group interval.
        */
        GROUP_BEGIN,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A node used for the drawing phase to mark the ending of a node group interval.
        */
        GROUP_END,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A node used for the the sequencing and drawing phase to mark a dummy node inserted to guarantee that a group
        * is non-empty on each layer that it is defined on.
        */
        GROUP_LAYER_DUMMY,
        /**
        * Node type constant as returned by {@link yfiles.hierarchic.incremental.INodeData#type}.
        * A node used for the the sequencing and drawing phase to mark a dummy node that has been inserted
        * as a legal end point of an edge connecting to a group node.
        */
        PROXY_FOR_EDGE_AT_GROUP
      }
    }
  }
  export module labeling{
    /**
    * This class places the labels of a graph using a greedy strategy.
    * This is the fastest label placing algorithm provided.
    */
    export interface GreedyMISLabeling extends yfiles.labeling.MISLabelingAlgorithm{
    }
    var GreedyMISLabeling:{
      $class:yfiles.lang.Class;
      new ():yfiles.labeling.GreedyMISLabeling;
    };
    /**
    * Solving labeling problem by reducing it to the maximum independent set problem.
    */
    export interface MISLabelingAlgorithm extends yfiles.labeling.AbstractLabelingAlgorithm{
      graph:yfiles.layout.LayoutGraph;
      /**
      * the conflict graph.
      */
      conflictGraph:yfiles.algorithms.Graph;
      /**
      * holds for each node in the conflictGraph the corresponding LabelCandidate.
      */
      nodesToBoxes:yfiles.algorithms.INodeMap;
      boxesToNodes:yfiles.algorithms.IMap;
      /**
      * holds for each node in the conflictGraph the corresponding integer index of the Label[].
      */
      nodesToID:yfiles.algorithms.INodeMap;
      /**
      * The custom profit model ratio.
      * @see {@link yfiles.labeling.AbstractLabelingAlgorithm#profitModel}
      * @see {@link yfiles.labeling.MISLabelingAlgorithm#optimizationStrategy}
      */
      customProfitModelRatio:number;
      /**
      * The optimization strategy of the labeling algorithm.
      * Possible values are:
      * {@link yfiles.labeling.OptimizationStrategy#NONE}, {@link yfiles.labeling.OptimizationStrategy#BALANCED},
      * {@link yfiles.labeling.OptimizationStrategy#NODE_OVERLAP}, {@link yfiles.labeling.OptimizationStrategy#EDGE_OVERLAP}
      * and {@link yfiles.labeling.OptimizationStrategy#LABEL_OVERLAP}.
      */
      optimizationStrategy:yfiles.labeling.OptimizationStrategy;
      /**
      * Creates one edge between two nodes if the corresponding label candidates are intersecting.
      */
      createEdges():void;
      /**
      * Creates a node map which assigns to each node the profit.
      */
      assignProfit():yfiles.algorithms.INodeMap;
      /**
      * Calculates the overlapping factor between two label candidates.
      * Default value is 1.0.
      */
      foundLabelOverlap(lc1:yfiles.layout.LabelCandidate,lc2:yfiles.layout.LabelCandidate,e:yfiles.algorithms.Edge):void;
      /**
      * Calculates the overlapping factor between a label candidate and a node.
      */
      foundNodeOverlap(lc:yfiles.layout.LabelCandidate,n:yfiles.algorithms.Node,nBox:yfiles.algorithms.YRectangle):void;
      /**
      * Calculates the overlapping factor between a label candidate and an edge segment.
      */
      foundEdgeOverlap(lc:yfiles.layout.LabelCandidate,e:yfiles.algorithms.Edge,eSegment:yfiles.algorithms.LineSegment):void;
      /**
      * Calculates the overlapping factor between a label candidate and a node halo.
      */
      foundHaloOverlap(lc:yfiles.layout.LabelCandidate,n:yfiles.algorithms.Node,haloRect:yfiles.algorithms.YRectangle):void;
    }
    var MISLabelingAlgorithm:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new instance of the MISLabelingAlgorithm class.
      */
      new ():yfiles.labeling.MISLabelingAlgorithm;
    };
    /**
    * This class is an abstract base class for labeling algorithms.
    * A labeling algorithm places a set of labels.
    */
    export interface AbstractLabelingAlgorithm extends yfiles.layout.AbstractLayoutStage{
      /**
      * The profit model that is used to rank the available positions for each label.
      * The higher the rank of a
      * position, the more likely it will be chosen by the algorithm. By default an instance of type {@link yfiles.layout.LabelRanking} is set.
      */
      profitModel:yfiles.layout.IProfitModel;
      /**
      * True if the labeling algorithm is allowed to move internal node labels.
      * A node label is deemed internal if the label's bounds are completely within the node bounds.
      */
      moveInternalNodeLabels:boolean;
      /**
      * True if the postprocessing step is applied.
      * The postprocessing step tries to further reduce the number of
      * overlaps.
      * Note: the postprocessing step is only applied to edge labels whose edge label model is
      * <code>FreeEdgeLabelModel</code> and node labels whose node label model is <code>FreeNodeLabelModel</code>.
      */
      applyPostprocessing:boolean;
      /**
      * <code>true</code> if the preference on which side of an edge a corresponding label should be placed is
      * interpreted by human perception instead of always following the edge from source to target.
      * <p>
      * Note: the alternative side handling is only applied to edge labels whose edge label model is
      * <code>FreeEdgeLabelModel</code>.
      * </p>
      */
      useAlternativeSideHandling:boolean;
      /**
      * How label candidates which overlap with nodes are handled.
      * If <code>true</code> these candidates are not
      * considered, if <code>false</code> these candidates are considered, but a penalty is assigned to them.
      */
      removeNodeOverlaps:boolean;
      /**
      * How label candidates which overlap with edges are handled.
      * If <code>true</code> these candidates are not
      * considered, if <code>false</code> these candidates are considered, but a penalty is assigned to them.
      */
      removeEdgeOverlaps:boolean;
      /**
      * Specifies whether labels assigned to nodes in a graph should be placed or ignored.
      * This method has higher priority
      * than a specified selection, that means that all selected node labels are ignored by this algorithm if this property
      * is set to <code>false</code>.
      * @see {@link yfiles.labeling.AbstractLabelingAlgorithm#selectedLabelsDpKey}
      */
      placeNodeLabels:boolean;
      /**
      * Specifies whether labels assigned to edges in a graph should be placed or ignored.
      * This method has higher priority
      * than a specified selection, that means that all selected edge labels are ignored by this algorithm if this property
      * is set to <code>false</code>.
      * @see {@link yfiles.labeling.AbstractLabelingAlgorithm#selectedLabelsDpKey}
      */
      placeEdgeLabels:boolean;
      /**
      * The labeling selection <code>DataProvider</code> key.
      * The data provider registered with this key has to return <code>true</code>
      * for labels that should be placed and <code>false</code> for all other
      * labels.
      */
      selectedLabelsDpKey:Object;
      /**
      * Determines whether or not edge labels associated with a "free" label model
      * should be automatically flipped
      * if they would be upside-down.
      * <p>
      * By default, this property is set to <code>false</code>.
      * </p>
      */
      autoFlipping:boolean;
      /**
      * Returns <code>true</code>.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Place the labels in the graph.
      * This method is equivalent to the <code>label()</code> method.
      * @param {yfiles.layout.LayoutGraph} graph The graph to label.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given node object is zero.
      * It is called by the label-methods for each node object in the input graph.
      * @see {@link yfiles.labeling.AbstractLabelingAlgorithm#checkGroupNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the node object is zero.
      */
      checkNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given group node object is zero.
      * It is called by the label-methods for each group node object in the input graph.
      * @see {@link yfiles.labeling.AbstractLabelingAlgorithm#checkNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the group node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the group node object is zero.
      */
      checkGroupNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * Place the labels in the graph.
      * @param {yfiles.layout.LayoutGraph} gl The graph to label.
      */
      label(gl:yfiles.layout.LayoutGraph):void;
      /**
      * Place a subset of the labels.
      * @param {Object} key 
      * The key for a <code>DataProvider</code> in <code>gl</code>. Labels which should be placed return
      * <code>true</code>.
      */
      labelSubset(gl:yfiles.layout.LayoutGraph,key:Object):void;
      /**
      * Place some labels in the graph.
      * The selection is ignored, if set.
      */
      labelSubsetLists(gl:yfiles.layout.LayoutGraph,nodeLabels:yfiles.algorithms.YList,edgeLabels:yfiles.algorithms.YList):void;
      /**
      * Returns the profit model that is used to rank the available positions for each label.
      * The higher the rank of a
      * position, the more likely it will be chosen by the algorithm. By default an instance of type {@link yfiles.layout.LabelRanking} is set.
      */
      getProfit(l:yfiles.layout.LabelCandidate):number;
      /**
      * The set of all generated candidate rectangles.
      * <p>
      * <b>Debug only.</b>
      * </p>
      */
      rects:yfiles.algorithms.YList;
      /**
      * Specifies whether the candidate rectangles should be stored to be retrieved.
      * <p>
      * <b>Debug only.</b>
      * </p>
      */
      storeRects:boolean;
      /**
      * Specifies whether edge labels may overlap with edges belonging to the same edge group.
      * If edge labels overlap with other edges of the same group, this flag decides
      * whether these positions are allowed.
      */
      edgeGroupOverlapAllowed:boolean;
    }
    var AbstractLabelingAlgorithm:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key to specify for each {@link yfiles.layout.IEdgeLabelLayout}s and each
      * {@link yfiles.layout.INodeLabelLayout} a replacement {@link yfiles.layout.IEdgeLabelModel} or {@link yfiles.layout.INodeLabelModel},
      * respectively, that is used by the labeling algorithm instead of the original label model.
      * If this key is not
      * defined or if a label has no mapping, the original model is used as normal. Otherwise, a model parameter that
      * fits the calculated position of the replacement model best is set for the original model.
      * This feature is especially useful to restrict a free model. For example, to place a label upon its associated edge,
      * a centered {@link yfiles.layout.RotatedSliderEdgeLabelLayoutModel} can be used a replacement model.
      */
      LABEL_MODEL_DP_KEY:Object;
      /**
      * Creates a new instance of this class.
      */
      new ():yfiles.labeling.AbstractLabelingAlgorithm;
    };
    /**
    * This class is based on the enhanced profit model and places the labels of a graph using a simulated annealing
    * strategy taking into account the amount of overlaps of labels.
    * The algorithm is inspired by the article of
    * Christensen, Marks and Shieber.
    */
    export interface SALabeling extends yfiles.labeling.MISLabelingAlgorithm{
      /**
      * Specifies whether or not this labeling algorithm should work deterministically.
      * In deterministic mode this labeling algorithm produces
      * the same layout results for the same input graph and layout/labeling
      * parameters.
      * <p>
      * By default deterministic mode is disabled.
      * </p>
      */
      deterministicMode:boolean;
      /**
      * The time limit for the algorithm (in milliseconds).
      * Note, that this limit is not strictly observed.
      */
      maximalDuration:number;
    }
    var SALabeling:{
      $class:yfiles.lang.Class;
      new ():yfiles.labeling.SALabeling;
    };
    export enum OptimizationStrategy{
      /**
      * Use a balanced optimization strategy.
      */
      BALANCED,
      /**
      * Use an optimization strategy that especially reduces overlaps between labels and nodes as well as labels and node
      * halos.
      */
      NODE_OVERLAP,
      /**
      * Use an optimization strategy that especially reduces overlaps between labels.
      */
      LABEL_OVERLAP,
      /**
      * Use an optimization strategy that especially reduces overlaps between labels and edges.
      */
      EDGE_OVERLAP,
      /**
      * Use no optimization strategy.
      */
      NONE
    }
  }
  export module lang{
    /**
    * Provides a method by which implementors can be compared to each other.
    */
    export interface IComparable<T> extends Object{
      /**
      * Compares this object to the given object of the same type.
      * @param {T} obj The object to compare this to.
      * @return {number} <ul>
      * <li>-1: this is less than <code>obj</code></li>
      * <li>0: this is equal to <code>obj</code></li>
      * <li>1: this is greater than <code>obj</code></li>
      * </ul>
      * @see Specified by {@link yfiles.lang.IComparable#compareTo}.
      */
      compareTo(obj:T):number;
    }
    var IComparable:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * The base type of an enumeration. It is not type safe. All enums extend {@link yfiles.lang.Enum}
    * and should be used instead of "magic values".
    * <p>
    * The members of the enum type definition will be static and an enum can not be constructed.
    * </p>
    * <pre><code>
    *  var RequestState = yfiles.lang.Enum('RequestState', {
    *      SEND: 1,
    *      PROCESSED: 2,
    *      SHIPPED: 3,
    *      FAILED: 4,
    *     });
    *     if(state === RequestState.FAILED) { ... }
    * </code></pre>
    */
    export interface Enum extends Object{
    }
    var Enum:{
      $class:yfiles.lang.Class;
      /**
      * Returns the value of the field with the given ID.
      * @param {yfiles.lang.Class} type The type of the enum.
      * @param {string} id The name of the field.
      * @param {boolean} ignoreCase If <code>true</code>, then the case of the field
      * will be ignored and the search is case-insensitive.
      * @return {yfiles.lang.Enum} The value of the field with the given ID.
      */
      parse(type:yfiles.lang.Class,id:string,ignoreCase:boolean):yfiles.lang.Enum;
      /**
      * Returns the name of an enum value.
      * @param {yfiles.lang.Class} type The type of the enum.
      * @param {yfiles.lang.Enum} value The value of the field.
      * @return {string} The name of the field.
      */
      getName(type:yfiles.lang.Class,value:yfiles.lang.Enum):string;
      /**
      * Returns a list of all numeric values.
      * @param {yfiles.lang.Class} type The type of the enum.
      * @return {yfiles.collections.IEnumerable.<Object>} A list of all numeric values.
      */
      getValues(type:yfiles.lang.Class):yfiles.collections.IEnumerable<Object>;
      /**
      * Returns a list of all field names that represent an enum value.
      * @param {yfiles.lang.Class} type The type of the enum.
      * @return {yfiles.collections.IEnumerable.<Object>} A list of all field names that represent an enum value.
      */
      getValueNames(type:yfiles.lang.Class):yfiles.collections.IEnumerable<Object>;
    };
    /**
    * Base type for types that provide value type semantics, which means that they
    *  are cloned when their containing type is cloned.
    * <p>
    *  They provide a static {@link yfiles.lang.Struct#createDefault} method that can be used to create an instance
    *   of an struct where all of its values are set to their default without using any of its constructors.
    *  </p>
    *  <p>
    *  Besides those properties, they can be treated like any other class, i.e. they can implement {@link yfiles.lang.Trait Traits} and can
    *  be tested with <code>a instanceof A</code> and <code>A.$class.isInstance(a)</code>.
    *  </p>
    * @see {@link yfiles.lang.Struct#createDefault}
    */
    export interface Struct extends Object{
      /**
      * Tests whether another object is equal to this struct.
      * As opposed to the implementation of {@link yfiles.lang.Object_Interface}, this implementation
      * tests the members of both objects to determine equality.
      * @param {Object} other The other struct.
      * @return {boolean} <code>true</code>, if both objects are equal; <code>false</code> otherwise.
      */
      equals(other:Object):boolean;
      /**
      * Calculates the hash code of this struct based on its members.
      * @return {number} The hash code.
      */
      hashCode():number;
    }
    var Struct:{
      $class:yfiles.lang.Class;
      /**
      * This methods creates an instance of the struct in which all of its values are set to their default values without
      *  using any of its constructors.
      */
      createDefault():Object;
    };
    /**
    * Wrapper around JavaScript function objects.
    * Compared with plain JavaScript functions,
    * <ul>
    * <li>delegates can be bound to a different target, which acts as <code>this</code> in the delegate function body,</li>
    * <li>multiple delegates can be combined into a single delegate instance, which provides multicast functionality.</li>
    * </ul>
    */
    export interface delegate extends Object{
    }
    var delegate:{
      $class:yfiles.lang.Class;
      /**
      * Apply <code>function</code> in the <b>current</b> execution context.
      * @param {yfiles.lang.delegate} function The function to execute.
      * @param {Object[]} args Optional function arguments.
      * @return {Object} The result from invoking <code>function</code>.
      */
      dynamicInvoke(a:yfiles.lang.delegate,args:Object[]):Object;
      /**
      * Creates a new delegate from the given <code>functions</code> and the execution target.
      * When the delegate is executed, the <code>functions</code> will be <code>applied</code> on <code>target</code>, independent from the current closure.
      * If multiple functions are specified, they will all be applied in order.
      * @param {yfiles.lang.delegate[]} functions The functions from which the delegate should be created.
      * @param {Object} target The target object on which the <code>functions</code> should be applied.
      * @return {yfiles.lang.delegate} A new delegate.
      */
      createDelegate(functions:yfiles.lang.delegate[],target:Object):yfiles.lang.delegate;
      /**
      * Return a list of all delegates that are combined into <code>del</code>.
      * @param {yfiles.lang.delegate} del The delegate to test.
      * @return {yfiles.lang.delegate[]} A list of all delegates that are combined into <code>del</code>.
      */
      getInvocationList(del:yfiles.lang.delegate):yfiles.lang.delegate[];
      /**
      * Combines two delegates into a single one.
      * @param {yfiles.lang.delegate} d1 One of the delegates to combine.
      * @param {yfiles.lang.delegate} d2 One of the delegates to combine.
      * @return {yfiles.lang.delegate} A delegate that combines both original delegates.
      */
      combine(d1:yfiles.lang.delegate,d2:yfiles.lang.delegate):yfiles.lang.delegate;
      /**
      * Removes the first occurrence of <code>d2</code> from the {@link yfiles.lang.delegate#getInvocationList invocation list} of <code>d1</code>.
      * @param {yfiles.lang.delegate} d1 The delegate that should be modified.
      * @param {yfiles.lang.delegate} d2 The delegate that should be removed.
      * @return {yfiles.lang.delegate} The modified delegate <code>d1</code>.
      */
      remove(d1:yfiles.lang.delegate,d2:yfiles.lang.delegate):yfiles.lang.delegate;
      /**
      * Removes all occurrences of <code>d2</code> from the {@link yfiles.lang.delegate#getInvocationList invocation list} of <code>d1</code>.
      * @param {yfiles.lang.delegate} d1 The delegate that should be modified.
      * @param {yfiles.lang.delegate} d2 The delegate that should be removed.
      * @return {yfiles.lang.delegate} The modified delegate <code>d1</code>.
      */
      removeAll(d1:yfiles.lang.delegate,d2:yfiles.lang.delegate):yfiles.lang.delegate;
    };
    /**
    * A trait is an interface that may or may not have default implementations of its
    * methods, properties and fields.
    * <p>
    * Traits have very specific rules in case two traits with the same member are implemented by a subtype:
    * <ul>
    *     <li>If both method definitions are abstract, then the method is abstract.</li>
    *     <li>If one method definition is abstract and the other concrete, then the concrete method is used.</li>
    *     <li>If both method definitions are concrete:
    *      <ul>
    *          <li>If the traits are implemented at the same level, then the method is abstract.</li>
    *          <li>If one of the traits is a sub-type of the other, then its method definition will be used.</li>
    *      </ul>
    *     </li>
    * </ul>
    * </p>
    * <p>
    * In all of those cases, the rule is that a subtype overrides the parent types' definitions.
    * Example: Given the traits A, B, C and D where A defines a method "a" to be abstract and B and C extending
    * trait A with concrete implementations of "a", when D is a trait that implements both B and C, its version of
    * "a" will be abstract, unless it defines its own implementation of "a", in which case that definition is used.
    * </p>
    * <p>
    * All trait types have a <code>$class</code> property, which contains their {@link yfiles.lang.Class type}, and
    * a static {@link yfiles.lang.Trait#isTrait} method that can be used to test whether an object implements the trait.
    * </p>
    */
    export interface Trait extends Object{
    }
    var Trait:{
      $class:yfiles.lang.Class;
      /**
      * Tests whether the given object is a trait.
      * This method is equivalent to using <code>obj.$class.isTrait</code> but safe in case the object does not have a
      * <code>$class</code> property.
      * @param {Object} o The trait candidate.
      * @return {boolean} <code>true</code>, if the object is a trait; <code>false</code> otherwise.
      */
      isTrait(o:Object):boolean;
    };
    /**
    * An Assembly is a top-level namespace that may contain {@link yfiles.lang.Attribute}s.
    */
    export interface Assembly extends Object{
      /**
      * The fully qualified name of the assembly.
      */
      fullName:string;
      /**
      * Returns all {@link yfiles.lang.Attribute}s registered for this assembly.
      * @param {boolean} inherit 
      * @return {yfiles.lang.Attribute[]} All attributes registered for this assembly.
      */
      getCustomAttributes(inherit:boolean):yfiles.lang.Attribute[];
      /**
      * Returns all {@link yfiles.lang.Attribute}s registered for this assembly that are instances of the given <code>type</code>.
      * @param {yfiles.lang.Class} type The type of the attribute.
      * @param {boolean} inherit 
      * @return {yfiles.lang.Attribute[]} All attributes registered for this assembly that are instances of the given type.
      */
      getCustomAttributesOfType(type:yfiles.lang.Class,inherit:boolean):yfiles.lang.Attribute[];
      /**
      * Returns the {@link yfiles.lang.Class} object for <code>name</code>, if such a type is defined in the assembly's namespace.
      * @param {string} name The fully qualified name of the type.
      * @param {boolean} throwError 
      * @return {yfiles.lang.Class} Returns the specified type, or <code>null</code> if no such type is defined.
      */
      getType(name:string,throwError:boolean):yfiles.lang.Class;
      /**
      * Tests if an {@link yfiles.lang.Attribute} of the given <code>type</code> is defined for this Assembly.
      * @param {yfiles.lang.Class} type The attribute type.
      * @return {boolean} <code>true</code>, if an attribute of the type is defined for this assembly; <code>false</code> otherwise.
      */
      isDefined(type:yfiles.lang.Class):boolean;
    }
    var Assembly:{
      $class:yfiles.lang.Class;
      /**
      * Returns the primary assembly.
      * @return {yfiles.lang.Assembly} The primary assembly.
      */
      getExecutingAssembly():yfiles.lang.Assembly;
    };
    /**
    * Wrapper class for the JavaScript <code>boolean</code> primitive type.
    */
    export interface Boolean extends Object,yfiles.lang.IComparable<yfiles.lang.Boolean>,yfiles.lang.IObjectComparable{
      /**
      * Compares this boolean with another one.
      * @param {yfiles.lang.Boolean} obj The other boolean to compare with.
      * @return {number} <code>0</code> if both booleans are equal, <code>-1</code> if this boolean is <code>false</code> and the other is <code>true</code>, <code>1</code> otherwise.
      * @see Specified by {@link yfiles.lang.IComparable#compareTo}.
      */
      compareTo(obj:yfiles.lang.Boolean):number;
      /**
      * Compares this boolean with another object.
      * @param {Object} obj The other object to compare with.
      * @return {number} <code>0</code> if both booleans are equal, <code>-1</code> if this boolean is <code>false</code> and the other is <code>true</code>, <code>1</code> otherwise.
      * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
      */
      compareToObject(obj:Object):number;
    }
    var Boolean:{
      $class:yfiles.lang.Class;
    };
    /**
    * This type represents an abstract value, that is a function that is not implemented.
    */
    export interface Abstract extends Object{
    }
    var Abstract:{
      $class:yfiles.lang.Class;
      /**
      * Tests whether the given object or property descriptor is a representation of an abstract value.
      * @param {Object} o The object to test.
      * @return {boolean} <code>true</code>, if the object is abstract; <code>false</code> otherwise.
      */
      isAbstract(o:Object):boolean;
    };
    /**
    * The root of the class hierarchy of the yFiles for HTML class framework.
    * Two of these methods are actually defined on the native JavaScript <code>object</code> prototype:
    * <ul>
    * <li>{@link yfiles.lang.Object_Interface#hashCode}</li>
    * <li>{@link yfiles.lang.Object_Interface#equals}</li>
    * </ul>
    * The other methods are part of the {@link yfiles.lang.Object_Interface} type, only.
    */
    export interface Object_Interface extends Object{
      /**
      * Returns the hash code of this object.
      * If two objects are {@link yfiles.lang.Object_Interface#equals equal}, then they must have the same hash code.
      * @return {number} The hash code of this object.
      */
      hashCode():number;
      /**
      * Tests whether this object and the other object are equal.
      * @param {Object} other The tested object.
      * @return {boolean} <code>true</code>, if the objects are equal; <code>false</code> otherwise.
      */
      equals(other:Object):boolean;
      /**
      * Returns the type of this object.
      * @return {yfiles.lang.Class} The type of this object.
      */
      getClass():yfiles.lang.Class;
      /**
      * Shallow clones an object. It will also clone any value types.
      * @return {Object} A cloned instance of the same type.
      */
      memberwiseClone():Object;
      /**
      * Displays the textual representation of the object.
      * @return {string} The textual representation of this object.
      */
      toString():string;
      /**
      * Returns an object with a get and/or a set method that is optionally bound to this instance.
      * The requested <code>name</code> must be a property (with getter and/or setter).
      * @param {string} name The name of the property.
      * @param {boolean} bound If <code>true</code>, then the get/set methods of the returned object will be bound to this instance.
      * @return {Object} An object with a get and/or set method that reads/writes to the specified field.
      */
      getOwnProperty(name:string,bound:boolean):Object;
    }
    var Object_Interface:{
      $class:yfiles.lang.Class;
      /**
      * Tests if two objects are equal.
      * @param {Object} a One of the objects. Can be null or of any type.
      * @param {Object} b One of the objects. Can be null or of any type.
      * @return {boolean} <code>true</code>, if the objects are equal; <code>false</code> otherwise.
      */
      equals(a:Object,b:Object):boolean;
      /**
      * Tests if two objects are identical.
      * @param {Object} a One of the objects.
      * @param {Object} b One of the objects.
      * @return {boolean} <code>true</code>, if the objects are the identical; <code>false</code> otherwise.
      */
      referenceEquals(a:Object,b:Object):boolean;
      /**
      * Returns the most recently defined property descriptor in the prototype chain of the given object.
      * @param {Object} o The object that the property belongs to
      * @param {string} name The name of the property.
      * @return {Object} The most recently defined property descriptor in the prototype chain of the given object.
      */
      getPropertyDescriptor(o:Object,name:string):Object;
    };
    /**
    * A function that transforms a class definition object into a class type.
    * <p>
    * The class definition object may contain any of the following special identifiers:
    * <ul>
    *     <li><code>$extends</code>: An object reference that points to the parent object.</li>
    *     <li><code>$with</code>: An array of traits this class implements.</li>
    *     <li><code>$abstract</code>: A boolean value that indicates whether or not this class is abstract.</li>
    *     <li><code>$static</code>: An object that contains methods, fields and properties that should
    *          be statically available and will be registered on the constructor function instead of
    *          its prototype.</li>
    *     <li><code>$meta</code>: An array of {@link yfiles.lang.Attribute}s or a function that returns an array of
    *          {@link yfiles.lang.Attribute}s that describe the class.</li>
    * </ul>
    * </p>
    * <p>
    * Additionally, it may contain methods, properties and fields that should be added to the constructor functions prototype.
    * If the value of an field is an object with a <code>$meta</code> property, then it will be used as a
    * property descriptor for the field (meaning that <code>writable</code>, <code>enumerable</code> and <code>configurable</code>, <code>value</code> and <code>get</code>, <code>set</code>
    * can be used as in a property descriptor for <code>Object.defineProperty</code>
    * and the value of the <code>$meta</code> property is stored for usage in the reflection API.
    * If the object has a <code>get</code> and/or <code>set</code> property, then it will also be used as a property descriptor.
    * <pre><code>
    *     var MyList = yfiles.lang.Class('MyList', {
    *         $extends: my.AbstractList,
    *         $with: [my.Iterable, my.Collection],
    *         constructor: function() { // the constructor function
    *         },
    *         add: function(obj) { ... },
    *         size: { // transformed into a property
    *          'get': function() { return ...; }
    *         },
    *         $static: {
    *          create: function() { ... }
    *         }
    *     });
    *     // usage
    *     var list = new MyList();
    *     list.add("hello");
    *     list.size === 1; // true
    * </code></pre>
    * </p>
    * <p>
    * The constructor property can be either a function (in case of a single constructor) or an object
    * that is transformed into named constructors.
    * <pre><code>
    *     var Rect = yfiles.lang.Class('Rect', {
    *      constructor: {
    *          'default': function(x, y, width, height) { ... },
    *          'FromPoints': function(topLeft, bottomRight) { ... },
    *          'FromPoint': function(topLeft, width, height) { ... }
    *      }
    *     });
    *     // usage:
    *     var myrect = new Rect(10, 10, 50, 50);
    *     myrect instanceof Rect; // true
    *     myrect = new Rect.FromPoints({x: 10, y: 10}, {x: 60, y: 60});
    *     myrect instanceof Rect; // true
    *     myrect = new Rect.FromPoint({x: 10, y: 10}, 50, 50);
    *     myrect instanceof Rect; // true
    * </code></pre>
    * Named constructors can call other constructors and can be written like any other constructor,
    * i.e. <code>this</code> will be a new instance of the class that is being constructed.
    * </p>
    * <p>
    * To access super methods, you can use the static <code>$super</code> property that is added to all classes.
    * Example (inside a method or property of the previously defined Rect class):
    * <pre><code>Rect.$super.toString.call(this);</code></pre>
    * If you do not specify the parent class of a new class, then {@link yfiles.lang.Object_Interface} will be used as its
    * base type.
    * The parent class of {@link yfiles.lang.Object_Interface} is the standard JavaScript <code>Object.prototype</code>.
    * Every class has a couple of static methods and properties:
    * <ul>
    *     <li>{@link yfiles.lang.Class#isInstance}: tests whether an object is an instance of this class.</li>
    *     <li><code>$class</code>: a reference to the {@link yfiles.lang.Class} instance that provides reflective information
    *     about this type.</li>
    *     <li><code>$super</code>: the parent class.</li>
    * </ul>
    * </p>
    */
    export interface Class extends Object{
      /**
      * Returns a type that describes an array with the specified dimensions and this type as element type.
      * @param {number} rank The dimension of the array type
      * @return {yfiles.lang.Class} A type that describes an array with the specified dimensions and this type as element type.
      */
      makeArrayType(rank:number):yfiles.lang.Class;
      /**
      * Returns the dimension of this type if it is an array type or <code>0</code>, otherwise.
      * @return {number} The dimension of this type if it is an array type or <code>0</code>, otherwise.
      */
      getArrayRank():number;
      /**
      * Returns the type of the members of this type is an array, otherwise the type itself.
      * @return {yfiles.lang.Class} The type of the members of this type is an array, otherwise the type itself.
      */
      getElementType():yfiles.lang.Class;
      /**
      * A reference to the type itself.
      * @return {yfiles.lang.Class} 
      */
      clone():yfiles.lang.Class;
      /**
      * Tests whether an object is an instance of this type.
      * This is the only way to test if an object implements a {@link yfiles.lang.Trait}.
      * @param {Object} o The object that may be an instance of this type.
      * @return {boolean} <code>true</code>, if the object is an instance of this type; <code>false</code> otherwise.
      */
      isInstance(o:Object):boolean;
      /**
      * Tests whether or not this type is a sub type of the given type.
      * @param {yfiles.lang.Class} c The parent type candidate.
      * @return {boolean}  <code>true</code>, if this type is a sub type of the given type; <code>false</code> otherwise.
      */
      isSubclassOf(c:yfiles.lang.Class):boolean;
      /**
      * Tests whether this type is a parent type of the given type.
      * @param {yfiles.lang.Class} c The sub type candidate.
      * @return {boolean} <code>true</code>, if this type is a sub type of the given type; <code>false</code> otherwise.
      */
      isAssignableFrom(c:yfiles.lang.Class):boolean;
      /**
      * The direct parent type of this type (not including {@link yfiles.lang.Trait}s or <code>null</code>,
      * if no parent type exists.
      */
      baseType:yfiles.lang.Class;
      /**
      * The {@link yfiles.lang.Assembly} that this type belongs to.
      */
      assembly:yfiles.lang.Assembly;
      /**
      * <code>true</code>, if this type represents a true class; <code>false</code> otherwise.
      */
      isClass:boolean;
      /**
      * <code>true</code>, if this type represents an enum; <code>false</code> otherwise.
      */
      isEnum:boolean;
      /**
      * <code>true</code>, if this type represents a {@link yfiles.lang.Trait}; <code>false</code> otherwise.
      */
      isInterface:boolean;
      /**
      * <code>true</code>, if this type represents a primitive type; <code>false</code> otherwise.
      * The primitive types are: number, string and boolean.
      */
      isPrimitive:boolean;
      /**
      * <code>true</code>, if this type has public visibility; <code>false</code> otherwise.
      */
      isPublic:boolean;
      /**
      * <code>true</code>, if this type represents a value type; <code>false</code> otherwise.
      * A value type is either a primitive or an instance of a {@link yfiles.lang.Struct}.
      */
      isValueType:boolean;
      /**
      * Creates a new instance of this type using its default constructor.
      * @return {Object} A new instance of this type using its default constructor.
      */
      newInstance():Object;
      /**
      * Returns a filtered list of all interfaces implemented by this type.
      * @param {function(yfiles.lang.Class):boolean} filter A function that takes a {@link yfiles.lang.Class} and the <code>filterCriteria</code> parameter
      *          and returns <code>true</code>, if the interface type should be returned and <code>false</code> otherwise.
      * @param {Object} filterCriteria An optional criteria object that should be passed to the filter function.
      * @return {yfiles.lang.Trait[]} An array of all implemented interfaces that pass the specified filter.
      */
      findInterfaces(filter:(obj:yfiles.lang.Class)=>boolean,filterCriteria:Object):yfiles.lang.Trait[];
      /**
      * Returns a list of all interfaces implemented by this type.
      * @return {yfiles.lang.Trait[]} A list of all interfaces implemented by this type.
      */
      getInterfaces():yfiles.lang.Trait[];
      /**
      * Finds all members of the specified type that match the criteria.
      * @param {yfiles.lang.Class} type  The type that is being reflected.
      * @param {yfiles.system.MemberTypes} memberType  The types of interesting members.
      * @param {yfiles.system.BindingFlags} bindingAttr  A flag that specifies attributes that members must match.
      * @param {function(yfiles.system.MemberInfo):boolean} filter  An optional function that takes a {@link yfiles.system.MemberInfo} and
      *         the filterCriteria object and returns <code>true</code> if the member should be accepted.
      * @param {Object} filterCriteria  An optional criteria object that should be passed to the filter function.
      * @return {yfiles.system.MemberInfo[]}  An array of members that match the specified criteria.
      */
      findMembers(type:yfiles.lang.Class,memberType:yfiles.system.MemberTypes,bindingAttr:yfiles.system.BindingFlags,filter:(obj:yfiles.system.MemberInfo)=>boolean,filterCriteria:Object):yfiles.system.MemberInfo[];
      /**
      * If <code>flags</code> is undefined or <code>null</code>, returns all members that are public and belong to the type itself and not its parent type,
      * otherwise, the members that match the specified {@link yfiles.system.BindingFlags}.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.system.MemberInfo[]} The members that match the criteria.
      */
      getMembers(flags:yfiles.system.BindingFlags):yfiles.system.MemberInfo[];
      /**
      * Returns a member with the given <code>memberName</code>.
      * If <code>flags</code> is undefined or <code>null</code>, the member must be public and belong to the type itself and not its parent type,
      * otherwise, the member must match the specified {@link yfiles.system.BindingFlags}.
      * @param {string} memberName The name of the member.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.system.MemberInfo} The member with the given name that matches the criteria.
      */
      getMember(memberName:string,flags:yfiles.system.BindingFlags):yfiles.system.MemberInfo;
      /**
      * Returns a list of all constructors of the type. If <code>flags</code> is undefined or <code>null</code>, returns all constructors that are public,
      * otherwise, the constructors that match the specified {@link yfiles.system.BindingFlags}.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.system.ConstructorInfo[]} An array of constructors.
      */
      getConstructors(flags:yfiles.system.BindingFlags):yfiles.system.ConstructorInfo[];
      /**
      * Returns a list of all fields of the type. If <code>flags</code> is undefined or <code>null</code>, returns all fields that are public.
      * Otherwise, the fields that match the specified {@link yfiles.system.BindingFlags}.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.system.FieldInfo[]} An array of fields.
      */
      getFields(flags:yfiles.system.BindingFlags):yfiles.system.FieldInfo[];
      /**
      * Returns a field with the given <code>memberName</code>.
      * If <code>flags</code> is undefined or <code>null</code>, the field must be public and belong to the type itself and not its parent type.
      * Otherwise, the field must match the specified {@link yfiles.system.BindingFlags}.
      * @param {string} memberName The name of the field.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.system.FieldInfo} The field with the given name that matches the criteria.
      */
      getField(memberName:string,flags:yfiles.system.BindingFlags):yfiles.system.FieldInfo;
      /**
      * Returns a list of all methods of the type. If <code>flags</code> is undefined or <code>null</code>, returns all methods that are public.
      * Otherwise, the methods that match the specified {@link yfiles.system.BindingFlags}.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.system.MethodInfo[]} An array of methods.
      */
      getMethods(flags:yfiles.system.BindingFlags):yfiles.system.MethodInfo[];
      /**
      * Returns a method with the given <code>memberName</code> and <code>argTypes</code>.
      * If <code>flags</code> is undefined or <code>null</code>, the method must be public and belong to the type itself and not its parent type.
      * Otherwise, the method must match the specified {@link yfiles.system.BindingFlags}.
      * @param {string} memberName The name of the method.
      * @param {yfiles.lang.Class[]} argTypes The argument types of the method.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.system.MemberInfo} The method with the given name that matches the criteria.
      */
      getMethod(memberName:string,argTypes:yfiles.lang.Class[],flags:yfiles.system.BindingFlags):yfiles.system.MemberInfo;
      /**
      * Returns a list of all nested types of the type. If <code>flags</code> is undefined or <code>null</code>, returns all nested types that are public.
      * Otherwise, the nested types that match the specified {@link yfiles.system.BindingFlags}.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.lang.Class[]} An array of nested types.
      */
      getNestedTypes(flags:yfiles.system.BindingFlags):yfiles.lang.Class[];
      /**
      * Returns a nested type with the given <code>memberName</code>.
      * If <code>flags</code> is undefined or <code>null</code>, the nested type must be public and belong to the type itself and not its parent type.
      * Otherwise, the nested type must match the specified {@link yfiles.system.BindingFlags}.
      * @param {string} memberName The name of the nested type.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.lang.Class} The nested type with the given name that matches the criteria.
      */
      getNestedType(memberName:string,flags:yfiles.system.BindingFlags):yfiles.lang.Class;
      /**
      * Returns a list of all properties of the type. If <code>flags</code> is undefined or <code>null</code>, returns all properties that are public.
      * Otherwise, the properties that match the specified {@link yfiles.system.BindingFlags}.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.system.PropertyInfo[]} An array of properties.
      */
      getProperties(flags:yfiles.system.BindingFlags):yfiles.system.PropertyInfo[];
      /**
      * Returns a property with the given <code>memberName</code> and <code>type</code>.
      * If <code>flags</code> is undefined or <code>null</code>, the property must be public and belong to the type itself and not its parent type.
      * Otherwise, the property must match the specified {@link yfiles.system.BindingFlags}.
      * @param {string} memberName The name of the property.
      * @param {yfiles.lang.Class} type The name of the property.
      * @param {yfiles.lang.Class[]} indexerTypes Unused.
      * @param {yfiles.system.BindingFlags} flags The optional binding flags.
      * @return {yfiles.system.PropertyInfo} The property with the given name that matches the criteria.
      */
      getProperty(memberName:string,type:yfiles.lang.Class,indexerTypes:yfiles.lang.Class[],flags:yfiles.system.BindingFlags):yfiles.system.PropertyInfo;
      /**
      * The default constructor function of this type that contains all of its static members and the prototype chain link.
      */
      object:Object;
      /**
      * Returns all attributes that belong to this type.
      * @param {boolean} inherit If <code>true</code>, then the attributes of the parent types are also
      *   added to the list. Default value is <code>false</code>.
      * @return {yfiles.lang.Attribute[]} A list of attributes that belong to this type.
      */
      getCustomAttributes(inherit:boolean):yfiles.lang.Attribute[];
      /**
      * Tests whether this type has an {@link yfiles.lang.Attribute} of the specified <code>attributeType</code>.
      * @param {yfiles.lang.Class} attributeType The type of the attribute that is tested.
      * @param {boolean} inherit If <code>true</code>, then the attributes of the parent types are also considered. Default value is <code>false</code>.
      * @return {boolean} Whether this type has an {@link yfiles.lang.Attribute} of the specified <code>attributeType</code>.
      */
      isDefined(attributeType:yfiles.lang.Class,inherit:boolean):boolean;
      /**
      * The type of the reflected type.
      */
      memberType:yfiles.system.MemberTypes;
      /**
      * The short name of this class.
      */
      name:string;
      /**
      * The fully qualified of this class.
      */
      fullName:string;
      /**
      * The namespace of this class.
      */
      namespace:string;
      /**
      * Identifier for the type: "Class", "Enum" or "Trait".
      */
      type:string;
      /**
      * The type that is being accessed via reflection.
      * This is always the type instance itself
      */
      reflectedType:yfiles.lang.Class;
      /**
      * Returns all attributes that belong to this type and are instances of the specified <code>attributeType</code>.
      * @param {yfiles.lang.Class} attributeType The type that all matched attributes should implement.
      * @param {boolean} inherit If <code>true</code>, then the attributes of the parent types are also added to the list. Default value is <code>false</code>.
      * @return {yfiles.lang.Attribute[]} A list of attributes that belong to this type and are instances of the specified attribute.
      */
      getCustomAttributesOfType(attributeType:yfiles.lang.Class,inherit:boolean):yfiles.lang.Attribute[];
      /**
      * Returns the {@link yfiles.lang.Attribute}s of the member with the given name.
      * The {@link yfiles.lang.Attribute}s are not evaluated unless this method is invoked.
      * @param {string} name The name of the member whose properties are to be provided.
      * @return {yfiles.lang.Attribute[]} A list of attributes for the specified member.
      */
      getAttributesFor(name:string):yfiles.lang.Attribute[];
    }
    var Class:{
      $class:yfiles.lang.Class;
      /**
      * Returns the class object for the given name, or <code>null</code> if no such class exists.
      * @param {string} name The name of the requested class.
      * @return {yfiles.lang.Class} The class object or <code>null</code>, if no such class exists.
      */
      forName(name:string):yfiles.lang.Class;
      /**
      * Returns a list of all assemblies, where an assembly is defined as a top-level namespace.
      * @return {yfiles.lang.Assembly[]} An array of assembly objects.
      */
      getAssemblies():yfiles.lang.Assembly[];
      /**
      * Modify an existing object <code>obj</code> that is not created
      * with the help of the yfiles class framework to be usable with our library functions.
      * This method modifies a given object <code>obj</code> in the following ways:
      * <ul>
      * <li>Methods and properties that implement member declarations of the <code>traits</code> are callable
      * from yfiles library code.</li>
      * <li>For each interface <code>trait</code> in <code>traits</code>, <code>trait.isInstance(obj)</code> is true.</li>
      * </ul>
      * Note that this method does not enable extended usages, e.g. <code>obj</code> does not implement the full reflection API necessary for GraphML
      * serialization, and it is not possible to inject actual classes as opposed to interfaces.
      * To modify an object on an instance level:
      * <pre><code>
      * //Create a plain JavaScript object
      * var myHitTestable = {};
      * myHitTestable.isHit = function(p, ctx) { return false; };
      * myHitTestable.lookup = function(clazz) { return null; };
      * //Modify
      * yfiles.lang.Class.injectInterfaces(myHitTestable, [yfiles.drawing.IHitTestable, yfiles.support.ILookup]);
      * //These are equally valid:
      * //yfiles.lang.Class.injectInterfaces(myHitTestable, ["yfiles.drawing.IHitTestable", "yfiles.support.ILookup"]);
      * //yfiles.lang.Class.injectInterfaces(myHitTestable, [yfiles.drawing.IHitTestable.$class, yfiles.support.ILookup.$class]);
      * //As well as using a variable number of arguments, such as:
      * //yfiles.lang.Class.injectInterfaces(myHitTestable, yfiles.drawing.IHitTestable, yfiles.support.ILookup);
      * //This is true now:
      * yfiles.drawing.IHitTestable.isInstance(myHitTestable);
      * //And the object can be used where an interface instance is expected:
      * graphEditorInputMode.clickInputMode.validClickHitTestable = myHitTestable;
      * </code></pre> 
      * It is also possible to modify an object prototype, e.g. in TypeScript:
      * Class definition:
      * <pre><code> 
      * export class MyHitTestable implements yfiles.drawing.IHitTestable {
      *    isHit(p: yfiles.geometry.PointD, ctx: yfiles.canvas.ICanvasContext): boolean {
      *        return false;
      *    }
      * }
      * </code></pre>
      * Usage:
      * <pre><code>
      * //This is false:
      * //yfiles.drawing.IHitTestable.isInstance(new MyHitTestable());
      * //Modify
      * yfiles.lang.Class.injectInterfaces(MyHitTestable.prototype, [yfiles.drawing.IHitTestable]);
      * //Now it is true
      * var myHitTestable = new MyHitTestable();
      * yfiles.drawing.IHitTestable.isInstance(myHitTestable);
      * //And the object can be used where an interface instance is expected:
      * graphEditorInputMode.clickInputMode.validClickHitTestable = myHitTestable;
      * </code></pre>
      * @param {Object} obj The object to modify.
      * @param {Object[]} traits Array or variable number of {@link yfiles.lang.Trait}s, {@link yfiles.lang.Class} objects of traits or fully qualified string
      * names of traits.
      */
      injectInterfaces(obj:Object,traits:Object[]):void;
    };
    /**
    * Wrapper class for the JavaScript <code>string</code> primitive type.
    */
    export interface String extends Object,yfiles.lang.IComparable<yfiles.lang.String>,yfiles.lang.IObjectComparable{
      /**
      * Compares this string with another one.
      * @param {yfiles.lang.String} obj The other string to compare with.
      * @return {number} <code>0</code> if both strings are equal, <code>-1</code> if this string comes before the other one in lexicographic sort order, <code>1</code> otherwise.
      * @see Specified by {@link yfiles.lang.IComparable#compareTo}.
      */
      compareTo(obj:yfiles.lang.String):number;
      /**
      * Compares this string with another one.
      * @param {Object} obj The other string to compare with.
      * @return {number} <code>0</code> if both strings are equal, <code>-1</code> if this string comes before the other one in lexicographic sort order, <code>1</code> otherwise.
      * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
      */
      compareToObject(obj:Object):number;
    }
    var String:{
      $class:yfiles.lang.Class;
    };
    /**
    * Wrapper class for the JavaScript <code>number</code> primitive type.
    */
    export interface Number extends Object,yfiles.lang.IComparable<yfiles.lang.Number>,yfiles.lang.IObjectComparable{
      /**
      * Compares this number with another one.
      * @param {yfiles.lang.Number} obj The other number to compare with.
      * @return {number} <code>0</code> if both numbers are equal, <code>-1</code> if this number is smaller than the other one, <code>1</code> otherwise.
      * @see Specified by {@link yfiles.lang.IComparable#compareTo}.
      */
      compareTo(obj:yfiles.lang.Number):number;
      /**
      * Compares this number with another object.
      * @param {Object} obj The other object to compare with.
      * @return {number} <code>0</code> if both numbers are equal, <code>-1</code> if this number is smaller than the other one, <code>1</code> otherwise.
      * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
      */
      compareToObject(obj:Object):number;
    }
    var Number:{
      $class:yfiles.lang.Class;
    };
    /**
    * Specialized type that can be used to describe meta information about other types, methods, fields, properties and constructors.
    * <p>All attributes extend {@link yfiles.lang.Attribute} or a subtype of an attribute. 
    * They can also implement {@link yfiles.lang.Trait Traits}.</p>
    * <p>The actual creation of an attribute is delayed to the point in time when it is needed by the reflection API.
    * Therefore, the attribute constructors are wrapped and replaced by a function that creates an instance of the attribute.
    * <pre><code>
    * var MyAttribute = yfiles.lang.Attribute('MyAttribute', {
    *  constructor: function(message) {
    *      this.message = message;
    *  }
    * });
    * var MyClass = yfiles.lang.Class('MyClass', {
    *  $meta: [MyAttribute('hello').init(recipient: 'world')]
    * });
    * var attr = yfiles.lang.Attribute.getCustomAttribute(MyClass.$class, MyAttribute.$class);
    * console.log(attr.message + ' ' + attr.recipient); // 'hello world'
    * </code></pre>
    * Even though MyAttribute is invoked at the definition of MyClass, no attribute is created until
    * the reflection API is used (in the above example: using {@link yfiles.lang.Attribute#getCustomAttribute}).</p>
    * <p>
    * The result of the constructor function of an attribute is a function, that, when invoked, returns
    * an instance of the attribute. It also provides an init method that adds the properties of the given object
    * to the attribute.
    * </p>
    * <p>
    * <b>Note:</b> Attribute constructors are always called <b>without</b> the <code>new</code> keyword.
    * </p>
    */
    export interface Attribute extends Object{
    }
    var Attribute:{
      $class:yfiles.lang.Class;
      /**
      * Constructor for a new attribute definition.
      * <p>The constructor is wrapped and replaced by function that create an instance of the attribute to delay
      * the actual creation to the point in time when it is needed by the reflection API.
      * <pre><code>
      * var MyAttribute = yfiles.lang.Attribute('MyAttribute', {
      *  constructor: function(message) {
      *      this.message = message;
      *  }
      * });
      * var MyClass = yfiles.lang.Class('MyClass', {
      *  $meta: [MyAttribute('hello').init(recipient: 'world')]
      * });
      * var attr = yfiles.lang.Attribute.getCustomAttribute(MyClass.$class, MyAttribute.$class);
      * console.log(attr.message + ' ' + attr.recipient); // 'hello world'
      * </code></pre>
      * Even though MyAttribute is invoked at the definition of MyClass, no attribute is created until
      * the reflection API is used (in the above example: using {@link yfiles.lang.Attribute#getCustomAttribute}).</p>
      * <p>
      * The result of the constructor function of an attribute is a function, that, when invoked, returns
      * an instance of the attribute. It also provides an init method that adds the properties of the given object
      * to the attribute.
      * </p>
      * <p>
      * <b>Note:</b> Attribute constructors are always called <b>without</b> the <code>new</code> keyword.
      * </p>
      * @param {string} name The attribute name.
      * @param {Object} definition The attribute definition code.
      */
      new (name:string,definition:Object):yfiles.lang.Attribute;
      /**
      * Returns the first attribute of the given <code>attributeType</code> that is registered for a given member info or type.
      * If none can be found, then <code>null</code> is returned.
      * @param {Object} element The reflection object (type, method, property...) for which to retrieve the attribute.
      * @param {yfiles.lang.Class} attributeType The type of the attribute.
      * @return {yfiles.lang.Attribute} An attribute of the specified <code>attributeType</code>, or <code>null</code> if no such attribute can be found.
      */
      getCustomAttribute(element:Object,attributeType:yfiles.lang.Class):yfiles.lang.Attribute;
    };
    /**
    * Wrapper for the native JavaScript <code>Error</code> type. This class can be used to write custom errors and include a stack trace.
    */
    export interface Exception extends Object{
      /**
      * Gets or sets the exception message.
      */
      message:string;
    }
    var Exception:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new exception with the given message.
      * @param {string} message The exception message.
      * @see {@link yfiles.lang.Exception#message}
      */
      new (message:string):yfiles.lang.Exception;
    };
    /**
    * Provides a method by which implementors can be compared to each other.
    */
    export interface IObjectComparable extends Object{
      /**
      * Compares this object to the given object of the same type.
      * @param {Object} obj The object to compare this to.
      * @return {number} <ul>
      * <li>-1: this is less than <code>obj</code></li>
      * <li>0: this is equal to <code>obj</code></li>
      * <li>1: this is greater than <code>obj</code></li>
      * </ul>
      * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
      */
      compareToObject(obj:Object):number;
    }
    var IObjectComparable:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
  }
  export module layout{
    /**
    * This class can be used as a decorating stage for layout algorithms that
    * cannot handle node groups.
    * Before calling the core layout algorithms, this
    * class will augment the graph structure. For each node that belongs to a group,
    * a so-called "parent-edge" will be temporarily inserted into the graph.
    */
    export interface ParentEdgeAugmentationStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns true if the core layouter can layout the augmented graph.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var ParentEdgeAugmentationStage:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of ParentEdgeAugmentationStage.
      */
      new ():yfiles.layout.ParentEdgeAugmentationStage;
    };
    /**
    * This class is a default implementation of the LabelLayout interface.
    */
    export interface LabelLayoutImpl extends Object,yfiles.layout.ILabelLayout{
      /**
      * The box of the label.
      * @see Specified by {@link yfiles.layout.ILabelLayout#orientedBox}.
      */
      orientedBox:yfiles.algorithms.YOrientedRectangle;
      /**
      * The bounding box of the label.
      * @see Specified by {@link yfiles.layout.ILabelLayout#box}.
      */
      box:yfiles.algorithms.YRectangle;
      /**
      * The label model parameter that describes
      * the position of this label.
      * @see Specified by {@link yfiles.layout.ILabelLayout#modelParameter}.
      */
      modelParameter:Object;
    }
    var LabelLayoutImpl:{
      $class:yfiles.lang.Class;
    };
    /**
    * This interface provides label-specific keys that can
    * be used to add data providers to a layout graph.
    * Label aware layout algorithms like
    * may look for such data providers.
    * Instead of setting up label layout data and data providers one can also use
    * the  layout stage {@link yfiles.layout.LabelLayoutTranslator} to automatically translate
    * information provided by the standard label layout classes {@link yfiles.layout.IEdgeLabelLayout} and
    * {@link yfiles.layout.INodeLabelLayout} to layout data accessible by the keys defined below.
    */
    export interface LabelLayoutKeys extends Object{
    }
    var LabelLayoutKeys:{
      $class:yfiles.lang.Class;
      /**
      * Key that is used to add or access a data provider to a graph that must
      * return for each edge of the graph an array of type {@link yfiles.layout.LabelLayoutData}.
      */
      EDGE_LABEL_LAYOUT_DP_KEY:Object;
      /**
      * Key that is used to add or access a data provider to a graph that must
      * returns for each node of the graph an array of type {@link yfiles.layout.LabelLayoutData}.
      */
      NODE_LABEL_LAYOUT_DP_KEY:Object;
      /**
      * Key that is used to store whether or not a label (i.e., an instance of {@link yfiles.layout.ILabelLayout})
      * should be considered during layout.
      * A label is ignored if the data provider registered with this key is
      * not <code>null</code> and {@link yfiles.algorithms.IDataProvider#getBool} returns <code>true</code>.
      * <p>
      * Currently this key is directly considered by the following layout algorithms:.
      * Furthermore, layout stage {@link yfiles.layout.LabelLayoutTranslator} only translates labels that should not be ignored.
      * </p>
      */
      IGNORE_LABEL_DP_KEY:Object;
    };
    /**
    * Implements the ranking for edge and node labels for Graph2D.
    * Node label positions have no ranking for the moment, they are all
    * equal to 1.
    */
    export interface LabelRanking extends Object,yfiles.layout.IProfitModel{
      /**
      * Returns the profit for placing a label-candidate.
      * Higher profit means higher probability that the candidate is chosen
      * by a labeling algorithm.
      * @param {yfiles.layout.LabelCandidate} candidate a label candidate
      * @return {number} a value between 0 and 1.
      * @see Specified by {@link yfiles.layout.IProfitModel#getProfit}.
      */
      getProfit(candidate:yfiles.layout.LabelCandidate):number;
    }
    var LabelRanking:{
      $class:yfiles.lang.Class;
    };
    /**
    * This class encapsulates layout data for a label.
    * The data is used
    * by clients to inform label aware layouters about labeling constraints like label size and
    * preferred placement. Label aware layouters like 
    * on the other hand return the calculated label positions by assigning the
    * corresponding bounds to the passed in label layout data.
    * Data providers are being used to associate an array of LabelLayoutData with either
    * the nodes or the edges of a layout graph. The data providers must be registered with the
    * input graph by using one of the keys defined in {@link yfiles.layout.LabelLayoutKeys}.
    */
    export interface LabelLayoutData extends Object{
      /**
      * The{@link yfiles.algorithms.YOrientedRectangle  oriented bounds} of the label.
      */
      bounds:yfiles.algorithms.YOrientedRectangle;
      /**
      * Sets the {@link yfiles.algorithms.YOrientedRectangle#width  width} and {@link yfiles.algorithms.YOrientedRectangle#height  height}
      * of the oriented {@link yfiles.layout.LabelLayoutData#bounds  bounds} of this label.
      * Note that {@link yfiles.layout.LabelLayoutData#width} and {@link yfiles.layout.LabelLayoutData#height} in contrast yield the width and height of the bounding
      * box of the oriented bounds, which only coincide with the size of the oriented bounds in the case where the
      * oriented bounds are not rotated.
      */
      setSize(width:number,height:number):void;
      /**
      * The width of the label.
      */
      width:number;
      /**
      * The height of the label.
      */
      height:number;
      /**
      * Sets the coordinates of the upper-left corner of the bounding box of the label.
      */
      setLocation(x:number,y:number):void;
      /**
      * The x-coordinate of the label's upper-left corner of the bounding box.
      */
      x:number;
      /**
      * The y-coordinate of the label's upper-left corner of the bounding box.
      */
      y:number;
      /**
      * The preferred placement for this label.
      */
      preferredPlacement:yfiles.layout.LabelPlacements;
      /**
      * The preferred placement for this label.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified descriptor is
      * <code>null</code>.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor}
      * @see {@link yfiles.layout.LabelPlacements}
      */
      preferredPlacementDescriptor:yfiles.layout.PreferredPlacementDescriptor;
      /**
      * Returns a string representation of this object.
      */
      toString():string;
    }
    var LabelLayoutData:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of LabelLayoutData.
      * {@link yfiles.layout.LabelPlacements#ANYWHERE} is used
      * as preferred placement specifier.
      * @param {number} width the width of the label
      * @param {number} height the height of the label
      */
      FromWidthAndHeight:{
        new (width:number,height:number):yfiles.layout.LabelLayoutData;
      };
      /**
      * Creates a new instance of LabelLayoutData.
      * @param {number} width the width of the label
      * @param {number} height the height of the label
      * @param {yfiles.layout.LabelPlacements} preferredPlacement a preferred placement specifier
      * @see {@link yfiles.layout.LabelLayoutData#preferredPlacement}
      */
      FromWidthHeightWithPreferredPlacement:{
        new (width:number,height:number,preferredPlacement:yfiles.layout.LabelPlacements):yfiles.layout.LabelLayoutData;
      };
      /**
      * Creates a new instance of LabelLayoutData.
      * @param {yfiles.algorithms.YOrientedRectangle} bounds 
      * the {@link yfiles.algorithms.YOrientedRectangle  oriented bounds} of the label
      * @see {@link yfiles.layout.LabelPlacements}
      */
      FromRectangle:{
        new (bounds:yfiles.algorithms.YOrientedRectangle):yfiles.layout.LabelLayoutData;
      };
      /**
      * Creates a new instance of LabelLayoutData.
      * @param {yfiles.algorithms.YOrientedRectangle} bounds 
      * the {@link yfiles.algorithms.YOrientedRectangle  oriented bounds} of the label
      * @param {yfiles.layout.LabelPlacements} preferredPlacement a preferred placement specifier
      * @see {@link yfiles.layout.LabelPlacements}
      * @see {@link yfiles.layout.LabelLayoutData#preferredPlacement}
      */
      FromRectangleWithPreferredPlacement:{
        new (bounds:yfiles.algorithms.YOrientedRectangle,preferredPlacement:yfiles.layout.LabelPlacements):yfiles.layout.LabelLayoutData;
      };
      /**
      * Creates a new instance of LabelLayoutData.
      * @param {yfiles.algorithms.YOrientedRectangle} bounds 
      * the {@link yfiles.algorithms.YOrientedRectangle  oriented bounds} of the label
      * @param {yfiles.layout.PreferredPlacementDescriptor} preferredPlacement a preferred placement specifier
      * @see {@link yfiles.layout.LabelPlacements}
      * @see {@link yfiles.layout.LabelLayoutData#preferredPlacementDescriptor}
      * @throws {yfiles.system.ArgumentException} 
      * if the specified descriptor is
      * <code>null</code>.
      */
      FromRectangleWithPreferredPlacementDescriptor:{
        new (bounds:yfiles.algorithms.YOrientedRectangle,preferredPlacement:yfiles.layout.PreferredPlacementDescriptor):yfiles.layout.LabelLayoutData;
      };
    };
    /**
    * Recursively traverses a hierarchically organized graph in a bottom-up fashion
    * and applies the given layout algorithm (i.e.
    * the core layouter) to the contents (direct children)
    * of each group node.
    * The size of the group nodes can be further determined by setting a customized
    * GroupBoundsCalculator implementation.
    * <p>
    * Note that this class can be run without a core layouter instance.
    * In this case no layout is calculated, instead the group node bounds are merely
    * adjusted to fit their respective contents. There are two alternatives for applying different layout styles
    * to the contents of group nodes:
    * 1. Map each group node to the corresponding layouter using data provider key {@link yfiles.layout.RecursiveGroupLayouter#GROUP_NODE_LAYOUTER_DP_KEY}.
    * The content of the hierarchy root is laid out with the core layouter.
    * 2. Alternatively you can use a {@link yfiles.layout.LayoutMultiplexer} as core layouter.
    * </p>
    */
    export interface RecursiveGroupLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * Whether or not to consider the initial coordinates of the graph elements.
      * This option should be enabled if the recursive group layouter uses a layouter that runs in "from sketch mode".
      * If it is enabled, the recursive group layouter sets the coordinates of the node elements to their initial position
      * before the corresponding layouter is called.
      * By default this option is disabled.
      */
      considerSketch:boolean;
      /**
      * Specifies whether or not temporary port candidates should be inserted for edges without such candidates.
      * If we do not insert such port candidates, inter-edges (edges which traverse the boundary of a group node)
      * always end at the border/center of the corresponding group node and, thus, are routed straight-line
      * (see {@link yfiles.layout.RecursiveGroupLayouter#routeInterEdges}).
      * Hence, enabling this option may produce more suitable edge routes if the layout algorithm applied
      * to the content of a group node can handle port candidates.
      * The default value is <code>false</code>.
      * Note: predefined port candidates are always satisfied, even if this option is disabled
      * (only if the applied layouter supports them).
      * @see {@link yfiles.layout.RecursiveGroupLayouter#routeInterEdges}
      * @see {@link yfiles.layout.RecursiveGroupLayouter#routeInterEdges}
      */
      autoAssignPortCandidates:boolean;
      /**
      * Specifies whether or not port constraints should be temporarily replaced by port candidates.
      * If port constraints are not replaced by port candidates,
      * inter-edges (edges which traverse the boundary of a group node) always end at the border/center of the
      * corresponding group node (even if those edges have port constraints) and, thus, are routed straight-line
      * (see {@link yfiles.layout.RecursiveGroupLayouter#routeInterEdges}) without considering the constraint.
      * Port candidates are automatically redirected to their original location.
      * Hence, enabling this option may produce more suitable edge routes if the layout algorithm
      * applied to the content of a group node can handle port candidates.
      * The default value is <code>true</code>.
      * @see {@link yfiles.layout.RecursiveGroupLayouter#routeInterEdges}
      * @see {@link yfiles.layout.RecursiveGroupLayouter#routeInterEdges}
      */
      replacePortConstraints:boolean;
      /**
      * Specifies whether or not group nodes without children are handled the same
      * way as group nodes with children.
      * Defaults to <code>true</code>.
      * @see {@link yfiles.layout.RecursiveGroupLayouter#routeInterEdges}
      * @see {@link yfiles.layout.RecursiveGroupLayouter#routeInterEdges}
      */
      considerEmptyGroups:boolean;
      /**
      * The current edge router used to layout inter-edges.
      * During layout edges that connect from outside a group
      * node to the content inside (inter-edges) are temporarily connected to the group node itself. Hence, they are routed
      * when the original graph structure is restored using this edge router.
      * <p>
      * It is required that a suitable {@link yfiles.layout.RecursiveGroupLayouter#interEdgesDpKey  selection key} is specified. The same
      * selection key must be used to set the sphere of action for the edge router.
      * </p>
      * <p>
      * By default, no edge router is specified.
      * </p>
      * @see {@link yfiles.layout.RecursiveGroupLayouter#interEdgesDpKey}
      * @see {@link yfiles.layout.RecursiveGroupLayouter#interEdgesDpKey}
      */
      interEdgeRouter:yfiles.layout.ILayouter;
      /**
      * The key that is used to mark the inter-edges to be routed.
      * Note that this layouter automatically marks these edges and registers the DataProvider using the specified key.
      * The key should be used by the specified inter-edge router to obtain the edges to be routed.
      * <p>
      * By default, {@link yfiles.layout.LayouterKeys#SELECTED_EDGES_DP_KEY} is used.
      * </p>
      * @see {@link yfiles.layout.RecursiveGroupLayouter#interEdgeRouter}
      * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
      * @see {@link yfiles.layout.RecursiveGroupLayouter#interEdgeRouter}
      */
      interEdgesDpKey:Object;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * This method is called after calculating the overall layout and reroutes the inter-edges,
      * i.e., edges which traverse the boundary of a group node.
      * More precisely, if those edges do not have port candidates or the applied layout algorithm does not
      * support this kind of constraints,
      * the route of inter-edges always ends at the border/center of the corresponding group node.
      * This method identifies such edges and routes them using the specified edge router. By default, these edges are
      * routed straight-line.
      * @param {yfiles.layout.LayoutGraph} graph the input graph.
      * @param {yfiles.algorithms.EdgeList} interEdges the edges which traverse the boundary of a group node.
      * @see {@link yfiles.layout.RecursiveGroupLayouter#autoAssignPortCandidates}
      * @see {@link yfiles.layout.RecursiveGroupLayouter#replacePortConstraints}
      * @see {@link yfiles.layout.RecursiveGroupLayouter#interEdgeRouter}
      */
      routeInterEdges(graph:yfiles.layout.LayoutGraph,interEdges:yfiles.algorithms.EdgeList):void;
      /**
      * The currently installed GroupBoundsCalculator instance.
      */
      groupBoundsCalculator:yfiles.layout.IGroupBoundsCalculator;
    }
    var RecursiveGroupLayouter:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to retrieve a {@link yfiles.layout.ILayouter}
      * instance for each group node.
      * The specified layouter instance is applied to the content of the group node.
      * For the top level elements the core layouter is used.
      * If the data provider returns "null" the corresponding group node is handled non-recursive, i.e.,
      * the group node and its content is laid out with the {@link yfiles.layout.ILayouter}
      * instance specified by the nearest predecessor of the group node (with respect to the grouping hierarchy) which is associated with a layouter.
      * If the content of a group node should not be changed, the group node can be associated with a "null" layouter,
      * e.g., constant {@link yfiles.layout.RecursiveGroupLayouter#NULL_LAYOUTER}.
      */
      GROUP_NODE_LAYOUTER_DP_KEY:Object;
      /**
      * A constant that represents a layouter implementation that does nothing.
      */
      NULL_LAYOUTER:yfiles.layout.ILayouter;
      /**
      * Creates a new instance of RecursiveGroupLayouter.
      */
      new ():yfiles.layout.RecursiveGroupLayouter;
      /**
      * Creates a new instance of RecursiveGroupLayouter using the given layout
      * algorithm.
      */
      WithCoreLayouter:{
        new (core:yfiles.layout.ILayouter):yfiles.layout.RecursiveGroupLayouter;
      };
      /**
      * Creates a new instance of RecursiveGroupLayouter using the given layout
      * algorithm and GroupBoundsCalculator implementation.
      */
      WithCoreLayouterAndCalculator:{
        new (core:yfiles.layout.ILayouter,gbc:yfiles.layout.IGroupBoundsCalculator):yfiles.layout.RecursiveGroupLayouter;
      };
    };
    /**
    * Layout stage that automatically translates label layout information provided by the standard
    * label layout classes {@link yfiles.layout.IEdgeLabelLayout} and {@link yfiles.layout.INodeLabelLayout} to layout data
    * of type {@link yfiles.layout.LabelLayoutData} that is accessible by the keys defined in class {@link yfiles.layout.LabelLayoutKeys}.
    * One can use this layout stage as label layouter of a label aware layouter. This can be done by
    * assigning the stage by an appropriate call to
    * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  setLabelLayouter}.
    * <p>
    * When writing the {@link yfiles.layout.LabelLayoutData}, the {@link yfiles.layout.LabelLayoutData#bounds  bounds} are set relative.
    * In case of a node label the bounds' {@link yfiles.algorithms.YOrientedRectangle#anchor  anchor} is relative
    * to the center of the owning node. In case of an edge label the bounds' anchor is relative to the center
    * of the source node of the owning edge.
    * </p>
    * <p>
    * If {@link yfiles.layout.LabelLayoutTranslator#writeBackNodeLabels  writing back node labels} and/or
    * {@link yfiles.layout.LabelLayoutTranslator#writeBackEdgeLabels  writing back edge labels} is enabled, the {@link yfiles.layout.LabelLayoutData}
    * is written back to the {@link yfiles.layout.INodeLabelLayout}s and/or {@link yfiles.layout.IEdgeLabelLayout}s.
    * </p>
    * <p>
    * Per default the {@link yfiles.layout.LabelLayoutData#bounds  bounds} are now interpreted absolute but by activating
    * {@link yfiles.layout.LabelLayoutTranslator#writeBackRelativeNodeLabelLocation} and/or {@link yfiles.layout.LabelLayoutTranslator#writeBackRelativeEdgeLabelLocation}
    * this can be changed to interpret them relative as explained above.
    * </p>
    * Note that care must be taken on the choice of label model that is used by the
    * classes {@link yfiles.layout.IEdgeLabelLayout} and {@link yfiles.layout.INodeLabelLayout}. The calculated label positions
    * must be consistent with the label positions allowed by the label model. The best label layout
    * results are achieved by choosing {@link yfiles.layout.FreeEdgeLabelLayoutModel} for edge layouts and
    * {@link yfiles.layout.FreeNodeLabelLayoutModel} for node layouts.
    */
    export interface LabelLayoutTranslator extends Object,yfiles.layout.ILayoutStage{
      /**
      * The core layouter.
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
      /**
      * Before invoking the core layouter this stage translates traditional
      * label layout information to data provider based label layout data.
      * Afterwards the calculated layout data will be written back to the
      * original label layout.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Determines whether or not this stage should automatically flip edge label
      * content depending on the label's rotation angle.
      * <p>
      * More precisely, if this option is enabled and the up vector of the {@link yfiles.algorithms.YOrientedRectangle} associated with an
      * {@link yfiles.layout.IEdgeLabelLayout} (see method {@link yfiles.layout.ILabelLayout#orientedBox}) points downward ({@link yfiles.algorithms.YOrientedRectangle#upY  upY} > 0),
      * this stage automatically flips the label, i.e., it rotates the label by 180 degree without changing
      * the label's center.
      * </p>
      * <p>
      * By default, this property is set to <code>true</code>.
      * </p>
      * @see {@link yfiles.layout.LayoutTool#autoFlipBox}
      * @see {@link yfiles.layout.LayoutTool#autoFlipBox}
      */
      autoFlippingEnabled:boolean;
      /**
      * Specifies whether or not to reset the orientation of node labels.
      * If this option is enabled, the up vector of the corresponding oriented
      * box is set to (0,-1). Default value is false.
      */
      resettingNodeLabelOrientation:boolean;
      /**
      * Specifies whether or not to reset the orientation of edge labels.
      * If this option is enabled, the up vector of the corresponding oriented
      * box is set to (0,-1). Default value is true.
      */
      resettingEdgeLabelOrientation:boolean;
      /**
      * The returned result gets calculated by the core layouter.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Specifies whether edge labels are written back to their model.
      * Defaults to <code>true</code>.
      */
      writeBackEdgeLabels:boolean;
      /**
      * Specifies whether edge label{@link yfiles.layout.LabelLayoutData#bounds  bounds} are interpreted relative when writing them
      * back to the model.
      * <p>
      * This option is only considered if {@link yfiles.layout.LabelLayoutTranslator#writeBackEdgeLabels} is set to <code>true</code>.
      * </p>
      * <p>
      * Default is <code>false</code>.
      * </p>
      */
      writeBackRelativeEdgeLabelLocation:boolean;
      /**
      * Specifies whether node labels are written back to their model.
      * Defaults to <code>false</code>.
      */
      writeBackNodeLabels:boolean;
      /**
      * Specifies whether node label{@link yfiles.layout.LabelLayoutData#bounds  bounds} are interpreted relative when writing them
      * back to the model.
      * <p>
      * This option is only considered if {@link yfiles.layout.LabelLayoutTranslator#writeBackNodeLabels} is set to <code>true</code>.
      * </p>
      * <p>
      * Default is <code>false</code>.
      * </p>
      */
      writeBackRelativeNodeLabelLocation:boolean;
      /**
      * Specifies whether node label translation is enabled.
      * Defaults to <code>false</code>.
      */
      translateNodeLabels:boolean;
      /**
      * Specifies whether edge label translation is enabled.
      * Defaults to <code>true</code>.
      */
      translateEdgeLabels:boolean;
    }
    var LabelLayoutTranslator:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of LabelLayoutTranslator.
      * Initially no core layouter will be bound to this layout stage.
      */
      new ():yfiles.layout.LabelLayoutTranslator;
    };
    /**
    * A <code>NodeHalo</code> object specifies a rectangular area around a specific node.
    * A layouter that supports node
    * halos, keeps this area clear of graph elements, except the node labels of this specific node and the adjacent
    * segments of its edges. All minimum distances to this node, which are used in the
    * layout calculation e.g. minimal first segment length, will be extended by the halo size.
    * <p>
    * This class defines a key used to associate a {@link yfiles.algorithms.IDataProvider} that provide node halos for all nodes of the
    * input graph. 
    * </p>
    * <p>
    * See <a href="@DGUIDE_PREFIX@/layout_advanced_features.html#adv_node_halos">the developer's guide section on Node Halos</a> for 
    * details about the individual algorithms that provide support for node halos.
    * </p>
    */
    export interface NodeHalo extends Object{
      /**
      * The halo size at the top side of the node.
      */
      top:number;
      /**
      * The halo size at the left side of the node.
      */
      left:number;
      /**
      * The halo size at the bottom side of the node.
      */
      bottom:number;
      /**
      * The halo size at the right side of the node.
      */
      right:number;
      equals(o:Object):boolean;
      hashCode():number;
    }
    var NodeHalo:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key that can be used to store {@link yfiles.layout.NodeHalo}-instances for the nodes
      * that specify the sizes of the nodes' halos.
      */
      NODE_HALO_DP_KEY:Object;
      /**
      * A constant holding a <code>NodeHalo</code> with zero size on each side.
      */
      ZERO_HALO:yfiles.layout.NodeHalo;
      /**
      * Creates a <code>NodeHalo</code> object with the specified values.
      * The values must not be negative, {@link Number#NaN}
      * or {@link Number#POSITIVE_INFINITY}, otherwise the method will throw an <code>IllegalArgumentException</code>.
      * @param {number} top The halo size at the top side of the node.
      * @param {number} left The halo size at the left side of the node.
      * @param {number} bottom The halo size at the bottom side of the node.
      * @param {number} right The halo size at the right side of the node.
      * @throws {yfiles.system.ArgumentException} 
      * if one of the values is negative, {@link Number#NaN} or {@link Number#POSITIVE_INFINITY}
      */
      createFromTopLeftBottomAndRight(top:number,left:number,bottom:number,right:number):yfiles.layout.NodeHalo;
      /**
      * Creates a <code>NodeHalo</code> object with the specified value on each side of the node.
      * The value must not be
      * negative, {@link Number#NaN} or {@link Number#POSITIVE_INFINITY}, otherwise the method will throw an
      * <code>IllegalArgumentException</code>.
      * @param {number} value The halo size at each side of the node.
      * @throws {yfiles.system.ArgumentException} 
      * if the value is negative, {@link Number#NaN} or {@link Number#POSITIVE_INFINITY}
      */
      create(value:number):yfiles.layout.NodeHalo;
      /**
      * Checks whether a {@link yfiles.algorithms.IDataProvider} has been registered at the given graph, that holds
      * <code>NodeHalo</code> instances.
      * @param {yfiles.layout.LayoutGraph} graph The graph to check.
      * @return {boolean} 
      * <code>true</code> if a {@link yfiles.algorithms.IDataProvider} has been registered at the given graph, that holds
      * <code>NodeHalo</code> instances, <code>false</code> otherwise.
      */
      hasHalos(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Returns the <code>NodeHalo</code> of the given node if available, otherwise a <code>NodeHalo</code> with zero size.
      * @param {yfiles.layout.LayoutGraph} graph The graph containing the given node.
      * @param {yfiles.algorithms.Node} node The node whose <code>NodeHalo</code> will be determined.
      * @return {yfiles.layout.NodeHalo} 
      * the <code>NodeHalo</code> of the given node if available, otherwise a <code>NodeHalo</code> with zero
      * size.
      */
      getHalo(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):yfiles.layout.NodeHalo;
      /**
      * Returns a {@link yfiles.algorithms.YRectangle} instance with the bounds of the given node and if available its <code>NodeHalo</code>.
      * @param {yfiles.layout.LayoutGraph} graph The graph containing the given node.
      * @param {yfiles.algorithms.Node} node The node whose <code>NodeHalo</code> will be determined.
      * @return {yfiles.algorithms.YRectangle} 
      * a {@link yfiles.algorithms.YRectangle} instance with the bounds of the given node and if available its <code>NodeHalo</code>
      */
      getHaloBox(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):yfiles.algorithms.YRectangle;
    };
    /**
    * This class is a container for several helper and utility functions for
    * the LayoutGraph class.
    * @see {@link yfiles.layout.LayoutGraph}
    */
    export interface LayoutTool extends Object{
    }
    var LayoutTool:{
      $class:yfiles.lang.Class;
      /**
      * Constraint specifier constant for the multi-row rectangle arrangement realized by
      * {@link yfiles.layout.LayoutTool#arrangeRectangleMultiRowsWithAlignment}
      * Both, height and width, are not limited in size by any constraint.
      * The rectangles will be arranged in a way
      * that the view ratio defined by the preferred height and width will be achieved.
      */
      MULTI_ROW_NO_CONSTRAINT:number;
      /**
      * Constraint specifier constant for the multi-row rectangle arrangement realized by
      * {@link yfiles.layout.LayoutTool#arrangeRectangleMultiRowsWithAlignment}
      * Limits the height of the arrangement to the given preferred height value.
      * If some rectangles are higher than
      * allowed, then they are placed nevertheless, but the constraint will be still considered for the rest and not
      * weakened to the height of the higher rectangles. Having one rectangle being higher than the constraint allows
      * does always result in arrangements consisting only of a single top-level row.
      */
      MULTI_ROW_HEIGHT_CONSTRAINT:number;
      /**
      * Constraint specifier constant for the multi-row rectangle arrangement realized by
      * {@link yfiles.layout.LayoutTool#arrangeRectangleMultiRowsWithAlignment}
      * Limits the width of the arrangement to the given preferred width value.
      * If a rectangle is wider than
      * allowed, then it will nevertheless be placed (in a row containing the rectangle alone), but the constraint
      * will be still considered for other rows and not weakened.
      */
      MULTI_ROW_WIDTH_CONSTRAINT:number;
      /**
      * Returns the label layout factory for the given graph.
      * Note that the factory instance is bound to the specified graph instance, i.e., you can only create, add and remove
      * labels for this graph.
      * @param {yfiles.layout.LayoutGraph} graph the graph.
      * @return {yfiles.layout.ILabelLayoutFactory} the label factory of the graph.
      */
      getLabelFactory(graph:yfiles.layout.LayoutGraph):yfiles.layout.ILabelLayoutFactory;
      /**
      * Determines the main direction of the edge flow by analyzing the current layout of the graph.
      * The method only considers edges for which the given DataProvider returns true.
      * @param {yfiles.layout.LayoutGraph} graph the underlying graph.
      * @param {yfiles.algorithms.IDataProvider} considerEdges the edges to consider.
      * @return {yfiles.layout.EdgeFlow} 
      * the flow direction, i.e., {@link yfiles.layout.EdgeFlow#DOWN}, {@link yfiles.layout.EdgeFlow#LEFT}, {@link yfiles.layout.EdgeFlow#NONE}, {@link yfiles.layout.EdgeFlow#RIGHT}
      * or {@link yfiles.layout.EdgeFlow#UP}.
      */
      determineEdgeFlowDirection(graph:yfiles.layout.LayoutGraph,considerEdges:yfiles.algorithms.IDataProvider):yfiles.layout.EdgeFlow;
      /**
      * Returns true if most of the edges of the graph are routed orthogonal.
      * The method only considers edges for which the given DataProvider returns true.
      * @param {yfiles.layout.LayoutGraph} graph the underlying graph.
      * @param {yfiles.algorithms.IDataProvider} considerEdges the edges to consider.
      * @return {boolean} true if most of the edges of the graph are routed orthogonal.
      */
      isUsingOrthogonalEdgeRoutes(graph:yfiles.layout.LayoutGraph,considerEdges:yfiles.algorithms.IDataProvider):boolean;
      /**
      * Returns true if most of the edges of the graph are routed octilinear.
      * The method only considers edges for which the
      * given DataProvider returns true.
      * <p>
      * Note: for orthogonal layouts this method returns true.
      * </p>
      * @param {yfiles.layout.LayoutGraph} graph the underlying graph.
      * @param {yfiles.algorithms.IDataProvider} considerEdges the edges to consider.
      * @return {boolean} true if most of the edges of the graph are routed octilinear.
      */
      isUsingOctilinearEdgeRoutes(graph:yfiles.layout.LayoutGraph,considerEdges:yfiles.algorithms.IDataProvider):boolean;
      /**
      * Returns the distance between the centers of two nodes.
      */
      getNodeDistance(graph:yfiles.layout.LayoutGraph,s:yfiles.algorithms.Node,t:yfiles.algorithms.Node):number;
      /**
      * Returns the length of path of a given edge.
      * The path starts
      * at the source point traverses through all control points and ends
      * at the target point.
      */
      getPathLength(graph:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge):number;
      /**
      * Reverses the layout of an edge.
      * This method reverses the order of points
      * and swaps source with target point.
      */
      reverseEdgeLayout(el:yfiles.layout.IEdgeLayout):void;
      /**
      * Assigns a trivial path which has no control points to all edges in the
      * specified graph and sets the edges' ports to the center of the
      * corresponding nodes.
      * Calling this method is equivalent to
      * <blockquote>
      * <c>resetPaths(gd, true)</c>
      * </blockquote>
      * @param {yfiles.layout.LayoutGraph} gd a graph diagram.
      * @see {@link yfiles.layout.LayoutTool#resetPathsAndPorts}
      */
      resetPaths(gd:yfiles.layout.LayoutGraph):void;
      /**
      * Assigns a trivial path which has no control points to all edges in the
      * specified graph.
      * @param {yfiles.layout.LayoutGraph} gd a graph diagram.
      * @param {boolean} resetPorts 
      * if <code>true</code>, the ports of the edges are set
      * to the center of the corresponding nodes.
      */
      resetPathsAndPorts(gd:yfiles.layout.LayoutGraph,resetPorts:boolean):void;
      /**
      * Assigns a trivial path which has no control points to the specified edge
      * and sets the edge's ports to the center of the corresponding node.
      * Calling this method is equivalent to
      * <blockquote>
      * <c>resetPath(gd, edge, true)</c>
      * </blockquote>
      * @param {yfiles.layout.LayoutGraph} gd a graph diagram.
      * @param {yfiles.algorithms.Edge} edge an edge in graph.
      * @see {@link yfiles.layout.LayoutTool#resetEdgePath}
      */
      resetPath(gd:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):void;
      /**
      * Assigns a trivial path which has no control points to the specified edge.
      * @param {yfiles.layout.LayoutGraph} gd a graph diagram.
      * @param {yfiles.algorithms.Edge} edge an edge in graph.
      * @param {boolean} resetPorts 
      * if <code>true</code>, the ports of the edge are set
      * to the center of the corresponding node.
      */
      resetEdgePath(gd:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge,resetPorts:boolean):void;
      /**
      * This helper method removes duplicate bends from all edges in the graph.
      * @param {yfiles.layout.LayoutGraph} gd a graph diagram.
      */
      removeDuplicateBends(gd:yfiles.layout.LayoutGraph):void;
      /**
      * This helper method removes duplicate bends from the given edge in the graph.
      * @param {yfiles.layout.LayoutGraph} gd a graph diagram.
      * @param {yfiles.algorithms.Edge} edge the edge.
      */
      removeDuplicateBendsForEdge(gd:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):void;
      /**
      * Moves the edge points of the given edge by the vector <code>(dx,dy)</code>.
      */
      moveEdge(g:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge,dx:number,dy:number):void;
      /**
      * Moves all edges accessible through the given edge cursor by the vector <code>(dx,dy)</code>.
      */
      moveEdges(g:yfiles.layout.LayoutGraph,edges:yfiles.algorithms.IEdgeCursor,dx:number,dy:number):void;
      /**
      * Moves the given node by the vector <code>(dx,dy)</code>.
      */
      moveNode(g:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node,dx:number,dy:number):void;
      /**
      * Moves all nodes accessible through the given node cursor by the vector <code>(dx,dy)</code>.
      */
      moveNodes(g:yfiles.layout.LayoutGraph,nodes:yfiles.algorithms.INodeCursor,dx:number,dy:number):void;
      /**
      * Moves the subgraph induced by edges accessible through the given edge cursor
      * by the vector <code>(dx,dy)</code>.
      */
      moveSubgraphAtEdges(g:yfiles.layout.LayoutGraph,edges:yfiles.algorithms.IEdgeCursor,dx:number,dy:number):void;
      /**
      * Moves the subgraph induced by nodes accessible through the given node cursor
      * by the vector <code>(dx,dy)</code>.
      */
      moveSubgraph(g:yfiles.layout.LayoutGraph,nodes:yfiles.algorithms.INodeCursor,dx:number,dy:number):void;
      /**
      * Returns the bounding box of the nodes and edges accessible through the given cursors.
      */
      getBoundingBox(graph:yfiles.layout.LayoutGraph,nc:yfiles.algorithms.INodeCursor,ec:yfiles.algorithms.IEdgeCursor):yfiles.algorithms.Rectangle2D;
      /**
      * Returns the bounding box of the given node.
      */
      getNodeBoundingBox(graph:yfiles.layout.LayoutGraph,n:yfiles.algorithms.Node):yfiles.algorithms.Rectangle2D;
      /**
      * Returns the bounding box of the nodes accessible through the given node cursor.
      */
      getBoundingBoxForNodes(graph:yfiles.layout.LayoutGraph,nc:yfiles.algorithms.INodeCursor):yfiles.algorithms.Rectangle2D;
      /**
      * Returns the bounding box of the given edge.
      */
      getEdgeBoundingBox(graph:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge):yfiles.algorithms.Rectangle2D;
      /**
      * Returns the bounding box of the edges accessible through the given edge cursor.
      */
      getBoundingBoxForEdges(graph:yfiles.layout.LayoutGraph,ec:yfiles.algorithms.IEdgeCursor):yfiles.algorithms.Rectangle2D;
      /**
      * Returns the bounding box of the nodes and edges accessible through the given cursors.
      * Optionally, the resulting bounding box will also include the bounds of
      * all node and edge labels attached to the accessible nodes and edges.
      */
      getBoundingBoxWithLabels(graph:yfiles.layout.LayoutGraph,nc:yfiles.algorithms.INodeCursor,ec:yfiles.algorithms.IEdgeCursor,includeLabels:boolean):yfiles.algorithms.Rectangle2D;
      /**
      * Returns the bounding box of the nodes and edges accessible through the given cursors.
      * Optionally, the resulting bounding box will also include the bounds of
      * all node and edge labels attached to the accessible nodes and edges.
      */
      getBoundingBoxWithNodeAndEdgeLabels(graph:yfiles.layout.LayoutGraph,nc:yfiles.algorithms.INodeCursor,ec:yfiles.algorithms.IEdgeCursor,includeNodeLabels:boolean,includeEdgeLabels:boolean):yfiles.algorithms.Rectangle2D;
      /**
      * Returns the bounding box of the nodes and edges accessible through the given cursors.
      * @param {yfiles.layout.LayoutGraph} graph The graph containing the nodes and edges to consider.
      * @param {yfiles.algorithms.INodeCursor} nc The node cursor to access the nodes to consider.
      * @param {yfiles.algorithms.IEdgeCursor} ec The edge cursor to access the edges to consider.
      * @param {boolean} includeNodeLabels Whether the bounds calculation should take node labels into account.
      * @param {boolean} includeEdgeLabels Whether the bounds calculation should take edge labels into account.
      * @param {boolean} includeHalos Whether the bounds calculation should take node halos into account.
      * @return {yfiles.algorithms.Rectangle2D} the bounding box of the nodes and edges accessible through the given cursors.
      */
      getBoundingBoxWithNodeAndEdgeLabelsAndHalos(graph:yfiles.layout.LayoutGraph,nc:yfiles.algorithms.INodeCursor,ec:yfiles.algorithms.IEdgeCursor,includeNodeLabels:boolean,includeEdgeLabels:boolean,includeHalos:boolean):yfiles.algorithms.Rectangle2D;
      /**
      * Returns the upper left corner of the given label's paraxial bounding box
      * as encoded by the specified model parameter.
      * @param {yfiles.layout.INodeLabelModel} model the label model used to place the label.
      * @param {yfiles.algorithms.YDimension} labelSize the size of the label that should be placed.
      * @param {yfiles.layout.INodeLayout} nodeLayout the layout of the node to which the label belongs.
      * @param {Object} param 
      * the model parameter that describes the abstract position of
      * the label within the specified model. The parameter must have been
      * generated by said model.
      * @return {yfiles.algorithms.YPoint} the upper left corner of the label's bounding box.
      * @see {@link yfiles.layout.INodeLabelModel#getLabelPlacement}
      */
      getNodeLabelPlacement(model:yfiles.layout.INodeLabelModel,labelSize:yfiles.algorithms.YDimension,nodeLayout:yfiles.layout.INodeLayout,param:Object):yfiles.algorithms.YPoint;
      /**
      * Returns the upper left corner of the given label's paraxial bounding box
      * as encoded by the specified model parameter.
      * @param {yfiles.layout.IEdgeLabelModel} model the label model used to place the label.
      * @param {yfiles.algorithms.YDimension} labelSize the size of the label that should be placed.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout the layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout the layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout the layout of the target node of the label owning edge.
      * @param {Object} param 
      * the model parameter that describes the abstract position of
      * the label within the specified model. The parameter must have been
      * generated by said model.
      * @return {yfiles.algorithms.YPoint} the upper left corner of the label's bounding box.
      * @see {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}
      */
      getEdgeLabelPlacement(model:yfiles.layout.IEdgeLabelModel,labelSize:yfiles.algorithms.YDimension,edgeLayout:yfiles.layout.IEdgeLayout,sourceLayout:yfiles.layout.INodeLayout,targetLayout:yfiles.layout.INodeLayout,param:Object):yfiles.algorithms.YPoint;
      /**
      * Sets the ports to the center of the nodes.
      * @param {yfiles.layout.LayoutGraph} gd a graph diagram.
      */
      resetPorts(gd:yfiles.layout.LayoutGraph):void;
      /**
      * This helper method clips the path of an edge on the bounding box
      * of the start and end vertices.
      */
      getEdgeClippedOnBBWithSourceAndTargetNode(edge:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):yfiles.algorithms.YPointPath;
      /**
      * This helper method clips the path of an edge on the bounding box
      * of the start and end vertices.
      */
      getEdgeClippedOnBB(gd:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):yfiles.algorithms.YPointPath;
      /**
      * This helper method clips the path of an edge on the bounding box
      * of the start and end vertices.
      */
      getEdgeClippedOnBBWithSourceAndTargetNodeAndInset(edge:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout,inset:number):yfiles.algorithms.YPointPath;
      /**
      * This helper method tests if the path of an edge is outside
      * the bounding box of the start and end vertices.
      */
      isEdgeOutsideNodes(gd:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):boolean;
      /**
      * This helper method tests if the path of an edge is outside
      * the bounding box of the start and end vertices.
      */
      isEdgeOutsideSourceAndTargetNode(edge:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout,inset:number):boolean;
      /**
      * This helper method clips the path of the edge on the bounding box
      * of the start and end points.
      */
      clipEdgesOnBB(gd:yfiles.layout.LayoutGraph):void;
      /**
      * This helper method clips the path of the edge on the bounding box
      * of the start and end points.
      */
      clipEdgeOnBB(gd:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge):void;
      /**
      * Returns the path of the layout of a specific edge as a String.
      */
      edgeLayoutString(gd:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):string;
      /**
      * Round the values of the layout of a node.
      */
      roundNodeLayout(gd:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):void;
      /**
      * Round the values of the control points and ports of an edge.
      */
      roundEdgeLayout(gd:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):void;
      /**
      * Round the values of the layout of an entire layout.
      */
      roundLayout(gd:yfiles.layout.LayoutGraph):void;
      /**
      * Routes two edges which are incident to the same nodes, in parallel.
      * @see {@link yfiles.layout.LayoutTool#routeTwoEdgesParallelJoinEnds}
      */
      routeTwoEdgesParallel(gd:yfiles.layout.LayoutGraph,e1:yfiles.algorithms.Edge,e2:yfiles.algorithms.Edge,lineDistance:number):void;
      /**
      * Routes two edges which are incident to the same nodes, in parallel.
      * @param {yfiles.layout.LayoutGraph} gd the graph
      * @param {yfiles.algorithms.Edge} e1 the leading edge
      * @param {yfiles.algorithms.Edge} e2 the edge to be adjusted (may be e1)
      * @param {number} lineDistance the distance between the two edges
      * @param {boolean} joinEnds whether the end points should all be set to the end points of e1
      * @param {number} absJoinDist 
      * the absolute distance between the end points and the beginning to
      * the parallel segment routing
      * @param {number} relJoinDist 
      * the relative distance, measured relative to the length of the
      * first/last segments
      */
      routeTwoEdgesParallelJoinEnds(gd:yfiles.layout.LayoutGraph,e1:yfiles.algorithms.Edge,e2:yfiles.algorithms.Edge,lineDistance:number,joinEnds:boolean,absJoinDist:number,relJoinDist:number):void;
      /**
      * Routes a list of edges with are incident to the same nodes, in parallel.
      * Invoking this method is equivalent to:
      * <code>routeEdgesParallel(gd, e1, list, lineDistance, false, false, 0.0d, 0.0d)</code>.
      * @param {yfiles.layout.LayoutGraph} gd the graph
      * @param {yfiles.algorithms.Edge} e1 the leading edge
      * @param {yfiles.algorithms.EdgeList} list the list of edges that will be aligned to e1
      * @param {number} lineDistance the distance between two edges
      * @see {@link yfiles.layout.LayoutTool#routeEdgesParallelJoinEnds}
      */
      routeEdgesParallel(gd:yfiles.layout.LayoutGraph,e1:yfiles.algorithms.Edge,list:yfiles.algorithms.EdgeList,lineDistance:number):void;
      /**
      * Routes a list of edges which are incident to the same nodes, in parallel.
      * @param {yfiles.layout.LayoutGraph} gd the graph
      * @param {yfiles.algorithms.Edge} e1 the leading edge
      * @param {yfiles.algorithms.EdgeList} list the list of edges that will be aligned to e1
      * @param {number} lineDistance the distance between two edges
      * @param {boolean} adjustE1 whether e1 should be adjusted if the size of list is odd
      * @param {boolean} joinEnds whether the end points should all be set to the end points of e1
      * @param {number} absJoinDist 
      * the absolute distance between the end points and the beginning to
      * the parallel segment routing
      * @param {number} relJoinDist 
      * the relative distance, measured relative to the length of the
      * first/last segments
      */
      routeEdgesParallelJoinEnds(gd:yfiles.layout.LayoutGraph,e1:yfiles.algorithms.Edge,list:yfiles.algorithms.EdgeList,lineDistance:number,adjustE1:boolean,joinEnds:boolean,absJoinDist:number,relJoinDist:number):void;
      /**
      * Routes a self-loop.
      * @param {yfiles.algorithms.Edge} e An edge with <code>e.source.equals(e.target)</code>.
      */
      routeSelfLoop(gd:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge):void;
      /**
      * Set the layout of two parallel edges with different direction identical.
      * @param {yfiles.algorithms.Edge} e1 the edge for which the points are set.
      * @param {yfiles.algorithms.Edge} e2 the template.
      */
      assignReverseLayout(graph:yfiles.layout.LayoutGraph,e1:yfiles.algorithms.Edge,e2:yfiles.algorithms.Edge):void;
      /**
      * Returns the positions of the nodes of a graph's diagram.
      */
      getNodePositions(gd:yfiles.layout.LayoutGraph):string;
      /**
      * This method assigns the position (0,0) to all nodes in the graph,
      * and sets the edges to straight lines with ports in the center
      * of the adjacent node.
      */
      initDiagram(gd:yfiles.layout.LayoutGraph):void;
      /**
      * Reassigns the bounds of the rectangles in <code>rects</code> to fit in a
      * large rectangle, whose bounds will be stored in <code>finalRect</code>.
      * This procedure tries to generate a final rectangle, whose aspect ratio is
      * as close as possible to <code>viewRatio</code>. This is achieved by
      * arranging the rectangles in a rows. The number of used rows will be
      * returned.
      * This method invokes
      * {@link yfiles.layout.LayoutTool#arrangeRectangleRowsWithAlignment  arrangeRectangleRows}
      * with {@link yfiles.layout.RowAlignment#LEADING} as the last argument.
      * @param {yfiles.algorithms.Rectangle2D[]} rects the rectangles whose coordinates will be modified
      * @param {yfiles.algorithms.Rectangle2D} finalRect the exact dimension will be placed in this rectangle
      * @param {number} viewRatio the preferred ratio of the resulting bounds, must be greater than 0.
      * @return {number} the number of used rows
      */
      arrangeRectangleRows(rects:yfiles.algorithms.Rectangle2D[],finalRect:yfiles.algorithms.Rectangle2D,viewRatio:number):number;
      /**
      * Reassigns the bounds of the rectangles in <code>rects</code> to fit into a
      * large rectangle, whose bounds will be stored in <code>finalRect</code>.
      * This procedure tries to generate a final rectangle, whose aspect ratio is
      * as close as possible to <code>viewRatio</code>. This is achieved by
      * arranging the rectangles in a grid-like fashion.
      * The dimension of this grid is returned.
      * @param {yfiles.algorithms.Rectangle2D[]} rects the rectangles whose, coordinates will be modified
      * @param {yfiles.algorithms.Rectangle2D} finalRect the exact dimension will be placed in this rectangle
      * @param {number} viewRatio the preferred ratio of the grid, must be greater than 0.
      * @return {yfiles.algorithms.YDimension} the dimension of the grid
      */
      arrangeRectangleGrid(rects:yfiles.algorithms.Rectangle2D[],finalRect:yfiles.algorithms.Rectangle2D,viewRatio:number):yfiles.algorithms.YDimension;
      /**
      * Reassigns the bound of the rectangles in <code>rects</code> to fit in a large rectangle, whose bounds will be
      * stored in <code>finalRect</code>.
      * The rectangles will be placed within this bound arranged within rows, where
      * each row may be split into more sub-rows. This often leads to more compact results than provided by the procedure
      * used in {@link yfiles.layout.LayoutTool#arrangeRectangleRowsWithAlignment}.
      * A row will be subdivided into more rows, if two successive rectangles to be placed in the row could be placed
      * stacked within this row without making the row larger in height.
      * <p>This method calls
      * {@link yfiles.layout.LayoutTool#arrangeRectangleMultiRowsWithAlignment}
      * with the last alignment parameter being {@link yfiles.layout.RowAlignment#LEADING}. </p>
      * @param {yfiles.algorithms.Rectangle2D[]} rects the rectangles to arrange (coordinates will be assigned).
      * @param {yfiles.algorithms.Rectangle2D} finalRect the exact resulting dimension will be stored in this rectangle
      * @param {number} preferredWidth the preferred width of the result <code>finalRect</code>, must be greater than 0.
      * @param {number} preferredHeight the preferred height of the result <code>finalRect</code>, must be greater than 0.
      * @param {boolean} compaction 
      * if true, then the algorithm tries to always minimize the resulting dimension, whilst respecting
      * the given constraints.
      * @param {number} constraintMode 
      * the width or height constraints to consider. Possible values are
      * {@link yfiles.layout.LayoutTool#MULTI_ROW_NO_CONSTRAINT},{@link yfiles.layout.LayoutTool#MULTI_ROW_WIDTH_CONSTRAINT}
      * and {@link yfiles.layout.LayoutTool#MULTI_ROW_HEIGHT_CONSTRAINT}.
      * @return {number} the number of rows used
      */
      arrangeRectangleMultiRows(rects:yfiles.algorithms.Rectangle2D[],finalRect:yfiles.algorithms.Rectangle2D,preferredWidth:number,preferredHeight:number,compaction:boolean,constraintMode:number):number;
      /**
      * Reassigns the bound of the rectangles in <code>rects</code> to fit in a large rectangle, whose bounds will be
      * stored in <code>finalRect</code>.
      * The rectangles will be placed within this bound arranged within rows, where
      * each row may be split into more sub-rows. This often leads to more compact results than provided by the procedure
      * used in {@link yfiles.layout.LayoutTool#arrangeRectangleRowsWithAlignment}.
      * A row will be subdivided into more rows if two successive rectangles to be placed in the row could be placed
      * stacked within this row without making the row larger in height.
      * @param {yfiles.algorithms.Rectangle2D[]} rects the rectangles to arrange (coordinates will be assigned).
      * @param {yfiles.algorithms.Rectangle2D} finalRect the exact resulting dimension will be stored in this rectangle
      * @param {number} preferredWidth the preferred width of the result <code>finalRect</code>, must be greater than 0.
      * @param {number} preferredHeight the preferred height of the result <code>finalRect</code>, must be greater than 0.
      * @param {boolean} compaction 
      * if true, then the algorithm tries to always minimize the resulting dimension, whilst respecting
      * the given constraints.
      * @param {number} constraintMode 
      * the width or height constraints to consider. Possible values are
      * {@link yfiles.layout.LayoutTool#MULTI_ROW_NO_CONSTRAINT},{@link yfiles.layout.LayoutTool#MULTI_ROW_WIDTH_CONSTRAINT}
      * and {@link yfiles.layout.LayoutTool#MULTI_ROW_HEIGHT_CONSTRAINT}.
      * @param {number} alignment 
      * the alignment policy to follow. Possible values are {@link yfiles.layout.RowAlignment#LEADING}, {@link yfiles.layout.RowAlignment#TRAILING} and
      * {@link yfiles.layout.RowAlignment#CENTER}. The best results (regarding compactness) are achieved using {@link yfiles.layout.RowAlignment#LEADING}.
      * Other alignment modes are ignored.
      * @return {number} the number of rows used
      */
      arrangeRectangleMultiRowsWithAlignment(rects:yfiles.algorithms.Rectangle2D[],finalRect:yfiles.algorithms.Rectangle2D,preferredWidth:number,preferredHeight:number,compaction:boolean,constraintMode:number,alignment:number):number;
      /**
      * Reassigns the bounds of the rectangles in <code>rects</code> to fit into a
      * large rectangle, whose bounds will be stored in <code>finalRect</code>.
      * This procedure tries to generate a final rectangle, whose aspect ratio is
      * as close as possible to <code>viewRatio</code>. This is achieved by
      * arranging the rectangles in rows. The number of generated rows is
      * returned.
      * @param {yfiles.layout.RowAlignment} alignment 
      * determines the alignment policy for rows, that are not
      * completely filled
      * @param {yfiles.algorithms.Rectangle2D[]} rects the rectangles whose coordinates will be modified
      * @param {yfiles.algorithms.Rectangle2D} finalRect the exact dimension will be placed in this rectangle
      * @param {number} viewRatio the preferred ratio of the resulting bounds, must be greater than 0.
      * @return {number} the number of generated rows
      */
      arrangeRectangleRowsWithAlignment(rects:yfiles.algorithms.Rectangle2D[],finalRect:yfiles.algorithms.Rectangle2D,viewRatio:number,alignment:yfiles.layout.RowAlignment):number;
      /**
      * Checks whether or not the path of an edge intersects the interior of
      * a given rectangular area.
      */
      pathIntersectsRect(graph:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge,rect:yfiles.algorithms.Rectangle2D):boolean;
      /**
      * Applies a GraphLayout to a LayoutGraph.
      * <b>Precondition:</b> 
      * the GraphLayout data must be defined for
      * elements in the given LayoutGraph.
      */
      applyGraphLayout(graph:yfiles.layout.LayoutGraph,gl:yfiles.layout.IGraphLayout):void;
      /**
      * Aligns the specified nodes either vertically or horizontally according to
      * the specified node alignment mode.
      * <p>
      * For vertical arrangements, nodes are either
      * {@link yfiles.layout.NodeAlignment#LEADING  top-aligned},
      * {@link yfiles.layout.NodeAlignment#CENTERED  center-aligned},
      * {@link yfiles.layout.NodeAlignment#TRAILING  bottom-aligned}, or
      * {@link yfiles.layout.NodeAlignment#DISTRIBUTED  vertically distributed}.
      * </p><p>
      * For horizontal arrangements, nodes are either
      * {@link yfiles.layout.NodeAlignment#LEADING  left-aligned},
      * {@link yfiles.layout.NodeAlignment#CENTERED  center-aligned},
      * {@link yfiles.layout.NodeAlignment#TRAILING  right-aligned}, or
      * {@link yfiles.layout.NodeAlignment#DISTRIBUTED  horizontally distributed}.
      * </p><p>
      * In this context, <em>distributed</em> means that the specified nodes are
      * placed in such a way that the projections of their bounds onto the
      * vertical or horizontal coordinate axis do not overlap. E.g. after
      * vertically distributing nodes, <code>(n1.y + n1.height) &lt;= n2.y</code>
      * for two consecutively placed nodes <code>n1</code> and <code>n2</code>.
      * </p>
      * @param {yfiles.layout.LayoutGraph} g the graph that contains the specified nodes.
      * @param {yfiles.algorithms.NodeList} nodes a subset of the specified graph's nodes that is arranged.
      * @param {yfiles.algorithms.Node} referenceNode 
      * if <code>null</code>, the common coordinate for
      * aligning the specified nodes is calculated as the
      * the vertical minimum (top-aligned),
      * the vertical center,
      * the vertical maximum (bottom-aligned),
      * the horizontal minimum (left-aligned),
      * the horizontal center, or
      * the horizontal maximum (right-aligned)
      * of the bounds of the specified nodes; otherwise the appropriate coordinate
      * of the given reference node's bounds is used as common coordinate for
      * aligning the specified nodes.
      * The reference node is ignored when
      * {@link yfiles.layout.NodeAlignment#DISTRIBUTED  distributing} nodes.
      * @param {boolean} vertical 
      * if <code>true</code> nodes are aligned (or distributed)
      * according to their y-coordinates; otherwise nodes are aligned
      * (or distributed) according to their x-coordinates.
      * @param {yfiles.layout.NodeAlignment} mode 
      * one of <ul>
      * <li>{@link yfiles.layout.NodeAlignment#LEADING},</li>
      * <li>{@link yfiles.layout.NodeAlignment#CENTERED},</li>
      * <li>{@link yfiles.layout.NodeAlignment#TRAILING}, or</li>
      * <li>{@link yfiles.layout.NodeAlignment#DISTRIBUTED}.</li>
      * </ul>
      */
      alignNodeLayouts(g:yfiles.layout.LayoutGraph,nodes:yfiles.algorithms.NodeList,referenceNode:yfiles.algorithms.Node,vertical:boolean,mode:yfiles.layout.NodeAlignment):void;
      /**
      * Flips the orientation of a given rectangle, if its up vector points downward ({@link yfiles.algorithms.YOrientedRectangle#upY  upY} > 0).
      * That means, it rotates the rectangle by 180 degree without changing the rectangle's center.
      * @param {yfiles.algorithms.YOrientedRectangle} rect the given rectangle.
      * @return {boolean} <code>true</code> if the given rectangle was flipped and <code>false</code> otherwise.
      */
      autoFlipBox(rect:yfiles.algorithms.YOrientedRectangle):boolean;
    };
    /**
    * This class is an default implementation of the NodeLabelLayout
    * interface.
    */
    export interface NodeLabelLayoutImpl extends yfiles.layout.LabelLayoutImpl,yfiles.layout.INodeLabelLayout{
      /**
      * The node label model associated with this label layout.
      * @see Specified by {@link yfiles.layout.INodeLabelLayout#labelModel}.
      */
      labelModel:yfiles.layout.INodeLabelModel;
    }
    var NodeLabelLayoutImpl:{
      $class:yfiles.lang.Class;
      new ():yfiles.layout.NodeLabelLayoutImpl;
    };
    /**
    * This class represents a candidate position for label associated to a node
    * in a graph.
    */
    export interface NodeLabelCandidate extends yfiles.layout.LabelCandidate{
    }
    var NodeLabelCandidate:{
      $class:yfiles.lang.Class;
      /**
      * Returns a new instance of NodeLabelCandidate.
      * @param {yfiles.algorithms.YPoint} pos 
      * the location of the upper
      * left corner of the candidate.
      * @param {yfiles.algorithms.YDimension} size the size of the candidate.
      * @param {Object} param 
      * the parameters of the labeling model
      * associated with this candidate.
      * @param {yfiles.layout.INodeLabelLayout} owner the label associated to the candidate.
      */
      FromPositionAndSize:{
        new (pos:yfiles.algorithms.YPoint,size:yfiles.algorithms.YDimension,param:Object,owner:yfiles.layout.INodeLabelLayout):yfiles.layout.NodeLabelCandidate;
      };
      /**
      * Returns a new instance of NodeLabelCandidate.
      * @param {yfiles.algorithms.YOrientedRectangle} orientedBox the box that specifies the candidate's size and position.
      * @param {Object} param the parameters of the labeling model associated with this candidate.
      * @param {yfiles.layout.INodeLabelLayout} owner the label associated to the candidate.
      * @param {boolean} internal 
      * flag whether the candidate is inside the node,
      * or outside.
      */
      FromRectangle:{
        new (orientedBox:yfiles.algorithms.YOrientedRectangle,param:Object,owner:yfiles.layout.INodeLabelLayout,internal:boolean):yfiles.layout.NodeLabelCandidate;
      };
      /**
      * Returns a new instance of NodeLabelCandidate.
      * @param {yfiles.algorithms.YPoint} pos 
      * the location of the upper
      * left corner of the candidate.
      * @param {yfiles.algorithms.YDimension} size the size of the candidate.
      * @param {Object} param 
      * the parameters of the labeling model
      * associated with this candidate.
      * @param {yfiles.layout.INodeLabelLayout} owner the label associated to the candidate.
      * @param {boolean} internal 
      * flag whether the candidate is inside the node,
      * or outside.
      */
      FromPositionAndSizeWithInternal:{
        new (pos:yfiles.algorithms.YPoint,size:yfiles.algorithms.YDimension,param:Object,owner:yfiles.layout.INodeLabelLayout,internal:boolean):yfiles.layout.NodeLabelCandidate;
      };
    };
    /**
    * This class represents a drawing of a graph.
    */
    export interface LayoutGraph extends yfiles.algorithms.Graph,yfiles.layout.IGraphLayout{
      /**
      * Factory method that is called by {@link yfiles.algorithms.Graph#graphCopyFactory}
      * to create a (possibly shared) instance.
      * @return {yfiles.algorithms.GraphCopier.ICopyFactory} the (possibly shared) instance.
      */
      createGraphCopyFactory():yfiles.algorithms.GraphCopier.ICopyFactory;
      /**
      * Creates a new {@link yfiles.layout.ILabelLayoutFactory}.
      */
      createLabelFactory():yfiles.layout.ILabelLayoutFactory;
      /**
      * Returns the layout information for a node in the drawing.
      * @param {yfiles.algorithms.Node} node a node in the drawing.
      * @return {yfiles.layout.INodeLayout} the layout information for <code>node</code>.
      */
      getLayoutForNode(node:yfiles.algorithms.Node):yfiles.layout.INodeLayout;
      /**
      * Returns the layout information for an edge in the drawing.
      * @param {yfiles.algorithms.Edge} edge a edge in the drawing.
      * @return {yfiles.layout.IEdgeLayout} the layout information for <code>edge</code>.
      */
      getLayoutForEdge(edge:yfiles.algorithms.Edge):yfiles.layout.IEdgeLayout;
      /**
      * Returns
      * NodeLabelLayout objects which describe the layouts
      * of the labels that belong to the given node.
      * @param {yfiles.algorithms.Node} node a node in the drawing.
      * @return {yfiles.layout.INodeLabelLayout[]} the node label layout information for <code>node</code>.
      */
      getLabelLayoutForNode(node:yfiles.algorithms.Node):yfiles.layout.INodeLabelLayout[];
      /**
      * Returns
      * EdgeLabelLayout objects which describe the layouts
      * of the labels that belong to the given edge.
      * @param {yfiles.algorithms.Edge} edge an edge in the drawing.
      * @return {yfiles.layout.IEdgeLabelLayout[]} the edge label layout information for <code>edge</code>.
      */
      getLabelLayoutForEdge(edge:yfiles.algorithms.Edge):yfiles.layout.IEdgeLabelLayout[];
      /**
      * Returns the node which is described by a given label layout.
      */
      getFeatureNode(labelLayout:yfiles.layout.INodeLabelLayout):yfiles.algorithms.Node;
      /**
      * Returns the edge which is described by a given label layout.
      */
      getFeatureEdge(labelLayout:yfiles.layout.IEdgeLabelLayout):yfiles.algorithms.Edge;
      /**
      * Returns the layout information for a node in the drawing.
      * @param {Object} node a node in the drawing.
      * @return {yfiles.layout.INodeLayout} the layout information for <code>node</code>.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getNodeLayout}.
      */
      getNodeLayout(node:Object):yfiles.layout.INodeLayout;
      /**
      * Returns the layout information for an edge in the drawing.
      * @param {Object} edge a edge in the drawing.
      * @return {yfiles.layout.IEdgeLayout} the layout information for <code>edge</code>.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getEdgeLayout}.
      */
      getEdgeLayout(edge:Object):yfiles.layout.IEdgeLayout;
      /**
      * Returns
      * NodeLabelLayout objects which describe the layouts
      * of the labels that belong to the given node.
      * @param {Object} node a node in the drawing.
      * @return {yfiles.layout.INodeLabelLayout[]} the node label layout information for <code>node</code>.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getNodeLabelLayout}.
      */
      getNodeLabelLayout(node:Object):yfiles.layout.INodeLabelLayout[];
      /**
      * Returns
      * EdgeLabelLayout objects which describe the layouts
      * of the labels that belong to the given edge.
      * @param {Object} edge an edge in the drawing.
      * @return {yfiles.layout.IEdgeLabelLayout[]} the edge label layout information for <code>edge</code>.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getEdgeLabelLayout}.
      */
      getEdgeLabelLayout(edge:Object):yfiles.layout.IEdgeLabelLayout[];
      /**
      * Returns the center x-coordinate of the given node.
      */
      getCenterX(v:yfiles.algorithms.Node):number;
      /**
      * Returns the center y-coordinate of the given node.
      */
      getCenterY(v:yfiles.algorithms.Node):number;
      /**
      * Returns the position of a node in a drawing.
      * The position is defined by the center of the node.
      * @param {yfiles.algorithms.Node} node a node in the graph
      * @return {yfiles.algorithms.YPoint} the center of the node in the drawing of the node
      */
      getCenter(node:yfiles.algorithms.Node):yfiles.algorithms.YPoint;
      /**
      * Returns the upper left x-coordinate of the given node.
      */
      getX(v:yfiles.algorithms.Node):number;
      /**
      * Returns the upper left y-coordinate of the given node.
      */
      getY(v:yfiles.algorithms.Node):number;
      /**
      * Returns the position of the node in a drawing.
      * The position is defined by the upper left corner of the node.
      * @param {yfiles.algorithms.Node} node a node in the graph
      * @return {yfiles.algorithms.YPoint} the upper left corner of the drawing of the node
      */
      getLocation(node:yfiles.algorithms.Node):yfiles.algorithms.YPoint;
      /**
      * Returns the width of the given node.
      */
      getWidth(v:yfiles.algorithms.Node):number;
      /**
      * Returns the height of the given node.
      */
      getHeight(v:yfiles.algorithms.Node):number;
      /**
      * Returns the size of the node in a drawing.
      * @param {yfiles.algorithms.Node} node a node in the graph.
      * @return {yfiles.algorithms.YDimension} the size of the node.
      */
      getSize(node:yfiles.algorithms.Node):yfiles.algorithms.YDimension;
      /**
      * Returns the bounding box of a node.
      * @param {yfiles.algorithms.Node} node a node in the graph.
      * @return {yfiles.algorithms.YRectangle} a box.
      */
      getRectangle(node:yfiles.algorithms.Node):yfiles.algorithms.YRectangle;
      /**
      * Sets the position of a node in a drawing.
      * The position is defined by the center of the node.
      * @param {yfiles.algorithms.Node} node a node in the graph
      * @param {yfiles.algorithms.YPoint} position the center of the node in the drawing of the node
      */
      setCenter(node:yfiles.algorithms.Node,position:yfiles.algorithms.YPoint):void;
      /**
      * Sets the center coordinates of the given node.
      */
      setCenterCoords(v:yfiles.algorithms.Node,x:number,y:number):void;
      /**
      * Sets the size of the given node.
      */
      setSize(v:yfiles.algorithms.Node,w:number,h:number):void;
      /**
      * Set the size of the node in a drawing.
      * @param {yfiles.algorithms.Node} node a node in the graph
      * @param {yfiles.algorithms.YDimension} size the size of the node.
      */
      setSizeWithDimension(node:yfiles.algorithms.Node,size:yfiles.algorithms.YDimension):void;
      /**
      * Sets the upper left coordinates of the given node.
      */
      setLocationCoords(v:yfiles.algorithms.Node,x:number,y:number):void;
      /**
      * Set the position of the node in a drawing.
      * The position is defined by the upper left corner of the node.
      * @param {yfiles.algorithms.Node} node a node in the graph
      * @param {yfiles.algorithms.YPoint} position the upper left corner of the drawing of the node
      */
      setLocation(node:yfiles.algorithms.Node,position:yfiles.algorithms.YPoint):void;
      /**
      * Moves the location of a node by a given vector.
      * @param {yfiles.algorithms.Node} node a node in the graph
      * @param {number} dx the x-component of the vector
      * @param {number} dy the y-component of the vector
      */
      moveBy(node:yfiles.algorithms.Node,dx:number,dy:number):void;
      /**
      * Returns the control points of an edge.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @return {yfiles.algorithms.YPointPath} the sequence of control points.
      */
      getPoints(edge:yfiles.algorithms.Edge):yfiles.algorithms.YPointPath;
      /**
      * Returns the control points of an edge.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @return {yfiles.algorithms.YList} the sequence of control points as a YList
      */
      getPointList(edge:yfiles.algorithms.Edge):yfiles.algorithms.YList;
      /**
      * Returns the path of an edge.
      * The path of an edge is the position of the source port,
      * followed by the positions of the bends, followed by the position
      * of the target port.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @return {yfiles.algorithms.YPointPath} the path
      */
      getPath(edge:yfiles.algorithms.Edge):yfiles.algorithms.YPointPath;
      /**
      * Returns the path of an edge.
      * The path of an edge is the position of the source port,
      * followed by the positions of the bends, followed by the position
      * of the target port.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @return {yfiles.algorithms.YList} the path as a YList
      */
      getPathList(edge:yfiles.algorithms.Edge):yfiles.algorithms.YList;
      /**
      * Sets the path of an edge.
      * The path of an edge is the position of the source port,
      * followed by the positions of the bends, followed by the position
      * of the target port. Both source and target port are expected to be given
      * in absolute coordinates.
      * <b>Precondition:</b> The length of the path must be 2 at least.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @param {yfiles.algorithms.YPointPath} path the path sequence.
      */
      setPath(edge:yfiles.algorithms.Edge,path:yfiles.algorithms.YPointPath):void;
      /**
      * Sets the path of an edge.
      * The path of an edge is the position of the source port,
      * followed by the positions of the bends, followed by the position
      * of the target port. Both source and target port are expected to be given
      * in absolute coordinates.
      * <b>Precondition:</b> The length of the path must be 2 at least.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @param {yfiles.algorithms.YList} path the path sequence given as a YList
      */
      setPathWithPointList(edge:yfiles.algorithms.Edge,path:yfiles.algorithms.YList):void;
      /**
      * Sets the control points of an edge.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @param {yfiles.algorithms.YPointPath} points the sequence of control points.
      */
      setPoints(edge:yfiles.algorithms.Edge,points:yfiles.algorithms.YPointPath):void;
      /**
      * Sets the control points of an edge.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @param {yfiles.algorithms.YList} points the sequence of control points as a YList
      */
      setPointsWithPointList(edge:yfiles.algorithms.Edge,points:yfiles.algorithms.YList):void;
      /**
      * Set the two end points of an edge in absolute coordinates.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph.
      * @param {yfiles.algorithms.YPoint} source the port on the source side of the edge.
      * @param {yfiles.algorithms.YPoint} target the port on the target side of the edge.
      */
      setEndPointsAbs(edge:yfiles.algorithms.Edge,source:yfiles.algorithms.YPoint,target:yfiles.algorithms.YPoint):void;
      /**
      * Returns the coordinates of the source end point of an edge
      * in relative coordinates to the center of the source node.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      */
      getSourcePointRel(edge:yfiles.algorithms.Edge):yfiles.algorithms.YPoint;
      /**
      * Returns the coordinates of the target end point of an edge
      * in relative coordinates to the center of the target node.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      */
      getTargetPointRel(edge:yfiles.algorithms.Edge):yfiles.algorithms.YPoint;
      /**
      * Sets the coordinates of the source end point of an edge
      * in relative coordinates to the center of the source node.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @param {yfiles.algorithms.YPoint} point 
      */
      setSourcePointRel(edge:yfiles.algorithms.Edge,point:yfiles.algorithms.YPoint):void;
      /**
      * Sets the coordinates of the target end point of an edge
      * in relative coordinates to the center of the target node.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      */
      setTargetPointRel(edge:yfiles.algorithms.Edge,point:yfiles.algorithms.YPoint):void;
      /**
      * Returns the coordinates of the source end point of an edge
      * in absolute coordinates.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      */
      getSourcePointAbs(edge:yfiles.algorithms.Edge):yfiles.algorithms.YPoint;
      /**
      * Returns the coordinates of the target end point of an edge
      * in absolute coordinates.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      */
      getTargetPointAbs(edge:yfiles.algorithms.Edge):yfiles.algorithms.YPoint;
      /**
      * Sets the coordinates of the source end point of an edge
      * in absolute coordinates.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @param {yfiles.algorithms.YPoint} point 
      */
      setSourcePointAbs(edge:yfiles.algorithms.Edge,point:yfiles.algorithms.YPoint):void;
      /**
      * Sets the coordinates of the target end point of an edge
      * in absolute coordinates.
      * @param {yfiles.algorithms.Edge} edge an edge in the graph
      * @param {yfiles.algorithms.YPoint} point 
      */
      setTargetPointAbs(edge:yfiles.algorithms.Edge,point:yfiles.algorithms.YPoint):void;
      /**
      * A list, which contains the edges of the graph.
      */
      edgeList:yfiles.algorithms.EdgeList;
      /**
      * Returns the bounding box of the diagram.
      * This is the smallest rectangle containing the entire diagram.
      * If the graph does not contain any nodes (and therefore no edges either),
      * the bounding box will have negative width and/or height.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getBoundingBox}.
      */
      getBoundingBox():yfiles.algorithms.Rectangle;
    }
    var LayoutGraph:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new Layout Graph.
      */
      new ():yfiles.layout.LayoutGraph;
      /**
      * Creates a copy of the given subgraph.
      */
      FromLayoutGraph:{
        new (argGraph:yfiles.layout.LayoutGraph):yfiles.layout.LayoutGraph;
      };
      /**
      * Creates a copy of the given subgraph.
      */
      FromGraphForSubset:{
        new (graph:yfiles.layout.LayoutGraph,nodeSubset:yfiles.algorithms.ICursor):yfiles.layout.LayoutGraph;
      };
    };
    /**
    * This class delegates its layout calls to a core layout algorithm that is dynamically
    * chosen at runtime by inspecting the nodes of the input graph.
    * <p>
    * If a data provider is registered with the given graph using the look-up key {@link yfiles.layout.LayoutMultiplexer#LAYOUTER_DP_KEY}
    * it is used to retrieve the {@link yfiles.layout.ILayouter} objects that are stored for the graph's
    * nodes.
    * If no such data provider is registered, this layout stage's core layouter (if
    * any) is used for layout calculation of all nodes.
    * Note that the first non-<code>null</code> Layouter retrieved from the data provider
    * is used for all nodes.
    * </p>
    * <p>
    * The main purpose of this class is to enable the use of individual layout algorithms
    * for components (when used as the core layouter of class {@link yfiles.layout.ComponentLayouter})
    * or for the contents of group nodes (when used as the core layouter of class {@link yfiles.layout.RecursiveGroupLayouter}).
    * </p>
    */
    export interface LayoutMultiplexer extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Returns the core layout algorithm associated with the
      * nodes contained in the given graph.
      * The default implementation
      * looks up the layout algorithm in the data provider registered
      * with the key {@link yfiles.layout.LayoutMultiplexer#LAYOUTER_DP_KEY}.
      */
      getCoreLayouter(graph:yfiles.layout.LayoutGraph):yfiles.layout.ILayouter;
    }
    var LayoutMultiplexer:{
      $class:yfiles.lang.Class;
      new ():yfiles.layout.LayoutMultiplexer;
      /**
      * Look-up key used to register a {@link yfiles.algorithms.IDataProvider} that provides a
      * {@link yfiles.layout.ILayouter} object for each node of a graph.
      */
      LAYOUTER_DP_KEY:Object;
    };
    /**
    * An implementation of the copy factory interface used by {@link yfiles.algorithms.GraphCopier}
    * that can be used by implementations of {@link yfiles.layout.LayoutGraph}.
    */
    export interface LayoutGraphCopyFactory extends Object,yfiles.algorithms.GraphCopier.ICopyFactory{
      /**
      * Copies the <code>originalNode</code> from the source graph to the new <code>targetGraph</code>.
      * @param {yfiles.algorithms.Graph} targetGraph the graph to create the new node in
      * @param {yfiles.algorithms.Node} originalNode the original node from the source graph
      * @return {yfiles.algorithms.Node} the newly created node
      * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#copyNode}.
      */
      copyNode(targetGraph:yfiles.algorithms.Graph,originalNode:yfiles.algorithms.Node):yfiles.algorithms.Node;
      /**
      * Callback that copies the labels for a given node.
      */
      copyNodeLabels(originalLayoutGraph:yfiles.layout.LayoutGraph,originalNode:yfiles.algorithms.Node,targetGraph:yfiles.layout.LayoutGraph,newNode:yfiles.algorithms.Node):void;
      /**
      * Copies the node label's layout.
      */
      copyNodeLabelLayout(nodeLabelLayout:yfiles.layout.INodeLabelLayout):yfiles.layout.INodeLabelLayout;
      /**
      * Copies the <code>originalEdge</code> from the source graph to the new <code>targetGraph</code>
      * using the specified new source and target node in the target graph.
      * @param {yfiles.algorithms.Graph} targetGraph the graph to create the new node in
      * @param {yfiles.algorithms.Node} newSource the source node in the target graph to use for the newly created edge
      * @param {yfiles.algorithms.Node} newTarget the target node in the target graph to use for the newly created edge
      * @param {yfiles.algorithms.Edge} originalEdge the original edge from the source graph
      * @return {yfiles.algorithms.Edge} the newly created edge
      * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#copyEdge}.
      */
      copyEdge(targetGraph:yfiles.algorithms.Graph,newSource:yfiles.algorithms.Node,newTarget:yfiles.algorithms.Node,originalEdge:yfiles.algorithms.Edge):yfiles.algorithms.Edge;
      /**
      * Creates a new {@link yfiles.layout.DefaultLayoutGraph}.
      * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#createGraph}.
      */
      createGraph():yfiles.algorithms.Graph;
      /**
      * Callback that copies the labels for a given edge.
      */
      copyEdgeLabels(originalLayoutGraph:yfiles.layout.LayoutGraph,originalEdge:yfiles.algorithms.Edge,layoutGraph:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):void;
      /**
      * Copies the edge label's layout.
      */
      copyEdgeLabelLayout(edgeLabelLayout:yfiles.layout.IEdgeLabelLayout):yfiles.layout.IEdgeLabelLayout;
      /**
      * Callback that will be called before the copy operation takes place.
      * At that point in time no entities have been copied to the new graph.
      * @param {yfiles.algorithms.Graph} sourceGraph the graph that will be used to copy the entities from.
      * @param {yfiles.algorithms.Graph} targetGraph the graph that will be used to copy the entities to.
      * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#preCopyGraphData}.
      */
      preCopyGraphData(originalGraph:yfiles.algorithms.Graph,newGraph:yfiles.algorithms.Graph):void;
      /**
      * Callback that will be called after the copy operation has completed.
      * At that point in time all entities have been copied to the new graph.
      * @param {yfiles.algorithms.Graph} sourceGraph the graph that was used to copy the entities from.
      * @param {yfiles.algorithms.Graph} targetGraph the graph that was used to copy the entities to.
      * @param {yfiles.algorithms.IMap} nodeMap 
      * a map that contains a mapping between the nodes in the source graph
      * to their corresponding nodes in the new graph.
      * @param {yfiles.algorithms.IMap} edgeMap 
      * a map that contains a mapping between the edges in the source graph
      * to their corresponding edges in the new graph.
      * @see Specified by {@link yfiles.algorithms.GraphCopier.ICopyFactory#postCopyGraphData}.
      */
      postCopyGraphData(originalGraph:yfiles.algorithms.Graph,newGraph:yfiles.algorithms.Graph,nodeMap:yfiles.algorithms.IMap,edgeMap:yfiles.algorithms.IMap):void;
    }
    export module LayoutGraphCopyFactory{
      /**
      * An implementation of the copy factory interface used by {@link yfiles.algorithms.GraphCopier}
      * that can be used by implementations of {@link yfiles.layout.LayoutGraph} that are hierarchically grouped
      * using {@link yfiles.layout.GroupingKeys}.
      */
      export interface HierarchicGraphCopyFactory extends yfiles.algorithms.GraphCopier.GraphDataCopyFactory{
        /**
        * Empty stub to be overwritten by subclass implementations.
        */
        preCopyData(src:yfiles.algorithms.Graph,dst:yfiles.algorithms.Graph):void;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.IMap} nodeMap a Map that maps old node instances to their new copies
        * @param {yfiles.algorithms.IMap} edgeMap a Map that maps old edge instances to their new copies
        */
        postCopyData(src:yfiles.algorithms.Graph,dst:yfiles.algorithms.Graph,nodeMap:yfiles.algorithms.IMap,edgeMap:yfiles.algorithms.IMap):void;
        /**
        * Empty stub to be overwritten by subclass implementations.
        * @param {yfiles.algorithms.Node} src the old entity
        * @param {yfiles.algorithms.Node} dst the new entity
        */
        copyNodeData(src:yfiles.algorithms.Node,dst:yfiles.algorithms.Node):void;
        /**
        * Factory method that creates an id for the given node.
        * This implementation uses the destination node itself as the id for the node.
        */
        createNodeId(srcId:Object,dst:yfiles.algorithms.Node):Object;
      }
    }
    var LayoutGraphCopyFactory:{
      $class:yfiles.lang.Class;
      HierarchicGraphCopyFactory:{
        $class:yfiles.lang.Class;
        new ():yfiles.layout.LayoutGraphCopyFactory;
        WithDelegatingFactory:{
          new (delegatingFactory:yfiles.algorithms.GraphCopier.ICopyFactory):yfiles.layout.LayoutGraphCopyFactory;
        };
      };
    };
    /**
    * Base class for candidate positions for labels.
    */
    export interface LabelCandidate extends Object,yfiles.algorithms.IPlaneObject{
      /**
      * The custom profit for this label candidate.
      * The value is restricted to the interval [0,1] where 1 specifies the highest possible profit (default is 0).
      * Note: the value is only considered if the labeling algorithm uses an optimization strategy (see {@link yfiles.labeling.MISLabelingAlgorithm#optimizationStrategy}).
      * @throws {yfiles.system.ArgumentException} if the value lies not in the interval [0,1].
      */
      customProfit:number;
      /**
      * The model parameter that was used by the underlying model to
      * generate this label candidate.
      */
      modelParameter:Object;
      /**
      * The upper left corner of the label candidate bounds.
      */
      location:yfiles.algorithms.YPoint;
      /**
      * The width and height of the label candidate bounds.
      */
      size:yfiles.algorithms.YDimension;
      /**
      * The minimal x-coordinate of the label candidate bounds.
      */
      x:number;
      /**
      * The minimal y-coordinate of the label candidate bounds.
      */
      y:number;
      /**
      * The width of the label candidate bounds.
      */
      width:number;
      /**
      * The height of the label candidate bounds.
      */
      height:number;
      /**
      * The bounding box of this label candidate.
      * @see Specified by {@link yfiles.algorithms.IPlaneObject#boundingBox}.
      */
      boundingBox:yfiles.algorithms.YRectangle;
      /**
      * The real bounds of this label candidate.
      */
      box:yfiles.algorithms.YOrientedRectangle;
      /**
      * The LabelLayout to which this candidate box belongs.
      */
      owner:yfiles.layout.ILabelLayout;
      /**
      * Specifies whether this candidate is an internal node label, i.e.
      * an label
      * which resides inside the boundaries of a node.
      */
      internal:boolean;
      /**
      * Sets the model parameters of the owner of this label candidate to the
      * model parameters of this candidate box.
      */
      propagate():void;
      /**
      * The penalty for a candidate position that overlaps the bounds of a node.
      * <p>
      * The penalty should be a factor between 0 and 1, where 0 means that an overlap is considered unimportant and 1
      * means that an overlap is considered severe.
      * </p>
      * <p>
      * By default node overlap penalty is set to 1.
      * </p>
      */
      nodeOverlapPenalty:number;
      /**
      * The penalty value for a candidate position that overlaps the path of an edge.
      * <p>
      * The penalty should be a factor between 0 and 1, where 0 means that an overlap is considered unimportant and 1
      * means that an overlap is considered severe.
      * </p>
      * <p>
      * By default edge overlap penalty is set to 1.
      * </p>
      */
      edgeOverlapPenalty:number;
      /**
      * The sum of node overlap penalty and edge overlap penalty.
      * @see {@link yfiles.layout.LabelCandidate#edgeOverlapPenalty}
      * @see {@link yfiles.layout.LabelCandidate#nodeOverlapPenalty}
      */
      overlapPenalty:number;
      /**
      * The model parameter that was used by the underlying model to
      * generate this label candidate.
      */
      parameter:Object;
      /**
      * If this box had been chosen by the labeling algorithm.
      */
      propagated:boolean;
      toString():string;
    }
    var LabelCandidate:{
      $class:yfiles.lang.Class;
      /**
      * Returns a new instance of LabelCandidate.
      * @param {yfiles.algorithms.YPoint} pos 
      * the location of the upper
      * left corner of the candidate.
      * @param {yfiles.algorithms.YDimension} size the size of the candidate.
      * @param {Object} param 
      * the parameters of the labeling model
      * associated with this candidate.
      * @param {yfiles.layout.ILabelLayout} owner the label associated to the candidate.
      */
      FromPointAndSize:{
        new (pos:yfiles.algorithms.YPoint,size:yfiles.algorithms.YDimension,param:Object,owner:yfiles.layout.ILabelLayout):yfiles.layout.LabelCandidate;
      };
      /**
      * Returns a new instance of LabelCandidate.
      * @param {yfiles.algorithms.YPoint} pos 
      * the location of the upper
      * left corner of the candidate.
      * @param {yfiles.algorithms.YDimension} size the size of the candidate.
      * @param {Object} param 
      * the parameters of the labeling model
      * with this candidate.
      * @param {yfiles.layout.ILabelLayout} owner the label associated to the candidate.
      * @param {boolean} internal 
      * flag whether the candidate is
      * allowed to overlap its own feature.
      */
      FromPointAndSizeCanOverlap:{
        new (pos:yfiles.algorithms.YPoint,size:yfiles.algorithms.YDimension,param:Object,owner:yfiles.layout.ILabelLayout,internal:boolean):yfiles.layout.LabelCandidate;
      };
      /**
      * Returns a new instance of LabelCandidate.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBox the box that specifies the candidate's size and position.
      * @param {Object} param 
      * the parameters of the labeling model
      * with this candidate.
      * @param {yfiles.layout.ILabelLayout} owner the label associated to the candidate.
      * @param {boolean} internal 
      * flag whether the candidate is
      * allowed to overlap its own feature.
      */
      FromRectangleCanOverlap:{
        new (labelBox:yfiles.algorithms.YOrientedRectangle,param:Object,owner:yfiles.layout.ILabelLayout,internal:boolean):yfiles.layout.LabelCandidate;
      };
      /**
      * Returns a new instance of LabelCandidate.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBox the box that specifies the candidate's size and position.
      * @param {Object} param 
      * the parameters of the labeling model
      * with this candidate.
      * @param {yfiles.layout.ILabelLayout} owner the label associated to the candidate.
      */
      FromRectangle:{
        new (labelBox:yfiles.algorithms.YOrientedRectangle,param:Object,owner:yfiles.layout.ILabelLayout):yfiles.layout.LabelCandidate;
      };
    };
    export interface LayouterKeys extends Object{
    }
    var LayouterKeys:{
      $class:yfiles.lang.Class;
      /**
      * The data provider key used to look up a unique Object identifier 
      * (consistent with hashCode() and equals() ) for each node in a graph.
      * Layout algorithms may use this information to provide consistent layouts
      * for multiple runs.
      * The looked up data provider should provide Object values
      * for the nodes of that graph. These should be consistent with the Object.hashCode()
      * and Object.equals() methods.
      */
      NODE_ID_DP_KEY:Object;
      /**
      * The data provider key used to look up a unique Object identifier 
      * (consistent with hashCode() and equals() ) for each edge in a graph.
      * Layout algorithms may use this information to provide consistent layouts
      * for multiple runs.
      * The looked up data provider should provide Object values
      * for the edges of that graph. These should be consistent with the Object.hashCode()
      * and Object.equals() methods.
      */
      EDGE_ID_DP_KEY:Object;
      /**
      * The data provider key used to look up the selected
      * state of the nodes of the graph to be laid out.
      * A layout algorithm will try to retrieve a 
      * data provider from the graph to be laid out with this key.
      * The looked up data provider should provide boolean values
      * for the nodes of that graph. The boolean value should signal
      * whether a node is to be considered as selected or not.
      * Note that for several layouters this key is used for restricting the sphere of action,
      * e.g. to layout the subgraph induced by the set of selected nodes in the
      * <code>SubgraphLayouter</code>.
      * However, it is often more convenient to use a specific data provider key for this
      * purpose, for example if you want to combine two layouters of this kind which have to operate
      * on different subsets of the graph. Thus, these layouters provide a method like
      * <code>setSubgraphNodesDpKey(Object)</code> in the case of the <code>SubgraphLayouter</code>
      * for using a different data provider.
      */
      SELECTED_NODES_DP_KEY:Object;
      /**
      * The data provider key used to look up the selected
      * state of the edges of the graph to be laid out.
      * A layout algorithm will try to retrieve a 
      * data provider from the graph to be laid out with this key.
      * The looked up data provider should provide boolean values
      * for the edges of that graph. The boolean value should signal
      * whether an edge is to be considered as selected or not.
      * Note that for several layouters this key is used for restricting the sphere of action,
      * e.g. to route only a subset of the edges by the <code>OrthogonalEdgeRouter</code>.
      * However, it is often more convenient to use a specific data provider key for this
      * purpose, for example if you want to combine two layouters of this kind which have to operate
      * on different subsets of the graph. Thus, these layouters provide a method
      * like <code>setSelectedEdgesDpKey(Object)</code> in the case of the <code>OrthogonalEdgeRouter</code>
      * for using a different data provider.
      */
      SELECTED_EDGES_DP_KEY:Object;
    };
    /**
    * Interface for a layouter that forms a stage of a larger layout
    * process.
    * It delegates the core layout process
    * to another layouter. A layout stage may perform pre-processing steps
    * before the core layouter gets called and post-processing steps after
    * the layouter gets called.
    */
    export interface ILayoutStage extends Object,yfiles.layout.ILayouter{
      /**
      * The core layouter.
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
    }
    var ILayoutStage:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Factory that provides methods to create, add and remove node/edge labels for {@link yfiles.layout.LayoutGraph}s.
    * It can be used, e.g., to temporarily add labels during layout calculation.
    * Note that original labels which are removed during a layout calculation
    * have to be re-added when the layout calculation is done. Otherwise
    * {@link yfiles.layout.BufferedLayouter  buffered layout calculations} and
    * {@link yfiles.layout.LayoutTool#applyGraphLayout  delayed layout results}
    * will most likely produce incorrect results or break down with
    * <code>ClassCastException</code>s.
    * <p>
    * An instance of the factory can be obtained with method {@link yfiles.layout.LayoutTool#getLabelFactory}.
    * This method uses the added protected {@link yfiles.layout.LayoutGraph#createLabelFactory} method to create the factory.
    * </p><p>
    * Note that each factory instance is bound to a specific graph instance, i.e., you can only create, add and remove
    * labels for the graph specified in method {@link yfiles.layout.LayoutTool#getLabelFactory  getLabelFactory}.
    * </p>
    */
    export interface ILabelLayoutFactory extends Object{
      /**
      * The graph associated with this label factory instance.
      * @see Specified by {@link yfiles.layout.ILabelLayoutFactory#graph}.
      */
      graph:yfiles.layout.LayoutGraph;
      /**
      * Adds the given node label layout to the given node.
      * The given label layout has to be created with method {@link yfiles.layout.ILabelLayoutFactory#createNodeLabelLayout}
      * or {@link yfiles.layout.ILabelLayoutFactory#createNodeLabelLayoutWithNodeLayoutAndModel}.
      * <p>
      * Note, implementations of this method must ensure that re-adding temporarily
      * removed original labels during
      * {@link yfiles.layout.BufferedLayouter  buffered layout calculations}
      * automatically restores the original order of labels at the given node.
      * Otherwise the layout calculation will most likely produce incorrect results
      * or break down with <code>ClassCastException</code>s.
      * </p>
      * @param {yfiles.algorithms.Node} node the given node.
      * @param {yfiles.layout.INodeLabelLayout} labelLayout the node label layout that should be added to the given node.
      * @see {@link yfiles.layout.ILabelLayoutFactory#createNodeLabelLayout}
      * @see {@link yfiles.layout.ILabelLayoutFactory#createNodeLabelLayoutWithNodeLayoutAndModel}
      * @throws {yfiles.system.ArgumentException} if the given label layout has already been added to the graph.
      * @see Specified by {@link yfiles.layout.ILabelLayoutFactory#addNodeLabelLayout}.
      */
      addNodeLabelLayout(node:yfiles.algorithms.Node,labelLayout:yfiles.layout.INodeLabelLayout):void;
      /**
      * Removes the given node label layout from the given node.
      * <p>
      * Note that original labels which are removed during a layout calculation
      * have to be re-added when the layout calculation is done. Otherwise
      * {@link yfiles.layout.BufferedLayouter  buffered layout calculations} and
      * {@link yfiles.layout.LayoutTool#applyGraphLayout  delayed layout results}
      * will most likely produce incorrect results or break down with
      * <code>ClassCastException</code>s.
      * </p>
      * @param {yfiles.algorithms.Node} node the given node.
      * @param {yfiles.layout.INodeLabelLayout} labelLayout the label layout that should be removed from the given node.
      * @see {@link yfiles.layout.ILabelLayoutFactory#addEdgeLabelLayout}
      * @see Specified by {@link yfiles.layout.ILabelLayoutFactory#removeNodeLabelLayout}.
      */
      removeNodeLabelLayout(node:yfiles.algorithms.Node,labelLayout:yfiles.layout.INodeLabelLayout):void;
      /**
      * Creates a new label layout for the given node.
      * Note that calling this method has no effect on the node's labels.
      * The returned label layout has to be added to the node using method {@link yfiles.layout.ILabelLayoutFactory#addNodeLabelLayout}.
      * <p>
      * This method should create a label layout with a
      * {@link yfiles.layout.INodeLabelModel} that supports the desired oriented label
      * box exactly as given.
      * </p>
      * @param {yfiles.algorithms.Node} node the given node.
      * @param {yfiles.algorithms.YOrientedRectangle} orientedBox the box specifying the size and location of the label.
      * @return {yfiles.layout.INodeLabelLayout} a new node label layout.
      * @see {@link yfiles.layout.ILabelLayoutFactory#addNodeLabelLayout}
      * @see Specified by {@link yfiles.layout.ILabelLayoutFactory#createNodeLabelLayout}.
      */
      createNodeLabelLayout(node:yfiles.algorithms.Node,orientedBox:yfiles.algorithms.YOrientedRectangle):yfiles.layout.INodeLabelLayout;
      /**
      * Creates a new label layout for the given node.
      * Note that calling this method has no effect on the node's labels.
      * The returned label layout has to be added to the node using method {@link yfiles.layout.ILabelLayoutFactory#addNodeLabelLayout}.
      * <p>
      * Note that the oriented box associated with the created node label layout (see method
      * {@link yfiles.layout.ILabelLayout#orientedBox}) may differ from the given oriented box, i.e.,
      * the box associated with the label layout corresponds to the closest box (with respect to the given box)
      * that is valid in the specified node label model.
      * </p>
      * @param {yfiles.algorithms.Node} node the given node.
      * @param {yfiles.algorithms.YOrientedRectangle} orientedBox the box specifying the size and location of the label.
      * @param {yfiles.layout.INodeLabelModel} model specifies the model of the created node label.
      * @return {yfiles.layout.INodeLabelLayout} a new node label layout.
      * @see {@link yfiles.layout.ILabelLayoutFactory#addNodeLabelLayout}
      * @see Specified by {@link yfiles.layout.ILabelLayoutFactory#createNodeLabelLayoutWithNodeLayoutAndModel}.
      */
      createNodeLabelLayoutWithNodeLayoutAndModel(node:yfiles.algorithms.Node,orientedBox:yfiles.algorithms.YOrientedRectangle,model:yfiles.layout.INodeLabelModel):yfiles.layout.INodeLabelLayout;
      /**
      * Adds the given edge label layout to the given edge.
      * The given label layout has to be created with method
      * {@link yfiles.layout.ILabelLayoutFactory#createEdgeLabelLayout} or
      * {@link yfiles.layout.ILabelLayoutFactory#createEdgeLabelLayoutWithEdgeLayoutModelAndPreferredPlacement}.
      * <p>
      * Note, implementations of this method must ensure that re-adding temporarily
      * removed original labels during
      * {@link yfiles.layout.BufferedLayouter  buffered layout calculations}
      * automatically restores the original order of labels at the given edge.
      * Otherwise the layout calculation will most likely produce incorrect results
      * or break down with <code>ClassCastException</code>s.
      * </p>
      * @param {yfiles.algorithms.Edge} edge the given edge.
      * @param {yfiles.layout.IEdgeLabelLayout} labelLayout the edge label layout that should be added to the given edge.
      * @see {@link yfiles.layout.ILabelLayoutFactory#createEdgeLabelLayout}
      * @see {@link yfiles.layout.ILabelLayoutFactory#createEdgeLabelLayoutWithEdgeLayoutModelAndPreferredPlacement}
      * @throws {yfiles.system.ArgumentException} if the given label layout has already been added to the graph.
      * @see Specified by {@link yfiles.layout.ILabelLayoutFactory#addEdgeLabelLayout}.
      */
      addEdgeLabelLayout(edge:yfiles.algorithms.Edge,labelLayout:yfiles.layout.IEdgeLabelLayout):void;
      /**
      * Removes the given edge label layout from the given edge.
      * <p>
      * Note that original labels which are removed during a layout calculation
      * have to be re-added when the layout calculation is done. Otherwise
      * {@link yfiles.layout.BufferedLayouter  buffered layout calculations} and
      * {@link yfiles.layout.LayoutTool#applyGraphLayout  delayed layout results}
      * will most likely produce incorrect results or break down with <code>ClassCastException</code>s.
      * </p>
      * @param {yfiles.algorithms.Edge} edge the given edge.
      * @param {yfiles.layout.IEdgeLabelLayout} labelLayout the label layout that should be removed from the given edge.
      * @see {@link yfiles.layout.ILabelLayoutFactory#addEdgeLabelLayout}
      * @see Specified by {@link yfiles.layout.ILabelLayoutFactory#removeEdgeLabelLayout}.
      */
      removeEdgeLabelLayout(edge:yfiles.algorithms.Edge,labelLayout:yfiles.layout.IEdgeLabelLayout):void;
      /**
      * Creates a new label layout for the given edge.
      * Note that calling this method has no effect on the edge's labels.
      * The returned label layout has to be added to the edge using method {@link yfiles.layout.ILabelLayoutFactory#addEdgeLabelLayout}.
      * <p>
      * This method should create a label layout with a
      * {@link yfiles.layout.IEdgeLabelModel} that supports the desired oriented label
      * box exactly as given.
      * </p>
      * @param {yfiles.algorithms.Edge} edge the given edge.
      * @param {yfiles.algorithms.YOrientedRectangle} orientedBox the box specifying the size and location of the label.
      * @return {yfiles.layout.IEdgeLabelLayout} a new edge label layout.
      * @see {@link yfiles.layout.ILabelLayoutFactory#addEdgeLabelLayout}
      * @see Specified by {@link yfiles.layout.ILabelLayoutFactory#createEdgeLabelLayout}.
      */
      createEdgeLabelLayout(edge:yfiles.algorithms.Edge,orientedBox:yfiles.algorithms.YOrientedRectangle):yfiles.layout.IEdgeLabelLayout;
      /**
      * Creates a new label layout for the given edge.
      * Note that calling this method has no effect on the edge's labels.
      * The returned label layout has to be added to the edge using method {@link yfiles.layout.ILabelLayoutFactory#addEdgeLabelLayout}.
      * <p>
      * Note that the oriented box associated with the created edge label layout (see method
      * {@link yfiles.layout.ILabelLayout#orientedBox}) may differ from the given oriented box, i.e.,
      * the box associated with the label layout corresponds to the closest box (with respect to the given box)
      * that is valid in the specified edge label model.
      * </p>
      * @param {yfiles.algorithms.Edge} edge the given edge.
      * @param {yfiles.algorithms.YOrientedRectangle} orientedBox the box specifying the size and location of the label.
      * @param {yfiles.layout.IEdgeLabelModel} model specifies the model of the created edge label.
      * @param {yfiles.layout.PreferredPlacementDescriptor} descriptor 
      * specifies the preferred placement descriptor of the created label. If this value is
      * <code>null</code>, the default descriptor is used.
      * @return {yfiles.layout.IEdgeLabelLayout} a new edge label layout.
      * @see {@link yfiles.layout.ILabelLayoutFactory#addEdgeLabelLayout}
      * @see Specified by {@link yfiles.layout.ILabelLayoutFactory#createEdgeLabelLayoutWithEdgeLayoutModelAndPreferredPlacement}.
      */
      createEdgeLabelLayoutWithEdgeLayoutModelAndPreferredPlacement(edge:yfiles.algorithms.Edge,orientedBox:yfiles.algorithms.YOrientedRectangle,model:yfiles.layout.IEdgeLabelModel,descriptor:yfiles.layout.PreferredPlacementDescriptor):yfiles.layout.IEdgeLabelLayout;
    }
    var ILabelLayoutFactory:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This is a general interface for algorithms that
    * perform a layout process on a given layout graph.
    */
    export interface ILayouter extends Object{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var ILayouter:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This interface describes the layout information for a node in the drawing
    * of a graph.
    * The layout information consists of the size and position of the node.
    */
    export interface INodeLayout extends Object{
      /**
      * X-Coordinate of the upper left corner of the node.
      * @see Specified by {@link yfiles.layout.INodeLayout#x}.
      */
      x:number;
      /**
      * Y-Coordinate of the upper left corner of the node.
      * @see Specified by {@link yfiles.layout.INodeLayout#y}.
      */
      y:number;
      /**
      * The width of the node.
      * @see Specified by {@link yfiles.layout.INodeLayout#width}.
      */
      width:number;
      /**
      * The height of the node.
      * @see Specified by {@link yfiles.layout.INodeLayout#height}.
      */
      height:number;
      /**
      * Sets the coordinates of the upper left corner of the node.
      * @param {number} x the x-coordinates of the upper left corner.
      * @param {number} y the y-coordinates of the upper left corner.
      * @see Specified by {@link yfiles.layout.INodeLayout#setLocation}.
      */
      setLocation(x:number,y:number):void;
      /**
      * Sets the size of the node.
      * @param {number} width the width of the node.
      * @param {number} height the height of the node.
      * @see Specified by {@link yfiles.layout.INodeLayout#setSize}.
      */
      setSize(width:number,height:number):void;
    }
    var INodeLayout:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This is an interface for ranking LabelCandidates.
    */
    export interface IProfitModel extends Object{
      /**
      * Returns the profit for placing a label-candidate.
      * Higher profit means higher probability that the candidate is chosen
      * by a labeling algorithm.
      * @param {yfiles.layout.LabelCandidate} candidate a label candidate
      * @return {number} a value between 0 and 1.
      * @see Specified by {@link yfiles.layout.IProfitModel#getProfit}.
      */
      getProfit(candidate:yfiles.layout.LabelCandidate):number;
    }
    var IProfitModel:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This interface defines the properties of one edge label
    * from the perspective of a labeling algorithm.
    * <p>
    * Note: if you update the model parameter with {@link yfiles.layout.ILabelLayout#modelParameter} you should also
    * update the corresponding {@link yfiles.layout.ILabelLayout#orientedBox  oriented box} to avoid inconsistency.
    * </p>
    */
    export interface INodeLabelLayout extends Object,yfiles.layout.ILabelLayout{
      /**
      * The node label model associated with this label layout.
      * @see Specified by {@link yfiles.layout.INodeLabelLayout#labelModel}.
      */
      labelModel:yfiles.layout.INodeLabelModel;
    }
    var INodeLabelLayout:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This interface defines the properties of the model
    * associated with a node label layout.
    * <p>
    * A node label model provides a set of possible
    * candidates for the placement of a node label.
    * </p>
    */
    export interface INodeLabelModel extends Object{
      /**
      * A model parameter that encodes the default position of this model's
      * allowed node label positions.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#defaultParameter}.
      */
      defaultParameter:Object;
      /**
      * Returns the oriented label position and bounds encoded by the given model
      * parameter.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label that should be placed.
      * @param {yfiles.layout.INodeLayout} nodeLayout The layout of the node to which the label belongs.
      * @param {Object} param 
      * The model parameter that describes the abstract position of
      * the label within this model. The parameter must have been generated by
      * this model.
      * @return {yfiles.algorithms.YOrientedRectangle} the oriented label position and bounds.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#getLabelPlacement}.
      */
      getLabelPlacement(labelSize:yfiles.algorithms.YDimension,nodeLayout:yfiles.layout.INodeLayout,param:Object):yfiles.algorithms.YOrientedRectangle;
      /**
      * Returns a list of {@link yfiles.layout.NodeLabelCandidate} objects each of which describes
      * a valid label position within this model.
      * @param {yfiles.layout.INodeLabelLayout} nl The label layout for which candidates should be generated.
      * @param {yfiles.layout.INodeLayout} nodeLayout The layout of the node to which the label belongs.
      * @return {yfiles.algorithms.YList} 
      * A list of {@link yfiles.layout.NodeLabelCandidate} objects.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#getLabelCandidates}.
      */
      getLabelCandidates(nl:yfiles.layout.INodeLabelLayout,nodeLayout:yfiles.layout.INodeLayout):yfiles.algorithms.YList;
      /**
      * Creates a model parameter that represents the given node label context best
      * within this model.
      * The created model parameter represents the closest parameter representation
      * of the given oriented label bounds that can be achieved within this model.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBounds The bounds of the label for which a parameter representation is sought.
      * @param {yfiles.layout.INodeLayout} nodeLayout The layout of the node to which the label belongs.
      * @return {Object} 
      * A model parameter that can be passed to the
      * {@link yfiles.layout.INodeLabelModel#getLabelPlacement} method.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#createModelParameter}.
      */
      createModelParameter(labelBounds:yfiles.algorithms.YOrientedRectangle,nodeLayout:yfiles.layout.INodeLayout):Object;
    }
    var INodeLabelModel:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This interface defines the properties of one label
    * from the perspective of a labeling algorithm.
    */
    export interface ILabelLayout extends Object{
      /**
      * The bounding box of the label.
      * @see Specified by {@link yfiles.layout.ILabelLayout#box}.
      */
      box:yfiles.algorithms.YRectangle;
      /**
      * The box of the label.
      * @see Specified by {@link yfiles.layout.ILabelLayout#orientedBox}.
      */
      orientedBox:yfiles.algorithms.YOrientedRectangle;
      /**
      * The label model parameter that describes
      * the position of this label.
      * @see Specified by {@link yfiles.layout.ILabelLayout#modelParameter}.
      */
      modelParameter:Object;
    }
    var ILabelLayout:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This interface defines the properties of one edge label
    * from the perspective of a labeling algorithm.
    * <p>
    * Note: if you update the model parameter with {@link yfiles.layout.ILabelLayout#modelParameter} you should also
    * update the corresponding {@link yfiles.layout.ILabelLayout#orientedBox oriented box} to avoid inconsistency.
    * </p>
    */
    export interface IEdgeLabelLayout extends Object,yfiles.layout.ILabelLayout{
      /**
      * The edge label model associated with this label layout.
      * @see Specified by {@link yfiles.layout.IEdgeLabelLayout#labelModel}.
      */
      labelModel:yfiles.layout.IEdgeLabelModel;
      /**
      * Preferred placement hints for layout algorithms.
      * @see Specified by {@link yfiles.layout.IEdgeLabelLayout#preferredPlacementDescriptor}.
      */
      preferredPlacementDescriptor:yfiles.layout.PreferredPlacementDescriptor;
    }
    var IEdgeLabelLayout:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This interface defines the properties of the model associated with an edge label
    * layout.
    * <p>
    * An edge label model provides a set of possible candidates for the placement of
    * an edge label.
    * </p>
    */
    export interface IEdgeLabelModel extends Object{
      /**
      * A model parameter that encodes the default position of this model's
      * allowed edge label positions.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#defaultParameter}.
      */
      defaultParameter:Object;
      /**
      * Returns the bounds of the label for the position encoded
      * by the given model parameter.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label that should be placed.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @param {Object} param 
      * The model parameter that describes the abstract position of the label within
      * this model.
      * The parameter must have been generated by this model.
      * @return {yfiles.algorithms.YOrientedRectangle} The bounds of the label.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}.
      */
      getLabelPlacement(labelSize:yfiles.algorithms.YDimension,edgeLayout:yfiles.layout.IEdgeLayout,sourceLayout:yfiles.layout.INodeLayout,targetLayout:yfiles.layout.INodeLayout,param:Object):yfiles.algorithms.YOrientedRectangle;
      /**
      * Returns a list of {@link yfiles.layout.EdgeLabelCandidate} objects each of which describes
      * a valid label position within this model.
      * @param {yfiles.layout.IEdgeLabelLayout} labelLayout The label for which candidates should be generated.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @return {yfiles.algorithms.YList} 
      * A list of {@link yfiles.layout.EdgeLabelCandidate} objects.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelCandidates}.
      */
      getLabelCandidates(labelLayout:yfiles.layout.IEdgeLabelLayout,edgeLayout:yfiles.layout.IEdgeLayout,sourceLayout:yfiles.layout.INodeLayout,targetLayout:yfiles.layout.INodeLayout):yfiles.algorithms.YList;
      /**
      * Creates a model parameter that represents the given edge label context best
      * within this model.
      * The created model parameter represents the closest parameter representation
      * of the given label location that can be achieved within this model.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBounds The bounds of the label for which a parameter representation is sought.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @return {Object} 
      * A model parameter that can be passed to the
      * {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}
      * method.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#createModelParameter}.
      */
      createModelParameter(labelBounds:yfiles.algorithms.YOrientedRectangle,edgeLayout:yfiles.layout.IEdgeLayout,sourceLayout:yfiles.layout.INodeLayout,targetLayout:yfiles.layout.INodeLayout):Object;
    }
    var IEdgeLabelModel:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This layout stage ensures that layout algorithms that cannot handle port constraints keep the
    * ports of edges with strong port constraints.
    * Without this stage the port locations get lost.
    * <p>
    * For each edge with strong port constraints, this stage simply stores the original port and restores it
    * after applying the core layouter.
    * Therefore, it either replaces the source/target port
    * by the original port or adds the original port to the
    * edge path calculated by the core layouter (see method {@link yfiles.layout.KeepStrongPortConstraintsStage#keepCalculatedPorts}).
    * </p>
    */
    export interface KeepStrongPortConstraintsStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Specifies whether or not the final edge routes should contain the ports calculated by the core layouter.
      * If this option is disabled, the
      * layout stage simply replaces the current source/target ports (calculated by the core layouter)
      * by the original ports (for strong ports only). Otherwise, the calculated ports are still contained in the
      * edge paths. Note that for layout algorithms
      * that produce non straight-line edge routes this option should always be enabled.
      * <p>
      * By default this option is enabled.
      * </p>
      */
      keepCalculatedPorts:boolean;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var KeepStrongPortConstraintsStage:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of this layout stage.
      */
      new ():yfiles.layout.KeepStrongPortConstraintsStage;
      /**
      * Creates a new instance of this layout stage using the specified layouter as core layouter.
      * @param {yfiles.layout.ILayouter} core the core layouter.
      */
      WithCoreLayouter :{
        new (core:yfiles.layout.ILayouter):yfiles.layout.KeepStrongPortConstraintsStage;
      };
    };
    /**
    * Interface implemented by classes that are responsible for calculating the
    * intersection point between an Edge and the visual representation of its
    * source or target node.
    * This interface is especially useful in conjunction with
    * the  {@link yfiles.layout.ILayoutStage}.
    */
    export interface IIntersectionCalculator extends Object{
      /**
      * Calculates an intersection point given the coordinates of a point lying on
      * the last/first segment of an Edge and a normalized direction.
      * If no such intersection can be found this method should return <code>null</code>.
      * @param {yfiles.layout.INodeLayout} nl 
      * the currently calculated {@link yfiles.layout.INodeLayout}
      * @param {number} xOffset 
      * the relative (to the node's center)
      * x-coordinate of a point on the last line segment
      * @param {number} yOffset the relative y-coordinate of a point on the last line segment
      * @param {number} dx 
      * the x component of the normalized direction vector indicating the
      * direction of the segment pointing towards the node
      * @param {number} dy 
      * the y component of the normalized direction vector indicating the
      * direction of the segment pointing towards the node
      * @return {yfiles.algorithms.YPoint} 
      * the new relative (to the node's center) intersection coordinates or
      * <code>null</code> if no such intersection could be found
      * @see Specified by {@link yfiles.layout.IIntersectionCalculator#calculateIntersectionPoint}.
      */
      calculateIntersectionPoint(nl:yfiles.layout.INodeLayout,xOffset:number,yOffset:number,dx:number,dy:number):yfiles.algorithms.YPoint;
    }
    var IIntersectionCalculator:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    export interface IntersectionCalculatorKeys extends Object{
    }
    var IntersectionCalculatorKeys:{
      $class:yfiles.lang.Class;
      /**
      * Key to be used when registering a DataProvider to a graph instance that provides
      * for each Edge object in a graph an <code>IntersectionCalculator</code> instance
      * that is configured to calculate the intersection of the edge and the source 
      * node.
      */
      SOURCE_INTERSECTION_CALCULATOR_DP_KEY:Object;
      /**
      * Key to be used when registering a DataProvider to a graph instance that provides
      * for each Edge object in a graph an <code>IntersectionCalculator</code> instance
      * that is configured to calculate the intersection of the edge and the target
      * node.
      */
      TARGET_INTERSECTION_CALCULATOR_DP_KEY:Object;
    };
    /**
    * This interface encapsulates the layout information for an edge.
    * The layout information consists of
    * the two end points of the edge layout and a sequence of control points
    * that determine the visual path of the edge.
    */
    export interface IEdgeLayout extends Object{
      /**
      * Returns the number of control points of the edge.
      * The source and target points are not included in the point count.
      * @return {number} the number of control points
      * @see Specified by {@link yfiles.layout.IEdgeLayout#pointCount}.
      */
      pointCount():number;
      /**
      * Returns the control point at position <code>index</code> of
      * the sequence.
      * @see {@link yfiles.layout.IEdgeLayout#setPoint}
      * @param {number} index position of the control point in the control point sequence.
      * @return {yfiles.algorithms.YPoint} the absolute coordinates of the control point at the given index.
      * @see Specified by {@link yfiles.layout.IEdgeLayout#getPoint}.
      */
      getPoint(index:number):yfiles.algorithms.YPoint;
      /**
      * Sets the coordinates of the control point at position <code>index</code> of
      * the sequence.
      * The first control point in the sequence has index 0
      * and the last control point has index pointCount() - 1.
      * @param {number} index position of the control point in the control point sequence.
      * @param {number} x absolute x-coordinate of the control point at the given index.
      * @param {number} y absolute y-coordinate of the control point at the given index.
      * @see Specified by {@link yfiles.layout.IEdgeLayout#setPoint}.
      */
      setPoint(index:number,x:number,y:number):void;
      /**
      * Adds a control point to the end of the control point sequence.
      * @param {number} x the absolute x-coordinate of the control point.
      * @param {number} y the absolute y-coordinate of the control point.
      * @see Specified by {@link yfiles.layout.IEdgeLayout#addPoint}.
      */
      addPoint(x:number,y:number):void;
      /**
      * Remove all control points from this edge layout.
      * @see Specified by {@link yfiles.layout.IEdgeLayout#clearPoints}.
      */
      clearPoints():void;
      /**
      * The relative coordinates of the first end point of this layout
      * that is associated with the source node of the edge.
      * <b>Getter:</b>The returned coordinates are relative to the center location of the source
      * node of the edge. To obtain the absolute coordinates of the end point it
      * is therefore necessary to add the center coordinates of the source node layout
      * to the returned value.
      * <b>Setter:</b>The given coordinates must be relative to the center location of the source
      * node of the edge.
      * @see {@link yfiles.layout.LayoutGraph#getCenterX}
      * @see {@link yfiles.layout.LayoutGraph#getCenterY}
      * @see {@link yfiles.layout.INodeLayout#x}
      * @see {@link yfiles.layout.INodeLayout#width}
      * @see {@link yfiles.layout.IEdgeLayout#targetPoint}
      * @see Specified by {@link yfiles.layout.IEdgeLayout#sourcePoint}.
      */
      sourcePoint:yfiles.algorithms.YPoint;
      /**
      * The relative coordinates of the second end point of this layout
      * that is associated with the target node of the edge.
      * <b>Getter:</b>The returned coordinates are relative to the center location of the target
      * node of the edge. To obtain the absolute coordinates of the end point it
      * is therefore necessary to add the center coordinates of the target node layout
      * to the returned value.
      * <b>Setter:</b>The given coordinates must be relative to the center location of the target
      * node of the edge.
      * @see {@link yfiles.layout.LayoutGraph#getCenterX}
      * @see {@link yfiles.layout.LayoutGraph#getCenterY}
      * @see {@link yfiles.layout.INodeLayout#x}
      * @see {@link yfiles.layout.INodeLayout#width}
      * @see Specified by {@link yfiles.layout.IEdgeLayout#targetPoint}.
      */
      targetPoint:yfiles.algorithms.YPoint;
    }
    var IEdgeLayout:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This interface defines the layout information of a  graph.
    */
    export interface IGraphLayout extends Object{
      /**
      * Returns the layout information for a given node.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getNodeLayout}.
      */
      getNodeLayout(node:Object):yfiles.layout.INodeLayout;
      /**
      * Returns the layout information for a given edge.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getEdgeLayout}.
      */
      getEdgeLayout(edge:Object):yfiles.layout.IEdgeLayout;
      /**
      * Returns an array of layout information for all node labels
      * belonging to the given node.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getNodeLabelLayout}.
      */
      getNodeLabelLayout(node:Object):yfiles.layout.INodeLabelLayout[];
      /**
      * Returns an array of layout information for all edge labels
      * belonging to the given edge.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getEdgeLabelLayout}.
      */
      getEdgeLabelLayout(edge:Object):yfiles.layout.IEdgeLabelLayout[];
      /**
      * Returns the bounding box of the graph layout.
      * That is the smallest rectangular area that contains all
      * defined layout elements. If there are no elements in this
      * graph layout, the resulting rectangle will have negative
      * width and height.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getBoundingBox}.
      */
      getBoundingBox():yfiles.algorithms.Rectangle;
    }
    var IGraphLayout:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This class is an default implementation of the EdgeLabelLayout
    * interface.
    */
    export interface EdgeLabelLayoutImpl extends yfiles.layout.LabelLayoutImpl,yfiles.layout.IEdgeLabelLayout{
      /**
      * The edge label model associated with this label layout.
      * @see Specified by {@link yfiles.layout.IEdgeLabelLayout#labelModel}.
      */
      labelModel:yfiles.layout.IEdgeLabelModel;
      /**
      * The edge label model associated with this label layout.
      */
      edgeLabelModel:yfiles.layout.IEdgeLabelModel;
      /**
      * The preferred placement of this label.
      */
      preferredPlacement:yfiles.layout.LabelPlacements;
      /**
      * The preferred placement of this label.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified descriptor is
      * <code>null</code>.
      * @see Specified by {@link yfiles.layout.IEdgeLabelLayout#preferredPlacementDescriptor}.
      */
      preferredPlacementDescriptor:yfiles.layout.PreferredPlacementDescriptor;
    }
    var EdgeLabelLayoutImpl:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new <code>EdgeLabelLayoutImpl</code> instance.
      */
      new ():yfiles.layout.EdgeLabelLayoutImpl;
    };
    /**
    * Helper for layouter with integrated edge labeling to support orientation and mirroring.
    * <p>
    * To calculate the position and orientation of edge labels, whose placements are defined with the
    * {@link yfiles.layout.PreferredPlacementDescriptor}, the {@link yfiles.layout.OrientationLayouter} would need the direction of the associated
    * edge. Since this direction is not available for the <code>OrientationLayouter</code>, because it is a wrapper, the
    * calculation must be done in the core layouter itself with the help of the <code>EdgeLabelOrientationSupport</code>.
    * </p>
    * <p>
    * Important: Since all layouters with integrated edge labeling could not deal with ambiguous preferred placement
    * descriptors (combinations of the same setting e.g. source or target for the
    * {@link yfiles.layout.PreferredPlacementDescriptor#placeAlongEdge}),
    * {@link yfiles.layout.EdgeLabelOrientationSupport#preProcessLabel} removes combinations and replaces the original
    * descriptor with a "non-ambiguous" one during the layout calculation.
    * </p>
    */
    export interface EdgeLabelOrientationSupport extends Object{
      /**
      * Replaces the {@link yfiles.layout.PreferredPlacementDescriptor}s of all edge labels in the given graph with non-ambiguous
      * descriptors.
      * <p>
      * It should be called by a layouter at the beginning of layout calculation to assure that the label's placement
      * is handled consistently.
      * </p>
      */
      replaceAmbiguousLabelDescriptors(graph:yfiles.algorithms.Graph):void;
      /**
      * Restores the {@link yfiles.layout.PreferredPlacementDescriptor}s of all edge labels in the given graph with their original
      * descriptors.
      * <p>
      * It should be called by a layouter at the end of layout calculation to assure that the original state of the
      * graph is not corrupted.
      * </p>
      */
      resetAmbiguousLabelDescriptors(graph:yfiles.algorithms.Graph):void;
      /**
      * Called by the core layouter with the integrated edge labeling for each edge label before the layouter uses the
      * labels geometry.
      * The method should be called as soon as the direction of the segment the label belongs to is
      * determined.
      * <p>
      * First it replaces the {@link yfiles.layout.LabelLayoutData#preferredPlacementDescriptor} of the edge label by a
      * <code>PreferredPlacementDescriptor</code> that has only relative references. This descriptor is orientation
      * independent and could be used in the core layouter. Second it rotates the
      * {@link yfiles.layout.LabelLayoutData#bounds  label} in respect of it <code>PreferredPlacementDescriptor</code> and
      * the direction of the segment it belongs to. After that call the core layouter could use the geometry
      * ({@link yfiles.layout.LabelLayoutData#width} and {@link yfiles.layout.LabelLayoutData#width}) of the label to
      * calculate its location.
      * </p>
      * @param {yfiles.algorithms.Graph} graph graph to get the orientation information from
      * @param {yfiles.layout.LabelLayoutData} label edge label whose segment direction is determined
      * @param {yfiles.layout.Direction} segmentDirection direction of the segment the edge label belongs to
      */
      preProcessLabel(graph:yfiles.algorithms.Graph,label:yfiles.layout.LabelLayoutData,segmentDirection:yfiles.layout.Direction):void;
      /**
      * Called by the core layouter with the integrated edge labeling for each edge label after the location of the label
      * is determined.
      * <p>
      * It restores the original {@link yfiles.layout.LabelLayoutData#preferredPlacementDescriptor} that has been replaced
      * in {@link yfiles.layout.EdgeLabelOrientationSupport#preProcessLabel}. Then it move and rotates the
      * {@link yfiles.layout.LabelLayoutData#bounds  label} in respect of the orientation.
      * </p>
      * @param {yfiles.algorithms.Graph} graph graph to get the orientation information from
      * @param {yfiles.layout.LabelLayoutData} label edge label whose location is determined
      */
      postProcessLabel(graph:yfiles.algorithms.Graph,label:yfiles.layout.LabelLayoutData):void;
    }
    var EdgeLabelOrientationSupport:{
      $class:yfiles.lang.Class;
      /**
      * Creates an instance.
      * Since this class handles the orientation of the edge labels, the core layouter should switch
      * the calculation in its {@link yfiles.layout.OrientationLayouter} off.
      */
      new ():yfiles.layout.EdgeLabelOrientationSupport;
      /**
      * Transforms a direction of the layout to the oriented layout.
      * @param {yfiles.layout.Direction} direction direction in the layout
      * @param {number} orientation 
      * @param {number} mirrorMask @return the direction in the oriented layout
      */
      getOrientedDirection(direction:yfiles.layout.Direction,orientation:number,mirrorMask:number):yfiles.layout.Direction;
      /**
      * Returns whether or not the orientation is mirrored.
      * @return {boolean} <code>true</code> if the orientation is mirrored; <code>false</code> otherwise
      * @param {number} orientation 
      * @param {number} mirrorMask 
      */
      isOrientationMirrored(orientation:number,mirrorMask:number):boolean;
      /**
      * Calculates and sets the up vector of an edge label considering the preferred placement of the label as well as the
      * direction of the edge segment the label is attached to.
      * @param {yfiles.layout.LabelLayoutData} label The data that describes the label orientation and is used to set the new up vector.
      * @param {yfiles.layout.Direction} segmentDirection The direction the edge segment is pointing to.
      * @see {@link yfiles.layout.EdgeLabelOrientationSupport#getEdgeLabelUpVector}
      */
      updateLabelOrientation(label:yfiles.layout.LabelLayoutData,segmentDirection:yfiles.layout.Direction):void;
      /**
      * Calculates the up vector of an edge label considering the preferred placement of the label as well as the direction
      * of the edge segment the label is attached to.
      * @param {yfiles.layout.PreferredPlacementDescriptor} descriptor The data describing the preferred label orientation.
      * @param {yfiles.layout.Direction} segmentDirection The direction the edge segment is pointing to.
      * @return {yfiles.algorithms.YVector} 
      * An up vector for the edge label that considers the preferred placement of the label as well as the
      * direction of the edge segment the label is attached to.
      */
      getEdgeLabelUpVector(descriptor:yfiles.layout.PreferredPlacementDescriptor,segmentDirection:yfiles.layout.Direction):yfiles.algorithms.YVector;
      /**
      * Calculates the up vector for a label whose right vector is rotated clockwise by the given rightVectorAngle.
      * @param {number} rightVectorAngle The angle in radians the right vector is rotated by.
      * @return {yfiles.algorithms.YVector} The up vector for a label whose right vector is rotated clockwise by the given angle.
      */
      getLabelUpVector(rightVectorAngle:number):yfiles.algorithms.YVector;
    };
    /**
    * An edge label model that allows placement of labels
    * at a fixed offset from the source intersection point of the node.
    */
    export interface FreeEdgeLabelLayoutModel extends Object,yfiles.layout.IEdgeLabelModel{
      /**
      * The default parameter.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#defaultParameter}.
      */
      defaultParameter:Object;
      /**
      * Returns a model parameter that represents the given edge label
      * context.
      * The created model parameter reproduces the location
      * of the given label bounds.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#createModelParameter}.
      */
      createModelParameter(labelBounds:yfiles.algorithms.YOrientedRectangle,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):Object;
      /**
      * Returns the positions of the upper left corner of the label
      * with given parameter.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}.
      */
      getLabelPlacement(labelSize:yfiles.algorithms.YDimension,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout,param:Object):yfiles.algorithms.YOrientedRectangle;
      /**
      * Returns exactly one label candidate that corresponds to
      * the actual label layout of the given label.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelCandidates}.
      */
      getLabelCandidates(label:yfiles.layout.IEdgeLabelLayout,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):yfiles.algorithms.YList;
    }
    export module FreeEdgeLabelLayoutModel{
      /**
      * The model parameters for the <code>FreeEdgeLabelModel</code>.
      */
      export interface ModelParameter extends Object{
        /**
        * The rotation angle of the label defined by this label position.
        */
        angle:number;
        /**
        * A point whose x-coordinate corresponds to the radius associated with this
        * class and whose y-coordinate corresponds to the angle associated with this class.
        */
        point:yfiles.algorithms.YPoint;
        /**
        * Sets angle and radius for this class.
        * The x-coordinate of the given point
        * holds the radius, the y-coordinate the angle.
        */
        setPoint(radius:number,theta:number):void;
        toString():string;
      }
    }
    var FreeEdgeLabelLayoutModel:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of {@link yfiles.layout.FreeEdgeLabelLayoutModel}.
      */
      new ():yfiles.layout.FreeEdgeLabelLayoutModel;
      ModelParameter:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of {@link yfiles.layout.FreeEdgeLabelLayoutModel.ModelParameter} with radius <code>50</code>
        * and angle <code>0</code>.
        */
        new ():yfiles.layout.FreeEdgeLabelLayoutModel;
        /**
        * Creates a new instance of {@link yfiles.layout.FreeEdgeLabelLayoutModel.ModelParameter} with given radius and angle.
        * @param {number} radius the distance of the label from the source node of the underlying edge
        * @param {number} theta 
        * the angle between the first segment of the underlying edge and the imaginary line to the center of
        * the label. the angle is measured in radian.
        */
        WithRadiusAndAngle:{
          new (radius:number,theta:number):yfiles.layout.FreeEdgeLabelLayoutModel;
        };
        /**
        * Creates a new instance of {@link yfiles.layout.FreeEdgeLabelLayoutModel.ModelParameter} with given radius and angle.
        * @param {number} radius the distance of the label from the source node of the underlying edge
        * @param {number} theta 
        * the angle between the first segment of the underlying edge and the
        * imaginary line to the center of the label. the angle is measured in radian.
        * @param {number} angle the rotation angle of the label.
        */
        WithRadiusAndAngleAndRotation:{
          new (radius:number,theta:number,angle:number):yfiles.layout.FreeEdgeLabelLayoutModel;
        };
      };
    };
    /**
    * A candidate position for edge labels.
    */
    export interface EdgeLabelCandidate extends yfiles.layout.LabelCandidate{
    }
    var EdgeLabelCandidate:{
      $class:yfiles.lang.Class;
      /**
      * Returns a new instance of LabelCandidate.
      * @param {yfiles.algorithms.YPoint} pos 
      * the location of the upper
      * left corner of the candidate.
      * @param {yfiles.algorithms.YDimension} size the size of the candidate.
      * @param {Object} param 
      * the parameters of the labeling model
      * associated with this candidate.
      * @param {yfiles.layout.IEdgeLabelLayout} owner the label associated to the candidate.
      */
      FromPointAndSize:{
        new (pos:yfiles.algorithms.YPoint,size:yfiles.algorithms.YDimension,param:Object,owner:yfiles.layout.IEdgeLabelLayout):yfiles.layout.EdgeLabelCandidate;
      };
      /**
      * Returns a new instance of EdgeLabelCandidate.
      * @param {yfiles.algorithms.YPoint} pos 
      * the location of the upper
      * left corner of the candidate.
      * @param {yfiles.algorithms.YDimension} size the size of the candidate.
      * @param {Object} param 
      * the parameters of the labeling model
      * associated with this candidate.
      * @param {yfiles.layout.IEdgeLabelLayout} owner the label associated to the candidate.
      * @param {boolean} internal 
      * flag whether the candidate is
      * allowed to overlap the layout of the associated edge.
      */
      FromPointAndSizeCanOverlap:{
        new (pos:yfiles.algorithms.YPoint,size:yfiles.algorithms.YDimension,param:Object,owner:yfiles.layout.IEdgeLabelLayout,internal:boolean):yfiles.layout.EdgeLabelCandidate;
      };
      /**
      * Returns a new instance of EdgeLabelCandidate.
      * @param {yfiles.algorithms.YOrientedRectangle} orientedBox the box that specifies the candidate's size and position.
      * @param {Object} param 
      * the parameters of the labeling model
      * associated with this candidate.
      * @param {yfiles.layout.IEdgeLabelLayout} owner the label associated to the candidate.
      * @param {boolean} internal 
      * flag whether the candidate is
      * allowed to overlap the layout of the associated edge.
      */
      new (orientedBox:yfiles.algorithms.YOrientedRectangle,param:Object,owner:yfiles.layout.IEdgeLabelLayout,internal:boolean):yfiles.layout.EdgeLabelCandidate;
      /**
      * Returns a new instance of EdgeLabelCandidate.
      * @param {yfiles.algorithms.YOrientedRectangle} orientedBox the box that specifies the candidate's size and position.
      * @param {Object} param 
      * the parameters of the labeling model
      * associated with this candidate.
      * @param {yfiles.layout.IEdgeLabelLayout} owner the label associated to the candidate.
      */
      FromRectangle:{
        new (orientedBox:yfiles.algorithms.YOrientedRectangle,param:Object,owner:yfiles.layout.IEdgeLabelLayout):yfiles.layout.EdgeLabelCandidate;
      };
    };
    /**
    * Class that represents directions.
    * Note: for each direction there exists exactly one object.
    */
    export interface Direction extends Object{
      /**
      * The direction that follows this direction in clockwise order.
      */
      turnCW:yfiles.layout.Direction;
      /**
      * The direction that follows this direction in counterclockwise order.
      */
      turnCCW:yfiles.layout.Direction;
      /**
      * The mirror direction (turns the direction two times).
      */
      mirror:yfiles.layout.Direction;
      /**
      * True if this direction is horizontal (right or left).
      */
      horizontal:boolean;
      /**
      * True if this direction is vertical (up or down).
      */
      vertical:boolean;
      /**
      * Returns the direction as int value.
      * @return {number} 0 for UP, 1 for RIGHT, 2 for DOWN, and 3 for LEFT.
      */
      getDirection():number;
      /**
      * Returns the current direction as string.
      * @return {string} ^ for UP, &gt; for RIGHT, v for DOWN, and &lt; for LEFT.
      */
      toString():string;
    }
    var Direction:{
      $class:yfiles.lang.Class;
      /**
      * Decodes the up direction.
      */
      UP:yfiles.layout.Direction;
      /**
      * Decodes the right direction.
      */
      RIGHT:yfiles.layout.Direction;
      /**
      * Decodes the down direction.
      */
      DOWN:yfiles.layout.Direction;
      /**
      * Decodes the left direction.
      */
      LEFT:yfiles.layout.Direction;
    };
    /**
    * An edge label model that allows placement of labels
    * at some positions along an edge.
    * <p>
    * It's possible to specify a distance value that controls the
    * distance between label and edge.
    * Furthermore, there's the possibility to mask out
    * arbitrary edge label candidates. This can either be done by
    * specifying predefined candidate masks or by OR-ing allowed label
    * candidates to a user defined mask.
    * </p>
    */
    export interface DiscreteEdgeLabelLayoutModel extends Object,yfiles.layout.IEdgeLabelModel{
      /**
      * The bit mask specifying the valid positions for edge labels.
      * <p>
      * Defaults to {@link yfiles.layout.DiscreteEdgeLabelPosition#SIX_POS}.
      * </p>
      */
      candidateMask:yfiles.layout.DiscreteEdgeLabelPosition;
      /**
      * The distance between the label's bounding box and the edge's path.
      */
      distance:number;
      /**
      * A model parameter that encodes the default position of this model's
      * allowed edge label positions.
      * Default positions are (in descending order):
      * <ul>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#CENTER}</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#SCENTER}</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#TAIL}</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#STAIL}</li>
      * </ul>
      * Descending order means that whenever two or more of the above default positions
      * are part of the allowed positions, then the model parameter encodes the one
      * that is listed first.
      * Note that the model parameter encodes {@link yfiles.layout.DiscreteEdgeLabelPosition#CENTER} when none of the above
      * default positions is part of the allowed positions.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#defaultParameter}.
      */
      defaultParameter:Object;
      /**
      * Creates a model parameter that represents the given edge label context best
      * within this model.
      * The created model parameter represents the closest parameter representation
      * of the given label location that can be achieved within this model.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBounds The bounds of the label for which a parameter representation is sought.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @return {Object} 
      * A model parameter that can be passed to the
      * {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}
      * method.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#createModelParameter}.
      */
      createModelParameter(labelBounds:yfiles.algorithms.YOrientedRectangle,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):Object;
      /**
      * Checks if the given model parameter encodes an edge label position that is
      * valid in this model.
      * @return {boolean} 
      * Whether the label position encoded by the given model parameter is among the
      * allowed positions.
      */
      isParameterValid(parameter:Object):boolean;
      /**
      * Returns the bounds of the label for the position encoded
      * by the given model parameter.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label that should be placed.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @param {Object} param 
      * The model parameter that describes the abstract position of the label within
      * this model.
      * The parameter must have been generated by this model.
      * @return {yfiles.algorithms.YOrientedRectangle} The bounds of the label.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}.
      */
      getLabelPlacement(labelSize:yfiles.algorithms.YDimension,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout,para:Object):yfiles.algorithms.YOrientedRectangle;
      /**
      * Returns a list of {@link yfiles.layout.EdgeLabelCandidate} objects each of which describes
      * a valid label position within this model.
      * @param {yfiles.layout.IEdgeLabelLayout} labelLayout The label for which candidates should be generated.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @return {yfiles.algorithms.YList} 
      * A list of {@link yfiles.layout.EdgeLabelCandidate} objects.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelCandidates}.
      */
      getLabelCandidates(label:yfiles.layout.IEdgeLabelLayout,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):yfiles.algorithms.YList;
      /**
      * Returns the coordinates of the upper-left corner of the given label position.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label that should be placed.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceNode The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetNode The layout of the target node of the label owning edge.
      * @param {yfiles.layout.DiscreteEdgeLabelPosition} pos 
      * A label position (given by a symbolic position specifier) that is valid in
      * this model.
      * @return {yfiles.algorithms.YOrientedRectangle} The coordinates of the upper-left corner of a label position.
      */
      getLabelPlacementForPosition(labelSize:yfiles.algorithms.YDimension,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout,pos:yfiles.layout.DiscreteEdgeLabelPosition):yfiles.algorithms.YOrientedRectangle;
    }
    var DiscreteEdgeLabelLayoutModel:{
      $class:yfiles.lang.Class;
      /**
      * Returns a new instance of DiscreteEdgeLabelModel.
      * Position mask {@link yfiles.layout.DiscreteEdgeLabelPosition#SIX_POS} is used to define the allowed positions for
      * an edge label.
      */
      new ():yfiles.layout.DiscreteEdgeLabelLayoutModel;
      /**
      * Returns a new instance of DiscreteEdgeLabelModel.
      * @param {yfiles.layout.DiscreteEdgeLabelPosition} candidateMask Position mask that defines the allowed positions for an edge label.
      */
      FromPosition:{
        new (candidateMask:yfiles.layout.DiscreteEdgeLabelPosition):yfiles.layout.DiscreteEdgeLabelLayoutModel;
      };
      /**
      * Returns a model parameter that encodes the specified position.
      * @param {number} position 
      * one of
      * <ul>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#SHEAD},</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#HEAD},</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#THEAD},</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#STAIL},</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#TAIL},</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#TTAIL},</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#SCENTER},</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#CENTER},</li>
      * <li>{@link yfiles.layout.DiscreteEdgeLabelPosition#TCENTER}</li>
      * </ul>
      * @return {Object} a model parameter that encodes the specified position.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified position is not one
      * of the symbolic position constants defined in this class.
      */
      createPositionParameter(position:number):Object;
    };
    /**
    * A node label model that allows placement of labels at eight positions around
    * a node and at nine positions inside the node.
    * It's possible to specify an insets value that controls the distance between label
    * and node.
    * Furthermore, there's the possibility to mask out arbitrary node label candidates.
    * This can either be done by specifying predefined candidate masks or by OR-ing
    * allowed node label candidates to a user defined mask.
    */
    export interface DiscreteNodeLabelLayoutModel extends Object,yfiles.layout.INodeLabelModel{
      /**
      * Allowed candidate positions, default is all positions.
      */
      candidateMask:yfiles.layout.DiscreteNodeLabelPosition;
      /**
      * The distance between the bounding boxes of label and node.
      * It is applied to all label positions, except the {@link yfiles.layout.DiscreteNodeLabelPosition#CENTER} position.
      */
      distance:number;
      /**
      * A model parameter that encodes the default position of this model's
      * allowed node label positions.
      * Default positions are (in descending order):
      * <ul>
      * <li>{@link yfiles.layout.DiscreteNodeLabelPosition#CENTER}</li>
      * <li>{@link yfiles.layout.DiscreteNodeLabelPosition#NORTH_EAST}</li>
      * <li>{@link yfiles.layout.DiscreteNodeLabelPosition#NORTH}</li>
      * <li>{@link yfiles.layout.DiscreteNodeLabelPosition#EAST}</li>
      * </ul>
      * Descending order means that whenever two or more of the above default positions
      * are part of the allowed positions, then the model parameter encodes the one
      * that is listed first.
      * Note that the model parameter encodes {@link yfiles.layout.DiscreteNodeLabelPosition#CENTER} when none of the above
      * default positions is part of the allowed positions.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#defaultParameter}.
      */
      defaultParameter:Object;
      /**
      * Checks if the given model parameter encodes a node label position that is valid
      * in this model.
      * @return {boolean} 
      * Whether the label position encoded by the given model parameter is among the
      * allowed positions.
      */
      isParameterValid(parameter:Object):boolean;
      /**
      * Returns the the oriented label position and bounds encoded by the given
      * model parameter.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label.
      * @param {yfiles.layout.INodeLayout} nodeLayout The geometric description of the label's node.
      * @param {Object} param 
      * A model parameter that encodes a label position that is valid
      * in this model.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#getLabelPlacement}.
      */
      getLabelPlacement(labelSize:yfiles.algorithms.YDimension,nodeLayout:yfiles.layout.INodeLayout,param:Object):yfiles.algorithms.YOrientedRectangle;
      /**
      * Returns a list of candidate positions for the given node label.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#getLabelCandidates}.
      */
      getLabelCandidates(nl:yfiles.layout.INodeLabelLayout,nodeLayout:yfiles.layout.INodeLayout):yfiles.algorithms.YList;
      /**
      * Returns the oriented label position and bounds for a node label of the
      * specified size.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label.
      * @param {yfiles.layout.INodeLayout} nodeLayout The geometric description of the label's node.
      * @param {yfiles.layout.DiscreteNodeLabelPosition} pos A label position that is valid in this model.
      * @return {yfiles.algorithms.YOrientedRectangle} the oriented label position and bounds.
      */
      getLabelPlacementForPosition(labelSize:yfiles.algorithms.YDimension,nodeLayout:yfiles.layout.INodeLayout,pos:yfiles.layout.DiscreteNodeLabelPosition):yfiles.algorithms.YOrientedRectangle;
      /**
      * Creates a model parameter that represents the given node label context best
      * within this model.
      * The created model parameter represents the closest parameter representation
      * of the given oriented label bounds that can be achieved within this model.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBounds The bounds of the label for which a parameter representation is sought.
      * @param {yfiles.layout.INodeLayout} nodeLayout The layout of the node to which the label belongs.
      * @return {Object} 
      * A model parameter that can be passed to the
      * {@link yfiles.layout.INodeLabelModel#getLabelPlacement} method.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#createModelParameter}.
      */
      createModelParameter(labelBounds:yfiles.algorithms.YOrientedRectangle,nodeLayout:yfiles.layout.INodeLayout):Object;
    }
    var DiscreteNodeLabelLayoutModel:{
      $class:yfiles.lang.Class;
      /**
      * Returns a new instance of DiscreteNodeLabelModel.
      * {@link yfiles.layout.DiscreteNodeLabelPosition#INTERNAL_MASK} is used to define the allowed positions for the node
      * label.
      * The distance between label and node is set to 4.0 [pixel].
      * @see {@link yfiles.layout.DiscreteNodeLabelLayoutModel#distance}
      */
      new ():yfiles.layout.DiscreteNodeLabelLayoutModel;
      /**
      * Returns a new instance of DiscreteNodeLabelModel.
      * The given position mask is used to define the allowed positions for the node
      * label.
      * The distance between label and node is set to 4.0 [pixel].
      * @param {yfiles.layout.DiscreteNodeLabelPosition} candidateMask Defines the allowed positions for the node label.
      * @see {@link yfiles.layout.DiscreteNodeLabelLayoutModel#distance}
      */
      FromPosition:{
        new (candidateMask:yfiles.layout.DiscreteNodeLabelPosition):yfiles.layout.DiscreteNodeLabelLayoutModel;
      };
      /**
      * Returns a new instance of DiscreteNodeLabelModel.
      * @param {yfiles.layout.DiscreteNodeLabelPosition} candidateMask Defines the allowed positions for the node label.
      * @param {number} inset The distance between label and node.
      * @see {@link yfiles.layout.DiscreteNodeLabelLayoutModel#distance}
      */
      FromPositionWithInset:{
        new (candidateMask:yfiles.layout.DiscreteNodeLabelPosition,inset:number):yfiles.layout.DiscreteNodeLabelLayoutModel;
      };
    };
    export enum FixPointPolicy{
      /**
      * Fix point calculation policy that results in the center of a given
      * rectangle to be considered the fix point.
      */
      CENTER,
      /**
      * Fix point calculation policy that results in the upper left corner of a
      * given rectangle to be considered the fix point.
      */
      UPPER_LEFT,
      /**
      * Fix point calculation policy that results in the upper right corner of a
      * given rectangle to be considered the fix point.
      */
      UPPER_RIGHT,
      /**
      * Fix point calculation policy that results in the lower right corner of a
      * given rectangle to be considered the fix point.
      */
      LOWER_RIGHT,
      /**
      * Fix point calculation policy that results in the lower left corner of a
      * given rectangle to be considered the fix point.
      */
      LOWER_LEFT
    }
    export enum LabelPlacements{
      /**
      * Preferred placement specifier for edge labels. 
      * Expresses that the label should be placed near the source
      * node of an edge.
      */
      AT_SOURCE,
      /**
      * Preferred placement specifier for edge labels. 
      * Expresses that the label should be placed near the target
      * node of an edge.
      */
      AT_TARGET,
      /**
      * Preferred placement specifier for edge labels. 
      * Expresses that the label should be placed near the center
      * of the edge path.
      */
      AT_CENTER,
      /**
      * Placement specifier mask. Masks all placement specifiers that are not one of
      * {@link yfiles.layout.LabelPlacements#AT_TARGET}, {@link yfiles.layout.LabelPlacements#AT_SOURCE}, or {@link yfiles.layout.LabelPlacements#AT_CENTER}.
      */
      ALONG_EDGE_MASK,
      /**
      * Preferred placement specifier for edge labels. 
      * Expresses that the label should be placed on the path of the edge.
      */
      ON_EDGE,
      /**
      * Preferred placement specifier for edge labels. 
      * Expresses that the label should be placed on the left hand side of the edge
      * path if looking from the source node into the direction of the target node.
      */
      LEFT_OF_EDGE,
      /**
      * Preferred placement specifier for edge labels. 
      * Expresses that the label should be placed on the right hand side of the edge
      * path if looking from the source node into the direction of the target node.
      */
      RIGHT_OF_EDGE,
      /**
      * Placement specifier mask. Masks all placement specifiers that are not one of
      * {@link yfiles.layout.LabelPlacements#ON_EDGE}, {@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE}, or {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE}.
      */
      ON_SIDE_OF_EDGE_MASK,
      /**
      * Preferred placement specifier for edge labels.
      * Expresses that the label can be placed anywhere along the edge or on any side of the edge.
      */
      ANYWHERE
    }
    export enum LayoutOrientation{
      /**
      * Orientation specifier. Layout will be oriented from top to bottom,
      * which is the default for all layout algorithms.
      */
      TOP_TO_BOTTOM,
      /**
      * Orientation specifier. Layout will be from left to right, which means
      * that the layout will be rotated by 90 degrees counterclockwise
      */
      LEFT_TO_RIGHT,
      /**
      * Orientation specifier. Layout will be from right to left, which means
      * that the layout will be rotated by 90 degrees clockwise
      */
      RIGHT_TO_LEFT,
      /**
      * Orientation specifier. Layout will be from bottom to top, which means
      * that the layout will be flipped along the x axis.
      */
      BOTTOM_TO_TOP
    }
    export enum DiscreteNodeLabelPosition{
      /**
      * Symbolic position specifier. Places the label north of the node.
      */
      NORTH,
      /**
      * Symbolic position specifier. Places the label north-west of  the node.
      */
      NORTH_WEST,
      /**
      * Symbolic position specifier. Places the label north-east of  the node.
      */
      NORTH_EAST,
      /**
      * Symbolic position specifier. Places the label east of  the node.
      */
      EAST,
      /**
      * Symbolic position specifier. Places the label west of  the node.
      */
      WEST,
      /**
      * Symbolic position specifier. Places the label south of  the node.
      */
      SOUTH,
      /**
      * Symbolic position specifier. Places the label south-west of  the node.
      */
      SOUTH_WEST,
      /**
      * Symbolic position specifier. Places the label south-east of  the node.
      */
      SOUTH_EAST,
      /**
      * Symbolic position specifier. Places the label in the center of  the node.
      */
      CENTER,
      /**
      * Symbolic position specifier. Places the label at the bottom inside of the node.
      */
      BOTTOM,
      /**
      * Symbolic position specifier. Places the label at the top inside of the node.
      */
      TOP,
      /**
      * Symbolic position specifier. Places the label at the left inside of the node.
      */
      LEFT,
      /**
      * Symbolic position specifier. Places the label at the right inside of the node.
      */
      RIGHT,
      /**
      * Symbolic position specifier. Places the label at the top-left inside of the node.
      */
      TOP_LEFT,
      /**
      * Symbolic position specifier. Places the label at the top-right inside of the node.
      */
      TOP_RIGHT,
      /**
      * Symbolic position specifier. Places the label at the bottom-left inside of the node.
      */
      BOTTOM_LEFT,
      /**
      * Symbolic position specifier. Places the label at the bottom-right inside of the node.
      */
      BOTTOM_RIGHT,
      /**
      * Position mask that constrains the positions to
      * {@link yfiles.layout.DiscreteNodeLabelPosition#NORTH} and {@link yfiles.layout.DiscreteNodeLabelPosition#SOUTH}.
      */
      SANDWICH_MASK,
      /**
      * Position mask that allows only the nine node-internal positions.
      */
      INTERNAL_MASK,
      /**
      * Position mask that constrains the positions to
      * {@link yfiles.layout.DiscreteNodeLabelPosition#EAST}, {@link yfiles.layout.DiscreteNodeLabelPosition#WEST}, {@link yfiles.layout.DiscreteNodeLabelPosition#NORTH}, and {@link yfiles.layout.DiscreteNodeLabelPosition#SOUTH}.
      */
      SIDES_MASK,
      /**
      * Position mask that constrains the positions to
      * {@link yfiles.layout.DiscreteNodeLabelPosition#NORTH_EAST}, {@link yfiles.layout.DiscreteNodeLabelPosition#NORTH_WEST}, {@link yfiles.layout.DiscreteNodeLabelPosition#SOUTH_EAST}, and {@link yfiles.layout.DiscreteNodeLabelPosition#SOUTH_WEST}.
      */
      CORNER_MASK,
      /**
      * Position mask that allows only the eight node-external positions.
      */
      EIGHT_POS_MASK
    }
    /**
    * A node label model that allows placement of labels at a fixed offset relative
    * to the node's upper-left corner.
    */
    export interface FreeNodeLabelLayoutModel extends Object,yfiles.layout.INodeLabelModel{
      /**
      * A model parameter that encodes the default position of this model's
      * allowed node label positions.
      * <p>
      * The offset is set to a default value of -20 pixel for both directions, i.e.,
      * the node label's upper-left corner is placed 20 pixel to the left and 20
      * pixel above the node.
      * </p>
      * @see Specified by {@link yfiles.layout.INodeLabelModel#defaultParameter}.
      */
      defaultParameter:Object;
      /**
      * Returns the oriented label position and bounds encoded by the given model
      * parameter.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label that should be placed.
      * @param {yfiles.layout.INodeLayout} nodeLayout The layout of the node to which the label belongs.
      * @param {Object} param 
      * The model parameter that describes the abstract position of
      * the label within this model. The parameter must have been generated by
      * this model.
      * @return {yfiles.algorithms.YOrientedRectangle} the oriented label position and bounds.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#getLabelPlacement}.
      */
      getLabelPlacement(labelSize:yfiles.algorithms.YDimension,nodeLayout:yfiles.layout.INodeLayout,param:Object):yfiles.algorithms.YOrientedRectangle;
      /**
      * Returns a list of candidate positions for the given node label.
      * The list consists of exactly one position.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#getLabelCandidates}.
      */
      getLabelCandidates(nl:yfiles.layout.INodeLabelLayout,nodeLayout:yfiles.layout.INodeLayout):yfiles.algorithms.YList;
      /**
      * Creates a model parameter that represents the given node label context best
      * within this model.
      * The created model parameter represents the closest parameter representation
      * of the given oriented label bounds that can be achieved within this model.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBounds The bounds of the label for which a parameter representation is sought.
      * @param {yfiles.layout.INodeLayout} nodeLayout The layout of the node to which the label belongs.
      * @return {Object} 
      * A model parameter that can be passed to the
      * {@link yfiles.layout.INodeLabelModel#getLabelPlacement} method.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#createModelParameter}.
      */
      createModelParameter(labelBounds:yfiles.algorithms.YOrientedRectangle,nodeLayout:yfiles.layout.INodeLayout):Object;
    }
    export module FreeNodeLabelLayoutModel{
      /**
      * The model parameter that encodes a node label position within FreeNodeLabelModel.
      * Holds the offset of a node label's upper-left corner relative to its node's
      * upper-left corner.
      */
      export interface ModelParameter extends Object{
        /**
        * The offset of this ModelParameter.
        */
        point:yfiles.algorithms.YPoint;
        /**
        * Sets the node label's offset.
        */
        setPoint(dx:number,dy:number):void;
      }
    }
    var FreeNodeLabelLayoutModel:{
      $class:yfiles.lang.Class;
      /**
      * Returns a new instance of FreeNodeLabelModel.
      */
      new ():yfiles.layout.FreeNodeLabelLayoutModel;
      ModelParameter:{
        $class:yfiles.lang.Class;
        /**
        * Returns a new instance of ModelParameter.
        * It has no offset, i.e., the upper-left corners of both node label and node
        * are at the same location.
        */
        new ():yfiles.layout.FreeNodeLabelLayoutModel;
        /**
        * Returns a new instance of ModelParameter with the given offset.
        */
        WithOffset:{
          new (dx:number,dy:number):yfiles.layout.FreeNodeLabelLayoutModel;
        };
      };
    };
    export enum ComponentArrangementStyles{
      /**
      * Style specification constant describing no special component arrangement at all.
      * Components will be centered at the same position they resided at before the layout
      * started. If combined with the style modifier {@link yfiles.layout.ComponentArrangementStyles#MODIFIER_NO_OVERLAP}
      * components might get moved so that they don't overlap after the layout.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      NONE,
      /**
      * Style specification constant describing a component arrangement strategy that
      * tries to place components in multiple rows so that the overall aspect ratio of all
      * components gets as close to the aspect ratio of the preferred layout size as possible.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      * @see {@link yfiles.layout.ComponentLayouter#setPreferredLayoutSize}
      */
      ROWS,
      /**
      * Style specification constant describing a component arrangement strategy that
      * places components next to each other in a single row. If combined with the
      * style modifier {@link yfiles.layout.ComponentArrangementStyles#MODIFIER_AS_IS}
      * components will be placed in the same order as they were placed before the layout.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      SINGLE_ROW,
      /**
      * Style specification constant describing a component arrangement strategy that
      * places components above each other in a single column. If combined with the
      * style modifier {@link yfiles.layout.ComponentArrangementStyles#MODIFIER_AS_IS}
      * components will be placed in the same order as they were placed before the layout.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      SINGLE_COLUMN,
      /**
      * Style specification constant describing a component arrangement strategy that
      * tries to place components like in a rectangular cloud around the biggest component. Entities
      * of different components will not overlap, however the bounding boxes of the components
      * may overlap.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      PACKED_RECTANGLE,
      /**
      * Style specification constant describing a component arrangement strategy that
      * tries to place components like in a rectangular cloud around the biggest component. Entities
      * of different components will not overlap, however the bounding boxes of the components
      * may overlap. In contrast to {@link yfiles.layout.ComponentArrangementStyles#PACKED_RECTANGLE} components might even be placed in empty spaces inside other components.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      PACKED_COMPACT_RECTANGLE,
      /**
      * Style specification constant describing a component arrangement strategy that
      * tries to place components like in a cloud around the biggest component. Entities
      * of different components will not overlap, however the bounding boxes of the components
      * may overlap.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      PACKED_CIRCLE,
      /**
      * Style specification constant describing a component arrangement strategy that
      * tries to place components like in a cloud around the biggest component. Entities
      * of different components will not overlap, however the bounding boxes of the components
      * may overlap. In contrast to {@link yfiles.layout.ComponentArrangementStyles#PACKED_CIRCLE} components might even be placed in empty spaces inside other components.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      PACKED_COMPACT_CIRCLE,
      /**
      * Style specification constant describing a component arrangement strategy that places components in multiple
      * rows. In contrast to {@link yfiles.layout.ComponentArrangementStyles#ROWS}, each row may also be divided into further sub-rows, thus especially
      * being advantageous, if there are few very large components and many significantly smaller ones.
      * The strategy tries to arrange the components such that the aspect ratio of the final component placement
      * gets as close as possible to the aspect ratio of the preferred layout size, configurable
      * using {@link yfiles.layout.ComponentLayouter#setPreferredLayoutSize}.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      MULTI_ROWS,
      /**
      * Style specification constant describing a component arrangement strategy that places components in multiple
      * rows. In contrast to {@link yfiles.layout.ComponentArrangementStyles#ROWS}, each row may also be divided into further sub-rows, thus especially
      * being advantageous, if there are few very large components and many significantly smaller ones.
      * The strategy tries to arrange the components such that the aspect ratio of the final component placement
      * gets close to the aspect ratio of the preferred layout size, configurable using
      * {@link yfiles.layout.ComponentLayouter#setPreferredLayoutSize}. But in contrast to {@link yfiles.layout.ComponentArrangementStyles#MULTI_ROWS}, this strategy
      * tries not always to come as close to the preferred view ratio, if not necessary, i.e. if a ratio close to the preferred
      * ratio only induces a lot of unused view space. This unused space will be minimized.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      MULTI_ROWS_COMPACT,
      /**
      * Style specification constant describing a component arrangement strategy.
      * It uses the same core strategy as {@link yfiles.layout.ComponentArrangementStyles#MULTI_ROWS}, but under the restriction that the resulting
      * height does not exceed the preferred height ({@link yfiles.layout.ComponentLayouter#preferredLayoutSize}).
      * Note, that the preferred width and thus the aspect ratio will be ignored.
      * In contrast to {@link yfiles.layout.ComponentArrangementStyles#MULTI_ROWS_HEIGHT_CONSTRAINT_COMPACT}, the result will be an arrangement which uses as
      * much height as possible, even if that means that all components will be arranged in one single column.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      MULTI_ROWS_HEIGHT_CONSTRAINT,
      /**
      * Style specification constant describing a component arrangement strategy.
      * It uses the same core strategy as {@link yfiles.layout.ComponentArrangementStyles#MULTI_ROWS}, but under the restriction that the resulting
      * height does not exceed the preferred height ({@link yfiles.layout.ComponentLayouter#preferredLayoutSize}).
      * Note, that the preferred width and thus the aspect ratio will be ignored. In comparison with
      * {@link yfiles.layout.ComponentArrangementStyles#MULTI_ROWS_HEIGHT_CONSTRAINT}, the result will be compacted, which means that an arrangement
      * with the minimum width such that the height constraint is still fulfilled will be realized.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      MULTI_ROWS_HEIGHT_CONSTRAINT_COMPACT,
      /**
      * Style specification constant describing a component arrangement strategy.
      * It uses the same core strategy as {@link yfiles.layout.ComponentArrangementStyles#MULTI_ROWS}, but under the restriction that the resulting
      * width does not exceed the preferred width ({@link yfiles.layout.ComponentLayouter#preferredLayoutSize}).
      * Note, that the preferred height and thus the aspect ratio will be ignored.
      * In contrast to {@link yfiles.layout.ComponentArrangementStyles#MULTI_ROWS_WIDTH_CONSTRAINT_COMPACT} the result will be an arrangement which uses as
      * much space in width as possible, even if that means that all components will be arranged in a single row.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      MULTI_ROWS_WIDTH_CONSTRAINT,
      /**
      * Style specification constant describing a component arrangement strategy.
      * It uses the same core strategy as {@link yfiles.layout.ComponentArrangementStyles#MULTI_ROWS}, but under the restriction that the resulting
      * width does not exceed the preferred width ({@link yfiles.layout.ComponentLayouter#preferredLayoutSize}).
      * Note, that the preferred height and thus the aspect ratio will be ignored. In comparison with
      * {@link yfiles.layout.ComponentArrangementStyles#MULTI_ROWS_HEIGHT_CONSTRAINT} the result will be compacted, in order to minimize
      * unused view space induced by components that are large in height.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      MULTI_ROWS_WIDTH_CONSTRAINT_COMPACT,
      /**
      * Use this constant for masking actual styles constants from style modifiers.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      MASK,
      /**
      * Modifier constant that can be added to normal style constants to indicate that
      * the arrangement strategy should take the initial positions of the components
      * into account.
      * Combining this modifier is supported with the following styles:
      * {@link yfiles.layout.ComponentArrangementStyles#SINGLE_ROW}, {@link yfiles.layout.ComponentArrangementStyles#SINGLE_COLUMN}, {@link yfiles.layout.ComponentArrangementStyles#PACKED_RECTANGLE},
      * {@link yfiles.layout.ComponentArrangementStyles#PACKED_COMPACT_RECTANGLE}, {@link yfiles.layout.ComponentArrangementStyles#PACKED_CIRCLE}, and
      * {@link yfiles.layout.ComponentArrangementStyles#PACKED_COMPACT_CIRCLE}.
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      MODIFIER_AS_IS,
      /**
      * Modifier constant that can be added to normal style constants to indicate that
      * the arrangement strategy should produce a non-overlapping component layout.
      * Combining this modifier is supported with {@link yfiles.layout.ComponentArrangementStyles#NONE}.
      * <p>
      * Note that non-overlapping component layout (in the sense that no elements from
      * adjacent components overlap) is inherently supported by the following styles:
      * {@link yfiles.layout.ComponentArrangementStyles#PACKED_RECTANGLE}, {@link yfiles.layout.ComponentArrangementStyles#PACKED_COMPACT_RECTANGLE}, {@link yfiles.layout.ComponentArrangementStyles#PACKED_CIRCLE},
      * and {@link yfiles.layout.ComponentArrangementStyles#PACKED_COMPACT_CIRCLE}.
      * </p>
      * @see {@link yfiles.layout.ComponentLayouter#style}
      */
      MODIFIER_NO_OVERLAP
    }
    export enum DiscreteEdgeLabelPosition{
      /**
      * Symbolic position specifier. 
      * Places the label near the source node. 
      * The label's position is to the left of or above the edge's path.
      */
      SHEAD,
      /**
      * Symbolic position specifier.
      * Places the label near the middle of the edge's path.
      * The label's position is to the left of or above the edge's path.
      */
      HEAD,
      /**
      * Symbolic position specifier. 
      * Places the label near the target node. 
      * The label's position is to the left of or above the edge's path. 
      * Places the label near the target node on the "head" side of the edge.
      */
      THEAD,
      /**
      * Symbolic position specifier. 
      * Places the label near the source node. 
      * The label's position is to the right of or below the edge's path.
      */
      STAIL,
      /**
      * Symbolic position specifier. 
      * Places the label near the middle of the edge's path. 
      * The label's position is to the right of or below the edge's path.
      */
      TAIL,
      /**
      * Symbolic position specifier. 
      * Places the label near the target node. 
      * The label's position is to the right of or below the edge's path.
      */
      TTAIL,
      /**
      * Symbolic position specifier. 
      * Places the label near the source node directly on the edge path.
      */
      SCENTER,
      /**
      * Symbolic position specifier. 
      * Places the label near the middle of an edge directly on its path.
      */
      CENTER,
      /**
      * Symbolic position specifier. 
      * Places the label near the target node directly on the edge path.
      */
      TCENTER,
      /**
      * Position mask that constrains allowed positions to the two near the edge's 
      * end points. 
      * Namely, these are {@link yfiles.layout.DiscreteEdgeLabelPosition#HEAD} and {@link yfiles.layout.DiscreteEdgeLabelPosition#TAIL}.
      */
      TWO_POS,
      /**
      * Position mask that constrains allowed positions to {@link yfiles.layout.DiscreteEdgeLabelPosition#CENTER}.
      */
      CENTERED,
      /**
      * Position mask that constrains allowed positions to a set of six positions on 
      * the "head" and "tail" sides of an edge. 
      * Namely, these are {@link yfiles.layout.DiscreteEdgeLabelPosition#SHEAD}, {@link yfiles.layout.DiscreteEdgeLabelPosition#HEAD}, {@link yfiles.layout.DiscreteEdgeLabelPosition#THEAD}, {@link yfiles.layout.DiscreteEdgeLabelPosition#STAIL}, 
      * {@link yfiles.layout.DiscreteEdgeLabelPosition#TAIL}, and {@link yfiles.layout.DiscreteEdgeLabelPosition#TTAIL}.
      */
      SIX_POS,
      /**
      * Position mask that constrains allowed positions to a set of three positions 
      * directly on the edge's path. 
      * Namely, these are {@link yfiles.layout.DiscreteEdgeLabelPosition#SCENTER}, {@link yfiles.layout.DiscreteEdgeLabelPosition#CENTER}, and {@link yfiles.layout.DiscreteEdgeLabelPosition#TCENTER}.
      */
      THREE_CENTER
    }
    /**
    * This class is a default implementation of the NodeLayout interface.
    */
    export interface DefaultNodeLayout extends Object,yfiles.layout.INodeLayout{
      /**
      * Sets the coordinates of the upper left corner of the node.
      * @param {number} x the x-coordinates of the upper left corner.
      * @param {number} y the y-coordinates of the upper left corner.
      * @see Specified by {@link yfiles.layout.INodeLayout#setLocation}.
      */
      setLocation(x:number,y:number):void;
      /**
      * Sets the center coordinates of the node.
      * @param {number} x the x-coordinates of the center.
      * @param {number} y the y-coordinates of the center
      */
      setCenter(x:number,y:number):void;
      /**
      * Sets the size of the node.
      * @param {number} width the width of the node.
      * @param {number} height the height of the node.
      * @see Specified by {@link yfiles.layout.INodeLayout#setSize}.
      */
      setSize(width:number,height:number):void;
      /**
      * The height of the node.
      * @see Specified by {@link yfiles.layout.INodeLayout#height}.
      */
      height:number;
      /**
      * The width of the node.
      * @see Specified by {@link yfiles.layout.INodeLayout#width}.
      */
      width:number;
      /**
      * X-Coordinate of the upper left corner of the node.
      * @see Specified by {@link yfiles.layout.INodeLayout#x}.
      */
      x:number;
      /**
      * Y-Coordinate of the upper left corner of the node.
      * @see Specified by {@link yfiles.layout.INodeLayout#y}.
      */
      y:number;
    }
    var DefaultNodeLayout:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of DefaultNodeLayout.
      */
      new ():yfiles.layout.DefaultNodeLayout;
      /**
      * Creates a new instance of DefaultNodeLayout as copy of another instance
      * of NodeLayout.
      * @param {yfiles.layout.INodeLayout} layout another instance of NodeLayout.
      */
      FromNodeLayout:{
        new (layout:yfiles.layout.INodeLayout):yfiles.layout.DefaultNodeLayout;
      };
      /**
      * Creates a new instance of DefaultNodeLayout.
      * @param {number} x the x-coordinate of the upper left corner of the node.
      * @param {number} y the y-coordinate of the upper left corner of the node.
      * @param {number} width the width of the node.
      * @param {number} height the height of the node.
      */
      FromXYWidthAndHeight:{
        new (x:number,y:number,width:number,height:number):yfiles.layout.DefaultNodeLayout;
      };
      /**
      * Creates a new instance of DefaultNodeLayout.
      * @param {yfiles.algorithms.YPoint} location the upper-left corner coordinate of the node layout.
      * @param {yfiles.algorithms.YDimension} size the size of the node layout.
      */
      FromLocationAndSize:{
        new (location:yfiles.algorithms.YPoint,size:yfiles.algorithms.YDimension):yfiles.layout.DefaultNodeLayout;
      };
    };
    /**
    * An abstract base class for layout algorithms that
    * provides services to simplify and decompose the input graph
    * before it is passed to the core layout routine itself.
    * Subclass layout algorithms have to provide implementations
    * for the abstract methods
    * {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
    * and
    * {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
    * The maximal number of steps involved before and after the core layout
    * will be invoked are summarized below.
    * <ul>
    * <li>Copy the input graph</li>
    * <li>Hide all but the induced subgraph</li>
    * <li>Decompose the graph into it's connected components. On each component
    * perform the steps 3-11</li>
    * <li>Prepare for an orientation change</li>
    * <li>Hide parallel edges</li>
    * <li>Hide self-loops</li>
    * <li>Invoke core layouter on simplified graph</li>
    * <li>Unhide and route self-loops</li>
    * <li>Unhide and route parallel edges</li>
    * <li>Complete orientation change of layout</li>
    * <li>Arrange connected components of the graph</li>
    * <li>Unhide non-induced subgraph</li>
    * <li>Assign label positions</li>
    * <li>Copy layout information back to original input graph or pass out
    * layout information separately</li>
    * </ul>
    * Each of the phases above can be subdued if necessary.
    */
    export interface CanonicMultiStageLayouter extends Object,yfiles.layout.ILayouter{
      /**
      * Subclasses have to provide core layout code in this method.
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Subclasses have to provide information whether or not they
      * can layout the given graph.
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given node object is zero.
      * It is called by the {@link yfiles.layout.CanonicMultiStageLayouter#doLayout} method for each node object in the input graph.
      * @see {@link yfiles.layout.CanonicMultiStageLayouter#checkGroupNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the node object is zero.
      */
      checkNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given group node object is zero.
      * It is called by the {@link yfiles.layout.CanonicMultiStageLayouter#doLayout} method for each group node object in the input graph.
      * @see {@link yfiles.layout.CanonicMultiStageLayouter#checkNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the group node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the group node object is zero.
      */
      checkGroupNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * Prepends a stage to the layout pipeline.
      * Stage added with this method
      * will be invoked before any other stages will be invoked.
      */
      prependStage(stage:yfiles.layout.ILayoutStage):void;
      /**
      * Appends a stage to the layout pipeline.
      * Stages added with this method will be
      * invoked just before the core layouter will be invoked.
      */
      appendStage(stage:yfiles.layout.ILayoutStage):void;
      /**
      * Removes a LayoutStage that has been previously added by the methods
      * {@link yfiles.layout.CanonicMultiStageLayouter#appendStage} or {@link yfiles.layout.CanonicMultiStageLayouter#prependStage}.
      */
      removeStage(stage:yfiles.layout.ILayoutStage):void;
      /**
      * The algorithm used for placing labels.
      * <b>Getter:</b>By default an instance of class
      * {@link yfiles.labeling.GreedyMISLabeling} will be returned.
      * <b>Setter:</b>Note that
      * assigning a new layout stage will not automatically activate it.
      * To activate this stage use {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouterEnabled}.
      */
      labelLayouter:yfiles.layout.ILayoutStage;
      /**
      * The LayoutStage used for routing
      * Self-loops.
      * By default an instance of class
      * {@link yfiles.layout.SelfLoopLayouter} will be returned.
      */
      selfLoopLayouter:yfiles.layout.ILayoutStage;
      /**
      * The LayoutStage responsible for routing
      * parallel edges.
      * By default an instance of class
      * {@link yfiles.layout.ParallelEdgeLayouter} will be returned.
      */
      parallelEdgeLayouter:yfiles.layout.ILayoutStage;
      /**
      * The LayoutStage responsible for laying out the
      * connected components of the graph.
      */
      componentLayouter:yfiles.layout.ILayoutStage;
      /**
      * The LayoutStage that is responsible for
      * constraining the layout process to a subgraph
      * of the target graph.
      */
      subgraphLayouter:yfiles.layout.ILayoutStage;
      /**
      * The <code>LayoutStage</code> that is responsible for
      * hiding away grouping information for the layout algorithm.
      */
      groupNodeHider:yfiles.layout.ILayoutStage;
      /**
      * The LayoutStage that is responsible for
      * changing the orientation of the computed layout.
      */
      orientationLayouter:yfiles.layout.ILayoutStage;
      /**
      * Specifies whether or not the OrientationLayouter
      * is enabled.
      * By default it is activated but does not change
      * orientation of the layout.
      */
      orientationLayouterEnabled:boolean;
      /**
      * The main layout orientation.
      * The layouter tries to arrange nodes
      * in such a way that all edges point in the main layout direction.
      * <p>
      * Note, the documentation for the other layout options assumes that the
      * default layout orientation {@link yfiles.layout.LayoutOrientation#TOP_TO_BOTTOM} is
      * being used.
      * </p>
      */
      layoutOrientation:yfiles.layout.LayoutOrientation;
      /**
      * Specifies whether or not the SelfLoopLayouter
      * is enabled.
      * By default it is enabled.
      */
      selfLoopLayouterEnabled:boolean;
      /**
      * Specifies whether or not LabelLayouter
      * is enabled.
      * By default it is disabled.
      */
      labelLayouterEnabled:boolean;
      /**
      * Specifies whether or not to hide away group nodes before the layout begins.
      * By default this is enabled for instances that cannot deal with node
      * groupings.
      */
      hideGroupNodes:boolean;
      /**
      * Specifies whether or not ComponentLayouter
      * is enabled.
      * By default it is enabled.
      */
      componentLayouterEnabled:boolean;
      /**
      * Specifies whether or not the ParallelEdgeLayouter
      * is enabled.
      * By default it is enabled.
      */
      parallelEdgeLayouterEnabled:boolean;
      /**
      * Specifies whether or not the SubgraphLayouter
      * is enabled.
      * By default it is disabled.
      */
      subgraphLayouterEnabled:boolean;
      /**
      * Disables all layout stages and performs only the core layouter.
      */
      enableOnlyCore():void;
      /**
      * Calculates a layout for the given graph.
      * The given graph will not be copied during the
      * layout process and the layout will be
      * immediately applied to the given graph.
      * This method is not side effect free in the sense that
      * the order of edges or nodes in the input graph
      * may change during the layout process.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(layoutGraph:yfiles.layout.LayoutGraph):void;
      /**
      * Calculates a layout for the given graph interface
      * and layout.
      * The calculated layout will be written
      * back to the given layout.
      */
      doLayoutWithGraphAndLayout(graph:yfiles.algorithms.IGraphInterface,layout:yfiles.layout.IGraphLayout):void;
      /**
      * Returns a layout for the given layout graph.
      * The given graph will not be modified by the layout process.
      */
      calcLayout(layoutGraph:yfiles.layout.LayoutGraph):yfiles.layout.IGraphLayout;
      /**
      * Returns a layout for the given graph interface and layout.
      * The given graph and layout will not be modified by the layout process.
      */
      calcLayoutWithGraphAndLayout(graph:yfiles.algorithms.IGraphInterface,layout:yfiles.layout.IGraphLayout):yfiles.layout.IGraphLayout;
      /**
      * Tests whether or not the given graph can be laid out
      * by this layouter.
      * All stage layouters and the core layouter must
      * be able to calculate the layout to make this test successful.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
    }
    var CanonicMultiStageLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Constructs a new AbstractLayouter.
      */
      new ():yfiles.layout.CanonicMultiStageLayouter;
    };
    /**
    * This layout stage arranges the connected components of a graph.
    * <p>
    * It is possible to specify a core layout algorithm that will
    * be invoked on all connected components of the graph
    * before this layouter arranges the components themselves.
    * </p>
    * <p>
    * ComponentLayouter will handle hierarchically grouped graphs in a special way.
    * The contents of a group node will always belong to the same component
    * as the group node itself.
    * </p>
    */
    export interface ComponentLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * Sets the preferred layout size for this layouter.
      * @param {number} width the preferred width of the calculated graph layout.
      * @param {number} height the preferred height of the calculated graph layout.
      * @see {@link yfiles.layout.ComponentLayouter#preferredLayoutSize}
      * @throws {yfiles.system.ArgumentException} when width or height is negative or zero.
      */
      setPreferredLayoutSize(width:number,height:number):void;
      /**
      * The preferred layout size for this layouter.
      * @throws {yfiles.system.ArgumentException} when the specified width or height is negative or zero.
      * @see {@link yfiles.layout.ComponentLayouter#setPreferredLayoutSize}
      */
      preferredLayoutSize:yfiles.algorithms.YDimension;
      /**
      * Determines if the preconditions for the graph layout algorithm
      * are fulfilled, by applying them to the connected components.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Determines which nodes will belong to the same graph component.
      * Additionally to normal connectedness a group node and all of its children
      * will belong to the same component.
      * @param {yfiles.layout.LayoutGraph} graph the input graph
      * @param {yfiles.algorithms.INodeMap} compNumber 
      * return value that will hold the zero-based number
      * of the component that it belongs to. The component number of
      * Node <code>v</code> is <code>compNum.getInt(v)</code>.
      * @return {number} the number of connected components of this graph.
      */
      findGraphComponents(graph:yfiles.layout.LayoutGraph,compNumber:yfiles.algorithms.INodeMap):number;
      /**
      * Calculate the layout.
      * This is done by decomposing the graph in its connected components
      * and applying the core layout algorithm on each component.
      * @see {@link yfiles.layout.AbstractLayoutStage#coreLayouter}
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Calculates and returns the bounding box of a graph component including node halos.
      * This method will be
      * invoked for each component of the graph. Depending on the state of
      * property <code>labelAwarenessEnabled</code> the returned bounding box will
      * also take node and edge labels into account.
      */
      calcBoundingBox(graph:yfiles.layout.LayoutGraph):yfiles.algorithms.Rectangle2D;
      /**
      * Determines whether or not to take node and edge labels into account when
      * calculating the bounding box of the graph components.
      * <p>
      * By default this feature is enabled.
      * </p>
      * @see {@link yfiles.layout.ComponentLayouter#calcBoundingBox}
      */
      considerLabels:boolean;
      /**
      * Produces a non-overlapping component graph layout.
      * This method moves the graph components in such a
      * fashion that their bounding boxes do not
      * overlap. The arrangement strategy used takes
      * the ratio of the overall layout area into account.
      * Subclasses may want to overwrite this method.
      * @param {yfiles.layout.LayoutGraph} graph the layout graph.
      * @param {yfiles.algorithms.NodeList[]} nodes array of type NodeList. The i-th NodeList contains all nodes of the i-th graph component.
      * @param {yfiles.algorithms.EdgeList[]} edges array of type EdgeList. The i-th EdgeList contains all edges of the i-th graph component.
      * @param {yfiles.algorithms.YRectangle[]} bbox array of type YRectangle. The i-th YRectangle contains the current bounding box of the i-th graph component.
      * @param {yfiles.algorithms.Rectangle2D[]} boxes 
      * array of type Rectangle2D. The i-th Rectangle2D contains the extended bounding box of the i-th graph component.
      * The method arranges these boxes in such a way that they do not overlap. Then the i-th graph component must be placed
      * inside the i-th box.
      */
      arrangeComponents(graph:yfiles.layout.LayoutGraph,nodes:yfiles.algorithms.NodeList[],edges:yfiles.algorithms.EdgeList[],bbox:yfiles.algorithms.YRectangle[],boxes:yfiles.algorithms.Rectangle2D[]):void;
      /**
      * Specifies whether or not the separately laid out components of the input graph should be
      * arranged by this class.
      * <p>
      * By default this feature is enabled.
      * </p>
      */
      componentArrangement:boolean;
      /**
      * Sets the origin for a subgraph.
      */
      setOrigin(graph:yfiles.layout.LayoutGraph,nl:yfiles.algorithms.NodeList,el:yfiles.algorithms.EdgeList,org:yfiles.algorithms.YPoint,r:yfiles.algorithms.YRectangle):void;
      /**
      * The current grid spacing.
      * Components will be moved by multiples of this value, thus keeping their offset to the grid.
      * That way, components or parts of them that were placed on a grid before, will stay on their original grid.
      * The grid spacing also influences the distance between the components.
      * <p>
      * Note that this option keeps existing grid locations intact but won't correct the location of a component
      * to the grid specified here.
      * </p>
      * <p>
      * If grid spacing equals 0, the grid won't be considered at all.
      * </p>
      */
      gridSpacing:number;
      /**
      * The current component spacing.
      * This value represents the minimum
      * allowed distance between the bounding boxes of to components.
      */
      componentSpacing:number;
      /**
      * Determines whether or not grouping information bound to the graph will be
      * used to calculate the components.
      * <p>
      * The default value is <code>true</code>.
      * </p>
      */
      groupingActive:boolean;
      /**
      * The component arrangement style used by this <code>ComponentLayouter</code>.
      * <p>
      * The default is {@link yfiles.layout.ComponentArrangementStyles#ROWS}.
      * </p>
      */
      style:yfiles.layout.ComponentArrangementStyles;
      arrangeFields(graph:yfiles.layout.LayoutGraph,nodes:yfiles.algorithms.NodeList[],edges:yfiles.algorithms.EdgeList[],bbox:yfiles.algorithms.YRectangle[],boxes:yfiles.algorithms.Rectangle2D[],circular:boolean,fill:boolean,fromSketch:boolean):void;
    }
    var ComponentLayouter:{
      $class:yfiles.lang.Class;
      /**
      * DataProvider key that can be used to determine which nodes should be laid out.
      * Note that components will be laid out if and only if at least one of the nodes
      * that make up the component returns <code>true</code> if queried through the
      * DataProvider instance. If no such instance is registered with the graph,
      * all components will be laid out by the core layout algorithm.
      */
      LAYOUT_NODE_DP_KEY:Object;
      /**
      * DataProvider key that can be used to determine components by hand.
      * The algorithm will use the {@link yfiles.algorithms.IDataProvider#get} method to query for
      * object instances that will be used to determine components:
      * If <code>null</code> is returned for a node that node's component will be determined as usual.
      * If non-<code>null</code> values are returned, they will be compared using their natural order
      * ({@link yfiles.lang.IObjectComparable}) to determine the component order.
      */
      GIVEN_COMPONENT_DP_KEY:Object;
      /**
      * Initializes a new <code>ComponentLayouter</code> instance.
      * @param {yfiles.layout.ILayouter} coreLayouter 
      * the layout algorithm that is invoked for connected
      * components of the input graph.
      * @see {@link yfiles.layout.ComponentLayouter#doLayout}
      */
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.layout.ComponentLayouter;
      };
      /**
      * Initializes a new <code>ComponentLayouter</code> instance.
      * @see {@link yfiles.layout.ComponentLayouter#setPreferredLayoutSize}
      */
      new ():yfiles.layout.ComponentLayouter;
    };
    /**
    * A layouter that allows to express a layout stage
    * as a chain of more basic layout stages.
    */
    export interface CompositeLayouter extends Object,yfiles.layout.ILayouter{
      /**
      * Prepends a stage to this composite layout stage.
      * Stage added with this method
      * will be invoked before any other stages will be invoked.
      */
      prependStage(stage:yfiles.layout.ILayoutStage):void;
      /**
      * The chain of layout stages that make up this composite layout stage.
      */
      layoutStages:yfiles.algorithms.IList;
      /**
      * Appends a stage to the layout pipeline.
      * Stages added with this method will be
      * invoked just before the core layouter of the composite layout stage will be invoked.
      */
      appendStage(stage:yfiles.layout.ILayoutStage):void;
      /**
      * Returns true if all layout stages and the core layout stage
      * can layout the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Assigns a new graph layout to the given layout graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var CompositeLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of <code>CompositeLayouter</code> with the
      * specified <code>LayoutStage</code> prepended to the specified
      * <code>Layouter</code>.
      * @param {yfiles.layout.ILayoutStage} stage 
      * a <code>LayoutStage</code> that is prepended to the specified
      * core layouter.
      * @param {yfiles.layout.ILayouter} coreLayouter 
      * a <code>Layouter</code> that is used as core (i.e.
      * innermost) layouter for this <code>CompositeLayouter</code>.
      */
      new (stage:yfiles.layout.ILayoutStage,coreLayouter:yfiles.layout.ILayouter):yfiles.layout.CompositeLayouter;
    };
    /**
    * A hull layouter that invokes another layout algorithm on a copy of its input
    * graph.
    * After the layout process has finished the calculated layout
    * will be either written back to the original graph or
    * will be provided as a separate graph layout information
    * in terms of the original input graph.
    * This class also provides the possibility to perform arbitrary
    * layout algorithms merely on a graph interface plus associated
    * graph layout. This comes in handy if an application has its own
    * graph and merely provides an graph interface adapter to the yFiles
    * graph layout machinery.
    */
    export interface BufferedLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * Invokes the core Layouter on a copy of the given graph.
      * @return {yfiles.layout.IGraphLayout} the calculated graph layout for the given graph
      */
      calcLayout(layoutGraph:yfiles.layout.LayoutGraph):yfiles.layout.IGraphLayout;
      /**
      * Invokes the core Layouter on a copy of the given graph.
      * @return {yfiles.layout.IGraphLayout} the calculated graph layout for the given graph
      */
      calcLayoutWithGraphAndLayout(graph:yfiles.algorithms.IGraphInterface,layout:yfiles.layout.IGraphLayout):yfiles.layout.IGraphLayout;
      /**
      * Invokes the core Layouter on a copy of the given graph.
      * The calculated layout will be written back to the given graph.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(layoutGraph:yfiles.layout.LayoutGraph):void;
      /**
      * Invokes the core Layouter on a copy of the given graph.
      * The calculated layout will be written back to the given graph.
      */
      doLayoutWithGraphAndLayout(graph:yfiles.algorithms.IGraphInterface,layout:yfiles.layout.IGraphLayout):void;
      /**
      * Whether or not this layouter can layout the given graph.
      * The result of this method will be provided by the associated
      * core layouter.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
    }
    var BufferedLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Instantiates a new BufferedLayouter.
      * No core layouter will be bound this layouter yet.
      */
      new ():yfiles.layout.BufferedLayouter;
      /**
      * Instantiates a new BufferedLayouter that wraps
      * the given core layouter.
      */
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.layout.BufferedLayouter;
      };
    };
    /**
    * Partial LayoutStage implementation that handles
    * the management of the core layouter part.
    */
    export interface AbstractLayoutStage extends Object,yfiles.layout.ILayoutStage{
      /**
      * The core layouter.
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
      /**
      * Invokes the layout routine of the core layouter.
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Queries the core layouter whether or not the given graph
      * can be laid out.
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var AbstractLayoutStage:{
      $class:yfiles.lang.Class;
      /**
      * Default constructor.
      */
      new ():yfiles.layout.AbstractLayoutStage;
      /**
      * Initializes this AbstractLayoutStage with the given core Layouter.
      */
      WithCoreLayouter:{
        new (core:yfiles.layout.ILayouter):yfiles.layout.AbstractLayoutStage;
      };
    };
    /**
    * This class is a default implementation of the EdgeLayout interface.
    */
    export interface DefaultEdgeLayout extends Object,yfiles.layout.IEdgeLayout{
      /**
      * Returns the number of control points of the edge.
      * The source and target points are not included in the point count.
      * @return {number} the number of control points
      * @see Specified by {@link yfiles.layout.IEdgeLayout#pointCount}.
      */
      pointCount():number;
      /**
      * Returns the control point at position <code>index</code> of
      * the sequence.
      * @see {@link yfiles.layout.IEdgeLayout#setPoint}
      * @param {number} index position of the control point in the control point sequence.
      * @return {yfiles.algorithms.YPoint} the absolute coordinates of the control point at the given index.
      * @see Specified by {@link yfiles.layout.IEdgeLayout#getPoint}.
      */
      getPoint(index:number):yfiles.algorithms.YPoint;
      /**
      * Sets the coordinates of the control point at position <code>index</code> of
      * the sequence.
      * The first control point in the sequence has index 0
      * and the last control point has index pointCount() - 1.
      * @param {number} index position of the control point in the control point sequence.
      * @param {number} x absolute x-coordinate of the control point at the given index.
      * @param {number} y absolute y-coordinate of the control point at the given index.
      * @see Specified by {@link yfiles.layout.IEdgeLayout#setPoint}.
      */
      setPoint(index:number,x:number,y:number):void;
      /**
      * Adds a control point to the end of the control point sequence.
      * @param {number} x the absolute x-coordinate of the control point.
      * @param {number} y the absolute y-coordinate of the control point.
      * @see Specified by {@link yfiles.layout.IEdgeLayout#addPoint}.
      */
      addPoint(x:number,y:number):void;
      /**
      * Remove all control points from this edge layout.
      * @see Specified by {@link yfiles.layout.IEdgeLayout#clearPoints}.
      */
      clearPoints():void;
      /**
      * The relative coordinates of the first end point of this layout
      * that is associated with the source node of the edge.
      * <b>Getter:</b>The returned coordinates are relative to the center location of the source
      * node of the edge. To obtain the absolute coordinates of the end point it
      * is therefore necessary to add the center coordinates of the source node layout
      * to the returned value.
      * <b>Setter:</b>The given coordinates must be relative to the center location of the source
      * node of the edge.
      * @see {@link yfiles.layout.LayoutGraph#getCenterX}
      * @see {@link yfiles.layout.LayoutGraph#getCenterY}
      * @see {@link yfiles.layout.INodeLayout#x}
      * @see {@link yfiles.layout.INodeLayout#width}
      * @see {@link yfiles.layout.IEdgeLayout#targetPoint}
      * @see Specified by {@link yfiles.layout.IEdgeLayout#sourcePoint}.
      */
      sourcePoint:yfiles.algorithms.YPoint;
      /**
      * The relative coordinates of the second end point of this layout
      * that is associated with the target node of the edge.
      * <b>Getter:</b>The returned coordinates are relative to the center location of the target
      * node of the edge. To obtain the absolute coordinates of the end point it
      * is therefore necessary to add the center coordinates of the target node layout
      * to the returned value.
      * <b>Setter:</b>The given coordinates must be relative to the center location of the target
      * node of the edge.
      * @see {@link yfiles.layout.LayoutGraph#getCenterX}
      * @see {@link yfiles.layout.LayoutGraph#getCenterY}
      * @see {@link yfiles.layout.INodeLayout#x}
      * @see {@link yfiles.layout.INodeLayout#width}
      * @see Specified by {@link yfiles.layout.IEdgeLayout#targetPoint}.
      */
      targetPoint:yfiles.algorithms.YPoint;
    }
    var DefaultEdgeLayout:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new DefaultEdgeLayout.
      */
      new ():yfiles.layout.DefaultEdgeLayout;
      /**
      * Creates a new DefaultEdgeLayout which is the copy of another EdgeLayout.
      * @param {yfiles.layout.IEdgeLayout} layout another edge layout
      */
      FromEdgeLayout:{
        new (layout:yfiles.layout.IEdgeLayout):yfiles.layout.DefaultEdgeLayout;
      };
    };
    /**
    * This class is a default implementation of the simple GraphLayout
    * interface.
    */
    export interface DefaultGraphLayout extends Object,yfiles.layout.IGraphLayout{
      /**
      * Sets the layout information associated with the given node object.
      */
      setNodeLayout(node:Object,layout:yfiles.layout.INodeLayout):void;
      /**
      * Sets the layout information associated with the given edge object.
      */
      setEdgeLayout(edge:Object,layout:yfiles.layout.IEdgeLayout):void;
      /**
      * Returns the layout information associated with the given edge object.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getEdgeLayout}.
      */
      getEdgeLayout(edge:Object):yfiles.layout.IEdgeLayout;
      /**
      * Returns the layout information associated with the given node object.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getNodeLayout}.
      */
      getNodeLayout(node:Object):yfiles.layout.INodeLayout;
      /**
      * Sets the node label layouts associated with the given node.
      */
      setNodeLabelLayout(node:Object,layout:yfiles.layout.INodeLabelLayout[]):void;
      /**
      * Returns the node label layouts associated with the given node.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getNodeLabelLayout}.
      */
      getNodeLabelLayout(node:Object):yfiles.layout.INodeLabelLayout[];
      /**
      * Sets the edge label layouts associated with the given edge.
      */
      setEdgeLabelLayout(edge:Object,layout:yfiles.layout.IEdgeLabelLayout[]):void;
      /**
      * Returns the edge label layouts associated with the given edge.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getEdgeLabelLayout}.
      */
      getEdgeLabelLayout(edge:Object):yfiles.layout.IEdgeLabelLayout[];
      /**
      * Returns the bounding box of this graph layout
      * This is the smallest rectangle containing the entire layout.
      * If the layout does not contain any node layout information
      * (and therefore no edge layout information either),
      * the bounding box will have negative width and/or height.
      * @see Specified by {@link yfiles.layout.IGraphLayout#getBoundingBox}.
      */
      getBoundingBox():yfiles.algorithms.Rectangle;
    }
    var DefaultGraphLayout:{
      $class:yfiles.lang.Class;
      new ():yfiles.layout.DefaultGraphLayout;
    };
    /**
    * This class is a default implementation of the abstract class LayoutGraph.
    */
    export interface DefaultLayoutGraph extends yfiles.layout.LayoutGraph{
      /**
      * NodeMap used to associate node label layouts with the nodes of this graph.
      * @see {@link yfiles.layout.DefaultLayoutGraph#setNodeLabelLayoutMultiple}
      */
      nodeLabelMap:yfiles.algorithms.INodeMap;
      /**
      * EdgeMap used to associate edge label layouts with the edges of this graph.
      * @see {@link yfiles.layout.DefaultLayoutGraph#setEdgeLabelLayout}
      */
      edgeLabelMap:yfiles.algorithms.IEdgeMap;
      /**
      * Map used to associate the owner of a node label with the node label itself.
      */
      nodeLabelFeatureMap:yfiles.algorithms.IMap;
      /**
      * Map used to associate the owner of an edge label with the edge label itself.
      */
      edgeLabelFeatureMap:yfiles.algorithms.IMap;
      /**
      * Creates a new {@link yfiles.layout.LayoutGraphCopyFactory.HierarchicGraphCopyFactory}.
      * @see Overrides {@link yfiles.layout.LayoutGraph#createGraphCopyFactory}
      */
      createGraphCopyFactory():yfiles.algorithms.GraphCopier.ICopyFactory;
      /**
      * Returns the layout information for a node in the drawing.
      * @param {yfiles.algorithms.Node} v a node in the drawing.
      * @return {yfiles.layout.INodeLayout} the layout information for <code>node</code>.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getLayoutForNode}
      */
      getLayoutForNode(v:yfiles.algorithms.Node):yfiles.layout.INodeLayout;
      /**
      * Sets the layout information for a node in the drawing.
      */
      setNodeLayout(v:yfiles.algorithms.Node,layout:yfiles.layout.INodeLayout):void;
      /**
      * Sets the layout information for an edge in the drawing.
      */
      setEdgeLayout(e:yfiles.algorithms.Edge,layout:yfiles.layout.IEdgeLayout):void;
      /**
      * Returns the layout information for an edge in the drawing.
      * @param {yfiles.algorithms.Edge} e a edge in the drawing.
      * @return {yfiles.layout.IEdgeLayout} the layout information for the given edge.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getLayoutForEdge}
      */
      getLayoutForEdge(e:yfiles.algorithms.Edge):yfiles.layout.IEdgeLayout;
      /**
      * Returns NodeLabelLayout objects that describe the layouts
      * of the labels belonging to the given node.
      * @param {yfiles.algorithms.Node} node a node in the drawing.
      * @return {yfiles.layout.INodeLabelLayout[]} the node label layout information for the given node.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getLabelLayoutForNode}
      */
      getLabelLayoutForNode(node:yfiles.algorithms.Node):yfiles.layout.INodeLabelLayout[];
      /**
      * Sets the NodeLabelLayout object which describes the layout
      * of the label that belongs to the given node.
      * @param {yfiles.algorithms.Node} node a node in the drawing.
      * @param {yfiles.layout.INodeLabelLayout} layout a layout object for the node label
      */
      setNodeLabelLayout(node:yfiles.algorithms.Node,layout:yfiles.layout.INodeLabelLayout):void;
      /**
      * Sets the NodeLabelLayout objects which describe the layouts
      * of the labels that belong to the given node.
      * @param {yfiles.algorithms.Node} node a node in the drawing.
      * @param {yfiles.layout.INodeLabelLayout[]} llayout an array of node label layout objects
      */
      setNodeLabelLayoutMultiple(node:yfiles.algorithms.Node,llayout:yfiles.layout.INodeLabelLayout[]):void;
      /**
      * Sets the EdgeLabelLayout objects which describe the layouts
      * of the labels that belong to the given edge.
      * @param {yfiles.algorithms.Edge} edge an edge in the drawing.
      * @param {yfiles.layout.IEdgeLabelLayout[]} layout an array of edge label layout objects
      */
      setEdgeLabelLayout(edge:yfiles.algorithms.Edge,layout:yfiles.layout.IEdgeLabelLayout[]):void;
      /**
      * Returns EdgeLabelLayout objects which describe the layouts
      * of the labels that belong to the given edge.
      * @param {yfiles.algorithms.Edge} edge an edge in the drawing.
      * @return {yfiles.layout.IEdgeLabelLayout[]} the edge label layout information for the given edge.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getLabelLayoutForEdge}
      */
      getLabelLayoutForEdge(edge:yfiles.algorithms.Edge):yfiles.layout.IEdgeLabelLayout[];
      /**
      * Returns the node which is described by a given label layout.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getFeatureNode}
      */
      getFeatureNode(labelLayout:yfiles.layout.INodeLabelLayout):yfiles.algorithms.Node;
      /**
      * Returns the edge which is described by a given label layout.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getFeatureEdge}
      */
      getFeatureEdge(labelLayout:yfiles.layout.IEdgeLabelLayout):yfiles.algorithms.Edge;
      /**
      * Override this to create your own EdgeLayouts.
      */
      createEdgeLayout():yfiles.layout.IEdgeLayout;
      /**
      * Override this to create your own NodeLayouts.
      */
      createNodeLayout():yfiles.layout.INodeLayout;
      /**
      * Creates a new label layout factory for this graph.
      * @return {yfiles.layout.ILabelLayoutFactory} the new label layout factory.
      * @see Overrides {@link yfiles.layout.LayoutGraph#createLabelFactory}
      */
      createLabelFactory():yfiles.layout.ILabelLayoutFactory;
    }
    var DefaultLayoutGraph:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new Layout Graph.
      */
      new ():yfiles.layout.DefaultLayoutGraph;
      /**
      * Creates a copy of the given subgraph.
      */
      FromGraph:{
        new (argGraph:yfiles.layout.LayoutGraph):yfiles.layout.DefaultLayoutGraph;
      };
      /**
      * Creates a copy of the given subgraph.
      */
      FromGraphForSubset:{
        new (graph:yfiles.layout.LayoutGraph,nodeSubset:yfiles.algorithms.ICursor):yfiles.layout.DefaultLayoutGraph;
      };
      /**
      * Creates a copy of the given subgraph.
      */
      FromDefaultLayoutGraphForSubset:{
        new (graph:yfiles.layout.DefaultLayoutGraph,nodeSubset:yfiles.algorithms.ICursor):yfiles.layout.DefaultLayoutGraph;
      };
    };
    /**
    * This is a LayoutGraph implementation that serves as a copy of
    * another LayoutGraph or as copy of a combined GraphInterface and
    * and GraphLayout interface implementation.
    */
    export interface CopiedLayoutGraph extends yfiles.layout.LayoutGraph{
      /**
      * Creates an copied edge.
      * The mappings are updated so that it is possible to look up the newly created
      * node by using {@link yfiles.layout.CopiedLayoutGraph#getCopiedEdge}.
      * This method can be used to keep the CopiedLayoutGraph in sync with the original graph.
      * @param {Object} origEdge the original edge the copied edge is based on
      * @return {yfiles.algorithms.Edge} the newly created edge (belongs to the copied graph)
      */
      createEdge(origEdge:Object):yfiles.algorithms.Edge;
      /**
      * Creates a factory that delegates to the {@link yfiles.layout.CopiedLayoutGraph#createNodeWithOriginalNode}
      * and {@link yfiles.layout.CopiedLayoutGraph#createEdge} methods of this instance.
      * @see Overrides {@link yfiles.layout.LayoutGraph#createGraphCopyFactory}
      */
      createGraphCopyFactory():yfiles.algorithms.GraphCopier.ICopyFactory;
      /**
      * Creates a copy of the given original node.
      * The mappings are updated so that the lookup methods
      * ({@link yfiles.layout.CopiedLayoutGraph#getOriginalNode} and {@link yfiles.layout.CopiedLayoutGraph#getCopiedNode} can be used.
      * This method is especially useful to keep the CopiedLayoutGraph in sync with the original graph.
      * @param {Object} origNode the node of the original graph the copy will be created for
      * @return {yfiles.algorithms.Node} the newly created node that represents a copy of the given node.
      */
      createNodeWithOriginalNode(origNode:Object):yfiles.algorithms.Node;
      /**
      * Synchronizes the structure of the CopiedLayoutGraph with the actual structure of the underlying LayoutGraph.
      */
      syncStructure():void;
      /**
      * Returns the layout information for a node in the drawing.
      * @param {yfiles.algorithms.Node} v a node in the drawing.
      * @return {yfiles.layout.INodeLayout} the layout information for <code>node</code>.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getLayoutForNode}
      */
      getLayoutForNode(v:yfiles.algorithms.Node):yfiles.layout.INodeLayout;
      /**
      * Returns the layout information for an edge in the drawing.
      * @param {yfiles.algorithms.Edge} e an edge in the drawing.
      * @return {yfiles.layout.IEdgeLayout} the layout information for the given edge.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getLayoutForEdge}
      */
      getLayoutForEdge(e:yfiles.algorithms.Edge):yfiles.layout.IEdgeLayout;
      /**
      * Returns NodeLabelLayout objects which describe the layouts
      * of the labels that belong to the given node.
      * @param {yfiles.algorithms.Node} v a node in the drawing.
      * @return {yfiles.layout.INodeLabelLayout[]} the node label layout information for <code>node</code>.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getLabelLayoutForNode}
      */
      getLabelLayoutForNode(v:yfiles.algorithms.Node):yfiles.layout.INodeLabelLayout[];
      /**
      * Returns EdgeLabelLayout objects which describe the layouts
      * of the labels that belong to the given edge.
      * @param {yfiles.algorithms.Edge} e an edge in the drawing.
      * @return {yfiles.layout.IEdgeLabelLayout[]} the edge label layout information for the given edge.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getLabelLayoutForEdge}
      */
      getLabelLayoutForEdge(e:yfiles.algorithms.Edge):yfiles.layout.IEdgeLabelLayout[];
      /**
      * Returns the node which is described by a given label layout.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getFeatureNode}
      */
      getFeatureNode(labelLayout:yfiles.layout.INodeLabelLayout):yfiles.algorithms.Node;
      /**
      * Returns the edge which is described by a given label layout.
      * @see Overrides {@link yfiles.layout.LayoutGraph#getFeatureEdge}
      */
      getFeatureEdge(labelLayout:yfiles.layout.IEdgeLabelLayout):yfiles.algorithms.Edge;
      /**
      * The GraphLayout that is valid for the original graph.
      * The information contained
      * in the GraphLayout is identical to the graph layout associated with this graph, but it
      * uses the original graph elements as lookup domain, i.e.
      * <code>getLayout(copiedNode)</code> corresponds to
      * <code>getLayoutForOriginalGraph().getLayout(getOriginalNode(copiedNode))</code>.
      */
      layoutForOriginalGraph:yfiles.layout.IGraphLayout;
      /**
      * Writes the current layout information to the original graph.
      * Works only when the graph was constructed as copy of another graph.
      */
      commitLayoutToOriginalGraph():void;
      /**
      * Returns the original node that corresponds to the given
      * node.
      * @param {yfiles.algorithms.Node} v a node in this graph that is a copy of the returned node
      * @return {Object} a node in the original graph whose copy is the given node
      */
      getOriginalNode(v:yfiles.algorithms.Node):Object;
      /**
      * Returns the original edge that corresponds to the given
      * edge.
      * @param {yfiles.algorithms.Edge} e an edge in this graph that is a copy of the returned edge
      * @return {Object} an edge in the original graph whose copy is the given edge
      */
      getOriginalEdge(e:yfiles.algorithms.Edge):Object;
      /**
      * Returns the copied node that corresponds to the given
      * original node.
      * @param {Object} v a node in the original graph whose copy is in this graph
      * @return {yfiles.algorithms.Node} a node in this graph that is the copy of the given original node
      */
      getCopiedNode(v:Object):yfiles.algorithms.Node;
      /**
      * Returns the copied edge that corresponds to the given
      * original edge.
      * @param {Object} e an edge in the original graph whose copy is in this graph
      * @return {yfiles.algorithms.Edge} an edge in this graph that is the copy of the given original edge
      */
      getCopiedEdge(e:Object):yfiles.algorithms.Edge;
      /**
      * The original graph.
      */
      originalGraph:yfiles.algorithms.IGraphInterface;
      /**
      * The original layout.
      */
      originalLayout:yfiles.layout.IGraphLayout;
      /**
      * Creates a new label layout factory for this graph.
      * @return {yfiles.layout.ILabelLayoutFactory} the new label layout factory.
      * @see Overrides {@link yfiles.layout.LayoutGraph#createLabelFactory}
      */
      createLabelFactory():yfiles.layout.ILabelLayoutFactory;
    }
    var CopiedLayoutGraph:{
      $class:yfiles.lang.Class;
      /**
      * Initializes this graph as a copy of the given graph.
      */
      new (graph:yfiles.layout.LayoutGraph):yfiles.layout.CopiedLayoutGraph;
      /**
      * Initializes this graph as a copy of the given graph interface
      * and graph layout.
      */
      FromGraphAndLayout:{
        new (graph:yfiles.algorithms.IGraphInterface,layout:yfiles.layout.IGraphLayout):yfiles.layout.CopiedLayoutGraph;
      };
    };
    /**
    * A layout stage for hierarchically grouped graphs.
    * Activating this stage
    * guarantees that a core layouter will keep the relative positions of nodes
    * within the same group.
    * Also, this stage is responsible for routing edges that connect nodes
    * belonging to hierarchically unrelated groups.
    * <p>
    * More precisely, the stage temporarily replaces fixed group nodes (see {@link yfiles.layout.FixedGroupLayoutStage#FIXED_GROUP_NODES_DP_KEY}) with normal
    * nodes of the same size while the groups' content is removed from the graph during layout.
    * The nodes are used as placeholders
    * and to keep the relations to the remaining graph elements. Edges that connect from outside the group node to its
    * content (inter-edges) are redirected such that they connect to the node that replaces the group.
    * After layout, the group nodes are restored and the stage inserts the content at the new group position
    * (derived from the position of the associated node). The content
    * itself (including the edges between content nodes) remains unchanged and is only relocated. Furthermore,
    * the inter-edges are connected to their original source/target and the stage reroutes them using the
    * specified inter-edge routing algorithm (see {@link yfiles.layout.FixedGroupLayoutStage#orthogonalEdgeRouter}).
    * </p>
    */
    export interface FixedGroupLayoutStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * The inter-edge routing style used by this layouter.
      */
      interEdgeRoutingStyle:yfiles.layout.InterEdgeRoutingStyle;
      /**
      * The orthogonal edge router instance used to route
      * the inter-edges orthogonally.
      * Inter-edges that have to be routed with the specified routing algorithm
      * will be marked using this stage's {@link yfiles.layout.FixedGroupLayoutStage#INTER_EDGES_DP_KEY} data provider
      * key.
      * @see {@link yfiles.layout.FixedGroupLayoutStage#INTER_EDGES_DP_KEY}
      */
      orthogonalEdgeRouter:yfiles.layout.ILayouter;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var FixedGroupLayoutStage:{
      $class:yfiles.lang.Class;
      /**
      * This key can be used to <em>select</em> specific group nodes whose contents
      * should keep their relative positions.
      * A group node is considered <em>selected</em> in this context, if the
      * corresponding <code>DataProvider</code> returns <code>true</code> for
      * <b>the node or any of its ancestor (group) nodes</b>.
      * <p>
      * <b>Note:</b>
      * If there is no <code>DataProvider</code> for this key, all group nodes are
      * considered <em>selected</em>.
      * </p>
      */
      FIXED_GROUP_NODES_DP_KEY:Object;
      /**
      * This key is used to mark edges as inter-edges for orthogonal routing.
      * The registered data provider's {@link yfiles.algorithms.IDataProvider#getBool getBool} method will return <code>true</code> for inter-edges (i.e. edges
      * that have to be routed) and <code>false</code> for all other edges.
      */
      INTER_EDGES_DP_KEY:Object;
      /**
      * Initializes a new instance of <code>FixedGroupLayoutStage</code>.
      */
      new ():yfiles.layout.FixedGroupLayoutStage;
      /**
      * Initializes a new instance of <code>FixedGroupLayoutStage</code> with the
      * given core layouter.
      * @param {yfiles.layout.ILayouter} core the core layout algorithm for this stage.
      */
      WithCoreLayouter:{
        new (core:yfiles.layout.ILayouter):yfiles.layout.FixedGroupLayoutStage;
      };
    };
    /**
    * This layout stage provides a framework for layouts that are based on a divide and conquer approach.
    * The workings of this stage is subdivided into four stages:
    * <ul>
    * <li>
    * The input graph is partitioned into smaller units. Implementations of this phase can
    * be set using method {@link yfiles.layout.PartitionLayouter#partitionFinder}.
    * </li>
    * <li>
    * Optionally, the graph partitions are laid out by an layout algorithm. Implementations of this phase can
    * be set using method {@link yfiles.layout.AbstractLayoutStage#coreLayouter}.
    * </li>
    * <li>
    * The graph partitions are independently arranged. Implementations of this phase can
    * be set using method {@link yfiles.layout.PartitionLayouter#partitionPlacer}.
    * </li>
    * <li>
    * Edges that connect nodes in different graph partitions will be routed. Implementations of this phase can
    * be set using method {@link yfiles.layout.PartitionLayouter#interEdgeRouter}
    * </li>
    * </ul>
    */
    export interface PartitionLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns {@link yfiles.layout.AbstractLayoutStage#canLayoutCore}.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The currently set PartitionFinder instance.
      */
      partitionFinder:yfiles.layout.PartitionLayouter.IPartitionFinder;
      /**
      * The currently set PartitionPlacer instance.
      */
      partitionPlacer:yfiles.layout.PartitionLayouter.IPartitionPlacer;
      /**
      * The currently set InterEdgeRouter instance.
      */
      interEdgeRouter:yfiles.layout.PartitionLayouter.IInterEdgeRouter;
    }
    export module PartitionLayouter{
      /**
      * Implementations of this interface are responsible to partition the input graph.
      */
      export interface IPartitionFinder extends Object{
        /**
        * Returns a partition id for each node of an input graph.
        * Nodes that share a common partition id
        * will be considered to belong to the same partition.
        * @param {yfiles.layout.LayoutGraph} graph the input graph
        * @param {yfiles.algorithms.INodeMap} partitionIDMap used to return the resulting partition ids
        * @see Specified by {@link yfiles.layout.PartitionLayouter.IPartitionFinder#findPartitions}.
        */
        findPartitions(graph:yfiles.layout.LayoutGraph,partitionIDMap:yfiles.algorithms.INodeMap):void;
      }
      /**
      * Implementations of this interface are responsible for arranging the graph partitions.
      * Arranging a
      * graph partition usually involves to apply a coordinate translation to all elements belonging to
      * the partition in order to generate a non-overlapping node-arrangement.
      */
      export interface IPartitionPlacer extends Object{
        /**
        * Arranges the graph while taking partition ids and inter-edge information into account.
        * @param {yfiles.layout.LayoutGraph} graph the input graph
        * @param {yfiles.algorithms.IDataProvider} partitionIDDP the partition id for each node in the graph.
        * @param {yfiles.algorithms.IDataProvider} interEdgeDP 
        * holds a boolean value for each edge of the graph indicating if the
        * edge is an inter-edge or not. An inter-edge is an edge that connects nodes that do not
        * belong to the same partition.
        * @see Specified by {@link yfiles.layout.PartitionLayouter.IPartitionPlacer#placePartitions}.
        */
        placePartitions(graph:yfiles.layout.LayoutGraph,partitionIDDP:yfiles.algorithms.IDataProvider,interEdgeDP:yfiles.algorithms.IDataProvider):void;
      }
      /**
      * Implementations of this interface are responsible for routing inter-edges.
      * An inter-edge is an edge that connects nodes that do not
      * belong to the same partition.
      */
      export interface IInterEdgeRouter extends Object{
        /**
        * Routes inter-edges of the partitioned graph.
        * @param {yfiles.layout.LayoutGraph} graph the input graph
        * @param {yfiles.algorithms.IDataProvider} partitionIDDP the partition id for each node in the graph.
        * @param {yfiles.algorithms.IDataProvider} interEdgeDP 
        * holds a boolean value for each edge of the graph indicating if the
        * edge is an inter-edge or not.
        * @see Specified by {@link yfiles.layout.PartitionLayouter.IInterEdgeRouter#routeInterEdges}.
        */
        routeInterEdges(graph:yfiles.layout.LayoutGraph,partitionIDDP:yfiles.algorithms.IDataProvider,interEdgeDP:yfiles.algorithms.IDataProvider):void;
      }
      /**
      * InterEdgeRouter implementation that routes inter-edges using
      * {@link yfiles.router.ChannelEdgeRouter}.
      */
      export interface ChannelInterEdgeRouter extends Object,yfiles.layout.PartitionLayouter.IInterEdgeRouter{
        /**
        * <code>true</code> if this <code>ChannelInterEdgeRouter</code>
        * is configured to route inter-partition edges only.
        * By default, all edges are routed, i.e. <code>routeInterEdgesOnly</code>
        * is set to <code>false</code>.
        * @see {@link yfiles.layout.PartitionLayouter.ChannelInterEdgeRouter#routeInterEdges}
        * @see {@link yfiles.layout.PartitionLayouter.ChannelInterEdgeRouter#routeInterEdges}
        */
        routeInterEdgesOnly:boolean;
        /**
        * The{@link yfiles.algorithms.IDataProvider} key which is used to register the
        * inter-edge data provider passed to
        * {@link yfiles.layout.PartitionLayouter.ChannelInterEdgeRouter#routeInterEdges}
        * on the given graph.
        * Defaults to {@link yfiles.layout.LayouterKeys#SELECTED_EDGES_DP_KEY}.
        */
        interEdgeDPKey:Object;
        /**
        * The{@link yfiles.router.ChannelEdgeRouter} instance used to route inter-edges.
        */
        channelEdgeRouter:yfiles.router.ChannelEdgeRouter;
        /**
        * The maximum relative distance between an edge and its closest
        * node for edges routed outside the bounding box of all graph nodes.
        * <b>Getter:</b>A negative value means that there is no restriction for the edge-node
        * distance.
        * <b>Setter:</b>The value is relative in the way that edges to the left or right
        * of the nodes' bounding box must satisfy
        * <code>dist(edge, bounding box) &lt;= (bounding box width) * margin</code>
        * and edges above or below the nodes' bounding box must satisfy
        * <code>dist(edge, bounding box) &lt;= (bounding box height) * margin</code>.
        * Passing in a negative value effectively allow edges to be arbitrarily
        * far from their closest nodes.
        * By default <code>margin</code> is set to <code>-1.0</code>.
        */
        margin:number;
        /**
        * Routes inter-edges of the partitioned graph.
        * This implementation will register/deregister <code>interEdgeDP</code>
        * on the specified input graph before/after doing any actual routing.
        * @param {yfiles.layout.LayoutGraph} graph the input graph.
        * @param {yfiles.algorithms.IDataProvider} partitionIDDP the partition id for each node in the graph.
        * @param {yfiles.algorithms.IDataProvider} interEdgeDP 
        * holds a boolean value for each edge of the graph
        * indicating if the edge is an inter-edge or not.
        * @see {@link yfiles.layout.PartitionLayouter.ChannelInterEdgeRouter#interEdgeDPKey}
        * @see {@link yfiles.layout.PartitionLayouter.ChannelInterEdgeRouter#interEdgeDPKey}
        * @see Specified by {@link yfiles.layout.PartitionLayouter.IInterEdgeRouter#routeInterEdges}.
        */
        routeInterEdges(graph:yfiles.layout.LayoutGraph,partitionIDDP:yfiles.algorithms.IDataProvider,interEdgeDP:yfiles.algorithms.IDataProvider):void;
      }
      /**
      * InterEdgeRouter implementation that routes inter-edges using {@link yfiles.router.polyline.EdgeRouter}.
      */
      export interface PolylineInterEdgeRouter extends Object,yfiles.layout.PartitionLayouter.IInterEdgeRouter{
        /**
        * The <code>DataProvider</code> key to mark edges as
        * <em>selected</em>.
        * <p>
        * By default, {@link yfiles.layout.LayouterKeys#SELECTED_EDGES_DP_KEY} is used.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#selectedEdgesDpKey}
        * @see {@link yfiles.router.polyline.EdgeRouter#selectedEdgesDpKey}
        * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
        * @see {@link yfiles.router.polyline.EdgeRouter#selectedEdgesDpKey}
        * @see {@link yfiles.router.polyline.EdgeRouter#selectedEdgesDpKey}
        */
        selectedEdgesDpKey:Object;
        /**
        * <code>true</code> if this <code>PolylineInterEdgeRouter</code>
        * is configured to route inter-partition edges only.
        * By default, all edges are routed, i.e. <code>routeInterEdgesOnly</code>
        * is set to <code>false</code>.
        * @see {@link yfiles.layout.PartitionLayouter.PolylineInterEdgeRouter#routeInterEdges}
        * @see {@link yfiles.layout.PartitionLayouter.PolylineInterEdgeRouter#routeInterEdges}
        */
        routeInterEdgesOnly:boolean;
        /**
        * Routes inter-edges of the partitioned graph.
        * @param {yfiles.layout.LayoutGraph} graph the input graph
        * @param {yfiles.algorithms.IDataProvider} partitionIDDP the partition id for each node in the graph.
        * @param {yfiles.algorithms.IDataProvider} interEdgeDP 
        * holds a boolean value for each edge of the graph indicating if the
        * edge is an inter-edge or not.
        * @see Specified by {@link yfiles.layout.PartitionLayouter.IInterEdgeRouter#routeInterEdges}.
        */
        routeInterEdges(graph:yfiles.layout.LayoutGraph,clusterIDDP:yfiles.algorithms.IDataProvider,interEdgeDP:yfiles.algorithms.IDataProvider):void;
        /**
        * The{@link yfiles.router.polyline.EdgeRouter} instance used to route inter-edges.
        */
        edgeRouter:yfiles.router.polyline.EdgeRouter;
      }
      /**
      * InterEdgeRouter implementation that routes inter-edges using {@link yfiles.router.OrthogonalEdgeRouter}.
      */
      export interface OrthogonalInterEdgeRouter extends Object,yfiles.layout.PartitionLayouter.IInterEdgeRouter{
        /**
        * The <code>DataProvider</code> key to mark edges as
        * <em>selected</em>.
        * <p>
        * By default, {@link yfiles.layout.LayouterKeys#SELECTED_EDGES_DP_KEY} is used.
        * </p>
        * @see {@link yfiles.router.OrthogonalEdgeRouter#selectedEdgesDpKey}
        * @see {@link yfiles.router.OrthogonalEdgeRouter#selectedEdgesDpKey}
        * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
        * @see {@link yfiles.router.OrthogonalEdgeRouter#selectedEdgesDpKey}
        * @see {@link yfiles.router.OrthogonalEdgeRouter#selectedEdgesDpKey}
        */
        selectedEdgesDpKey:Object;
        /**
        * Routes inter-edges of the partitioned graph.
        * @param {yfiles.layout.LayoutGraph} graph the input graph
        * @param {yfiles.algorithms.IDataProvider} partitionIDDP the partition id for each node in the graph.
        * @param {yfiles.algorithms.IDataProvider} interEdgeDP 
        * holds a boolean value for each edge of the graph indicating if the
        * edge is an inter-edge or not.
        * @see Specified by {@link yfiles.layout.PartitionLayouter.IInterEdgeRouter#routeInterEdges}.
        */
        routeInterEdges(graph:yfiles.layout.LayoutGraph,clusterIDDP:yfiles.algorithms.IDataProvider,interEdgeDP:yfiles.algorithms.IDataProvider):void;
        /**
        * The{@link yfiles.router.OrthogonalEdgeRouter} instance used to route inter-edges.
        */
        orthogonalEdgeRouter:yfiles.router.OrthogonalEdgeRouter;
      }
      /**
      * PartitionFinder implementation that uses {@link yfiles.algorithms.Groups#edgeBetweennessClusteringWithCost}
      * as partition strategy.
      */
      export interface EdgeBetweennessPartitionFinder extends Object,yfiles.layout.PartitionLayouter.IPartitionFinder{
        /**
        * Returns a partition id for each node of an input graph.
        * Nodes that share a common partition id
        * will be considered to belong to the same partition.
        * @param {yfiles.layout.LayoutGraph} graph the input graph
        * @param {yfiles.algorithms.INodeMap} partitionIDMap used to return the resulting partition ids
        * @see Specified by {@link yfiles.layout.PartitionLayouter.IPartitionFinder#findPartitions}.
        */
        findPartitions(graph:yfiles.layout.LayoutGraph,clusterIDMap:yfiles.algorithms.INodeMap):void;
        /**
        * The maximum number of partitions that this class should return.
        * By default there is no limit
        * to the number of returned partitions.
        */
        maximumPartitionCount:number;
        /**
        * The minimum number of partitions that this class should return.
        * By default this value is set to <code>0</code>.
        */
        minimumPartitionCount:number;
      }
      /**
      * PartitionPlacer implementation that uses {@link yfiles.layout.ComponentLayouter} to place
      * the partitions.
      */
      export interface ComponentPartitionPlacer extends Object,yfiles.layout.PartitionLayouter.IPartitionPlacer{
        /**
        * Arranges the graph while taking partition ids and inter-edge information into account.
        * @param {yfiles.layout.LayoutGraph} graph the input graph
        * @param {yfiles.algorithms.IDataProvider} partitionIDDP the partition id for each node in the graph.
        * @param {yfiles.algorithms.IDataProvider} interEdgeDP 
        * holds a boolean value for each edge of the graph indicating if the
        * edge is an inter-edge or not. An inter-edge is an edge that connects nodes that do not
        * belong to the same partition.
        * @see Specified by {@link yfiles.layout.PartitionLayouter.IPartitionPlacer#placePartitions}.
        */
        placePartitions(graph:yfiles.layout.LayoutGraph,clusterIDDP:yfiles.algorithms.IDataProvider,interEdgeDP:yfiles.algorithms.IDataProvider):void;
        /**
        * The ComponentLayouter instance used to place the graph partitions.
        */
        componentLayouter:yfiles.layout.ComponentLayouter;
      }
    }
    var PartitionLayouter:{
      $class:yfiles.lang.Class;
      new ():yfiles.layout.PartitionLayouter;
      ChannelInterEdgeRouter:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of this class.
        */
        new ():yfiles.layout.PartitionLayouter;
      };
      PolylineInterEdgeRouter:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of this class.
        */
        new ():yfiles.layout.PartitionLayouter;
      };
      OrthogonalInterEdgeRouter:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of this class.
        */
        new ():yfiles.layout.PartitionLayouter;
      };
      EdgeBetweennessPartitionFinder:{
        $class:yfiles.lang.Class;
        new ():yfiles.layout.PartitionLayouter;
      };
      ComponentPartitionPlacer:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of this class.
        */
        new ():yfiles.layout.PartitionLayouter;
      };
    };
    /**
    * LayoutStage that assigns edges to the ports specified by {@link yfiles.layout.PortConstraint}s or {@link yfiles.layout.PortCandidate}s after
    * calling the core layout.
    * It can be used to adjust ports for layout algorithms that cannot handle such constraints.
    * <p>
    * If <code>PortCandidate</code>s are assigned for edges and nodes, this stage tries to match them. When there is no
    * match, the <code>PortCandidate</code> with the lowest costs specified for the edge is chosen.
    * While <code>PortConstraint</code>s are also matched to <code>PortCandidate</code>s at nodes and edges, it is not
    * recommended to mix them because they belong to different concepts.
    * </p>
    * <p>
    * Furthermore, option {@link yfiles.layout.PortCandidateAssignmentStage#pathCorrection} allows to specify whether the edge path should be
    * corrected after correcting a port.
    * </p>
    * @see {@link yfiles.layout.PortConstraint}
    * @see {@link yfiles.layout.PortCandidate}
    * @see {@link yfiles.layout.PortCandidateSet}
    * @see {@link yfiles.layout.PortCandidateAssignmentStage#pathCorrection}
    */
    export interface PortCandidateAssignmentStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Specifies whether or not this stage corrects the edge paths after moving the port to the location specified by a
      * {@link yfiles.layout.PortConstraint} or {@link yfiles.layout.PortCandidate}s.
      * <p>
      * If path correction is enabled, the edge will be rerouted within a specific area around its source/target node.
      * Outside this area it will keep the route that was calculated by the {@link yfiles.layout.AbstractLayoutStage#coreLayouter  core layouter}.
      * When disabled, only the ports are moved which may be more suitable for initially straight edges.
      * </p>
      * <p>
      * Note that the path correction uses a simple orthogonal routing strategy that is fast but may produce
      * overlapping edge segments as well as edge-node intersections.
      * </p>
      * <p>
      * By default this option is disabled.
      * </p>
      */
      pathCorrection:boolean;
    }
    var PortCandidateAssignmentStage:{
      $class:yfiles.lang.Class;
      new ():yfiles.layout.PortCandidateAssignmentStage;
      WithCoreLayouter :{
        new (core:yfiles.layout.ILayouter):yfiles.layout.PortCandidateAssignmentStage;
      };
    };
    /**
    * Class for creating a partition grid, i.e., a grid that partitions the drawing area into rectangular partition cells.
    * The grid consists of rows and columns that are created using the corresponding constructors of this class or method
    * #addColumn or #addRow. The PartitionGrid object has to be registered to the graph using DataProvider key {@link yfiles.layout.PartitionGrid#PARTITION_GRID_DP_KEY};
    * <p>
    * Each node can be assigned to a {@link yfiles.layout.PartitionCellId} which represents a set of partition cells.
    * The mapping has to be registered to the graph using DataProvider key {@link yfiles.layout.PartitionGrid#PARTITION_CELL_DP_KEY}.
    * Simple partition cell identifiers which represent a single partition cell, i.e., a row-/column-pair, can be created
    * using method {@link yfiles.layout.PartitionGrid#createCellIdForDescriptors} or {@link yfiles.layout.PartitionGrid#createCellId}.
    * </p>
    * <p>
    * Nodes can also be mapped to a partition cell identifier that represents a multi-cell, i.e., a cell spanning multiple columns and rows.
    * Please note, however, that multi-cells are not allowed to overlap each other. This means that the user has to ensure
    * that each partition cell (row-/column-pair) is associated with at most one partition cell identifier.
    * The multi-cell identifier can be created using methods {@link yfiles.layout.PartitionGrid#createCellSpanIdForDescriptors},
    * {@link yfiles.layout.PartitionGrid#createCellSpanId}, {@link yfiles.layout.PartitionGrid#createCellSpanIdForDescriptorLists},
    * {@link yfiles.layout.PartitionGrid#createColumnSpanId}, and {@link yfiles.layout.PartitionGrid#createRowSpanId}.
    * </p>
    * <p>
    * Note: if at least one node is mapped to a multi-cell, enabling option {@link yfiles.layout.PartitionGrid#optimizeColumnOrder}
    * or {@link yfiles.layout.PartitionGrid#optimizeRowOrder} has no effect.
    * </p>
    * <p>
    * Note: A group node mapped to a multi-cell identifier represents the corresponding multi-cell, i.e., its boundary corresponds
    * to the smallest rectangle containing all partition cells (rows and columns) specified by the multi-cell.
    * The boundary does not depend on the
    * partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually
    * assigned to one of the partition cells.
    * Furthermore, edges incident to such a group node are not considered during the layout.
    * Mapping a group node to a simple partition cell identifier has no effect.
    * </p>
    */
    export interface PartitionGrid extends Object{
      /**
      * Specifies whether the order of the columns should be chosen automatically.
      * <b>Getter:</b>The default is <code>true</code>.
      * <p>
      * Note: if at least one node is mapped to a multi-cell (i.e., a cell spanning multiple columns/rows),
      * enabling this option has no effect.
      * </p>
      * <b>Setter:</b><p>
      * For all columns where {@link yfiles.layout.ColumnDescriptor#indexFixed}
      * is set to <code>true</code>, the relative ordering given by the indices
      * is preserved. The remaining columns may be resorted so that the overall edge lengths are minimized.
      * </p>
      * <p>
      * Note: if at least one node is mapped to a multi-cell (i.e., a cell spanning multiple columns/rows),
      * enabling this option has no effect.
      * </p>
      */
      optimizeColumnOrder:boolean;
      /**
      * Specifies whether the order of the rows should be chosen automatically.
      * <b>Getter:</b>The default is <code>true</code>.
      * <p>
      * Note: if at least one node is mapped to a multi-cell (i.e., a cell spanning multiple columns/rows),
      * enabling this option has no effect.
      * </p>
      * <b>Setter:</b><p>
      * For all rows where {@link yfiles.layout.RowDescriptor#indexFixed}
      * is set to <code>true</code>, the relative ordering given by the indices
      * is preserved. The remaining rows may be resorted so that the overall edge lengths are minimized.
      * </p>
      * <p>
      * Note: if at least one node is mapped to a multi-cell (i.e., a cell spanning multiple columns/rows),
      * enabling this option has no effect.
      * </p>
      */
      optimizeRowOrder:boolean;
      /**
      * Creates a partition cell identifier that represents a cell spanning a whole column.
      * <p>
      * A group node mapped to such a partition cell identifier represents the column, i.e., its enclosing boundary
      * corresponds to that of the column. The boundary does not depend on the
      * partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually
      * assigned to one of the partition cells.
      * Furthermore, edges incident to such a group node are not considered during the layout.
      * </p>
      * @param {number} columnIndex the column index of the column defining the cell
      * @return {yfiles.layout.PartitionCellId} the partition cell identifier
      */
      createColumnSpanId(columnIndex:number):yfiles.layout.PartitionCellId;
      /**
      * Creates a partition cell identifier that represents a multi-cell spanning multiple columns and rows.
      * <p>
      * The partition cell identifier represents all cells defined by a
      * row with index between fromRow and toRow (both including) and
      * a column with index between fromCol and toCol (both including).
      * </p>
      * <p>
      * A group node mapped to such a partition cell identifier represents the multi-cell, i.e., its boundary corresponds
      * to the smallest rectangle containing all partition cells specified by the partition cell identifier.
      * The boundary does not depend on the
      * partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually
      * assigned to one of the partition cells.
      * Furthermore, edges incident to such a group node are not considered during the layout.
      * </p>
      * @param {number} fromRowIndex the row index of the topmost row defining the cell
      * @param {number} fromColIndex the column index of the leftmost column defining the cell
      * @param {number} toRowIndex the row index of the bottommost row defining the cell
      * @param {number} toColIndex the column index of the rightmost column defining the cell
      * @return {yfiles.layout.PartitionCellId} the partition cell identifier
      */
      createCellSpanId(fromRowIndex:number,fromColIndex:number,toRowIndex:number,toColIndex:number):yfiles.layout.PartitionCellId;
      /**
      * Creates a partition cell identifier that represents a multi-cell spanning multiple columns and rows.
      * <p>
      * The partition cell identifier represents all cells spanned by the columns of columnList and rows of rowList.
      * </p>
      * <p>
      * A group node mapped to such a partition cell identifier represents the multi-cell, i.e., its boundary corresponds
      * to the smallest rectangle containing all partition cells specified by the partition cell identifier.
      * The boundary does not depend on the
      * partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually
      * assigned to one of the partition cells.
      * Furthermore, edges incident to such a group node are not considered during the layout.
      * </p>
      * @param {yfiles.algorithms.ICollection} rowList the rows defining the cell
      * @param {yfiles.algorithms.ICollection} columnList the columns defining the cell
      * @return {yfiles.layout.PartitionCellId} the partition cell identifier
      */
      createCellSpanIdForDescriptorLists(rowList:yfiles.algorithms.ICollection,columnList:yfiles.algorithms.ICollection):yfiles.layout.PartitionCellId;
      /**
      * Creates a partition cell identifier that represents a multi-cell spanning multiple columns and rows.
      * <p>
      * The partition cell identifier represents all cells defined by a
      * row between fromRow and toRow (both including) and
      * a column between fromCol and toCol (both including).
      * </p>
      * <p>
      * A group node mapped to such a partition cell identifier represents the multi-cell, i.e., its boundary corresponds
      * to the smallest rectangle containing all partition cells specified by the partition cell identifier.
      * The boundary does not depend on the
      * partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually
      * assigned to one of the partition cells.
      * Furthermore, edges incident to such a group node are not considered during the layout.
      * </p>
      * @param {yfiles.layout.RowDescriptor} fromRow the topmost row defining the cell
      * @param {yfiles.layout.ColumnDescriptor} fromCol the leftmost column defining the cell
      * @param {yfiles.layout.RowDescriptor} toRow the bottommost row defining the cell
      * @param {yfiles.layout.ColumnDescriptor} toCol the rightmost column defining the cell
      * @return {yfiles.layout.PartitionCellId} the partition cell identifier
      */
      createCellSpanIdForDescriptors(fromRow:yfiles.layout.RowDescriptor,fromCol:yfiles.layout.ColumnDescriptor,toRow:yfiles.layout.RowDescriptor,toCol:yfiles.layout.ColumnDescriptor):yfiles.layout.PartitionCellId;
      /**
      * Creates a partition cell identifier that represents a cell spanning a whole row.
      * <p>
      * A group node mapped to such a partition cell identifier
      * represents the row, i.e., its enclosing boundary corresponds to that of the row.
      * The boundary does not depend on the
      * partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually
      * assigned to one of the partition cells.
      * Furthermore, edges incident to such a group node are not considered during the layout.
      * </p>
      * @param {number} rowIndex the row index of the row defining the cell
      * @return {yfiles.layout.PartitionCellId} the partition cell identifier
      */
      createRowSpanId(rowIndex:number):yfiles.layout.PartitionCellId;
      /**
      * Adds a new row to the partition grid.
      * The index of the row (as returned by {@link yfiles.layout.RowDescriptor#index}) is set to the size of the list returned by {@link yfiles.layout.PartitionGrid#rows}.
      * @return {yfiles.layout.RowDescriptor} the new row.
      */
      addRow():yfiles.layout.RowDescriptor;
      /**
      * Adds a new column to the partition grid.
      * The index of the column (as returned by {@link yfiles.layout.ColumnDescriptor#index}) is set to the size of the list returned by {@link yfiles.layout.PartitionGrid#columns}.
      * @return {yfiles.layout.ColumnDescriptor} the new column.
      */
      addColumn():yfiles.layout.ColumnDescriptor;
      /**
      * Returns the row with the given index.
      * @param {number} index the index of the row to be returned
      * @return {yfiles.layout.RowDescriptor} the row with the given index or null if there is no such row
      */
      getRow(index:number):yfiles.layout.RowDescriptor;
      /**
      * Returns the column with the given index.
      * @param {number} index the index of the column to be returned
      * @return {yfiles.layout.ColumnDescriptor} the column with the given index or null if there is no such column
      */
      getColumn(index:number):yfiles.layout.ColumnDescriptor;
      /**
      * The rows of the partition grid.
      */
      rows:yfiles.algorithms.YList;
      /**
      * The columns of the partition grid.
      */
      columns:yfiles.algorithms.YList;
      /**
      * Creates a partition cell identifier that represents the cell defined by the given column and row.
      * @param {yfiles.layout.RowDescriptor} rd the row defining the cell
      * @param {yfiles.layout.ColumnDescriptor} cd the column defining the cell
      * @return {yfiles.layout.PartitionCellId} the partition cell identifier
      * @throws {yfiles.system.ArgumentException} if the given column/row is <code>null</code>.
      */
      createCellIdForDescriptors(rd:yfiles.layout.RowDescriptor,cd:yfiles.layout.ColumnDescriptor):yfiles.layout.PartitionCellId;
      /**
      * Creates a partition cell identifier that represents the cell defined by the given column and row index.
      * @param {number} rowIndex the row index of the row defining the cell
      * @param {number} columnIndex the column index of the column defining the cell
      * @return {yfiles.layout.PartitionCellId} the partition cell identifier
      * @throws {yfiles.system.ArgumentException} if the given column/row index is not valid.
      */
      createCellId(rowIndex:number,columnIndex:number):yfiles.layout.PartitionCellId;
      /**
      * A method that is called at the end of the {@link yfiles.layout.OrientationLayouter} stage.
      * @param {yfiles.layout.OrientationLayouter} orientationLayouter the instance of the orientation layouter
      * @param {yfiles.layout.OrientationLayouter.Transformer} transformer provides a method for transferring a point to its final position
      * @see {@link yfiles.layout.OrientationLayouter}
      */
      finalizeOrientationChange(orientationLayouter:yfiles.layout.OrientationLayouter,transformer:yfiles.layout.OrientationLayouter.Transformer):void;
      /**
      * A method that is called at the beginning of the {@link yfiles.layout.OrientationLayouter} stage.
      * @param {yfiles.layout.OrientationLayouter} orientationLayouter the instance of the orientation layouter
      * @param {yfiles.layout.OrientationLayouter.Transformer} transformer provides a method for transferring an original point to its temporary position
      * @see {@link yfiles.layout.OrientationLayouter}
      */
      prepareOrientationChange(orientationLayouter:yfiles.layout.OrientationLayouter,transformer:yfiles.layout.OrientationLayouter.Transformer):void;
    }
    var PartitionGrid:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to store the {@link yfiles.layout.PartitionGrid} structure.
      * If the provider contains a partition grid structure
      * this structure will be considered during layout (provided that the layout algorithm supports such constraints).
      */
      PARTITION_GRID_DP_KEY:Object;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to store {@link yfiles.layout.PartitionCellId}
      * instances for nodes of the graph.
      * Each node is placed inside the columns/rows defined by the corresponding partition cell identifier.
      * Instances can be shared among multiple nodes, but don't have to be shared.
      * Note, that multi-cell identifiers (i.e., a identifier that represents multiple columns/rows) are not allowed to overlap each other.
      * @see {@link yfiles.layout.PartitionCellId}
      */
      PARTITION_CELL_DP_KEY:Object;
      /**
      * Constructs an empty partition grid.
      */
      new ():yfiles.layout.PartitionGrid;
      /**
      * Constructs a partition grid with rowCount rows and columnCount columns.
      * @param {number} rowCount the number of rows
      * @param {number} columnCount the number of columns
      */
      WithRowAndColumnCount:{
        new (rowCount:number,columnCount:number):yfiles.layout.PartitionGrid;
      };
      /**
      * Constructs a partition grid with rowCount rows and columnCount columns as well as the given insets and min sizes.
      * @param {number} rowCount the number of rows
      * @param {number} columnCount the number of columns
      * @param {number} rowInsets the top and bottom insets of the rows
      * @param {number} columnInsets the left and right insets of the columns
      * @param {number} minRowSize the minimum row height
      * @param {number} minColumnSize the minimum column width
      */
      WithRowAndColumnCountAndSize:{
        new (rowCount:number,columnCount:number,rowInsets:number,columnInsets:number,minRowSize:number,minColumnSize:number):yfiles.layout.PartitionGrid;
      };
      /**
      * Returns the partition grid associated with the given graph.
      * @param {yfiles.algorithms.Graph} graph the graph
      * @return {yfiles.layout.PartitionGrid} the partition grid of the graph or null if the graph has no associated partition grid
      */
      getPartitionGrid(graph:yfiles.algorithms.Graph):yfiles.layout.PartitionGrid;
      /**
      * Checks whether the nodes of the graph are assigned to at least two different partition rows.
      * @deprecated For internal use only. Might be changed or removed in the future.
      * @param {yfiles.algorithms.Graph} graph the input graph
      * @return {boolean} true, if the nodes of the graph are assigned to at least two different partition rows.
      */
      hasAtLeastTwoNonEmptyRows(graph:yfiles.algorithms.Graph):boolean;
    };
    /**
    * This class represents a row of a {@link yfiles.layout.PartitionGrid}.
    * The results of the calculation of the geometry of the row will be placed
    * into the instances of this class after the layout.
    * @see {@link yfiles.layout.PartitionGrid}
    */
    export interface RowDescriptor extends Object,yfiles.lang.IObjectComparable{
      /**
      * The index of the row within the partition grid.
      */
      index:number;
      /**
      * Compares this object to the given object of the same type.
      * @param {Object} obj The object to compare this to.
      * @return {number} <ul>
      * <li>-1: this is less than <code>obj</code></li>
      * <li>0: this is equal to <code>obj</code></li>
      * <li>1: this is greater than <code>obj</code></li>
      * </ul>
      * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
      */
      compareToObject(o:Object):number;
      /**
      * The minimum row height.
      * The default is <code>0.0d</code>.
      * @throws {yfiles.system.ArgumentException} if minimumHeight is negative
      */
      minimumHeight:number;
      /**
      * The top row insets where no element
      * will lie in the resulting drawing.
      * The default is <code>0.0d</code>.
      * @throws {yfiles.system.ArgumentException} if topInset is negative
      */
      topInset:number;
      /**
      * The bottom row insets where no element
      * will lie in the resulting drawing.
      * The default is <code>0.0d</code>.
      * @throws {yfiles.system.ArgumentException} if bottomInset is negative
      */
      bottomInset:number;
      /**
      * The computed height of the row
      * after the layout has been calculated.
      */
      computedHeight:number;
      /**
      * The original position (smaller y-coordinate) of the row.
      */
      originalPosition:number;
      /**
      * The original height of the row.
      */
      originalHeight:number;
      /**
      * The computed position (smaller y-coordinate) of the row
      * after the layout has been calculated.
      */
      computedPosition:number;
      /**
      * The tightness factor of the row.
      * <b>Getter:</b>The default is <code>0.0d</code>.
      * <b>Setter:</b>The greater the value the
      * more will the row to be forced to be of its minimal possible height.
      * A value of <code>0.0d</code> will disable compression of the row.
      * A value of <code>1.0d</code> will try to force the column to be of
      * its {@link yfiles.layout.RowDescriptor#minimumHeight  minimum height}.
      * @throws {yfiles.system.ArgumentException} if tightness is out of the valid range
      */
      tightness:number;
      /**
      * Specifies whether the index of this row is fixed or whether
      * the algorithm should try to find the best possible position.
      * <b>Getter:</b>The default is <code>true</code>
      * <b>Setter:</b><p>
      * For all rows where this property is set to <code>true</code>, the relative ordering given by the indices
      * is preserved. The remaining rows may be resorted so that the overall edge lengths are minimized.
      * </p>
      * <p>
      * By default, this feature is enabled. </p>
      */
      indexFixed:boolean;
    }
    var RowDescriptor:{
      $class:yfiles.lang.Class;
    };
    export enum InterEdgeRoutingStyle{
      /**
      * Inter-edge routing style specifier. Adopts the edge layout from
      * the core layouter.
      */
      ADOPT,
      /**
      * Inter-edge routing style specifier. Routes the inter-edges in an orthogonal style.
      */
      ORTHOGONAL,
      /**
      * Inter-edge routing style specifier. Routes the inter-edges as a straight line.
      */
      STRAIGHTLINE
    }
    /**
    * Represents an identifier for partition cells of the partition grid.
    * @see {@link yfiles.layout.PartitionGrid}
    */
    export interface PartitionCellId extends Object{
      /**
      * A collection of elements of type Pair.
      * Each pair consists of a column and a row defining a single partition cell.
      * Note: a partition cell id that covers more than one partition cell can only be assigned to group nodes.
      */
      cells:yfiles.algorithms.ICollection;
      /**
      * True if the partition cell id represents a multi-cell, i.e., whether or not it was created with method
      * {@link yfiles.layout.PartitionGrid#createCellSpanIdForDescriptorLists},
      * {@link yfiles.layout.PartitionGrid#createCellSpanIdForDescriptors},
      * {@link yfiles.layout.PartitionGrid#createCellSpanId}, {@link yfiles.layout.PartitionGrid#createColumnSpanId} or
      * {@link yfiles.layout.PartitionGrid#createRowSpanId}.
      */
      isSpanning:boolean;
      /**
      * The first row associated with this partition cell id.
      */
      row:yfiles.layout.RowDescriptor;
      /**
      * The first column associated with this partition cell id.
      */
      column:yfiles.layout.ColumnDescriptor;
      equals(o:Object):boolean;
      hashCode():number;
    }
    export module PartitionCellId{
      /**
      * Represents a single partition cell, i.e., a row-column pair.
      */
      export interface Pair extends Object,yfiles.lang.IObjectComparable{
        /**
        * The RowDescriptor associated with this partition cell.
        */
        row:yfiles.layout.RowDescriptor;
        /**
        * The ColumnDescriptor associated with this partition cell.
        */
        column:yfiles.layout.ColumnDescriptor;
        /**
        * Compares this object to the given object of the same type.
        * @param {Object} obj The object to compare this to.
        * @return {number} <ul>
        * <li>-1: this is less than <code>obj</code></li>
        * <li>0: this is equal to <code>obj</code></li>
        * <li>1: this is greater than <code>obj</code></li>
        * </ul>
        * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
        */
        compareToObject(o:Object):number;
        equals(o:Object):boolean;
        hashCode():number;
      }
    }
    var PartitionCellId:{
      $class:yfiles.lang.Class;
    };
    export enum SwimlanesMode{
      /**
      * Swim lane ordering mode specifier. Specifies that node grouping is ignored during the swim lane ordering
      * optimization.
      * @see {@link yfiles.layout.Swimlanes#arrangeSwimlanesWithOrderingMode}
      */
      IGNORE_GROUPS,
      /**
      * Swim lane ordering mode specifier. Specifies that only node grouping is considered during the swim lane ordering
      * optimization.
      * @see {@link yfiles.layout.Swimlanes#arrangeSwimlanesWithOrderingMode}
      */
      ONLY_GROUPS,
      /**
      * Swim lane ordering mode specifier. Specifies that both node grouping and edge length are considered during the swim
      * lane ordering optimization.
      * @see {@link yfiles.layout.Swimlanes#arrangeSwimlanesWithOrderingMode}
      */
      MIXED
    }
    /**
    * This class represents a column of a {@link yfiles.layout.PartitionGrid}.
    * The results of the calculation of the geometry of the column will be placed
    * into the instances of this class after the layout.
    * @see {@link yfiles.layout.PartitionGrid}
    */
    export interface ColumnDescriptor extends Object,yfiles.lang.IObjectComparable{
      /**
      * The index of the column within the partition grid.
      */
      index:number;
      /**
      * Compares this object to the given object of the same type.
      * @param {Object} obj The object to compare this to.
      * @return {number} <ul>
      * <li>-1: this is less than <code>obj</code></li>
      * <li>0: this is equal to <code>obj</code></li>
      * <li>1: this is greater than <code>obj</code></li>
      * </ul>
      * @see Specified by {@link yfiles.lang.IObjectComparable#compareToObject}.
      */
      compareToObject(o:Object):number;
      /**
      * The minimum column width.
      * The default is <code>0.0d</code>.
      * @throws {yfiles.system.ArgumentException} if minimumWidth is negative
      */
      minimumWidth:number;
      /**
      * The left column insets where no element
      * will lie in the resulting drawing.
      * The default is <code>0.0d</code>.
      * @throws {yfiles.system.ArgumentException} if leftInset is negative
      */
      leftInset:number;
      /**
      * The right column insets where no element
      * will lie in the resulting drawing.
      * The default is <code>0.0d</code>.
      * @throws {yfiles.system.ArgumentException} if rightInset is negative
      */
      rightInset:number;
      /**
      * The computed width of the column
      * after the layout has been calculated.
      */
      computedWidth:number;
      /**
      * The original width of the column.
      */
      originalWidth:number;
      /**
      * The original position (smaller x-coordinate) of the column.
      */
      originalPosition:number;
      /**
      * The computed position (smaller x-coordinate) of the column
      * after the layout has been calculated.
      */
      computedPosition:number;
      /**
      * The tightness factor of the column.
      * <b>Getter:</b>The default is <code>0.0d</code>.
      * <b>Setter:</b>The greater the value the
      * more will the column to be forced to be of its minimal possible width.
      * A value of <code>0.0d</code> will disable compression of the column.
      * A value of <code>1.0d</code> will try to force the column to be of
      * its {@link yfiles.layout.ColumnDescriptor#minimumWidth  minimum width}.
      * @throws {yfiles.system.ArgumentException} if tightness is out of the valid range
      */
      tightness:number;
      /**
      * Specifies whether the index of this column is fixed or whether
      * the algorithm should try to find the best possible position.
      * <b>Getter:</b>The default is <code>true</code>
      * <b>Setter:</b><p>
      * For all columns where this property is set to <code>true</code>, the relative ordering given by the indices
      * is preserved. The remaining columns may be resorted so that the overall edge lengths are minimized.
      * </p>
      * <p>
      * By default, this feature is enabled. </p>
      */
      indexFixed:boolean;
    }
    var ColumnDescriptor:{
      $class:yfiles.lang.Class;
    };
    /**
    * Convenience implementation which allows for custom insets for each group node.
    * Insets are provided through a DataProvider which must be registered with the
    * graph prior to the invocation of the layout algorithm.
    */
    export interface InsetsGroupBoundsCalculator extends Object,yfiles.layout.IGroupBoundsCalculator{
      /**
      * Specifies whether the bounds calculation for group nodes takes labels of the
      * group's content nodes into account.
      * <p>
      * Defaults to <code>false</code>.
      * </p>
      */
      considerNodeLabelsEnabled:boolean;
      /**
      * Specifies whether the bounds calculation for group nodes takes labels of the group's content edges into account.
      * <p>
      * Defaults to <code>false</code>
      * </p>
      */
      considerEdgeLabels:boolean;
      /**
      * Specifies whether the bounds calculation for group nodes takes node halos of the
      * group's content nodes into account.
      * <p>
      * Defaults to <code>true</code>.
      * </p>
      */
      considerNodeHalos:boolean;
      /**
      * This method is called during the layout process.
      * It calculates the bounds for
      * the given groupNode instance that contains the children.
      * @param {yfiles.layout.LayoutGraph} graph the graph instance for which the bounds will be calculated
      * @param {yfiles.algorithms.Node} groupNode the group node whose bounds will be calculated
      * @param {yfiles.algorithms.NodeList} children a list of nodes which reside inside the group node
      * @return {yfiles.algorithms.Rectangle2D} a Rectangle2D instance that describes the bounds of the group node.
      * @see Specified by {@link yfiles.layout.IGroupBoundsCalculator#calculateBounds}.
      */
      calculateBounds(graph:yfiles.layout.LayoutGraph,groupNode:yfiles.algorithms.Node,children:yfiles.algorithms.NodeList):yfiles.algorithms.Rectangle2D;
      /**
      * This method enlarges the given graph bounds by the insets associated with the given group node.
      */
      createEnlargedBounds(graph:yfiles.layout.LayoutGraph,groupNode:yfiles.algorithms.Node,children:yfiles.algorithms.NodeList,bounds:yfiles.algorithms.Rectangle2D):yfiles.algorithms.Rectangle2D;
      /**
      * Calculates and returns the united bounds of the given nodes only,
      * no labels or adjacent edges are considered.
      */
      getNodeBounds(graph:yfiles.layout.LayoutGraph,nodes:yfiles.algorithms.NodeList):yfiles.algorithms.Rectangle2D;
      /**
      * The default insets.
      */
      defaultInsets:yfiles.algorithms.Insets;
      /**
      * The DataProvider key that is used to get the insets for the nodes.
      */
      groupNodeInsetsDpKey:Object;
    }
    var InsetsGroupBoundsCalculator:{
      $class:yfiles.lang.Class;
      /**
      * Constructs an instance that uses insets provided through the
      * data provider registered at the input graph with the public key
      * {@link yfiles.layout.GroupingKeys#GROUP_NODE_INSETS_DP_KEY}.
      */
      new ():yfiles.layout.InsetsGroupBoundsCalculator;
      /**
      * Constructs an instance that uses the specified insets as the default if
      * the data provider contains no insets information for a specific node.
      */
      FromInsets:{
        new (insets:yfiles.algorithms.Insets):yfiles.layout.InsetsGroupBoundsCalculator;
      };
      /**
      * Constructs an instance using the given DataProvider key.
      */
      InsetsGroupBoundsCalculator:{
        new (insetsDataProviderKey:Object):yfiles.layout.InsetsGroupBoundsCalculator;
      };
      /**
      * Constructs an instance using the given DataProvider key and default insets.
      */
      FromInsetsDataProviderKeyAndDefaultInsets:{
        new (insetsDataProviderKey:Object,defaultInsets:yfiles.algorithms.Insets):yfiles.layout.InsetsGroupBoundsCalculator;
      };
    };
    /**
    * A special component layouter that handles hierarchically grouped graphs
    * in a special way.
    * Unlike {@link yfiles.layout.ComponentLayouter} this layout stage allows
    * isolated subgraphs within a group to be laid out as a separate component.
    * The orthogonal group layouter  uses
    * this layout stage as component layouter.
    */
    export interface IsolatedGroupComponentLayouter extends yfiles.layout.ComponentLayouter{
      /**
      * Returns true, iff the coreLayouter returns true for all components
      * of the graph.
      * @see Overrides {@link yfiles.layout.ComponentLayouter#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Determines which nodes will belong to the same graph component.
      * Unlike {@link yfiles.layout.ComponentLayouter} this implementation identifies
      * isolated subgraphs within a group also as separate components.
      */
      findIsolatedGraphComponents(graph:yfiles.layout.LayoutGraph,compNumber:yfiles.algorithms.INodeMap):number;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var IsolatedGroupComponentLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Create a new instance of IsolatedGroupComponentLayouter.
      * @param {yfiles.layout.ILayouter} coreLayouter 
      * the core layouter being invoked for each component
      * of the graph.
      */
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.layout.IsolatedGroupComponentLayouter;
      };
      /**
      * Create a new instance of IsolatedGroupComponentLayouter.
      */
      new ():yfiles.layout.IsolatedGroupComponentLayouter;
    };
    /**
    * This subclass of {@link yfiles.layout.InsetsGroupBoundsCalculator} does not
    * only allow custom insets for each group node, but also makes sure to keep provided minimum
    * sizes registered for each node that are provided through a DataProvider which must be
    * registered with the graph prior to the invocation of the layout algorithm.
    * By default {@link yfiles.layout.GroupingKeys#MINIMUM_NODE_SIZE_DP_KEY} is used as the data provider key, but one can
    * also determine another using the according constructor or method {@link yfiles.layout.MinimumSizeGroupBoundsCalculator#minimumNodeSizeDpKey}.
    */
    export interface MinimumSizeGroupBoundsCalculator extends yfiles.layout.InsetsGroupBoundsCalculator{
      /**
      * This method is called during the layout process.
      * It calculates the bounds for
      * the given groupNode instance that contains the children.
      * @param {yfiles.layout.LayoutGraph} graph the graph instance for which the bounds will be calculated
      * @param {yfiles.algorithms.Node} groupNode the group node whose bounds will be calculated
      * @param {yfiles.algorithms.NodeList} children a list of nodes which reside inside the group node
      * @return {yfiles.algorithms.Rectangle2D} a Rectangle2D instance that describes the bounds of the group node.
      * @see Specified by {@link yfiles.layout.IGroupBoundsCalculator#calculateBounds}.
      */
      calculateBounds(graph:yfiles.layout.LayoutGraph,groupNode:yfiles.algorithms.Node,children:yfiles.algorithms.NodeList):yfiles.algorithms.Rectangle2D;
      /**
      * A value that describes how the node will be resized horizontally if the calculated width
      * of {@link yfiles.layout.InsetsGroupBoundsCalculator} is smaller than
      * the minimal width that is provided for the node.
      * <b>The default value is 0.5</b>, which means the node will grow equally to the left and to the right,
      * while the center stays put.
      */
      xAlignment:number;
      /**
      * A value that describes how the node will be resized vertically if the calculated height
      * of {@link yfiles.layout.InsetsGroupBoundsCalculator} is smaller than
      * the minimal height that is provided for the node.
      * <b>The default value is 0.5</b>, which means the node will grow equally upwards and downwards,
      * while the center stays put.
      */
      yAlignment:number;
      /**
      * The DataProvider key that is used to get the minimum sizes for the nodes.
      */
      minimumNodeSizeDpKey:Object;
      /**
      * The default minimum size for nodes.
      * <p>
      * By default this is a <code>YDimension</code> with length <code>0</code> and
      * width <code>0</code>.
      * </p>
      */
      defaultMinimumNodeSize:yfiles.algorithms.YDimension;
    }
    var MinimumSizeGroupBoundsCalculator:{
      $class:yfiles.lang.Class;
      /**
      * Constructs an instance that uses the minimum size provided through the data provider registered at the input
      * graph with the public key {@link yfiles.layout.GroupingKeys#MINIMUM_NODE_SIZE_DP_KEY}.
      */
      new ():yfiles.layout.MinimumSizeGroupBoundsCalculator;
      /**
      * Constructs an instance using the given DataProvider key.
      * @param {Object} minSizeDataProviderKey 
      * a DataProvider key that is used to get the
      * minimum sizes for the nodes.
      */
      ForKey:{
        new (minSizeDataProviderKey:Object):yfiles.layout.MinimumSizeGroupBoundsCalculator;
      };
    };
    /**
    * Implementations of this interface are responsible for calculating the bounds
    * of a group node during a layout process.
    */
    export interface IGroupBoundsCalculator extends Object{
      /**
      * This method is called during the layout process.
      * It calculates the bounds for
      * the given groupNode instance that contains the children.
      * @param {yfiles.layout.LayoutGraph} graph the graph instance for which the bounds will be calculated
      * @param {yfiles.algorithms.Node} groupNode the group node whose bounds will be calculated
      * @param {yfiles.algorithms.NodeList} children a list of nodes which reside inside the group node
      * @return {yfiles.algorithms.Rectangle2D} a Rectangle2D instance that describes the bounds of the group node.
      * @see Specified by {@link yfiles.layout.IGroupBoundsCalculator#calculateBounds}.
      */
      calculateBounds(graph:yfiles.layout.LayoutGraph,groupNode:yfiles.algorithms.Node,children:yfiles.algorithms.NodeList):yfiles.algorithms.Rectangle2D;
    }
    var IGroupBoundsCalculator:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Instances of this class can be used by algorithms to efficiently query the structure
    * of such type of graphs.
    * The grouping information is provided through DataProviders,
    * whose keys are defined in the GroupingKeys interface.
    */
    export interface GraphGrouping extends Object{
      /**
      * Initializes internal data structures.
      * The state of the graph at the moment
      * of this method invocation will be reflected by this instance.
      */
      init():void;
      /**
      * The LayoutGraph instance this object provides information for.
      * <p>This Grouping instance must have been created with a {@link yfiles.layout.LayoutGraph}</p>
      */
      layoutGraph:yfiles.layout.LayoutGraph;
      /**
      * The Graph instance this object provides information for.
      */
      graph:yfiles.algorithms.Graph;
      /**
      * Factory method for a NodeMap.
      */
      createInfoMap(graph:yfiles.algorithms.Graph):yfiles.algorithms.INodeMap;
      /**
      * Factory destructor method for a NodeMap.
      */
      disposeInfoMap(graph:yfiles.algorithms.Graph,infoMap:yfiles.algorithms.INodeMap):void;
      /**
      * Returns the parent of the given node or <code>null</code> if the node
      * is at the top of the hierarchy.
      */
      getParent(node:yfiles.algorithms.Node):yfiles.algorithms.Node;
      /**
      * A node instance that can be used as a handle to the virtual root
      * of the node hierarchy.
      * This handle can be given to the getChildren() method
      * to obtain the nodes, that are at the top level of the hierarchy. The instance
      * is *not* part of the graph.
      */
      root:yfiles.algorithms.Node;
      /**
      * Returns the children of the given group node as a NodeList.
      */
      getChildren(parent:yfiles.algorithms.Node):yfiles.algorithms.NodeList;
      /**
      * Returns all descendants of the given group node as a NodeList.
      * @param {yfiles.algorithms.Node} parent 
      * A group node.
      * If <code>null</code> is given, the graph's root is used.
      * @return {yfiles.algorithms.NodeList} 
      * A recursively built NodeList containing all descendants of the given group
      * node.
      */
      getDescendants(parent:yfiles.algorithms.Node):yfiles.algorithms.NodeList;
      /**
      * Determines if the given node is a group node.
      * Group nodes *may* have children.
      * Normal nodes never have children.
      */
      isGroupNode(node:yfiles.algorithms.Node):boolean;
      /**
      * Determines if the given node is a group node with children.
      */
      hasChildren(v:yfiles.algorithms.Node):boolean;
      /**
      * Determines if the given Edge is a normal edge, i.e.
      * whether it does not cross
      * any group node boundaries.
      */
      isNormalEdge(e:yfiles.algorithms.Edge):boolean;
      /**
      * Convenience method that returns a list of all Edges crossing the group node
      * boundary of the given group node in such a way, that there target is inside the
      * group node and the source does not lie inside the group node.
      */
      getEdgesGoingIn(groupNode:yfiles.algorithms.Node):yfiles.algorithms.EdgeList;
      /**
      * Convenience method that returns a list of all Edges crossing the group node
      * boundary of the given group node in such a way, that there target is outside the
      * group node and the source does not lie outside the group node.
      */
      getEdgesGoingOut(groupNode:yfiles.algorithms.Node):yfiles.algorithms.EdgeList;
      /**
      * Convenience method that returns a node that can be used to represent
      * <code>node</code> in the group <code>inGroup</code>, that is either the node
      * itself if it is an immediate child of <code>inGroup</code>, or a node that
      * is a child of <code>inGroup</code> and an ancestor of <code>node</code> at the
      * same time or <code>null</code> if neither of the latter applies.
      * @param {yfiles.algorithms.Node} node the node for which a representative will be returned
      * @param {yfiles.algorithms.Node} inGroup the group to which the representative should belong.
      */
      getRepresentative(node:yfiles.algorithms.Node,inGroup:yfiles.algorithms.Node):yfiles.algorithms.Node;
      /**
      * Disposes the data structures held by this instance.
      * Calling this method renders this instance useless.
      */
      dispose():void;
      /**
      * Returns the nearest common ancestor in the hierarchy structure.
      * <p>
      * This method returns the nearest ancestor of <code>n1</code> and
      * <code>n2</code> that contains both <code>n1</code> and <code>n2</code> or
      * it returns {@link yfiles.layout.GraphGrouping#root} if no such node exists.
      * In the special cases of <code>n2</code> being a child of <code>n1</code>
      * (or vice versa) or if <code>n1 == n2</code>, the parent of <code>n1</code>
      * (or <code>n2</code> respectively) is returned.
      * </p>
      * @param {yfiles.algorithms.Node} n1 one of the two nodes whose common ancestor is determined.
      * @param {yfiles.algorithms.Node} n2 one of the two nodes whose common ancestor is determined.
      * @return {yfiles.algorithms.Node} 
      * The nearest common ancestor node, or {@link yfiles.layout.GraphGrouping#root}.
      */
      getNearestCommonAncestor(n1:yfiles.algorithms.Node,n2:yfiles.algorithms.Node):yfiles.algorithms.Node;
    }
    var GraphGrouping:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of Grouping.
      * Grouping instances
      * provide a convenient way for all kind of algorithms to traverse the node
      * grouping hierarchy. The hierarchy is cached during the call to this constructor.
      * It is build using the information bound to the graph using the DataProviders
      * that are registered with the graph instance.
      * Grouping instances hold a state that with the graph instance that should be
      * {@link yfiles.layout.GraphGrouping#dispose  disposed} once the grouping instance is not needed anymore.
      */
      new (graph:yfiles.algorithms.Graph):yfiles.layout.GraphGrouping;
      /**
      * A graph is considered to be grouped if the three low-level
      * grouping data providers {@link yfiles.layout.GroupingKeys#GROUP_DP_KEY},
      * {@link yfiles.layout.GroupingKeys#NODE_ID_DP_KEY} and {@link yfiles.layout.GroupingKeys#PARENT_NODE_ID_DP_KEY}
      * are registered.
      * An instance of this class requires its graph to be grouped.
      */
      isGrouped(graph:yfiles.algorithms.Graph):boolean;
      /**
      * A graph is considered to be flat if it is either not grouped
      * or there is no group node that contains child nodes present in the graph.
      * This method determines whether a graph is flat
      */
      isFlat(graph:yfiles.algorithms.Graph):boolean;
    };
    /**
    * This interface defines data provider keys for those layout algorithms that can
    * handle hierarchically grouped graphs.
    * These keys define the parent-child relationship of nodes within the
    * hierarchy and tag nodes that act as group nodes.
    */
    export interface GroupingKeys extends Object{
    }
    var GroupingKeys:{
      $class:yfiles.lang.Class;
      /**
      * This key is used to register a DataProvider instance with a graph, that 
      * associates each node instance with a unique (based on hashCode() and equals())
      * id.
      */
      NODE_ID_DP_KEY:Object;
      /**
      * This key is used to actually describe the hierarchy of the nodes in the graph.
      * For each node that is not at the top level of the hierarchy, the id of the containing
      * node can be obtained through the data provider associated with this key.
      */
      PARENT_NODE_ID_DP_KEY:Object;
      /**
      * This key is used to distinguish normal nodes from group nodes.
      * For every node
      * the DataProvider should return true iff the node is a group node (and therefore might
      * have children.
      */
      GROUP_DP_KEY:Object;
      /**
      * This key is used to provide insets for group nodes.
      * Insets are used to provide 
      * space around the contents of a group node. This space can then be used for 
      * labels and other visual decorations.
      * For each group node, a {@link yfiles.algorithms.Insets} (or a {@link yfiles.algorithms.Insets})
      * object can be provided using a data provider bound to the graph using this key.
      */
      GROUP_NODE_INSETS_DP_KEY:Object;
      /**
      * This key is used to provide minimum sizes for nodes.
      * For each node, a {@link yfiles.algorithms.YDimension} object can be provided using a
      * data provider that is bound to the graph with this key.
      */
      MINIMUM_NODE_SIZE_DP_KEY:Object;
    };
    /**
    * A layout stage for hierarchically grouped graphs.
    * Activating this stage
    * removes all group nodes and adjacent edges from the graph before
    * passing it on to its core layouter.
    * After the core layouter has arranged the graph, the hidden elements
    * will be reinserted in the graph again.
    */
    export interface GroupNodeHider extends yfiles.layout.AbstractLayoutStage{
      /**
      * Specifies whether or not group nodes without children will be hidden.
      * Defaults to <code>true</code>.
      */
      hidingEmptyGroupNodes:boolean;
      /**
      * Hides the group nodes and adjacent edges from the graph.
      * Furthermore this method removes all grouping related DataProviders from the input graph.
      */
      hideGroupNodes(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Unhides group nodes and adjacent edges from the graph that were previously hidden using method
      * {@link yfiles.layout.GroupNodeHider#hideGroupNodes}.
      * Furthermore this method restores all
      * previously removed grouping related DataProviders on the input graph.
      */
      unhideGroupNodes(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The currently installed GroupBoundsCalculator instance.
      */
      groupBoundsCalculator:yfiles.layout.IGroupBoundsCalculator;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var GroupNodeHider:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of GroupNodeHider.
      */
      new ():yfiles.layout.GroupNodeHider;
      /**
      * Creates a new instance of GroupNodeHider.
      * @param {yfiles.layout.ILayouter} coreLayouter the core layouter used by this layout stage.
      */
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.layout.GroupNodeHider;
      };
    };
    export enum SliderRatio{
      /**
      * Symbolic ratio specifier. 
      * Valid only in conjunction with slider mode {@link yfiles.layout.SliderMode#CENTER}.
      */
      CENTER,
      /**
      * Symbolic ratio specifier. 
      * Valid only in conjunction with slider mode {@link yfiles.layout.SliderMode#SIDE}.
      * Determines a label to be right of or below the edge's path.
      */
      TAIL,
      /**
      * Symbolic ratio specifier. 
      * Valid only in conjunction with slider mode {@link yfiles.layout.SliderMode#SIDE}.
      * Determines a label to be left of or above the edge's path.
      */
      HEAD,
      /**
      * Symbolic ratio specifier. 
      * Valid only in conjunction with slider mode {@link yfiles.layout.SliderMode#SIDE}.
      * Determines a label to be left of the edge's path.
      */
      LEFT,
      /**
      * Symbolic ratio specifier. 
      * Valid only in conjunction with slider mode {@link yfiles.layout.SliderMode#SIDE}.
      * Determines a label to be right of the edge's path.
      */
      RIGHT
    }
    export enum PortDirection{
      /**
      * Constant indicating a port in the north of a node.
      */
      NORTH,
      /**
      * Constant indicating a port in the east of a node.
      */
      EAST,
      /**
      * Constant indicating a port in the west of a node.
      */
      WEST,
      /**
      * Constant indicating a port in the south of a node.
      */
      SOUTH,
      /**
      * Constant indicating a port lying in the direction of the main flow of the edge or overall layout.
      * The exact direction is domain specific.
      */
      WITH_THE_FLOW,
      /**
      * Constant indicating a port lying in the opposite direction of the main flow of the edge or overall layout.
      * The exact direction is domain specific.
      */
      AGAINST_THE_FLOW,
      /**
      * Constant indicating a port lying to the left of the direction of the main flow
      * of the edge or overall layout.
      * The exact direction is domain specific.
      */
      LEFT_IN_FLOW,
      /**
      * Constant indicating a port lying in the right of the direction of the main flow
      * of the edge or overall layout.
      * The exact direction is domain specific.
      */
      RIGHT_IN_FLOW,
      /**
      * A bitwise combination of all possible direction constants.
      */
      ANY
    }
    export enum PortSide{
      /**
      * Weak constraint specifier. Indicates that any side of the
      * node will do for the port direction.
      */
      ANY,
      /**
      * Weak constraint specifier. Indicates that a port has to connect
      * at the north side (i.e. top side) of a node.
      */
      NORTH,
      /**
      * Weak constraint specifier. Indicates that a port has to connect
      * at the south side (i.e. bottom side) of a node.
      */
      SOUTH,
      /**
      * Weak constraint specifier. Indicates that a port has to connect
      * at the east side (i.e. right side) of a node.
      */
      EAST,
      /**
      * Weak constraint specifier. Indicates that a port has to connect
      * at the west side (i.e. left side) of a node.
      */
      WEST
    }
    export enum LabelSideReference{
      /**
      * Side placement specifier for edge labels. Expresses that the preferred side
      * (as specified by {@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE} and
      * {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE}) is interpreted relative
      * to the edge flow.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#sideReference}
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#sideReference}
      */
      RELATIVE_TO_EDGE_FLOW,
      /**
      * Side placement specifier for edge labels. Expresses that the preferred side
      * (as specified by {@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE} and
      * {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE}) is interpreted absolute.
      * On horizontal segments labels with preferred side
      * {@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE} are placed above the
      * segment.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#sideReference}
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#sideReference}
      */
      ABSOLUTE_WITH_LEFT_IN_NORTH,
      /**
      * Side placement specifier for edge labels. Expresses that the preferred side
      * (as specified by {@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE} and
      * {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE}) is interpreted absolute.
      * On horizontal segments labels with preferred side
      * {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE} are placed above the
      * segment.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#sideReference}
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#sideReference}
      */
      ABSOLUTE_WITH_RIGHT_IN_NORTH
    }
    export enum MirrorMask{
      /**
      * Constant that can be used to prevent any mirroring of layout orientations.
      */
      NONE,
      /**
      * Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
      * their corresponding axis. Adding this constant to the mask will result in mirror the y-axis of the graph for layout
      * orientation LayoutOrientation.TOP_TO_BOTTOM.
      */
      TOP_TO_BOTTOM,
      /**
      * Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
      * their corresponding axis. Adding this constant to the mask will result in mirror the x-axis of the graph for layout
      * orientation LayoutOrientation.RIGHT_TO_LEFT.
      */
      RIGHT_TO_LEFT,
      /**
      * Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
      * their corresponding axis. Adding this constant to the mask will result in mirror the y-axis of the graph for layout
      * orientation LayoutOrientation.BOTTOM_TO_TOP.
      */
      BOTTOM_TO_TOP,
      /**
      * Constant that can be used to create the mirror mask, that defines which layout orientations shall be mirrored at
      * their corresponding axis. Adding this constant to the mask will result in mirror the x-axis of the graph for layout
      * orientation LayoutOrientation.LEFT_TO_RIGHT.
      */
      LEFT_TO_RIGHT
    }
    export enum RowAlignment{
      /**
      * Constant which can be used for
      * {@link yfiles.layout.LayoutTool#arrangeRectangleRowsWithAlignment}.
      * Rectangles in one row will be aligned with the leading edge.
      */
      LEADING,
      /**
      * Constant which can be used for
      * {@link yfiles.layout.LayoutTool#arrangeRectangleRowsWithAlignment}.
      * Rectangles in one row will be aligned to the trailing edge.
      */
      TRAILING,
      /**
      * Constant which can be used for
      * {@link yfiles.layout.LayoutTool#arrangeRectangleRowsWithAlignment}.
      * Rectangles in one row will be justified in the row.
      */
      JUSTIFIED,
      /**
      * Constant which can be used for
      * {@link yfiles.layout.LayoutTool#arrangeRectangleRowsWithAlignment}.
      * Rectangles in one row will be centered on the row.
      */
      CENTER
    }
    export enum EdgeFlow{
      /**
      * Edge flow specifier used by method {@link yfiles.layout.LayoutTool#determineEdgeFlowDirection}.
      * This value specifies that the flow direction of most edges is up.
      * @see {@link yfiles.layout.LayoutTool#determineEdgeFlowDirection}
      */
      UP,
      /**
      * Edge flow specifier used by method {@link yfiles.layout.LayoutTool#determineEdgeFlowDirection}.
      * This value specifies that the flow direction of most edges is down.
      * @see {@link yfiles.layout.LayoutTool#determineEdgeFlowDirection}
      */
      DOWN,
      /**
      * Edge flow specifier used by method {@link yfiles.layout.LayoutTool#determineEdgeFlowDirection}.
      * This value specifies that the flow direction of most edges is left.
      * @see {@link yfiles.layout.LayoutTool#determineEdgeFlowDirection}
      */
      LEFT,
      /**
      * Edge flow specifier used by method {@link yfiles.layout.LayoutTool#determineEdgeFlowDirection}.
      * This value specifies that the flow direction of most edges is right.
      * @see {@link yfiles.layout.LayoutTool#determineEdgeFlowDirection}
      */
      RIGHT,
      /**
      * Edge flow specifier used by method {@link yfiles.layout.LayoutTool#determineEdgeFlowDirection}.
      * This value specifies that there is no main flow direction.
      * @see {@link yfiles.layout.LayoutTool#determineEdgeFlowDirection}
      */
      NONE
    }
    export enum NodeAlignment{
      /**
      * Node alignment policy that results in top aligned nodes for
      * vertical alignment and left aligned nodes for horizontal alignments.
      * @see {@link yfiles.layout.LayoutTool#alignNodeLayouts}
      */
      LEADING,
      /**
      * Node alignment policy that results in center aligned nodes.
      * @see {@link yfiles.layout.LayoutTool#alignNodeLayouts}
      */
      CENTERED,
      /**
      * Node alignment policy that results in bottom aligned nodes for
      * vertical alignment and right aligned nodes for horizontal alignments.
      * @see {@link yfiles.layout.LayoutTool#alignNodeLayouts}
      */
      TRAILING,
      /**
      * Node alignment policy that results in vertically or horizontally
      * distributed nodes. In this context, <em>distributed</em> means that the
      * vertical (or horizontal) extensions of nodes do not overlap independent
      * of their horizontal (or vertical) position.
      * @see {@link yfiles.layout.LayoutTool#alignNodeLayouts}
      */
      DISTRIBUTED
    }
    export enum RotatedSliderMode{
      /**
      * Symbolic slider mode specifier.
      * Chooses continuous label positions directly on the edge path.
      */
      CENTER,
      /**
      * Symbolic slider mode specifier.
      * Chooses continuous label positions along both sides of the edge path.
      */
      SIDE,
      /**
      * Symbolic slider mode specifier.
      * Chooses continuous label positions along a side of the edge path.
      */
      SINGLE_SIDE
    }
    export enum SelfloopStyle{
      /**
      * Edge layout style modifier.
      * Using this style, selfloops are routed in an orthogonal fashion, i.e., the route consists of an alternating
      * sequence of horizontal and vertical line segments.
      * This style can be set with method {@link yfiles.layout.SelfLoopLayouter#layoutStyle}.
      * @see {@link yfiles.layout.SelfLoopLayouter#layoutStyle}
      */
      ORTHOGONAL,
      /**
      * Edge layout style modifier.
      * Using this style, the routes of selfloops are rounded.
      * This style can be set with method {@link yfiles.layout.SelfLoopLayouter#layoutStyle}.
      * @see {@link yfiles.layout.SelfLoopLayouter#layoutStyle}
      */
      ROUNDED
    }
    export enum SliderMode{
      /**
      * Symbolic slider mode specifier.
      * Chooses continuous label positions directly on the edge path.
      */
      CENTER,
      /**
      * Symbolic slider mode specifier.
      * Chooses continuous label positions along the sides of the edge path.
      */
      SIDE
    }
    export enum RotatedDiscreteEdgeLabelPosition{
      /**
      * Symbolic position specifier.
      * Places the label near the source node.
      * The label's position is to the left of or above the edge's path.
      * @see {@link yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel#positionRelativeToSegment}
      */
      SHEAD,
      /**
      * Symbolic position specifier.
      * Places the label near the middle of the edge's path.
      * The label's position is to the left of or above the edge's path.
      * @see {@link yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel#positionRelativeToSegment}
      */
      HEAD,
      /**
      * Symbolic position specifier.
      * Places the label near the target node.
      * The label's position is to the left of or above the edge's path.
      * Places the label near the target node on the "head" side of the edge.
      * @see {@link yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel#positionRelativeToSegment}
      */
      THEAD,
      /**
      * Symbolic position specifier.
      * Places the label near the source node.
      * The label's position is to the right of or below the edge's path.
      * @see {@link yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel#positionRelativeToSegment}
      */
      STAIL,
      /**
      * Symbolic position specifier.
      * Places the label near the middle of the edge's path.
      * The label's position is to the right of or below the edge's path.
      * @see {@link yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel#positionRelativeToSegment}
      */
      TAIL,
      /**
      * Symbolic position specifier.
      * Places the label near the target node.
      * The label's position is to the right of or below the edge's path.
      * @see {@link yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel#positionRelativeToSegment}
      */
      TTAIL,
      /**
      * Symbolic position specifier.
      * Places the label near the source node directly on the edge path.
      */
      SCENTER,
      /**
      * Symbolic position specifier.
      * Places the label near the middle of an edge directly on its path.
      */
      CENTER,
      /**
      * Symbolic position specifier.
      * Places the label near the target node directly on the edge path.
      */
      TCENTER,
      /**
      * Position mask that constrains allowed positions to the two near the edge's
      * end points.
      * Namely, these are {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#HEAD} and {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#TAIL}.
      * @see {@link yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel#positionRelativeToSegment}
      */
      TWO_POS,
      /**
      * Position mask that constrains allowed positions to {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#CENTER}.
      */
      CENTERED,
      /**
      * Position mask that constrains allowed positions to a set of six positions on
      * the "head" and "tail" sides of an edge.
      * Namely, these are {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#SHEAD}, {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#HEAD}, {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#THEAD}, {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#STAIL},
      * {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#TAIL}, and {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#TTAIL}.
      * @see {@link yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel#positionRelativeToSegment}
      */
      SIX_POS,
      /**
      * Position mask that constrains allowed positions to a set of three positions
      * directly on the edge's path.
      * Namely, these are {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#SCENTER}, {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#CENTER}, and {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#TCENTER}.
      */
      THREE_CENTER
    }
    export enum LabelAngleReference{
      /**
      * Angle interpretation specifier for edge labels. Expresses that the angle should be interpreted absolute and
      * not relative to the edge slope.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleReference}
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleReference}
      */
      ABSOLUTE,
      /**
      * Angle interpretation specifier for edge labels. Expresses that the angle should be interpreted relative to
      * the edge slope.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleReference}
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleReference}
      */
      RELATIVE_TO_EDGE_FLOW
    }
    export enum LabelAngleOnRightSideRotation{
      /**
      * Angle interpretation specifier for edge labels whose descriptor {@link yfiles.layout.PreferredPlacementDescriptor#isRightOfEdge}. Expresses that the angle
      * should be interpreted as clockwise and therefore as co-rotating with the angle of labels that are
      * left of or centered on edge.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleRotationOnRightSide}
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleRotationOnRightSide}
      */
      CLOCKWISE,
      /**
      * Angle interpretation specifier for edge labels whose descriptor {@link yfiles.layout.PreferredPlacementDescriptor#isRightOfEdge}. Expresses that the angle
      * should be interpreted as counter-clockwise and therefore as counter-rotating with the angle of
      * labels that are left of or centered on edge.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleRotationOnRightSide}
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleRotationOnRightSide}
      */
      COUNTER_CLOCKWISE
    }
    export enum LabelAngleOnRightSideOffset{
      /**
      * Angle offset specifier for edge labels whose descriptor {@link yfiles.layout.PreferredPlacementDescriptor#isRightOfEdge}. Expresses that for labels
      * right of edge no additional offset should be added to the angle offset.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleOffsetOnRightSide}
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleOffsetOnRightSide}
      */
      NONE,
      /**
      * Angle offset specifier for edge labels whose descriptor {@link yfiles.layout.PreferredPlacementDescriptor#isRightOfEdge}. Expresses that for labels
      * right of edge an additional offset of 180 degree should be added to the angle offset so that point symmetric label
      * placements left and right of the edge can be attained.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleOffsetOnRightSide}
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#angleOffsetOnRightSide}
      */
      SEMI
    }
    /**
    * A layout stage that improves the placement of edge labels.
    * This layout stage
    * expects that its core layouter calculates initial edge label layout data bound to the
    * data provider key {@link yfiles.layout.LabelLayoutKeys#EDGE_LABEL_LAYOUT_DP_KEY}. Next, this stage tries to
    * improve the position of the labels with respect to the preferred placement specifier of the
    * labels.
    * Most commonly, this layout stage is used in conjunction with the integrated edge
    * labeling functionality of class {@link yfiles.hierarchic.HierarchicLayouter}.
    */
    export interface LabelLayoutDataRefinement extends yfiles.layout.AbstractLayoutStage{
      /**
      * The internal labeling algorithm used to improve the
      * label positions.
      */
      internalLabelingAlgorithm:yfiles.labeling.AbstractLabelingAlgorithm;
      /**
      * Returns <code>true</code>.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Assigns a new graph layout to the given layout graph.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var LabelLayoutDataRefinement:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of LabelLayoutDataImprovement.
      */
      new ():yfiles.layout.LabelLayoutDataRefinement;
    };
    /**
    * A composite layout stage that allows to express a layout stage
    * as a chain of more basic layout stages.
    */
    export interface CompositeLayoutStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Prepends a stage to this composite layout stage.
      * Stages added with this method
      * will be invoked before any other stages will be invoked.
      */
      prependStage(stage:yfiles.layout.ILayoutStage):void;
      /**
      * The chain of layout stages that make up this composite layout stage.
      */
      layoutStages:yfiles.algorithms.IList;
      /**
      * Appends a stage to the layout pipeline.
      * Stages added with this method will be
      * invoked just before the core layouter of the composite layout stage will be invoked.
      */
      appendStage(stage:yfiles.layout.ILayoutStage):void;
      /**
      * Returns <code>true</code>.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Assigns a new graph layout to the given layout graph.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var CompositeLayoutStage:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of CompositeLayoutStage.
      */
      new ():yfiles.layout.CompositeLayoutStage;
      /**
      * Creates a new instance of CompositeLayoutStage.
      */
      FromOuterAndInnerStage:{
        new (outerStage:yfiles.layout.ILayoutStage,innerStage:yfiles.layout.ILayoutStage):yfiles.layout.CompositeLayoutStage;
      };
    };
    /**
    * This layout stage replaces bends with dummy nodes, calls the core layout
    * algorithm and recreates the bends.
    * Note that not all data provider values
    * bound to the edges will be automatically adopted be the replacement edges.
    * The adopted values must be provided by data providers registered with one of
    * the following known keys:
    * {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY},
    * {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY},
    * {@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY},
    * {@link yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY}.
    */
    export interface BendConverter extends Object,yfiles.layout.ILayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Prepares the graph before calling the core layouter.
      */
      prepare(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Undoes the graph changes performed by {@link yfiles.layout.BendConverter#prepare} after the
      * core layouter has finished.
      */
      unprepare(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The core layouter.
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
      /**
      * Specifies whether or not the edge group values of the original edge
      * should be adopted by its replacement edges.
      * The group node values
      * are looked up in DataProviders registered with the keys
      * {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY} and
      * {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}.
      */
      adoptEdgeGroups:boolean;
      /**
      * Specifies whether or not the port constraint values of the original edge
      * should be adopted by its replacement edges.
      * The group node values
      * are looked up in DataProviders registered with the keys
      * {@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY} and
      * {@link yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY}.
      */
      adoptPortConstraints:boolean;
      /**
      * Specifies whether or not the selection state of the original edge
      * should be adopted by its replacement edges.
      * The selection state
      * is looked up in DataProviders registered with the key
      * returned by {@link yfiles.layout.BendConverter#selectedEdgesDpKey}.
      * @see {@link yfiles.layout.BendConverter#selectedEdgesDpKey}
      * @see {@link yfiles.layout.BendConverter#selectedEdgesDpKey}
      */
      adoptSelection:boolean;
      /**
      * Callback method that will be invoked after new elements for the given edge
      * have been added to the given graph.
      * At this point the original edge is still
      * in the graph./
      */
      addedPathForEdge(graph:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge,dummyNodes:yfiles.algorithms.NodeList):void;
      /**
      * The <code>DataProvider</code> key to identify edges as
      * <em>selected</em>.
      * <p>
      * By default, {@link yfiles.layout.LayouterKeys#SELECTED_EDGES_DP_KEY} is used.
      * </p>
      * @see {@link yfiles.layout.BendConverter#adoptSelection}
      * @see {@link yfiles.layout.BendConverter#adoptSelection}
      * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
      * @see {@link yfiles.layout.BendConverter#adoptSelection}
      * @see {@link yfiles.layout.BendConverter#adoptSelection}
      */
      selectedEdgesDpKey:Object;
    }
    var BendConverter:{
      $class:yfiles.lang.Class;
      /**
      * DataProvider key used to specify the set of edges for which
      * this stage will replace bends by nodes.
      * If this
      * data provider key is being used, then it
      * must return for each edge in the input graph a boolean value indicating whether
      * or not it should be handled by this layouter.
      * If there is no data provider registered with this key, all edges will be handled.
      */
      SCOPE_DP_KEY:Object;
      /**
      * Creates a new instance of BendConverter.
      */
      new ():yfiles.layout.BendConverter;
      /**
      * Creates a new instance of BendConverter using the given size as
      * the width and height for the dummy nodes.
      */
      WithSize:{
        new (size:number):yfiles.layout.BendConverter;
      };
    };
    /**
    * This class represents a candidate for an edge's ports.
    * It may be a fixed port, where the exact port coordinates are given or a
    * free variant where the coordinates may be chosen arbitrarily. Additionally valid
    * in- respectively outgoing directions may be specified for edges connecting to
    * that PortCandidate's Port and a cost penalty may be specified that indicates the
    * cost associated with the usage of the port.
    * @see {@link yfiles.layout.PortCandidateSet}
    */
    export interface PortCandidate extends Object{
      /**
      * Determines whether this instance lies in the given direction.
      * @param {yfiles.layout.PortDirection} directionMask the mask of directions as defined by the constants in this class.
      * @return {boolean} whether this instance specifies on of the given directions
      */
      isInDirection(directionMask:yfiles.layout.PortDirection):boolean;
      /**
      * The direction mask for this instance.
      * @see {@link yfiles.layout.PortCandidate#getDirectionForLayoutOrientation}
      */
      direction:yfiles.layout.PortDirection;
      /**
      * Specifies whether this instance describes a fixed or
      * {@link yfiles.layout.PortConstraint#strong  strong} port.
      */
      fixed:boolean;
      /**
      * The x offset of the port with respect to the corresponding node's center.
      * @see {@link yfiles.layout.PortCandidate#fixed}
      * @see {@link yfiles.layout.PortCandidate#getXOffsetForLayoutOrientation}
      */
      xOffset:number;
      /**
      * The y offset of the port with respect to the corresponding node's center.
      * @see {@link yfiles.layout.PortCandidate#fixed}
      * @see {@link yfiles.layout.PortCandidate#getXOffsetForLayoutOrientation}
      */
      yOffset:number;
      hashCode():number;
      /**
      * A utility method for converting this instance to a {@link yfiles.layout.PortConstraint}.
      * @return {yfiles.layout.PortConstraint} a PortConstraint that matches this PortCandidate
      * @see {@link yfiles.layout.PortCandidate#toPortConstraintForLayoutOrientation}
      */
      toPortConstraint():yfiles.layout.PortConstraint;
      /**
      * A utility method for converting this instance to a {@link yfiles.layout.PortConstraint}
      * interpreted for the given {@link yfiles.layout.OrientationLayouter#orientation  layout orientation}.
      * @return {yfiles.layout.PortConstraint} a PortConstraint that matches this PortCandidate
      * @see {@link yfiles.layout.PortCandidate#toPortConstraint}
      */
      toPortConstraintForLayoutOrientation(layoutOrientation:yfiles.layout.LayoutOrientation):yfiles.layout.PortConstraint;
      /**
      * Tests for equality based on the internal attributes.
      */
      equals(other:Object):boolean;
      /**
      * The cost associated with the usage of this PortCandidate.
      */
      cost:number;
      /**
      * Returns the direction constant with respect to the given {@link yfiles.layout.OrientationLayouter#orientation  layout orientation}.
      * @param {yfiles.layout.LayoutOrientation} layoutOrientation the orientation for which the direction should be interpreted.
      * @return {yfiles.layout.PortDirection} 
      * the {@link yfiles.layout.PortCandidate#direction} with respect to the orientation.
      * @see {@link yfiles.layout.PortCandidate#direction}
      */
      getDirectionForLayoutOrientation(layoutOrientation:yfiles.layout.LayoutOrientation):yfiles.layout.PortDirection;
      /**
      * Yields the X-offset with respect for the given {@link yfiles.layout.OrientationLayouter#orientation  layout orientation}
      * and {@link yfiles.layout.OrientationLayouter#mirrorMask  mirror mask}.
      * @param {yfiles.layout.LayoutOrientation} layoutOrientation The orientation for which to interpret the x offset.
      * @param {yfiles.layout.MirrorMask} mirrorMask The mirror mask for which to interpret the x offset.
      * @return {number} The x offset.
      * @see {@link yfiles.layout.PortCandidate#xOffset}
      * @see {@link yfiles.layout.PortCandidate#getXOffsetForLayoutOrientation}
      */
      getXOffsetForLayoutOrientationWithMask(layoutOrientation:yfiles.layout.LayoutOrientation,mirrorMask:yfiles.layout.MirrorMask):number;
      /**
      * Yields the Y-offset with respect for the given {@link yfiles.layout.OrientationLayouter#orientation  layout orientation}
      * and {@link yfiles.layout.OrientationLayouter#mirrorMask  mirror mask}.
      * @param {yfiles.layout.LayoutOrientation} layoutOrientation The orientation for which to interpret the y offset.
      * @param {yfiles.layout.MirrorMask} mirrorMask The mirror mask for which to interpret the y offset.
      * @return {number} The y offset.
      * @see {@link yfiles.layout.PortCandidate#yOffset}
      * @see {@link yfiles.layout.PortCandidate#getYOffsetForLayoutOrientation}
      */
      getYOffsetForLayoutOrientationWithMask(layoutOrientation:yfiles.layout.LayoutOrientation,mirrorMask:yfiles.layout.MirrorMask):number;
      /**
      * Yields the X-offset with respect for the given {@link yfiles.layout.OrientationLayouter#orientation  layout orientation}.
      * @param {yfiles.layout.LayoutOrientation} layoutOrientation The orientation for which to interpret the x offset.
      * @return {number} The x offset.
      * @see {@link yfiles.layout.PortCandidate#xOffset}
      */
      getXOffsetForLayoutOrientation(layoutOrientation:yfiles.layout.LayoutOrientation):number;
      /**
      * Yields the Y-offset with respect for the given {@link yfiles.layout.OrientationLayouter#orientation  layout orientation}.
      * @param {yfiles.layout.LayoutOrientation} layoutOrientation The orientation for which to interpret the x offset.
      * @return {number} The y offset.
      * @see {@link yfiles.layout.PortCandidate#yOffset}
      */
      getYOffsetForLayoutOrientation(layoutOrientation:yfiles.layout.LayoutOrientation):number;
      /**
      * Returns a human-readable string representation of this PortCandidate.
      */
      toString():string;
    }
    var PortCandidate:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key that holds a {@link yfiles.algorithms.ICollection} of {@link yfiles.layout.PortCandidate}s for the
      * source port of each edge.
      */
      SOURCE_PC_LIST_DP_KEY:Object;
      /**
      * {@link yfiles.algorithms.IDataProvider} key that holds a {@link yfiles.algorithms.ICollection} of {@link yfiles.layout.PortCandidate}s for the
      * target port of each edge.
      */
      TARGET_PC_LIST_DP_KEY:Object;
      /**
      * Creates a new instance of PortCandidate using the given values.
      * Clients use the factory methods instead.
      * @see {@link yfiles.layout.PortCandidate#createCandidateFixedWithCost}
      */
      FromOffsetWithCost:{
        new (xOffset:number,yOffset:number,fixed:boolean,directionMask:yfiles.layout.PortDirection,cost:number):yfiles.layout.PortCandidate;
      };
      /**
      * Creates a new instance of PortCandidate using the given values.
      * Clients use the factory methods instead.
      * @see {@link yfiles.layout.PortCandidate#createCandidateFixed}
      */
      FromOffsetWithDirection:{
        new (xOffset:number,yOffset:number,directionMask:yfiles.layout.PortDirection):yfiles.layout.PortCandidate;
      };
      /**
      * Creates a new instance of PortCandidate using the given direction.
      * Clients use the factory methods instead.
      * @see {@link yfiles.layout.PortCandidate#createCandidate}
      */
      new (directionMask:yfiles.layout.PortDirection):yfiles.layout.PortCandidate;
      /**
      * Creates a new instance of PortCandidate using the given values.
      * Clients use the factory methods instead.
      * @see {@link yfiles.layout.PortCandidate#createCandidateFixedWithCost}
      */
      FromDirectionWithCost:{
        new (directionMask:yfiles.layout.PortDirection,cost:number):yfiles.layout.PortCandidate;
      };
      /**
      * Factory method that returns an instance describing a non-fixed port with 0 cost penalty for the given
      * direction.
      * @param {yfiles.layout.PortDirection} directionMask a bitwise combination of the constants in this class.
      */
      createCandidate(directionMask:yfiles.layout.PortDirection):yfiles.layout.PortCandidate;
      /**
      * Factory method that returns an instance describing a non-fixed port with the given
      * cost penalty for the given
      * direction.
      * @param {yfiles.layout.PortDirection} directionMask a bitwise combination of the constants in this class.
      * @param {number} cost the cost to associate with the usage of this port
      */
      createCandidateWithCost(directionMask:yfiles.layout.PortDirection,cost:number):yfiles.layout.PortCandidate;
      /**
      * Factory method that returns an instance describing a fixed port with zero
      * cost penalty for the given direction at the given offsets.
      * @param {yfiles.layout.PortDirection} directionMask a bitwise combination of the constants in this class.
      * @param {number} xOffset the x offset
      * @param {number} yOffset the y offset
      */
      createCandidateFixed(xOffset:number,yOffset:number,directionMask:yfiles.layout.PortDirection):yfiles.layout.PortCandidate;
      /**
      * Factory method that returns an instance describing a fixed port with the given
      * cost penalty for the given
      * direction at the given offset.
      * @param {yfiles.layout.PortDirection} directionMask a bitwise combination of the constants in this class.
      * @param {number} cost the cost to associate with the usage of this port
      * @param {number} xOffset the x offset
      * @param {number} yOffset the y offset
      */
      createCandidateFixedWithCost(xOffset:number,yOffset:number,directionMask:yfiles.layout.PortDirection,cost:number):yfiles.layout.PortCandidate;
      /**
      * Factory method that returns an instance describing a non-fixed port with zero
      * cost penalty for the direction specified by the given {@link yfiles.layout.PortConstraint}.
      * @param {yfiles.layout.PortConstraint} fromPortConstraint the port constraint to obtain the direction from
      */
      createCandidateFromConstraint(fromPortConstraint:yfiles.layout.PortConstraint):yfiles.layout.PortCandidate;
    };
    /**
    * This class describes a set of possible {@link yfiles.layout.PortCandidate}s and their cardinality for a node-like entity.
    */
    export interface PortCandidateSet extends Object{
      /**
      * Adds another PortCandidate with capacity 1 to the set of PortCandidates.
      * @param {yfiles.layout.PortCandidate} p the candidate to add.
      */
      add(p:yfiles.layout.PortCandidate):void;
      /**
      * Adds another PortCandidate with the given capacity to the set of candidates.
      * @param {yfiles.layout.PortCandidate} p the candidate to add
      * @param {number} connections the maximum number of connections allowed to the candidate
      */
      addWithCapacity(p:yfiles.layout.PortCandidate,connections:number):void;
      /**
      * The maximum number of connections this set allows or{@link Number#yfiles.system.Math#Int32MaxValue} if
      * the number is unbound.
      */
      connectionCount:number;
      /**
      * Removes the entry from the internal list of PortCandidate entries.
      * @param {yfiles.layout.PortCandidateSet.IEntry} entry the entry to remove from this set of candidates.
      */
      remove(entry:yfiles.layout.PortCandidateSet.IEntry):void;
      /**
      * An Iterator over the list of{@link yfiles.layout.PortCandidateSet.IEntry  entries}.
      */
      entries:yfiles.algorithms.IIterator;
      /**
      * Creates a CandidateMatcher instance that can be used to query {@link yfiles.layout.PortCandidateSet.IEntry  entries} from.
      * @return {yfiles.layout.PortCandidateSet.ICandidateMatcher} a fresh matching instance that reflects the current state of this set of candidates.
      */
      createMatcher():yfiles.layout.PortCandidateSet.ICandidateMatcher;
      /**
      * Calculates the cost for each entry for the given edge configuration.
      */
      getCost(entry:yfiles.layout.PortCandidateSet.IEntry,edge:yfiles.algorithms.Edge,source:boolean,xOffset:number,yOffset:number):number;
      /**
      * Returns the priority of the given entry.
      * The higher the priority the sooner it will be chosen by the {@link yfiles.layout.PortCandidateSet.ICandidateMatcher}.
      */
      getPriority(entry:yfiles.layout.PortCandidateSet.IEntry,edge:yfiles.algorithms.Edge,source:boolean):number;
    }
    export module PortCandidateSet{
      /**
      * The interface that is used by {@link yfiles.layout.PortCandidateSet} to retrieve {@link yfiles.layout.PortCandidate}s from.
      * @see {@link yfiles.layout.PortCandidateSet#createMatcher}
      */
      export interface ICandidateMatcher extends Object{
        /**
        * Returns the next best matching {@link yfiles.layout.PortCandidateSet.IEntry} for the given parameters.
        * @param {yfiles.algorithms.Edge} edge the edge that will connect to the port
        * @param {boolean} source whether the edge connects to the node with its source side
        * @param {number} xOffset the preferred x offset of the connection point (relative to the node's center)
        * @param {number} yOffset the preferred y offset of the connection point (relative to the node's center)
        * @param {number} directionMask 
        * a bitwise combination of the constants defined in {@link yfiles.layout.PortCandidate}
        * indicating the preferred connection points
        * @return {yfiles.layout.PortCandidateSet.IEntry} the next best entry with respect to the constraints and the costs
        * @see Specified by {@link yfiles.layout.PortCandidateSet.ICandidateMatcher#findMatchingCandidateForEdgeAtOffset}.
        */
        findMatchingCandidateForEdgeAtOffset(edge:yfiles.algorithms.Edge,source:boolean,xOffset:number,yOffset:number,directionMask:number):yfiles.layout.PortCandidateSet.IEntry;
        /**
        * Returns the next best matching {@link yfiles.layout.PortCandidateSet.IEntry} for the given parameters.
        * @param {yfiles.algorithms.Edge} edge the edge that will connect to the port
        * @param {boolean} source whether the edge connects to the node with its source side
        * @param {number} directionMask 
        * a bitwise combination of the constants defined in {@link yfiles.layout.PortCandidate}
        * indicating the preferred connection points
        * @return {yfiles.layout.PortCandidateSet.IEntry} the next best entry with respect to the constraints and the costs
        * @see Specified by {@link yfiles.layout.PortCandidateSet.ICandidateMatcher#findMatchingCandidateForEdge}.
        */
        findMatchingCandidateForEdge(edge:yfiles.algorithms.Edge,source:boolean,directionMask:number):yfiles.layout.PortCandidateSet.IEntry;
        /**
        * Returns the next best matching {@link yfiles.layout.PortCandidateSet.IEntry}.
        * @return {yfiles.layout.PortCandidateSet.IEntry} the next best entry with respect to the costs
        * @see Specified by {@link yfiles.layout.PortCandidateSet.ICandidateMatcher#findMatchingCandidate}.
        */
        findMatchingCandidate():yfiles.layout.PortCandidateSet.IEntry;
      }
      /**
      * An interface that is returned by the find methods in {@link yfiles.layout.PortCandidateSet.ICandidateMatcher}
      * and the {@link yfiles.layout.PortCandidateSet#entries} method.
      * This interface provides access to the actual {@link yfiles.layout.PortCandidate} and the maximum number of connections
      * allowed for that instance.
      */
      export interface IEntry extends Object{
        /**
        * The associated PortCandidate.
        * @see Specified by {@link yfiles.layout.PortCandidateSet.IEntry#portCandidate}.
        */
        portCandidate:yfiles.layout.PortCandidate;
        /**
        * The maximum number of connections allowed for the port candidate.
        * @see Specified by {@link yfiles.layout.PortCandidateSet.IEntry#connections}.
        */
        connections:number;
      }
    }
    var PortCandidateSet:{
      $class:yfiles.lang.Class;
      /**
      * A {@link yfiles.algorithms.IDataProvider} key used to associate instances of this class with nodes in a graph.
      */
      NODE_DP_KEY:Object;
      /**
      * Creates a new and empty instance of PortCandidateSet.
      * @see {@link yfiles.layout.PortCandidateSet#add}
      * @see {@link yfiles.layout.PortCandidateSet#addWithCapacity}
      */
      new ():yfiles.layout.PortCandidateSet;
    };
    /**
    * A layout stage that performs changes the orientation
    * of the layout that another algorithm calculates.
    * <p>
    * For all {@link yfiles.layout.CanonicMultiStageLayouter}s it is highly recommended to use
    * {@link yfiles.layout.CanonicMultiStageLayouter#orientationLayouter} for layout orientation changes and not to wrap
    * the <code>CanonicMultiStageLayouter</code> with an <code>OrientationLayouter</code>, which may cause unwanted
    * artifacts.
    * </p>
    */
    export interface OrientationLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * The orientation of the layout.
      * By default {@link yfiles.layout.LayoutOrientation#TOP_TO_BOTTOM} is set.
      */
      orientation:yfiles.layout.LayoutOrientation;
      /**
      * The mirror mask, that defines which orientations this layouter shall mirror.
      * Setting a layout orientation can be seen as rotating the graph  90, 180 or 270 degrees.
      * Afterwards the graph can be mirrored at the x-Axis (for horizontal layout orientations) or
      * y-Axis (for vertical layout orientations). Which directions are mirrored can be defined by the given mask.
      * <p>
      * By default a mirror mask is set, where {@link yfiles.layout.LayoutOrientation#BOTTOM_TO_TOP}, will be mirrored at the y-Axis.
      * </p>
      * @see {@link yfiles.layout.MirrorMask#BOTTOM_TO_TOP}
      * @see {@link yfiles.layout.MirrorMask#LEFT_TO_RIGHT}
      * @see {@link yfiles.layout.MirrorMask#RIGHT_TO_LEFT}
      * @see {@link yfiles.layout.MirrorMask#TOP_TO_BOTTOM}
      * @see {@link yfiles.layout.MirrorMask#BOTTOM_TO_TOP}
      * @see {@link yfiles.layout.MirrorMask#LEFT_TO_RIGHT}
      * @see {@link yfiles.layout.MirrorMask#RIGHT_TO_LEFT}
      * @see {@link yfiles.layout.MirrorMask#TOP_TO_BOTTOM}
      */
      mirrorMask:yfiles.layout.MirrorMask;
      /**
      * Specifies whether or not the set orientation is a horizontal
      * orientation, i.e.
      * one of {@link yfiles.layout.LayoutOrientation#LEFT_TO_RIGHT} or
      * {@link yfiles.layout.LayoutOrientation#RIGHT_TO_LEFT}.
      */
      horizontalOrientation:boolean;
      /**
      * Specifies whether or not the position of the edge labels should be changed during orientation change.
      * The core layouter should switch this off, when its integrated edge labeling is switched on.
      * Default is <code>true</code>.
      */
      considerEdgeLabels:boolean;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * This method will return whether the layouter will mirror the graph for a given layout orientation.
      * @param {yfiles.layout.LayoutOrientation} orientation the layout orientation, for which to check the mirror state.
      * @return {boolean} 
      * <ul><li>true - if the layouter will mirror the graph at the corresponding axis
      * (x-Axis for horizontal orientations, y-Axis for vertical orientations) for the given layout orientation.</li>
      * <li>false - otherwise.</li></ul>
      */
      isOrientationMirrored(orientation:yfiles.layout.LayoutOrientation):boolean;
      /**
      * Method that will be called before the core layouter gets activated.
      * It prepares the layout for the desired orientation by rotating/mirroring
      * the coordinates and bounds of the graph layout such that the core layouter
      * can perform the layout in the canonical TOP_TO_BOTTOM manner.
      */
      prepareOrientationChange(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Method that will be called after the core layouter has been activated.
      * It performs the inverse coordinate transformation that has been applied
      * to the layout by method {@link yfiles.layout.OrientationLayouter#prepareOrientationChange}.
      */
      completeOrientationChange(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Transforms a point for the preparation or completion
      * phase.
      * @param {boolean} prepare 
      * if <code>true</code> then the transformation
      * is for the preparation phase, otherwise for the completion phase.
      * @see {@link yfiles.layout.OrientationLayouter#prepareTransform}
      * @see {@link yfiles.layout.OrientationLayouter#completeTransform}
      */
      transform(p:yfiles.algorithms.YPoint,prepare:boolean):yfiles.algorithms.YPoint;
      /**
      * Transforms a point for the preparation phase.
      * @see {@link yfiles.layout.OrientationLayouter#prepareOrientationChange}
      */
      prepareTransform(p:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
      /**
      * Transforms a point for the completion phase.
      * @see {@link yfiles.layout.OrientationLayouter#completeOrientationChange}
      */
      completeTransform(p:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
      /**
      * Create and return an insets object that is a geometric transform of the given insets.
      * The transform will correspond to the currently set orientation.
      */
      createOrientedInsets(insets:yfiles.algorithms.Insets):yfiles.algorithms.Insets;
      /**
      * Create and return a node halo object that is a geometric transform of the given node halo.
      * The transform will correspond to the currently set orientation.
      */
      createOrientedNodeHalo(halo:yfiles.layout.NodeHalo):yfiles.layout.NodeHalo;
      /**
      * Create and return an YDimension object that is a geometric transform of the given size.
      * The transform will correspond to the currently set orientation.
      */
      createOrientedNodeSize(nodeSize:yfiles.algorithms.YDimension):yfiles.algorithms.YDimension;
    }
    export module OrientationLayouter{
      /**
      * Class that provides a method for transferring a point to its final position.
      * Used for internal purposes.
      */
      export interface Transformer extends Object{
        finalizeTransform(p:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
        initTransform(p:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
      }
    }
    var OrientationLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Instantiates a new OrientationLayouter.
      * the core layout routine
      * will be delegated to the given layouter.
      */
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.layout.OrientationLayouter;
      };
      /**
      * Instantiates a new OrientationLayouter.
      */
      new ():yfiles.layout.OrientationLayouter;
      /**
      * Instantiates a new OrientationLayouter with a given orientation.
      * @see {@link yfiles.layout.OrientationLayouter#orientation}
      */
      FromOrientation:{
        new (orientation:yfiles.layout.LayoutOrientation):yfiles.layout.OrientationLayouter;
      };
    };
    /**
    * A layout algorithm that routes parallel edges (edges that connect the same pair of nodes) of a graph.
    * A core layout algorithm can be specified for this class. In that case the performed layout process of this class
    * is subdivided into four stages:
    * <ul>
    * <li>Remove parallel edges from the input graph.
    * If there are parallel edges between two nodes v and w than
    * only one of these edges will remain in the graph. The remaining edge is called the leading edge and
    * is the representative of the other edges.</li>
    * <li>Invoke the core layouter on the now parallel edge free graph.</li>
    * <li>Reinsert all formerly removed edges of the graph.</li>
    * <li>Route the parallel edges such that they run in parallel
    * to their leading edge which was routed by the core layouter.</li>
    * </ul>
    */
    export interface ParallelEdgeLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * Holds the list of parallel edges that are hidden from the core layouter.
      */
      hiddenEdges:yfiles.algorithms.EdgeList;
      /**
      * EdgeMap that associates a hidden edge with the unique parallel edge not hidden from the core layouter.
      */
      parallelEdges:yfiles.algorithms.IEdgeMap;
      /**
      * Specifies whether or not edges should be considered as directed.
      * In directed mode only edges that have the same source and target node will be routed
      * in parallel (e.g., two edges (v,w) and (w,v) won't be routed in parallel).
      * In undirected mode, all edges connecting the same pair of nodes
      * will be routed in parallel. By default this feature is disabled.
      */
      directedMode:boolean;
      /**
      * Specifies whether or not the line distances between parallel edges should be determined automatically according to
      * the nodes' bounds.
      * If enabled, the line distances are chosen such that all parallel edges can be drawn straight-line and still connect
      * to the nodes' bounds. By default this feature is enabled.
      */
      adaptiveLineDistances:boolean;
      /**
      * The distance between two adjacent paths that run in parallel.
      * Note: if adaptive line distances are used (see {@link yfiles.layout.ParallelEdgeLayouter#adaptiveLineDistances}) the real distance may
      * be less than the given line distance.
      */
      lineDistance:number;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * This method assigns a layout to parallel edges.
      * The layout for each parallel edge follows the
      * layout of the one edge not being removed from the core layouter.
      */
      layoutParallelEdges(graph:yfiles.layout.LayoutGraph,parallelEdges:yfiles.algorithms.IEdgeMap):void;
      /**
      * This method detects parallel edges of the given graph.
      * From each set of parallel edges
      * it hides all but one edge from the given graph.
      */
      findAndHideParallelEdges(graph:yfiles.algorithms.Graph):void;
      /**
      * Specifies whether or not to join end points of parallel edges.
      * If enabled all lines end at the same point. By default, this feature is disabled.
      */
      joinEnds:boolean;
      /**
      * The absolute distance from the end point of the lines to the first
      * parallel segments if end joining is enabled.
      */
      absJoinEndDistance:number;
      /**
      * The relative distance from the end point of the lines to the first
      * parallel segments if end joining is enabled.
      * The length will be relative to the corresponding original
      * segment's length.
      */
      relJoinEndDistance:number;
      /**
      * Specifies whether this layouter will adjust the leading edge to obtain more symmetric results.
      * By default, this feature is enabled.
      */
      adjustLeadingEdge:boolean;
    }
    var ParallelEdgeLayouter:{
      $class:yfiles.lang.Class;
      /**
      * A {@link yfiles.algorithms.IDataProvider} key that can be used to tell the stage whether edges should be included in
      * or excluded from the calculation.
      * For every {@link yfiles.algorithms.Edge} instance the provider
      * should yield {@link yfiles.algorithms.IDataProvider#getBool  boolean} values to indicate whether an
      * edge should be laid out.
      * If no data provider is registered for the given key, all edges will be laid out.
      */
      SCOPE_DP_KEY:Object;
      /**
      * A {@link yfiles.algorithms.IDataProvider} key that can be used to specify which parallel edge should be used
      * as leading edge, i.e., as the edge whose layout is used to obtain the layout of the corresponding parallel edges.
      * For every {@link yfiles.algorithms.Edge} instance the provider should yield {@link yfiles.algorithms.IDataProvider#getBool  boolean} values
      * to indicate whether an edge is a leading edge.
      */
      LEADING_EDGE_DP_KEY:Object;
      /**
      * Creates a new instance of ParallelEdgeLayouter for the given core layouter.
      * @see {@link yfiles.layout.AbstractLayoutStage#coreLayouter}
      */
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.layout.ParallelEdgeLayouter;
      };
      /**
      * Creates a new instance of ParallelEdgeLayouter with no core layouter assigned.
      */
      new ():yfiles.layout.ParallelEdgeLayouter;
    };
    /**
    * This class is the default implementation for the NodeLabelLayout.
    */
    export interface DefaultNodeLabelLayout extends Object,yfiles.layout.INodeLabelLayout{
      /**
      * The bounding box of the label.
      * @see Specified by {@link yfiles.layout.ILabelLayout#box}.
      */
      box:yfiles.algorithms.YRectangle;
      /**
      * The box of the label.
      * @see Specified by {@link yfiles.layout.ILabelLayout#orientedBox}.
      */
      orientedBox:yfiles.algorithms.YOrientedRectangle;
      /**
      * The node label model associated with this label layout.
      * @see Specified by {@link yfiles.layout.INodeLabelLayout#labelModel}.
      */
      labelModel:yfiles.layout.INodeLabelModel;
      /**
      * The NodeLabelModel parameter that describes the position of the label layout.
      * @see Specified by {@link yfiles.layout.ILabelLayout#modelParameter}.
      */
      modelParameter:Object;
      /**
      * The node associated with this layout.
      */
      node:yfiles.algorithms.Node;
    }
    var DefaultNodeLabelLayout:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of {@link yfiles.layout.DefaultNodeLabelLayout}.
      * @param {yfiles.layout.INodeLabelModel} model the NodeLabel model for this label layout
      * @param {Object} param 
      * the NodeLabelModel parameter that describes the position
      * of the label layout.
      * @param {yfiles.algorithms.YRectangle} box the bounds of this label layout
      */
      FromRectangle:{
        new (model:yfiles.layout.INodeLabelModel,param:Object,box:yfiles.algorithms.YRectangle,node:yfiles.algorithms.Node):yfiles.layout.DefaultNodeLabelLayout;
      };
      /**
      * Creates a new instance of {@link yfiles.layout.DefaultNodeLabelLayout}.
      * @param {yfiles.layout.INodeLabelModel} model the NodeLabel model for this label layout
      * @param {Object} param the NodeLabelModel parameter that describes the position of the label layout.
      * @param {yfiles.algorithms.YOrientedRectangle} orientedBox the bounds of this label layout
      */
      FromOrientedRectangle:{
        new (model:yfiles.layout.INodeLabelModel,param:Object,orientedBox:yfiles.algorithms.YOrientedRectangle,node:yfiles.algorithms.Node):yfiles.layout.DefaultNodeLabelLayout;
      };
    };
    /**
    * This class implements a LayoutStage that can be used to adjust the final port
    * assignments after a layout has been calculated.
    * This can be useful if the port
    * assignment calculated by the layout algorithm is insufficient. This stage uses
    * {@link yfiles.algorithms.IDataProvider} instances bound to the graph using the keys defined in
    * the {@link yfiles.layout.IIntersectionCalculator} interface to calculate the new port offsets.
    * For each edge in the <code>LayoutGraph</code> instance the
    * <code>DataProvider</code>s are queried for an implementation of the
    * {@link yfiles.layout.IIntersectionCalculator} interface. If the result is non-<code>null</code>,
    * that implementation will be queried and if the result of the query is
    * non-<code>null</code>, the returned point will be applied to the edge layout.
    * For this layout stage to work use
    * {@link yfiles.layout.CompositeLayoutStage#prependStage} or
    * {@link yfiles.layout.CanonicMultiStageLayouter#prependStage}
    * to add this layout stage and register appropriate {@link yfiles.algorithms.IDataProvider}
    * implementations to the graph using the keys defined in {@link yfiles.layout.IIntersectionCalculator}.
    * Note, that this class will not change the coordinates of a port if it is
    * associated with a strong port constraint.
    * @see {@link yfiles.layout.IIntersectionCalculator}
    * @see {@link yfiles.layout.IntersectionCalculatorKeys#SOURCE_INTERSECTION_CALCULATOR_DP_KEY}
    * @see {@link yfiles.layout.IntersectionCalculatorKeys#TARGET_INTERSECTION_CALCULATOR_DP_KEY}
    * @see {@link yfiles.layout.PortConstraint}
    */
    export interface PortCalculator extends yfiles.layout.AbstractLayoutStage,yfiles.layout.ILayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Performs the actual port calculation on the specified graph instance.
      */
      calculatePorts(graph:yfiles.layout.LayoutGraph):void;
      /**
      * EPSILON used by {@link yfiles.layout.PortCalculator#equalsEps}.
      * By default this is <code>0.2d</code>.
      */
      eps:number;
      /**
      * Callback method that determines whether two points are equal.
      */
      equalsEps(x1:number,y1:number,x2:number,y2:number):boolean;
    }
    var PortCalculator:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new PortCalculator without a core layouter.
      */
      new ():yfiles.layout.PortCalculator;
      /**
      * Creates a new PortCalculator using the given layouter as the core of
      * this layout stage.
      */
      WithCoreLayouter:{
        new (core:yfiles.layout.ILayouter):yfiles.layout.PortCalculator;
      };
    };
    /**
    * Layout stage that can be used to normalize the order of the elements within a graph.
    * Amongst other factors,
    * the results produced by layout algorithms usually depend on the order of the nodes and edges within a graph.
    * Unfortunately, useful operations such as hiding or unhiding elements from a graph or
    * simply invoking layout algorithms on a graph will have the potential side effect of changing that order.
    * With this layout stage it is possible to establish a predefined order of nodes and edges within a graph to
    * avoid non-deterministic layout behavior. Defining the order of nodes and edges is done by
    * associating each node or edge in the graph with a <code>Comparable</code> value using DataProviders
    * registered with the key {@link yfiles.layout.NormalizingGraphElementOrderStage#COMPARABLE_NODE_DP_KEY}, or {@link yfiles.layout.NormalizingGraphElementOrderStage#COMPARABLE_EDGE_DP_KEY} respectively.
    * the DataProvider key
    */
    export interface NormalizingGraphElementOrderStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var NormalizingGraphElementOrderStage:{
      $class:yfiles.lang.Class;
      /**
      * The <code>DataProvider</code> registered with this key must return a
      * {@link yfiles.lang.IObjectComparable} object for each node thereby inducing a (global) order
      * for nodes.
      */
      COMPARABLE_NODE_DP_KEY:Object;
      /**
      * The <code>DataProvider</code> registered with this key must return a
      * {@link yfiles.lang.IObjectComparable} object for each edge thereby inducing a (global) order
      * for edges.
      */
      COMPARABLE_EDGE_DP_KEY:Object;
      new ():yfiles.layout.NormalizingGraphElementOrderStage;
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.layout.NormalizingGraphElementOrderStage;
      };
      /**
      * Convenience method that assigns comparable values for each node and edge.
      * The compared values
      * are induced from the current ordering of the nodes and edges within the given graph.
      */
      fillComparableMapFromGraph(graph:yfiles.algorithms.Graph,comparableNodeMap:yfiles.algorithms.IDataMap,comparableEdgeMap:yfiles.algorithms.IDataMap):void;
    };
    /**
    * This Layouter will take several {@link yfiles.layout.ILayouter} implementations and will
    * run these layout algorithms one after the other in the order in which they
    * were added.
    * <p>
    * This class can for example be used to bundle several layout steps and
    * handover a single layouter to a {@link yfiles.layout.BufferedLayouter}.
    * </p>
    */
    export interface SequentialLayouter extends Object,yfiles.layout.ILayouter{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Appends the given layouter to the end of the layouter chain.
      * @param {yfiles.layout.ILayouter} layouter the layouter that should be appended to the chain.
      */
      appendLayouter(layouter:yfiles.layout.ILayouter):void;
      /**
      * Appends the specified layouters to the end of the layouter chain.
      * @param {yfiles.collections.ICollection.<yfiles.layout.ILayouter>} layouters the layouters that should be appended to the chain.
      */
      appendLayouters(layouters:yfiles.collections.ICollection<yfiles.layout.ILayouter>):void;
      /**
      * A list of the layouters that are currently in the layout chain.
      * Note: this will overwrite the current chain.
      */
      layouters:yfiles.collections.IList<yfiles.layout.ILayouter>;
      /**
      * Clears the layouter chain and therefore removes all layouters.
      */
      clearLayouterChain():void;
    }
    var SequentialLayouter:{
      $class:yfiles.lang.Class;
      new ():yfiles.layout.SequentialLayouter;
    };
    /**
    * This layout stage can be used to enforce that a layout algorithm will not change
    * the relative coordinates of ports that are associated with a strong/fixed port constraint.
    */
    export interface PortConstraintEnforcementStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var PortConstraintEnforcementStage:{
      $class:yfiles.lang.Class;
      new ():yfiles.layout.PortConstraintEnforcementStage;
    };
    /**
    * A layout stage that can be used to (selectively) reverse edges in a
    * graph while keeping the layout and label positions of the reversed edges
    * as close to the pre-reversal layout and positions as possible.
    */
    export interface EdgeReversalStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Reverses <em>selected</em> edges in the specified graph.
      * An edge is considered <em>selected</em> in this context according to the
      * criteria described for {@link yfiles.layout.EdgeReversalStage#REVERSE_EDGES_DP_KEY}.
      * <p>
      * Implementation detail: This method calls
      * {@link yfiles.layout.EdgeReversalStage#reverseEdge} in order to reverse a
      * <em>selected</em> edge.
      * </p>
      * @param {yfiles.layout.LayoutGraph} graph the graph in which to reverse edges.
      * @see {@link yfiles.layout.EdgeReversalStage#REVERSE_EDGES_DP_KEY}
      */
      reverseEdges(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Reverse the specified edge in the specified graph.
      * The layout of the specified edge is reversed as specified in
      * {@link yfiles.layout.LayoutTool#reverseEdgeLayout}.
      * Moreover, the positions of all labels associated to the specified edge
      * are adjusted to match the pre-reversal position as closely as possible.
      * (Depending on a label's model it might not always be possible to achieve
      * an exact match.)
      * @param {yfiles.layout.LayoutGraph} graph the graph to which the specified edge belongs.
      * @param {yfiles.algorithms.Edge} edge the edge to be reversed.
      */
      reverseEdge(graph:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):void;
    }
    var EdgeReversalStage:{
      $class:yfiles.lang.Class;
      /**
      * This key can be used to <em>select</em> specific edges for reversal.
      * An edge is considered <em>selected</em> in this context, if the
      * corresponding <code>DataProvider</code> returns <code>true</code> for
      * said edge.
      * <p>
      * <b>Note:</b>
      * If there is no <code>DataProvider</code> for this key, all edges are
      * considered <em>selected</em>.
      * </p>
      */
      REVERSE_EDGES_DP_KEY:Object;
      new ():yfiles.layout.EdgeReversalStage;
      WithCoreLayouter:{
        new (core:yfiles.layout.ILayouter):yfiles.layout.EdgeReversalStage;
      };
      /**
      * Marks edges in a tree-structured graph component that need to be reversed
      * to make the specified node the root of the tree component.
      * Only edges in the graph component to which the specified node belongs will
      * be marked.
      * Edges are marked with a <code>boolean</code> <code>true</code> flag.
      * @param {yfiles.layout.LayoutGraph} graph the graph to which the specified node belongs.
      * @param {yfiles.algorithms.Node} root the node to be considered the root of its tree component.
      * @param {yfiles.algorithms.IDataAcceptor} reversedEdges 
      * a data acceptor that is used to mark edges for
      * reversal.
      * @see {@link yfiles.layout.EdgeReversalStage#REVERSE_EDGES_DP_KEY}
      * @throws {yfiles.system.ArgumentException} 
      * if the specified node does not belong to
      * the specified graph.
      */
      findReversedTreeEdges(graph:yfiles.layout.LayoutGraph,root:yfiles.algorithms.Node,reversedEdges:yfiles.algorithms.IDataAcceptor):void;
    };
    /**
    * A node label model that sets
    * the labels at the opposite side of the outgoing edges of a node.
    */
    export interface EdgeOppositeNodeLabelLayoutModel extends Object,yfiles.layout.INodeLabelModel{
      /**
      * The default position, this is offset (0,0).
      * @see Specified by {@link yfiles.layout.INodeLabelModel#defaultParameter}.
      */
      defaultParameter:Object;
      /**
      * Returns the oriented position and bounds for a label of the specified size.
      * @param {yfiles.algorithms.YDimension} labelSize the size of the label.
      * @param {yfiles.layout.INodeLayout} nodeLayout the geometric description of the labeled node.
      * @param {Object} param not used by this model
      * @see Specified by {@link yfiles.layout.INodeLabelModel#getLabelPlacement}.
      */
      getLabelPlacement(labelSize:yfiles.algorithms.YDimension,nodeLayout:yfiles.layout.INodeLayout,param:Object):yfiles.algorithms.YOrientedRectangle;
      /**
      * Creates a model parameter that represents the given node label context best
      * within this model.
      * The created model parameter represents the closest parameter representation
      * of the given oriented label bounds that can be achieved within this model.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBounds The bounds of the label for which a parameter representation is sought.
      * @param {yfiles.layout.INodeLayout} nodeLayout The layout of the node to which the label belongs.
      * @return {Object} 
      * A model parameter that can be passed to the
      * {@link yfiles.layout.INodeLabelModel#getLabelPlacement} method.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#createModelParameter}.
      */
      createModelParameter(labelBounds:yfiles.algorithms.YOrientedRectangle,nodeLayout:yfiles.layout.INodeLayout):Object;
      /**
      * Returns a list of candidate positions for the label.
      * The list consists of exactly one position.
      * @see Specified by {@link yfiles.layout.INodeLabelModel#getLabelCandidates}.
      */
      getLabelCandidates(nl:yfiles.layout.INodeLabelLayout,nodeLayout:yfiles.layout.INodeLayout):yfiles.algorithms.YList;
    }
    var EdgeOppositeNodeLabelLayoutModel:{
      $class:yfiles.lang.Class;
      new (g:yfiles.layout.LayoutGraph,n:yfiles.algorithms.Node):yfiles.layout.EdgeOppositeNodeLabelLayoutModel;
    };
    /**
    * This layout stage enforces a given minimum width/height of the nodes of a graph during the layout process.
    * Therefore it temporarily enlarges nodes whose width/height fall below the specified minimum values.
    */
    export interface MinNodeSizeStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var MinNodeSizeStage:{
      $class:yfiles.lang.Class;
      /**
      * Instantiates a new MinNodeSizeStage that wraps the given core layouter.
      * @param {yfiles.layout.ILayouter} core The core layouter.
      * @param {number} minWidth The minimum width of nodes that should be enforced.
      * @param {number} minHeight The minimum height of nodes that should be enforced.
      */
      ForSize:{
        new (core:yfiles.layout.ILayouter,minWidth:number,minHeight:number):yfiles.layout.MinNodeSizeStage;
      };
      /**
      * Instantiates a new MinNodeSizeStage that wraps the given core layouter.
      * The minimum width/height of nodes is set to 1.
      * @param {yfiles.layout.ILayouter} core The core layouter.
      */
      new (core:yfiles.layout.ILayouter):yfiles.layout.MinNodeSizeStage;
    };
    /**
    * A layout stage that can be used to "line-wrap" or "column-wrap" a graph layout.
    * This stage both supports wrapping a layout at a given width (height) or wrapping
    * the layout at a specific width (height) automatically so that the overall resulting
    * aspect ratio will be close to a specifiable value.
    * @see {@link yfiles.layout.GraphLayoutLineWrapper#fixedWidthLineBreaks}
    * @see {@link yfiles.layout.GraphLayoutLineWrapper#fixedWidth}
    * @see {@link yfiles.layout.GraphLayoutLineWrapper#targetRatio}
    * @see {@link yfiles.layout.GraphLayoutLineWrapper#columnMode}
    */
    export interface GraphLayoutLineWrapper extends yfiles.layout.AbstractLayoutStage{
      /**
      * The space between edges that should be used for the additional routing.
      * The default is <code>5</code>.
      */
      edgeSpacing:number;
      /**
      * Determines whether this algorithm should not wrap lines or rows, but columns.
      * If set to <code>true</code>, the layout will be wrapped vertically and new columns will
      * be appended to the right of the first column.
      * The {@link yfiles.layout.GraphLayoutLineWrapper#fixedWidth} property will be interpreted as a fixed height, in that case, of course.
      * The default is <code>false</code>.
      */
      columnMode:boolean;
      /**
      * The space between adjacent lines of the wrapped graph layout.
      * The default is <code>10</code>.
      */
      spacing:number;
      /**
      * Specifies whether lines should be going from left to right and right to left
      * in an alternating fashion.
      * If set to <code>true</code> every second line will be rotated 180 degrees and
      * ports will be adjusted correspondingly.
      * The default is <code>true</code>
      */
      mirror:boolean;
      /**
      * Specifies whether the algorithm should use the{@link yfiles.layout.GraphLayoutLineWrapper#fixedWidth  fixed width}
      * to determine line breaks.
      * The default is <code>false</code>.
      * @see {@link yfiles.layout.GraphLayoutLineWrapper#fixedWidth}
      * @see {@link yfiles.layout.GraphLayoutLineWrapper#targetRatio}
      * @see {@link yfiles.layout.GraphLayoutLineWrapper#fixedWidth}
      * @see {@link yfiles.layout.GraphLayoutLineWrapper#targetRatio}
      */
      fixedWidthLineBreaks:boolean;
      /**
      * The desired target aspect ratio the algorithm should try to generate.
      * This setting only affects the outcome if {@link yfiles.layout.GraphLayoutLineWrapper#fixedWidthLineBreaks}
      * is set to <code>false</code>.
      * The default is <code>1.0d</code>.
      */
      targetRatio:number;
      /**
      * The desired width of the lines to use if{@link yfiles.layout.GraphLayoutLineWrapper#fixedWidthLineBreaks} is set to
      * <code>true</code>.
      * Note that the algorithm will not necessarily be able to satisfy very small values since the nodes need to
      * fit into a line completely.
      * <p>
      * The default is <code>500</code>
      * </p>
      * @see {@link yfiles.layout.GraphLayoutLineWrapper#fixedWidthLineBreaks}
      * @see {@link yfiles.layout.GraphLayoutLineWrapper#fixedWidthLineBreaks}
      */
      fixedWidth:number;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var GraphLayoutLineWrapper:{
      $class:yfiles.lang.Class;
      new ():yfiles.layout.GraphLayoutLineWrapper;
    };
    /**
    * This class represents a constraint for either a source or target port
    * of an edge.
    * Objects of type PortConstraint are expected to be returned by
    * data providers that are registered by the keys defined in the
    * interface {@link yfiles.layout.PortConstraintKeys}.
    * A port constraint expresses at what position an edge is allowed
    * to connect to either its source or target node.
    * A weak port constraint limits the position of the port
    * to a particular side of a node.
    * Additionally, a strong port constraint fixes the position of the
    * port completely to the position of the current port coordinates.
    * For example, <code>PortConstraint p = PortConstraint.create(PortConstraint.NORTH)</code>
    * expresses that an edge should connect at the north side of a node. It is
    * a weak constraint.
    * On the other hand <code>p = PortConstraint.create(PortConstraint.NORTH, true)</code>
    * expresses that an edge should not only connect at the north side of a node
    * but also should use the current port coordinates. This is a strong constraint.
    */
    export interface PortConstraint extends Object{
      /**
      * <code>true</code> if this <code>PortConstraint</code> represents
      * a strong constraint and <code>false</code> otherwise.
      */
      strong:boolean;
      /**
      * The side of a node at which a port should connect.
      */
      side:yfiles.layout.PortSide;
      /**
      * Specifies whether or not this port constraint has
      * the weak constraint side {@link yfiles.layout.PortSide#NORTH} associated
      * with it.
      */
      atNorth:boolean;
      /**
      * Specifies whether or not this port constraint has
      * the weak constraint side {@link yfiles.layout.PortSide#SOUTH} associated
      * with it.
      */
      atSouth:boolean;
      /**
      * Specifies whether or not this port constraint has
      * the weak constraint side {@link yfiles.layout.PortSide#EAST} associated
      * with it.
      */
      atEast:boolean;
      /**
      * Specifies whether or not this port constraint has
      * the weak constraint side {@link yfiles.layout.PortSide#WEST} associated
      * with it.
      */
      atWest:boolean;
      /**
      * Specifies whether or not this port constraint has
      * the weak constraint side {@link yfiles.layout.PortSide#ANY} associated
      * with it.
      */
      atAnySide:boolean;
      hashCode():number;
      /**
      * Tests for equality based on the strong attribute and the
      * side attribute.
      */
      equals(other:Object):boolean;
      /**
      * Returns a string representation of this object.
      */
      toString():string;
    }
    var PortConstraint:{
      $class:yfiles.lang.Class;
      /**
      * Creates the empty constraint, that allows ports to connect at any side of a
      * node.
      */
      CreateDefault:{
        new ():yfiles.layout.PortConstraint;
      };
      /**
      * Creates the weak constraint, that allows ports to connect to a specific side
      * of a node.
      * @param {yfiles.layout.PortSide} side 
      * weak constraint specifier. One of {@link yfiles.layout.PortSide#ANY}, {@link yfiles.layout.PortSide#NORTH},
      * {@link yfiles.layout.PortSide#SOUTH}, {@link yfiles.layout.PortSide#EAST} or {@link yfiles.layout.PortSide#WEST}.
      */
      FromSide:{
        new (side:yfiles.layout.PortSide):yfiles.layout.PortConstraint;
      };
      /**
      * Creates a constraint, that allows ports to connect to a specific side
      * of a node.
      * @param {yfiles.layout.PortSide} side 
      * weak constraint specifier. One of {@link yfiles.layout.PortSide#ANY}, {@link yfiles.layout.PortSide#NORTH},
      * {@link yfiles.layout.PortSide#SOUTH}, {@link yfiles.layout.PortSide#EAST} or {@link yfiles.layout.PortSide#WEST}.
      * @param {boolean} strong 
      * whether the layouter should use the current port coordinates
      * (strong constraint)
      */
      new (side:yfiles.layout.PortSide,strong:boolean):yfiles.layout.PortConstraint;
      /**
      * Returns whether or not there are non-trivial
      * source or target port constraints associated with the
      * given edge.
      * The data provider keys
      * {@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY}
      * and {@link yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY}
      * are used to lookup the data providers in the given graph.
      */
      hasPC(graph:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge):boolean;
      /**
      * Returns whether or not there is a non-trivial
      * source port constraint associated with the
      * given edge.
      * The data provider key
      * {@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY}
      * is used to lookup the source port constraint data
      * provider in the given graph.
      */
      hasSPC(graph:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge):boolean;
      /**
      * Returns whether or not there is a non-trivial
      * target port constraint associated with the
      * given edge.
      * The data provider key
      * {@link yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY}
      * is used to lookup the source port constraint data
      * provider in the given graph.
      */
      hasTPC(graph:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge):boolean;
      /**
      * Returns the source port constraint associated with the
      * given edge.
      * The data provider key
      * {@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY}
      * is used to lookup the source port constraint data
      * provider in the given graph.
      */
      getSPC(graph:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge):yfiles.layout.PortConstraint;
      /**
      * Returns the target port constraint associated with the
      * given edge.
      * The data provider key
      * {@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY}
      * is used to lookup the source port constraint data
      * provider in the given graph.
      */
      getTPC(graph:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge):yfiles.layout.PortConstraint;
      /**
      * Creates a weak port constraint.
      * @param {yfiles.layout.PortSide} side 
      * One of {@link yfiles.layout.PortSide#ANY}, {@link yfiles.layout.PortSide#NORTH},
      * {@link yfiles.layout.PortSide#SOUTH}, {@link yfiles.layout.PortSide#EAST} or {@link yfiles.layout.PortSide#WEST}.
      */
      createWeak(side:yfiles.layout.PortSide):yfiles.layout.PortConstraint;
      /**
      * Creates a port constraint.
      * The boolean value defines whether it is a
      * strong or weak one.
      * @param {yfiles.layout.PortSide} side 
      * One of {@link yfiles.layout.PortSide#ANY}, {@link yfiles.layout.PortSide#NORTH}, {@link yfiles.layout.PortSide#SOUTH}, {@link yfiles.layout.PortSide#EAST} or {@link yfiles.layout.PortSide#WEST}.
      * @param {boolean} strong defines whether it is a strong or weak PortConstraint.
      */
      create(side:yfiles.layout.PortSide,strong:boolean):yfiles.layout.PortConstraint;
    };
    /**
    * A layout algorithm that routes the self-loops (reflexive edges) of a graph.
    * By default, this layouter routes self-loops in an orthogonal fashion.
    * It places the self-loop in the least crowded quadrant around a node.
    * <p>
    * A core layout algorithm can be specified for this class.
    * In that case, the performed layout process of this class is subdivided into four
    * stages:
    * </p>
    * <ul>
    * <li>Remove all self-loops of the input graph</li>
    * <li>Invoke the core layouter on the now self-loops free graph</li>
    * <li>Reinsert all formerly removed self-loops of the graph</li>
    * <li>Layout the self-loops of the input graph</li>
    * </ul>
    */
    export interface SelfLoopLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * The number of points that are used to round the corner of the selfloops.
      * If this value is set to one
      * the corners are drawn orthogonal. This value is only considered if style {@link yfiles.layout.SelfloopStyle#ROUNDED} is used.
      * @see {@link yfiles.layout.SelfloopStyle#ROUNDED}
      */
      cornerApproximationPointsCount:number;
      /**
      * The distance between two adjacent paths that run in parallel.
      * This value is only considered for layout style {@link yfiles.layout.SelfloopStyle#ROUNDED}.
      * @see {@link yfiles.layout.SelfloopStyle#ROUNDED}
      */
      lineDistance:number;
      /**
      * Whether or not smart selfloop placement should be enabled.
      * If this option is enabled, selfloops are placed on one of the four corners of the corresponding node. For the choice of the corner
      * the algorithm considers all incident edges.
      * Otherwise the selfloops are always placed at the upper left corner of the corresponding node.
      */
      smartSelfloopPlacement:boolean;
      /**
      * The layout style to be used.
      * Possible values are {@link yfiles.layout.SelfloopStyle#ORTHOGONAL} (default) and {@link yfiles.layout.SelfloopStyle#ROUNDED}.
      * @see {@link yfiles.layout.SelfloopStyle#ORTHOGONAL}
      * @see {@link yfiles.layout.SelfloopStyle#ROUNDED}
      */
      layoutStyle:yfiles.layout.SelfloopStyle;
      /**
      * Lays out the given graph.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Whether or not this layouter can layout the given graph.
      * Returns true if the core layouter can handle the given graph
      * after all of its self-loops (reflexive) edges have been hidden.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Lays out the self-loops of the given graph.
      * This method will be called after the core layouter has
      * laid out the graph and all self-loops have been reinserted
      * in the graph again.
      */
      layoutSelfLoops(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Specifies whether this algorithm should keep the existing layout of all self-loops.
      * If this property is set, the {@link yfiles.layout.SelfLoopLayouter#KEEP_SELF_LOOP_LAYOUT_DP_KEY} data provider
      * will be ignored.
      * No layout for any self-loop will be calculated, instead the existing self-loop
      * layout will be moved with its node.
      * The default is <code>false</code>.
      */
      keepAllSelfloopLayouts:boolean;
    }
    var SelfLoopLayouter:{
      $class:yfiles.lang.Class;
      /**
      * This {@link yfiles.algorithms.IDataProvider} key can be used to register a {@link yfiles.algorithms.IDataProvider}
      * with the graph to be laid out.
      * This algorithm will query for each self-loop
      * the boolean value from the data provider to determine whether the current layout
      * of the self-loop should be kept. I.e., if the <code>DataProvider</code> instance
      * obtained from the graph using this key returns <code>true</code> for a self-loop,
      * that self-loop will not be laid out by this stage but the bends will be moved
      * by that stage according to the movement of their node.
      * @see {@link yfiles.layout.SelfLoopLayouter#keepAllSelfloopLayouts}
      */
      KEEP_SELF_LOOP_LAYOUT_DP_KEY:Object;
      /**
      * Instantiates a new SelfLoopLayouter.
      */
      new ():yfiles.layout.SelfLoopLayouter;
      /**
      * Instantiates a new SelfLoopLayouter.
      * The core layout routine
      * will be delegated to the given layouter.
      */
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.layout.SelfLoopLayouter;
      };
    };
    /**
    * An edge label model that allows placement of labels at a set of continuous positions
    * along both sides of an edge or directly on the edge path.
    * <p>
    * The set of positions can be influenced by specifying the density value that controls
    * the spacing between adjacent label positions.
    * Furthermore, it's possible to specify distance values that control the distance
    * between label and edge and between label and nodes.
    * </p>
    */
    export interface SliderEdgeLabelLayoutModel extends Object,yfiles.layout.IEdgeLabelModel{
      /**
      * The model's slider mode.
      */
      mode:yfiles.layout.SliderMode;
      /**
      * Sets the minimum and maximum distances between the label's bounding box and
      * the edge's path.
      * @param {number} minDistance The minimal distance between label and edge.
      * @param {number} maxDistance The maximal distance between label and edge.
      * @see {@link yfiles.layout.SliderEdgeLabelLayoutModel#maximumDistance}
      * @see {@link yfiles.layout.SliderEdgeLabelLayoutModel#minimumDistance}
      * @see {@link yfiles.layout.SliderEdgeLabelLayoutModel#maximumDistance}
      * @see {@link yfiles.layout.SliderEdgeLabelLayoutModel#minimumDistance}
      */
      setDistances(minDistance:number,maxDistance:number):void;
      /**
      * The maximum distance between the label's bounding box and
      * the edge's path.
      * <p>
      * By default, a maximum distance of <code>1.0</code> is set.
      * </p>
      * @see {@link yfiles.layout.SliderEdgeLabelLayoutModel#setDistances}
      * @see {@link yfiles.layout.SliderEdgeLabelLayoutModel#setDistances}
      */
      maximumDistance:number;
      /**
      * The minimum distance between the label's bounding box and
      * the edge's path.
      * <p>
      * By default, a minimum distance of <code>1.0</code> is set.
      * </p>
      * @see {@link yfiles.layout.SliderEdgeLabelLayoutModel#setDistances}
      * @see {@link yfiles.layout.SliderEdgeLabelLayoutModel#setDistances}
      */
      minimumDistance:number;
      /**
      * The density to generate label candidate positions.
      * <p>
      * A density value of <code>1.0</code> (which is the default) generates the
      * most possible candidate positions without overlap.
      * </p>
      */
      density:number;
      /**
      * The minimal distance between the label's bounding box and a node's
      * borders.
      */
      nodeBorderDistance:number;
      /**
      * A model parameter that encodes the default position of this model's
      * allowed edge label positions.
      * The default positions for both slider edge label models are relative to the
      * first edge segment, either at the beginning of the segment ({@link yfiles.layout.SliderMode#SIDE}
      * model) or at its middle ({@link yfiles.layout.SliderMode#CENTER} model).
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#defaultParameter}.
      */
      defaultParameter:Object;
      /**
      * Returns the bounds of the label for the position encoded
      * by the given model parameter.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label that should be placed.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @param {Object} param 
      * The model parameter that describes the abstract position of the label within
      * this model.
      * The parameter must have been generated by this model.
      * @return {yfiles.algorithms.YOrientedRectangle} The bounds of the label.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}.
      */
      getLabelPlacement(labelSize:yfiles.algorithms.YDimension,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout,para:Object):yfiles.algorithms.YOrientedRectangle;
      /**
      * Returns a list of candidate positions for the given edge label.
      * The number of candidates and their respective locations are computed depending
      * on the geometries of both label and edge.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelCandidates}.
      */
      getLabelCandidates(label:yfiles.layout.IEdgeLabelLayout,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):yfiles.algorithms.YList;
      /**
      * Creates a model parameter that represents the given edge label context best
      * within this model.
      * The created model parameter represents the closest parameter representation
      * of the given label location that can be achieved within this model.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBounds The bounds of the label for which a parameter representation is sought.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @return {Object} 
      * A model parameter that can be passed to the
      * {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}
      * method.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#createModelParameter}.
      */
      createModelParameter(labelBounds:yfiles.algorithms.YOrientedRectangle,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):Object;
      /**
      * Returns the offset vector for a given edge label and a given edge segment.
      * The offset vector describes where to move a label candidate such that it keeps
      * a certain distance to the edge's path.
      * @param {number} dx x-coordinates delta for an edge segment.
      * @param {number} dy y-coordinates delta for an edge segment.
      * @param {number} width The label's width.
      * @param {number} height The label's height.
      * @param {yfiles.layout.SliderRatio} labelPosition 
      * One of the symbolic ratio specifiers {@link yfiles.layout.SliderRatio#CENTER}, {@link yfiles.layout.SliderRatio#LEFT},
      * or {@link yfiles.layout.SliderRatio#RIGHT}.
      * @return {yfiles.algorithms.YVector} An offset vector.
      */
      getOffsetVec(dx:number,dy:number,width:number,height:number,labelPosition:yfiles.layout.SliderRatio):yfiles.algorithms.YVector;
    }
    export module SliderEdgeLabelLayoutModel{
      /**
      * Encodes the model parameters for the two slider edge label models specified
      * by {@link yfiles.layout.SliderMode#CENTER} and {@link yfiles.layout.SliderMode#SIDE}.
      */
      export interface ModelParameter extends Object{
        /**
        * The index of the edge segment relative to which the label is placed.
        * The index is zero-based and starts at the edge's source end.
        * Let s denote the number of edge segments.
        * Then, a negative index value i denotes the segment with index s + i.
        */
        segmentNumber:number;
        /**
        * The label's ratio with respect to the length of the edge segment
        * relative to which it is placed.
        */
        ratio:number;
        /**
        * The offset vector between the label and the edge segment relative
        * to which it is placed.
        * The offset vector describes the distance between the edge segment and the
        * label's upper-left corner.
        */
        offsetVector:yfiles.algorithms.YVector;
        /**
        * The label's symbolic ratio specifier, i.e., one of{@link yfiles.layout.SliderRatio#CENTER},
        * {@link yfiles.layout.SliderRatio#LEFT}, or {@link yfiles.layout.SliderRatio#RIGHT}.
        */
        labelPosition:number;
        /**
        * The label's absolute ratio with respect to the entire length of the
        * edge path.
        */
        absRatio:number;
      }
    }
    var SliderEdgeLabelLayoutModel:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new instance of <code>SliderEdgeLabelModel</code>.
      * @param {yfiles.layout.SliderMode} mode 
      * Determines which slider mode to use.
      * Possible values are either {@link yfiles.layout.SliderMode#CENTER} or {@link yfiles.layout.SliderMode#SIDE}.
      */
      new (mode:yfiles.layout.SliderMode):yfiles.layout.SliderEdgeLabelLayoutModel;
      ModelParameter:{
        $class:yfiles.lang.Class;
        /**
        * Returns a new instance of ModelParameter that has the given characteristics.
        * @param {number} s The index of the edge segment relative to which the label should be placed.
        * @param {number} r 
        * The label's ratio with respect to the length of the edge segment relative
        * to which it should be placed.
        * @param {yfiles.algorithms.YVector} v 
        * The offset vector between the label and the edge segment relative to which
        * it should be placed.
        * @param {number} p 
        * One of the symbolic ratio specifiers {@link yfiles.layout.SliderRatio#CENTER}, {@link yfiles.layout.SliderRatio#LEFT},
        * or {@link yfiles.layout.SliderRatio#RIGHT}.
        * @param {number} aRatio 
        * The label's absolute ratio with respect to the entire length of the edge
        * path.
        * Note that this value is derived from the ratio value.
        */
        new (s:number,r:number,v:yfiles.algorithms.YVector,p:number,aRatio:number):yfiles.layout.SliderEdgeLabelLayoutModel;
      };
    };
    /**
    * Layout stage that can be used to fix the position of either a <em>single</em>
    * node or the alignment of the bounding box of several nodes (but not the
    * positions of the individual nodes).
    */
    export interface FixNodeLayoutStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * The fix point calculation policy used in
      * {@link yfiles.layout.FixNodeLayoutStage#calculateFixPoint} to determine which
      * point in the corresponding rectangle should be considered fixed.
      * <p>
      * By default, {@link yfiles.layout.FixPointPolicy#CENTER} is used.
      * </p>
      * @see {@link yfiles.layout.FixPointPolicy#CENTER}
      * @see {@link yfiles.layout.FixPointPolicy#UPPER_LEFT}
      * @see {@link yfiles.layout.FixPointPolicy#UPPER_RIGHT}
      * @see {@link yfiles.layout.FixPointPolicy#LOWER_RIGHT}
      * @see {@link yfiles.layout.FixPointPolicy#LOWER_LEFT}
      */
      fixPointPolicy:yfiles.layout.FixPointPolicy;
      /**
      * Determines whether or not subgraph edges should be taken into account
      * when calculating the bounding box of the fixed nodes.
      * <p>
      * By default, this property is set to <code>false</code>, i.e. subgraph
      * edges are not taken into account.
      * </p>
      * @see {@link yfiles.layout.FixNodeLayoutStage#calculateBounds}
      * @see {@link yfiles.layout.FixNodeLayoutStage#calculateBounds}
      */
      includingEdges:boolean;
      /**
      * Determines whether or not label geometries should be taken into account
      * when calculating the bounding box of the fixed nodes.
      * <p>
      * By default, this property is set to <code>false</code>, i.e. label
      * geometries are not taken into account.
      * </p>
      * @see {@link yfiles.layout.FixNodeLayoutStage#calculateBounds}
      * @see {@link yfiles.layout.FixNodeLayoutStage#calculateBounds}
      */
      includingLabels:boolean;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Calculates the fix point for the specified nodes in the specified graph.
      * The default implementation calls
      * {@link yfiles.layout.FixNodeLayoutStage#calculateBounds} and
      * {@link yfiles.layout.FixNodeLayoutStage#calculateFixPoint}.
      * @param {yfiles.layout.LayoutGraph} graph the graph associated to the specified nodes.
      * @param {yfiles.algorithms.NodeList} fixed the list of nodes for which a fix point has to be determined.
      * @return {yfiles.algorithms.YPoint} the fix point for the specified nodes in the specified graph.
      */
      calculateFixPointForNodes(graph:yfiles.layout.LayoutGraph,fixed:yfiles.algorithms.NodeList):yfiles.algorithms.YPoint;
      /**
      * Calculates the fix point of the specified rectangle according to the policy
      * returned by {@link yfiles.layout.FixNodeLayoutStage#fixPointPolicy}.
      * If the specified rectangle is <code>null</code> or the rectangle has
      * negative <code>width</code> or negative <code>height</code>,
      * <code>null</code> will be returned.
      * @param {yfiles.algorithms.Rectangle2D} bounds the rectangle for which to determine the fix point.
      * @return {yfiles.algorithms.YPoint} 
      * the fix point of the specified rectangle or <code>null</code> if
      * nothing should be fixed.
      * @see {@link yfiles.layout.FixNodeLayoutStage#fixPointPolicy}
      */
      calculateFixPoint(bounds:yfiles.algorithms.Rectangle2D):yfiles.algorithms.YPoint;
      /**
      * Calculates the bounding box of the specified nodes.
      * The return values of methods {@link yfiles.layout.FixNodeLayoutStage#includingEdges} and
      * {@link yfiles.layout.FixNodeLayoutStage#includingLabels} determine whether or not edges and labels
      * are taken into account when calculating the box.
      * @param {yfiles.layout.LayoutGraph} graph the graph associated to the specified nodes.
      * @param {yfiles.algorithms.NodeList} fixed the list of nodes that determine the bounding box.
      * @return {yfiles.algorithms.Rectangle2D} the bounding box of the specified nodes.
      * @see {@link yfiles.layout.FixNodeLayoutStage#includingEdges}
      * @see {@link yfiles.layout.FixNodeLayoutStage#includingLabels}
      */
      calculateBounds(graph:yfiles.layout.LayoutGraph,fixed:yfiles.algorithms.NodeList):yfiles.algorithms.Rectangle2D;
    }
    var FixNodeLayoutStage:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key to specify a <code>DataProvider</code>
      * whose {@link yfiles.algorithms.IDataProvider#getBool} method is used to
      * determine which nodes should be considered fixed.
      */
      FIXED_NODE_DP_KEY:Object;
      /**
      * Initializes a new <code>FixNodeLayoutStage</code>.
      */
      new ():yfiles.layout.FixNodeLayoutStage;
      /**
      * Initializes a new <code>FixNodeLayoutStage</code>.
      * @param {yfiles.layout.ILayouter} core the core layout algorithm for this stage.
      */
      WithCoreLayouter:{
        new (core:yfiles.layout.ILayouter):yfiles.layout.FixNodeLayoutStage;
      };
    };
    /**
    * An edge label model that allows placement of labels at a set of continuous positions
    * along both sides of an edge or directly on the edge path.
    * <p>
    * The set of positions can be influenced by specifying the density value that controls
    * the spacing between adjacent label positions.
    * Furthermore, it's possible to specify distance values that control the distance
    * between label and edge and between label and nodes.
    * </p>
    */
    export interface RotatedSliderEdgeLabelLayoutModel extends Object,yfiles.layout.IEdgeLabelModel{
      /**
      * The model's slider mode.
      */
      mode:yfiles.layout.RotatedSliderMode;
      /**
      * A value indicating whether the distance to the edge is interpreted
      * relatively to the edge's path.
      * If this value is set, the label is placed
      * to the left of the edge segment (relative to the segment direction) if
      * <code>distance</code> is less than <code>0</code> and to the right of the
      * edge segment if <code>distance</code> is greater than <code>0</code>.
      * If this value is not set, the label is placed below the edge segment (in
      * geometric sense) if <code>distance</code> ls less than <code>0</code> and
      * above the edge segment if <code>distance</code> is greater than
      * <code>0</code>.
      * <p>
      * The default value is <code>true</code>.
      * </p>
      * @see {@link yfiles.layout.RotatedSliderEdgeLabelLayoutModel#distance}
      * @see {@link yfiles.layout.RotatedSliderEdgeLabelLayoutModel#distance}
      */
      distanceRelativeToEdge:boolean;
      /**
      * The distance between the label's box and the edge's path.
      * The interpretation of positive/negative values depends on property
      * {@link yfiles.layout.RotatedSliderEdgeLabelLayoutModel#distanceRelativeToEdge  distanceRelativeToEdge}.
      * @see {@link yfiles.layout.RotatedSliderEdgeLabelLayoutModel#distanceRelativeToEdge}
      * @see {@link yfiles.layout.RotatedSliderEdgeLabelLayoutModel#distanceRelativeToEdge}
      * @see {@link yfiles.layout.RotatedSliderEdgeLabelLayoutModel#distanceRelativeToEdge}
      * @see {@link yfiles.layout.RotatedSliderEdgeLabelLayoutModel#distanceRelativeToEdge}
      */
      distance:number;
      /**
      * Specifies whether or not edge labels are automatically rotated according to
      * the angle of the corresponding reference edge segment.
      * <p>
      * By default, this feature is enabled.
      * </p>
      */
      autoRotationEnabled:boolean;
      /**
      * Determines whether or not edge labels get flipped if they would be upside down in their current position.
      * <p>
      * By default, this feature is disabled.
      * </p>
      */
      autoFlipping:boolean;
      /**
      * The angle (measured in radians) of the label model.
      * The angle is applied in clockwise direction.
      */
      angle:number;
      /**
      * A model parameter that encodes the default position of this model's
      * allowed edge label positions.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#defaultParameter}.
      */
      defaultParameter:Object;
      /**
      * Returns the bounds of the label for the position encoded
      * by the given model parameter.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label that should be placed.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @param {Object} param 
      * The model parameter that describes the abstract position of the label within
      * this model.
      * The parameter must have been generated by this model.
      * @return {yfiles.algorithms.YOrientedRectangle} The bounds of the label.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}.
      */
      getLabelPlacement(labelSize:yfiles.algorithms.YDimension,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout,para:Object):yfiles.algorithms.YOrientedRectangle;
      /**
      * Returns a list of candidate positions for the given edge label.
      * The number of candidates and their respective locations are computed depending
      * on the geometries of both label and edge.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelCandidates}.
      */
      getLabelCandidates(label:yfiles.layout.IEdgeLabelLayout,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):yfiles.algorithms.YList;
      /**
      * Creates a model parameter that represents the given edge label context best
      * within this model.
      * The created model parameter represents the closest parameter representation
      * of the given label location that can be achieved within this model.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBounds The bounds of the label for which a parameter representation is sought.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @return {Object} 
      * A model parameter that can be passed to the
      * {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}
      * method.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#createModelParameter}.
      */
      createModelParameter(labelBounds:yfiles.algorithms.YOrientedRectangle,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):Object;
    }
    var RotatedSliderEdgeLabelLayoutModel:{
      $class:yfiles.lang.Class;
      /**
      * Returns a new instance of RotatedSliderEdgeLabelModel.
      * @param {yfiles.layout.RotatedSliderMode} mode 
      * Determines which slider mode to use.
      * Possible values are {@link yfiles.layout.RotatedSliderMode#CENTER}, {@link yfiles.layout.RotatedSliderMode#SINGLE_SIDE} or {@link yfiles.layout.RotatedSliderMode#SIDE}.
      */
      new (mode:yfiles.layout.RotatedSliderMode):yfiles.layout.RotatedSliderEdgeLabelLayoutModel;
    };
    /**
    * Provides geometric transforms for (sub-)graphs.
    * This module provides the following kinds of geometric transforms
    * on graphs or subgraphs.
    * <ul>
    * <li>Mirroring along X-axis</li>
    * <li>Mirroring along Y-axis</li>
    * <li>Rotation by angle</li>
    * <li>Scaling by factor. (Node size scaling optional)</li>
    * <li>Translating</li>
    * </ul>
    * <p>
    * Here is an sample output of the layouter that rotated the inner
    * nine nodes of the grid by 45 degrees.
    * </p>
    * <center><img src="doc-files/y.layout.transformer.GraphTransformer.gif" border="1"/></center>
    */
    export interface GraphTransformer extends yfiles.layout.CanonicMultiStageLayouter,yfiles.layout.ILayoutStage{
      /**
      * The core layouter.
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
      /**
      * Specifies whether or not ComponentLayouter is enabled.
      * By default it is disabled.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#componentLayouterEnabled}
      */
      componentLayouterEnabled:boolean;
      /**
      * The transformation operation this layouter performs.
      * <p>
      * By default the <code>SCALE</code> operation is set.
      * </p>
      * @see {@link yfiles.layout.OperationType#MIRROR_XAXIS}
      * @see {@link yfiles.layout.OperationType#MIRROR_YAXIS}
      * @see {@link yfiles.layout.OperationType#ROTATE}
      * @see {@link yfiles.layout.OperationType#SCALE}
      * @see {@link yfiles.layout.OperationType#TRANSLATE}
      */
      operation:yfiles.layout.OperationType;
      /**
      * The angle of rotation.
      * The angle must be given in degrees.
      * This feature is only meaningful for the <code>ROTATE</code> operation.
      * <p>
      * By default the rotation angle is <code>0.0</code>.
      * </p>
      */
      rotationAngle:number;
      /**
      * Specifies whether or not the best fit rotation angle will be applied.
      * Also, to apply the best fit rotation
      * angle, the operation type of this layouter must be set to {@link yfiles.layout.OperationType#ROTATE}.
      * <p>
      * Use {@link yfiles.layout.GraphTransformer#setPreferedLayoutSize} to specify the preferred
      * aspect ratio of the resulting layout.
      * </p>
      */
      bestFitRotationEnabled:boolean;
      /**
      * Sets the preferred layout size for this layouter.
      */
      setPreferedLayoutSize(width:number,height:number):void;
      /**
      * Specifies whether or not to scale node sizes.
      * <p>
      * By default this feature is disabled.
      * </p>
      */
      scaleNodeSize:boolean;
      /**
      * The uniform scaling factor used for the <code>SCALE</code>
      * operation.
      * <p>
      * By default the scaling factor is set to <code>1.0</code>
      * </p>
      */
      scaleFactor:number;
      /**
      * Sets the scaling factors for the x-coordinates and y-coordinates
      * used for the <code>SCALE</code> operation.
      * <p>
      * By default the scaling factors are set to <code>1.0</code>
      * </p>
      */
      setScaleFactors(xFactor:number,yFactor:number):void;
      /**
      * The scaling factor used for the y-coordinate.
      */
      scaleFactorY:number;
      /**
      * The scaling factor used for the x-coordinate.
      */
      scaleFactorX:number;
      /**
      * The horizontal translation distance.
      * A positive value
      * means the graph is moved to the right; a negative value means the graph
      * is moved to the left. Defaults to <code>0</code>.
      * @see {@link yfiles.layout.GraphTransformer#translateY}
      * @see {@link yfiles.layout.GraphTransformer#translateY}
      * @see {@link yfiles.layout.OperationType#TRANSLATE}
      * @see {@link yfiles.layout.GraphTransformer#operation}
      * @see {@link yfiles.layout.GraphTransformer#translateY}
      * @see {@link yfiles.layout.GraphTransformer#translateY}
      * @see {@link yfiles.layout.OperationType#TRANSLATE}
      * @see {@link yfiles.layout.GraphTransformer#operation}
      */
      translateX:number;
      /**
      * The vertical translation distance.
      * A positive value
      * means the graph is moved downwards; a negative value means the graph
      * is moved upwards. Defaults to <code>0</code>.
      * @see {@link yfiles.layout.GraphTransformer#translateX}
      * @see {@link yfiles.layout.GraphTransformer#translateX}
      * @see {@link yfiles.layout.OperationType#TRANSLATE}
      * @see {@link yfiles.layout.GraphTransformer#operation}
      * @see {@link yfiles.layout.GraphTransformer#translateX}
      * @see {@link yfiles.layout.GraphTransformer#translateX}
      * @see {@link yfiles.layout.OperationType#TRANSLATE}
      * @see {@link yfiles.layout.GraphTransformer#operation}
      */
      translateY:number;
      /**
      * Returns always <code>true</code>.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Performs the selected transformation.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
    }
    var GraphTransformer:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of graph transformer.
      */
      new ():yfiles.layout.GraphTransformer;
      /**
      * Performs a rotation of the given graph such that its
      * resulting bounding box (approximately) fits best to
      * the given area bounds.
      */
      applyBestFitRotationAngle(graph:yfiles.layout.LayoutGraph,width:number,height:number):number;
      /**
      * Returns a rotation angle that, if applied to the given graph,
      * would minimize the zoom-level needed to display the graph in
      * an area of the given dimension.
      */
      findBestFitRotationAngle(graph:yfiles.layout.LayoutGraph,width:number,height:number):number;
      /**
      * Scales the coordinates of the given graph in such a way
      * that the resulting bounding box of the graph approximately equals
      * the bounds of the given rectangle.
      * <p>
      * Note that this operation won't have any effects, if there is
      * only one node in the graph or if there are nodes that are bigger
      * than the requested bounding box size.
      * </p>
      * <p>
      * The x- and y-scaling factors are returned
      * in a double array of size 2.
      * The first value of the array is the x-scaling factor
      * that has was used and the second value is the y-scaling
      * factor.
      * </p>
      */
      scaleToRect(g:yfiles.layout.LayoutGraph,rect:yfiles.algorithms.Rectangle):number[];
      /**
      * Assures that the given graph fits into the given rectangular bounds.
      * If the bounding box fits in the rectangle, nothing is done.
      * Otherwise the graph is scaled and optionally moved to fit.
      * This algorithm does not modify the node's sizes.
      * Note that this operation won't have any effects,
      * if there are nodes that are bigger
      * than the requested bounding box size.
      * @param {yfiles.layout.LayoutGraph} graph the graph to modify
      * @param {number} x the upper left x coordinate of the bounds
      * @param {number} y the upper left y coordinate of the bounds
      * @param {number} w the width of the bounds
      * @param {number} h the height of the bounds
      */
      setMaximalBounds(graph:yfiles.layout.LayoutGraph,x:number,y:number,w:number,h:number):void;
      /**
      * Translates the layout coordinates by the vector <code>(dx,dy)</code>.
      */
      translate(g:yfiles.layout.LayoutGraph,dx:number,dy:number):void;
    };
    /**
    * This class contains algorithms which allow for zooming parts of a diagram only
    * in a so-called fish-eye (radial) style.
    * This type of zoom however will not
    * introduce new bends for edges but will move the node centers and bends only.
    */
    export interface GraphZoomer extends Object,yfiles.layout.ILayouter{
      /**
      * Adds a zoom operation to the list of operations to be performed on the graph
      * during the doLayout phase.
      * @param {yfiles.algorithms.YPoint} center the center of the zoom
      * @param {number} innerRadius 
      * the radius of the circle around the center inside which the zoom level is
      * constantly set to <code>zoomFactor</code>
      * @param {number} outerRadius 
      * the radius of the outer circle around the center outside of which the zoomFactor
      * should be unchanged. This value must be greater than innerRadius
      * @param {number} zoomFactor the zoomFactor inside the inner circle
      */
      addRadialZoom(center:yfiles.algorithms.YPoint,innerRadius:number,outerRadius:number,zoomFactor:number):void;
      /**
      * Adds a zoom operation to the list of operations performed during the doLayout
      * phase.
      * This performs a zoom on a rectangular shape using the given radii and the
      * ratio defining the rectangle.
      * @param {yfiles.algorithms.YPoint} center the center of the zoom
      * @param {number} innerRadius 
      * the radius of the rectangular shape around the center inside which the zoom level is
      * constantly set to <code>zoomFactor</code>
      * @param {number} outerRadius 
      * the radius of the outer rectangular shape around the center outside of which the zoomFactor
      * should be unchanged. This value must be greater than innerRadius
      * @param {number} zoomFactor the zoomFactor inside the inner rectangle
      */
      addRectangularZoom(center:yfiles.algorithms.YPoint,innerRadius:number,outerRadius:number,ratio:number,zoomFactor:number):void;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as it's argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Assigns a new graph layout to the given layout graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    export module GraphZoomer{
      /**
      * This interface can be implemented for custom zoom types.
      */
      export interface IZoom extends Object{
        /**
        * This method take a Point2D as an argument, modifies it according to its
        * zoom policy and writes the modification back to the argument.
        * @see Specified by {@link yfiles.layout.GraphZoomer.IZoom#modifyPosition}.
        */
        modifyPosition(position:yfiles.algorithms.Point2D.Double):void;
      }
    }
    var GraphZoomer:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of <code>GraphZoomer</code>.
      */
      new ():yfiles.layout.GraphZoomer;
      /**
      * Convenience method which applies a radial zoom to the graph.
      */
      zoomRadial(graph:yfiles.layout.LayoutGraph,centerX:number,centerY:number,innerRadius:number,outerRadius:number,zoomFactor:number):void;
      /**
      * Convenience method which applies a rectangular zoom to the graph.
      */
      zoomRectangular(graph:yfiles.layout.LayoutGraph,centerX:number,centerY:number,innerRadius:number,outerRadius:number,ratio:number,zoomFactor:number):void;
      /**
      * Convenience method which applies a custom zoom to the graph.
      */
      zoom(graph:yfiles.layout.LayoutGraph,zoom:yfiles.layout.GraphZoomer.IZoom):void;
    };
    export enum OperationType{
      /**
      * Operation type constant. Specifies that the graph should be
      * mirrored along the x-axis.
      * @see {@link yfiles.layout.GraphTransformer#operation}
      * @see {@link yfiles.layout.GraphTransformer#operation}
      */
      MIRROR_XAXIS,
      /**
      * Operation type constant. Specifies that the graph should be
      * mirrored along the y-axis.
      * @see {@link yfiles.layout.GraphTransformer#operation}
      * @see {@link yfiles.layout.GraphTransformer#operation}
      */
      MIRROR_YAXIS,
      /**
      * Operation type constant. Specifies that the graph should be
      * rotated.
      * @see {@link yfiles.layout.GraphTransformer#operation}
      * @see {@link yfiles.layout.GraphTransformer#operation}
      */
      ROTATE,
      /**
      * Operation type constant. Specifies that the graph should be
      * scaled.
      * @see {@link yfiles.layout.GraphTransformer#operation}
      * @see {@link yfiles.layout.GraphTransformer#operation}
      */
      SCALE,
      /**
      * Operation type constant. Specifies that the graph should be
      * translated.
      * @see {@link yfiles.layout.GraphTransformer#operation}
      * @see {@link yfiles.layout.GraphTransformer#operation}
      */
      TRANSLATE
    }
    /**
    * A layout stage that filters out all graph elements
    * that are not part of a subgraph that is induced by
    * the selected nodes of the input graph.
    */
    export interface SubgraphLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * The <code>DataProvider</code> key which determines the nodes that
      * induce the subgraph to be laid out.
      * <p>
      * By default, {@link yfiles.layout.LayouterKeys#SELECTED_NODES_DP_KEY} is used.
      * </p>
      * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
      */
      subgraphNodesDpKey:Object;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
    }
    var SubgraphLayouter:{
      $class:yfiles.lang.Class;
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.layout.SubgraphLayouter;
      };
      new ():yfiles.layout.SubgraphLayouter;
    };
    /**
    * Helper class for swimlanes.
    */
    export interface Swimlanes extends Object{
    }
    export module Swimlanes{
      /**
      * Class that internally represents a swim lane.
      */
      export interface SwimlaneRepresentant extends Object{
        /**
        * The current position of the represented swim lane.
        * @see {@link yfiles.layout.Swimlanes.SwimlaneRepresentant#allowRearrangement}
        * @see {@link yfiles.layout.Swimlanes.SwimlaneRepresentant#allowRearrangement}
        */
        swimlanePos:number;
        /**
        * Specifies whether the represented swim lane can be rearranged.
        * For all swim lanes with rearrangement set to <code>false</code>, the relative ordering given by {@link yfiles.layout.Swimlanes.SwimlaneRepresentant#swimlanePos} is preserved. The remaining swim lanes may be rearranged.
        * @see {@link yfiles.layout.Swimlanes.SwimlaneRepresentant#swimlanePos}
        */
        allowRearrangement:boolean;
      }
    }
    var Swimlanes:{
      $class:yfiles.lang.Class;
      SwimlaneRepresentant:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of <code>SwimlaneRepresentant</code>.
        * @param {number} swimlanePos denotes the current position of the represented swim lane.
        * @param {boolean} allowRearrangement 
        * <code>true</code> if the represented swim lane may be rearranged (see {@link yfiles.layout.Swimlanes.SwimlaneRepresentant#allowRearrangement})
        */
        new (swimlanePos:number,allowRearrangement:boolean):yfiles.layout.Swimlanes;
      };
      /**
      * Calculates an ordering of the swim lanes such that:
      * 1) the number of swim lanes traversed by edges is reduced.
      * 2) the number of swim lanes spanned by group nodes (see
      * {@link yfiles.layout.GraphGrouping}) is reduced. (Note, that a group node can span a swim lane without having a
      * descendant in it.)
      * @param {yfiles.algorithms.Graph} graph the input graph.
      * @param {yfiles.algorithms.IDataProvider} node2Swimlane 
      * a DataProvider assigning an object of class {@link yfiles.layout.Swimlanes.SwimlaneRepresentant} to each node in the
      * graph. Two nodes v,w are in the same swim lane if they are assigned to the same swim lane
      * representative. After calling this method, method {@link yfiles.layout.Swimlanes.SwimlaneRepresentant#swimlanePos}
      * returns for each swim lane representative an integer value (>= 0) denoting the optimized
      * position of the associated swim lane.
      * @see {@link yfiles.layout.Swimlanes.SwimlaneRepresentant}
      * @see {@link yfiles.layout.GraphGrouping}
      */
      arrangeSwimlanes(graph:yfiles.algorithms.Graph,node2Swimlane:yfiles.algorithms.IDataProvider):void;
      /**
      * Calculates an ordering of the swim lanes such that:
      * 1) the number of swim lanes traversed by edges is reduced.
      * 2) the number of swim lanes spanned by group nodes (see
      * {@link yfiles.layout.GraphGrouping}) is reduced. (Note, that a group node can span a swim lane without having a
      * descendant in it.)
      * @param {yfiles.algorithms.Graph} graph the input graph.
      * @param {yfiles.algorithms.IDataProvider} node2Swimlane 
      * a DataProvider assigning an object of class {@link yfiles.layout.Swimlanes.SwimlaneRepresentant} to each node in the
      * graph. Two nodes v,w are in the same swim lane if they are assigned to the same swim lane
      * representative. After calling this method, method {@link yfiles.layout.Swimlanes.SwimlaneRepresentant#swimlanePos}
      * returns for each swim lane representative an integer value (>= 0) denoting the optimized
      * position of the associated swim lane.
      * @param {number} iterations the number of iterations performed by the heuristic. The default value is 5.
      * @param {yfiles.layout.SwimlanesMode} mode 
      * swim lane ordering mode specifier. Possible values are {@link yfiles.layout.SwimlanesMode#MIXED} (default), {@link yfiles.layout.SwimlanesMode#ONLY_GROUPS} and {@link yfiles.layout.SwimlanesMode#IGNORE_GROUPS}.
      * @see {@link yfiles.layout.Swimlanes.SwimlaneRepresentant}
      * @see {@link yfiles.layout.GraphGrouping}
      */
      arrangeSwimlanesWithOrderingMode(graph:yfiles.algorithms.Graph,node2Swimlane:yfiles.algorithms.IDataProvider,iterations:number,mode:yfiles.layout.SwimlanesMode):void;
    };
    /**
    * An rotated edge label model that allows placement of rotated labels at some positions along an edge.
    * <p>
    * It's possible to specify a distance value that controls the distance between the label and edge.
    * Furthermore, there's the possibility to mask out* arbitrary edge label candidates. This can either be done by
    * specifying predefined candidate masks or by OR-ing allowed label candidates to a user defined mask.
    * </p>
    */
    export interface RotatedDiscreteEdgeLabelLayoutModel extends Object,yfiles.layout.IEdgeLabelModel{
      /**
      * The bit mask specifying the valid positions for edge labels.
      * <p>
      * Defaults to {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#SIX_POS}.
      * </p>
      */
      candidateMask:yfiles.layout.RotatedDiscreteEdgeLabelPosition;
      /**
      * Specifies whether or not the label position mask should be interpreted relative to the edge segment.
      * If this value is set to false (default value), the position mask is interpreted in a geometric sense.
      * Note: this option is only relevant for non-center positions.
      */
      positionRelativeToSegment:boolean;
      /**
      * Specifies whether or not edge labels are automatically rotated
      * according to the angle of the corresponding reference edge segment.
      * <p>
      * By default, this feature is enabled.
      * </p>
      */
      autoRotationEnabled:boolean;
      /**
      * Determines whether or not edge labels get flipped if they would be upside down in their current position.
      * <p>
      * By default, this feature is disabled.
      * </p>
      */
      autoFlipping:boolean;
      /**
      * The angle (measured in radians) of the label model.
      * The angle is applied in clockwise direction.
      */
      angle:number;
      /**
      * The distance between the label's box and the edge's path.
      */
      distance:number;
      /**
      * A model parameter that encodes the default position of this model's allowed edge label positions.
      * Default positions are (in descending order):
      * <ul>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#CENTER}</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#SCENTER}</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#TAIL}</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#STAIL}</li>
      * </ul>
      * Descending order means that whenever two or more of the above default positions
      * are part of the allowed positions, then the model parameter encodes the one that is listed first.
      * Note that the model parameter encodes {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#CENTER} when none of the above
      * default positions is part of the allowed positions.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#defaultParameter}.
      */
      defaultParameter:Object;
      /**
      * Creates a model parameter that represents the given edge label context best
      * within this model.
      * The created model parameter represents the closest parameter representation
      * of the given label location that can be achieved within this model.
      * @param {yfiles.algorithms.YOrientedRectangle} labelBounds The bounds of the label for which a parameter representation is sought.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @return {Object} 
      * A model parameter that can be passed to the
      * {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}
      * method.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#createModelParameter}.
      */
      createModelParameter(labelBounds:yfiles.algorithms.YOrientedRectangle,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):Object;
      /**
      * Checks if the given model parameter encodes an edge label position that is
      * valid in this model.
      * @param {Object} parameter the model parameter to check.
      * @return {boolean} 
      * <code>true</code> if the specified object is a valid parameter
      * for this model and encodes a valid position according to this model's
      * {@link yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel#candidateMask  candidate mask}; <code>false</code> otherwise.
      */
      isParameterValid(parameter:Object):boolean;
      /**
      * Returns the bounds of the label for the position encoded
      * by the given model parameter.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label that should be placed.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @param {Object} param 
      * The model parameter that describes the abstract position of the label within
      * this model.
      * The parameter must have been generated by this model.
      * @return {yfiles.algorithms.YOrientedRectangle} The bounds of the label.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelPlacement}.
      */
      getLabelPlacement(labelSize:yfiles.algorithms.YDimension,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout,param:Object):yfiles.algorithms.YOrientedRectangle;
      /**
      * Returns a list of {@link yfiles.layout.EdgeLabelCandidate} objects each of which describes
      * a valid label position within this model.
      * @param {yfiles.layout.IEdgeLabelLayout} labelLayout The label for which candidates should be generated.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceLayout The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetLayout The layout of the target node of the label owning edge.
      * @return {yfiles.algorithms.YList} 
      * A list of {@link yfiles.layout.EdgeLabelCandidate} objects.
      * @see Specified by {@link yfiles.layout.IEdgeLabelModel#getLabelCandidates}.
      */
      getLabelCandidates(label:yfiles.layout.IEdgeLabelLayout,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout):yfiles.algorithms.YList;
      /**
      * Returns the coordinates of the upper-left corner of the given label position.
      * @param {yfiles.algorithms.YDimension} labelSize The size of the label that should be placed.
      * @param {yfiles.layout.IEdgeLayout} edgeLayout The layout of the edge to which the label belongs.
      * @param {yfiles.layout.INodeLayout} sourceNode The layout of the source node of the label owning edge.
      * @param {yfiles.layout.INodeLayout} targetNode The layout of the target node of the label owning edge.
      * @param {yfiles.layout.DiscreteEdgeLabelPosition} pos 
      * A label position (given by a symbolic position specifier) that is valid in
      * this model.
      * @return {yfiles.algorithms.YOrientedRectangle} The coordinates of the upper-left corner of a label position.
      */
      getLabelPlacementAtPosition(labelSize:yfiles.algorithms.YDimension,edgeLayout:yfiles.layout.IEdgeLayout,sourceNode:yfiles.layout.INodeLayout,targetNode:yfiles.layout.INodeLayout,pos:yfiles.layout.DiscreteEdgeLabelPosition):yfiles.algorithms.YOrientedRectangle;
    }
    var RotatedDiscreteEdgeLabelLayoutModel:{
      $class:yfiles.lang.Class;
      /**
      * Returns a new instance of RotatedDiscreteEdgeLabelModel.
      * Position mask {@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#SIX_POS} is used to define the allowed positions for
      * an edge label.
      */
      new ():yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel;
      /**
      * Returns a new instance of RotatedDiscreteEdgeLabelModel.
      * @param {yfiles.layout.RotatedDiscreteEdgeLabelPosition} candidateMask Position mask that defines the allowed positions for an edge label.
      */
      WithPosition:{
        new (candidateMask:yfiles.layout.RotatedDiscreteEdgeLabelPosition):yfiles.layout.RotatedDiscreteEdgeLabelLayoutModel;
      };
      /**
      * Returns a model parameter that encodes the specified position.
      * @param {number} position 
      * one of
      * <ul>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#SHEAD},</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#HEAD},</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#THEAD},</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#STAIL},</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#TAIL},</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#TTAIL},</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#SCENTER},</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#CENTER},</li>
      * <li>{@link yfiles.layout.RotatedDiscreteEdgeLabelPosition#TCENTER}</li>
      * </ul>
      * @return {Object} a model parameter that encodes the specified position.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified position is not one
      * of the symbolic position constants defined in this class.
      */
      createPositionParameter(position:number):Object;
      /**
      * Returns the symbolic position specifier that is encoded by the specified
      * model parameter.
      * @param {Object} parameter the model parameter that encodes the position.
      * @return {number} 
      * the symbolic position specifier that is encoded by the specified
      * model parameter.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified model parameter is not
      * valid for this model.
      */
      getPosition(parameter:Object):number;
    };
    /**
    * This interface defines keys used to associate {@link yfiles.algorithms.IDataProvider  DataProviders} 
    * that provide port constraints for all edges of the input graph.
    * The associated DataProvider can return an object of type 
    * {@link yfiles.layout.PortConstraint} for an edge.
    * LayoutAlgorithms implementing this interface indicate that they will
    * try to obey the port constraints provided by these keys.
    */
    export interface PortConstraintKeys extends Object{
    }
    var PortConstraintKeys:{
      $class:yfiles.lang.Class;
      /**
      * Key used to associate a {@link yfiles.algorithms.IDataProvider} that provides source port
      * constraints for edges of the input graph.
      * The associated DataProvider can return an object of type 
      * {@link yfiles.layout.PortConstraint} for an edge.
      */
      SOURCE_PORT_CONSTRAINT_DP_KEY:Object;
      /**
      * Key used to associate a {@link yfiles.algorithms.IDataProvider} that provides target port
      * constraints for edges of the input graph.
      * The associated DataProvider can return an object of type 
      * {@link yfiles.layout.PortConstraint} for an edge.
      */
      TARGET_PORT_CONSTRAINT_DP_KEY:Object;
      /**
      * Key used to associate a {@link yfiles.algorithms.IDataProvider} that provides source port
      * group information for edges of the input graph.
      * The associated DataProvider can return any object or null.
      * Edge sharing a source group identifier will share a common bus near the source 
      * or at a common source node
      * if possible.
      * null is not interpreted as a group identifier.
      */
      SOURCE_GROUP_ID_DP_KEY:Object;
      /**
      * Key used to associate a {@link yfiles.algorithms.IDataProvider} that provides target port
      * group information for edges of the input graph.
      * The associated DataProvider can return any object or null.
      * Edge sharing a target group identifier will share a common bus near the target 
      * or at a common target node
      * if possible.
      * null is not interpreted as a group identifier.
      */
      TARGET_GROUP_ID_DP_KEY:Object;
    };
    /**
    * Provides configuration services for the port constraints of a graph.
    */
    export interface PortConstraintConfigurator extends Object{
      /**
      * Creates and returns a port constraint for the given edge.
      * The side constraint is setup according to the current drawing of the edge.
      * @param {boolean} source 
      * if <code>true</code> a source port constraint for the given
      * edge will be created, otherwise a target port constraint.
      * @param {boolean} strong 
      * if <code>true</code> a strong port constraint is created,
      * otherwise a weak port constraint is created.
      */
      createPortConstraintFromSketchForEdge(graph:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge,source:boolean,strong:boolean):yfiles.layout.PortConstraint;
      /**
      * Creates weak port constraints for all edges of the given graph.
      * @param {yfiles.algorithms.IEdgeMap} spcMap an edge map that will be used to store the source port constraints of the edges.
      * @param {yfiles.algorithms.IEdgeMap} tpcMap an edge map that will be used to store the target port constraints of the edges.
      */
      createPortConstraintsFromSketchForGraph(graph:yfiles.layout.LayoutGraph,spcMap:yfiles.algorithms.IEdgeMap,tpcMap:yfiles.algorithms.IEdgeMap):void;
      /**
      * Creates port constraints for some edges of the given graph.
      * @param {yfiles.algorithms.IEdgeCursor} ec EdgeCursor that provides access to the edges for which to set port constraints.
      * @param {yfiles.algorithms.IEdgeMap} spcMap an edge map that will be used to store the source port constraints of the edges.
      * @param {boolean} strongSP whether or not to assign strong source port constraints
      * @param {yfiles.algorithms.IEdgeMap} tpcMap an edge map that will be used to store the target port constraints of the edges.
      * @param {boolean} strongTP whether or not to assign strong target port constraints
      */
      createPortConstraintsFromSketchForEdges(graph:yfiles.layout.LayoutGraph,ec:yfiles.algorithms.IEdgeCursor,spcMap:yfiles.algorithms.IEdgeMap,strongSP:boolean,tpcMap:yfiles.algorithms.IEdgeMap,strongTP:boolean):void;
    }
    var PortConstraintConfigurator:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of PortConstraintConfigurator.
      */
      new ():yfiles.layout.PortConstraintConfigurator;
    };
    /**
    * A descriptor that holds preferred placement information for automatic edge labeling.
    * <p>
    * It provides methods to specify
    * <ul>
    * <li>the placement along the edge ({@link yfiles.layout.LabelPlacements#AT_SOURCE}, {@link yfiles.layout.LabelPlacements#AT_CENTER}, {@link yfiles.layout.LabelPlacements#AT_TARGET})</li>
    * <li>the side of the edge ({@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE}, {@link yfiles.layout.LabelPlacements#ON_EDGE}, {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE})</li>
    * <li>the reference of the side ({@link yfiles.layout.LabelSideReference#RELATIVE_TO_EDGE_FLOW}, {@link yfiles.layout.LabelSideReference#ABSOLUTE_WITH_LEFT_IN_NORTH}, {@link yfiles.layout.LabelSideReference#ABSOLUTE_WITH_RIGHT_IN_NORTH})</li>
    * <li>the angle of the label</li>
    * <li>the reference of the angle ({@link yfiles.layout.LabelAngleReference#ABSOLUTE}, {@link yfiles.layout.LabelAngleReference#RELATIVE_TO_EDGE_FLOW})</li>
    * <li>the rotation behavior for label on the right side of the edge ({@link yfiles.layout.LabelAngleOnRightSideRotation#CLOCKWISE}, {@link yfiles.layout.LabelAngleOnRightSideRotation#COUNTER_CLOCKWISE})</li>
    * <li>the angle offset for label on the right side of the edge ({@link yfiles.layout.LabelAngleOnRightSideOffset#NONE}, {@link yfiles.layout.LabelAngleOnRightSideOffset#SEMI})</li>
    * <li>the distance between the label and its edge segment</li>
    * </ul>
    * </p>
    */
    export interface PreferredPlacementDescriptor extends Object{
      /**
      * The preferred placement along the edge.
      * Default is {@link yfiles.layout.LabelPlacements#AT_CENTER}.
      * @throws {yfiles.system.InvalidOperationException} 
      * if this instance is {@link yfiles.layout.PreferredPlacementDescriptor#isFrozen  immutable}.
      */
      placeAlongEdge:yfiles.layout.LabelPlacements;
      /**
      * The preferred side of the edge.
      * Default is {@link yfiles.layout.LabelPlacements#ON_EDGE}.
      * @throws {yfiles.system.InvalidOperationException} 
      * if this instance is {@link yfiles.layout.PreferredPlacementDescriptor#isFrozen  immutable}.
      */
      sideOfEdge:yfiles.layout.LabelPlacements;
      /**
      * Specifies how to interpret the preferred side as given by {@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE} and {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE}.
      * Default is {@link yfiles.layout.LabelSideReference#RELATIVE_TO_EDGE_FLOW}.
      * @throws {yfiles.system.InvalidOperationException} 
      * if this instance is {@link yfiles.layout.PreferredPlacementDescriptor#isFrozen  immutable}.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified value has not at least
      * one of the required bits set.
      */
      sideReference:yfiles.layout.LabelSideReference;
      /**
      * The angle (in radians) for the label rotation.
      * How this angle is applied is specified by {@link yfiles.layout.PreferredPlacementDescriptor#angleReference}, {@link yfiles.layout.PreferredPlacementDescriptor#angleRotationOnRightSide} and {@link yfiles.layout.PreferredPlacementDescriptor#angleOffsetOnRightSide}. Default is
      * 0.
      * @throws {yfiles.system.InvalidOperationException} 
      * if this instance is {@link yfiles.layout.PreferredPlacementDescriptor#isFrozen  immutable}.
      */
      angle:number;
      /**
      * Specifies the reference of the angle given by {@link yfiles.layout.PreferredPlacementDescriptor#angle}.
      * Default is
      * {@link yfiles.layout.LabelAngleReference#ABSOLUTE}.
      * @throws {yfiles.system.InvalidOperationException} 
      * if this instance is {@link yfiles.layout.PreferredPlacementDescriptor#isFrozen  immutable}.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified value has not at least
      * one of the required bits set.
      */
      angleReference:yfiles.layout.LabelAngleReference;
      /**
      * Specifies how the angle is applied to labels on the right side in respect of the labels of the left side of the
      * edge.
      * Default is {@link yfiles.layout.LabelAngleOnRightSideRotation#CLOCKWISE}.
      * @throws {yfiles.system.InvalidOperationException} 
      * if this instance is {@link yfiles.layout.PreferredPlacementDescriptor#isFrozen  immutable}.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified value has not at least
      * one of the required bits set.
      */
      angleRotationOnRightSide:yfiles.layout.LabelAngleOnRightSideRotation;
      /**
      * The angle offset for labels that are placed on the right side of the edge.
      * Default is {@link yfiles.layout.LabelAngleOnRightSideOffset#NONE}.
      * @throws {yfiles.system.InvalidOperationException} 
      * if this instance is {@link yfiles.layout.PreferredPlacementDescriptor#isFrozen  immutable}.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified value has not at least
      * one of the required bits set.
      */
      angleOffsetOnRightSide:yfiles.layout.LabelAngleOnRightSideOffset;
      /**
      * The preferred distance between a label and the corresponding edge segment.
      * If the given distance is &lt; 0, the distance is not fixed, i.e., it is chosen by the automatic labeling algorithm.
      * Default is -1.
      * @throws {yfiles.system.ArgumentException} if the specified value is infinite or NaN.
      * @throws {yfiles.system.InvalidOperationException} 
      * if this instance is {@link yfiles.layout.PreferredPlacementDescriptor#isFrozen  immutable}.
      */
      distanceToEdge:number;
      /**
      * If one of the preferred placements for this label is at source.
      */
      isAtSource:boolean;
      /**
      * If one of the preferred placements for this label is at center.
      */
      isAtCenter:boolean;
      /**
      * If one of the preferred placements for this label is at target.
      */
      isAtTarget:boolean;
      /**
      * If one of the preferred sides for this label is left of the edge.
      */
      isLeftOfEdge:boolean;
      /**
      * If one of the preferred sides for this label is on the edge.
      */
      isOnEdge:boolean;
      /**
      * If one of the preferred sides for this label is right of the edge.
      */
      isRightOfEdge:boolean;
      /**
      * If one of the angle interpretations is to interpret the angle absolute.
      */
      isAngleAbsolute:boolean;
      /**
      * If one of the angle interpretations is to interpret the angle relative to the edge slope.
      */
      isAngleRelativeToEdgeFlow:boolean;
      /**
      * If one of the angle interpretations is to interpret the angle of labels that are right of the edge as
      * co-rotating with the labels left of or centered on edge, i.e.
      * the angle of all labels is interpreted
      * clockwise.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#isRightOfEdge}
      */
      isAngleOnRightSideCoRotating:boolean;
      /**
      * If one of the angle interpretations is to interpret the angle of labels that are right of the edge as
      * counter-rotating with the labels left of or centered on edge, i.e.
      * the angle of labels left or centered on
      * edge is interpreted clockwise while the angle of labels right of edge is interpreted counter-clockwise.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#isRightOfEdge}
      */
      isAngleOnRightSideCounterRotating:boolean;
      /**
      * If one of the angle interpretations is to add no additional angle offset to labels that are right of the
      * edge.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#isRightOfEdge}
      */
      isAngleOffsetOnRightSideZero:boolean;
      /**
      * If one of the angle interpretations is to add an additional angle offset of 180 degree to labels that are
      * right of the edge.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#isRightOfEdge}
      */
      isAngleOffsetOnRightSide180:boolean;
      /**
      * If the preferred side specified by{@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE} and {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE} is interpreted relative to the edge flow.
      */
      isSideRelativeToEdgeFlow:boolean;
      /**
      * If the preferred side specified by{@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE} and {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE} is interpreted absolute and on horizontal segments, labels with preferred
      * side {@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE} are placed above the segment.
      */
      isSideAbsoluteWithLeftInNorth:boolean;
      /**
      * If the preferred side specified by{@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE} and {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE} is interpreted absolute and on horizontal segments, labels with preferred
      * side {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE} are placed above the segment.
      */
      isSideAbsoluteWithRightInNorth:boolean;
      toString():string;
      equals(o:Object):boolean;
      hashCode():number;
      /**
      * Returns whether or not this is an immutable descriptor instance.
      * If this instance is immutable, all <code>set</code> methods will throw an
      * {@link yfiles.system.InvalidOperationException} when invoked.
      * @return {boolean} 
      * <code>true</code> if this instance is immutable; <code>false</code>
      * otherwise.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#freeze}
      */
      isFrozen():boolean;
      /**
      * Makes this instance immutable.
      * If this instance is immutable, all <code>set</code> methods will throw an
      * {@link yfiles.system.InvalidOperationException} when invoked.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#isFrozen}
      */
      freeze():void;
    }
    var PreferredPlacementDescriptor:{
      $class:yfiles.lang.Class;
      /**
      * Creates a mutable instance of this descriptor.
      */
      new ():yfiles.layout.PreferredPlacementDescriptor;
      /**
      * Creates a mutable copy of the given PreferredPlacementDescriptor.
      * @param {yfiles.layout.PreferredPlacementDescriptor} descriptor PreferredPlacementDescriptor to make a copy from
      */
      FromDescriptor:{
        new (descriptor:yfiles.layout.PreferredPlacementDescriptor):yfiles.layout.PreferredPlacementDescriptor;
      };
      /**
      * Returns an immutable descriptor instance for the specified placement.
      * Descriptor instances returned by this method will use default values
      * for all properties but {@link yfiles.layout.PreferredPlacementDescriptor#placeAlongEdge  placement along edge}
      * and {@link yfiles.layout.PreferredPlacementDescriptor#sideOfEdge  side of edge}.
      * @param {yfiles.layout.LabelPlacements} placement 
      * an ORed combination of
      * {@link yfiles.layout.LabelPlacements#ANYWHERE}, {@link yfiles.layout.LabelPlacements#AT_SOURCE},
      * {@link yfiles.layout.LabelPlacements#AT_TARGET}, or {@link yfiles.layout.LabelPlacements#AT_CENTER} and
      * {@link yfiles.layout.LabelPlacements#LEFT_OF_EDGE}, {@link yfiles.layout.LabelPlacements#RIGHT_OF_EDGE}, or
      * {@link yfiles.layout.LabelPlacements#ON_EDGE}.
      * @return {yfiles.layout.PreferredPlacementDescriptor} an immutable descriptor instance for the specified placement.
      * @see {@link yfiles.layout.PreferredPlacementDescriptor#isFrozen}
      */
      newSharedInstance(placement:yfiles.layout.LabelPlacements):yfiles.layout.PreferredPlacementDescriptor;
    };
    /**
    * This LayoutStage removes all collinear bends found in the graph.
    * The algorithms traverses each edge path from source
    * to target and removes for each triple of consecutive collinear bends the middle one.
    */
    export interface RemoveColinearBendsStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * The current scale, to which this stage will refer, when checking for collinearity.
      * Default value is 2.0. Which means that values are rounded to the second position after the decimal point.
      * If the rounded values of an edge are leading to a collinear bend, this bend will be removed.
      */
      scale:number;
      /**
      * The current state of the remove straight only property.
      * In the first case, the angle at the middle bend must be 180 degrees, while in the second case, the
      * angle can be either 180 degrees or 0 degree. The default is <code>false</code>.
      */
      removeStraightOnly:boolean;
      /**
      * Removes collinear bends of the edges.
      * @param {yfiles.layout.LayoutGraph} graph the graph
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var RemoveColinearBendsStage:{
      $class:yfiles.lang.Class;
      new ():yfiles.layout.RemoveColinearBendsStage;
    };
  }
  export module licensing{
  }
  export module multipage{
    /**
    * A class that holds all information related to an edge.
    */
    export interface IEdgeInfo extends Object{
      /**
      * The unique id of the related edge.
      * @see Specified by {@link yfiles.multipage.IEdgeInfo#id}.
      */
      id:Object;
      /**
      * The type of the related edge.
      * @see Specified by {@link yfiles.multipage.IEdgeInfo#type}.
      */
      type:yfiles.multipage.EdgeType;
      /**
      * The original edge.
      * That is, for edges of type {@link yfiles.multipage.EdgeType#CONNECTOR},
      * the edge of the input graph that was split by the connector edge is
      * returned.
      * @see {@link yfiles.multipage.EdgeType#CONNECTOR}
      * @see Specified by {@link yfiles.multipage.IEdgeInfo#representedEdge}.
      */
      representedEdge:yfiles.algorithms.Edge;
    }
    var IEdgeInfo:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Factory used by class {@link yfiles.multipage.MultiPageLayouter} to create special nodes and edges.
    */
    export interface IElementFactory extends Object{
      /**
      * Callback method for creating a node of type {@link yfiles.multipage.NodeType#CONNECTOR}.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createNode} to create the node.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {yfiles.algorithms.YList} edgesIds 
      * a list that contains the ids of edges that are split by this connector. Note: multi-edges
      * (edges connecting the same nodes) may be split by the same connector pair.
      * @param {Object} representedNodeId the id of the node that is represented by this connector.
      * @return {yfiles.algorithms.Node} the created connector node
      * @see {@link yfiles.multipage.NodeType#CONNECTOR}
      * @see {@link yfiles.multipage.LayoutContext#createNode}
      * @see {@link yfiles.multipage.INodeInfo#representedNode}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createConnectorNode}.
      */
      createConnectorNode(context:yfiles.multipage.LayoutContext,edgesIds:yfiles.algorithms.YList,representedNodeId:Object):yfiles.algorithms.Node;
      /**
      * Callback method for creating a node of type {@link yfiles.multipage.NodeType#PROXY_REFERENCE}.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createNode} to create the node.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {Object} referringProxyId the id of the proxy to which the created node refers to.
      * @return {yfiles.algorithms.Node} the new proxy reference node.
      * @see {@link yfiles.multipage.NodeType#PROXY_REFERENCE}
      * @see {@link yfiles.multipage.LayoutContext#createNode}
      * @see {@link yfiles.multipage.NodeType#PROXY}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createProxyReferenceNode}.
      */
      createProxyReferenceNode(context:yfiles.multipage.LayoutContext,referringProxyId:Object):yfiles.algorithms.Node;
      /**
      * Callback method for creating a node of type {@link yfiles.multipage.NodeType#PROXY}.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createNode} to create the node.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {Object} origNodeId the id of the node for which a proxy has to be created.
      * @return {yfiles.algorithms.Node} the proxy.
      * @see {@link yfiles.multipage.LayoutContext#createNode}
      * @see {@link yfiles.multipage.NodeType#PROXY}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createProxyNode}.
      */
      createProxyNode(context:yfiles.multipage.LayoutContext,origNodeId:Object):yfiles.algorithms.Node;
      /**
      * Callback method for creating an edge of type {@link yfiles.multipage.EdgeType#CONNECTOR}.
      * The edge should connect the given connector and opposite node.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createEdge}
      * to create the edge.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {yfiles.algorithms.Node} connector the endpoint of the edge that represents the connector node.
      * @param {yfiles.algorithms.Node} opposite the other endpoint of the edge.
      * @param {Object} origEdgeId the id of the edge that is split by the connector edge.
      * @param {boolean} atTarget whether or not the connector node is the target of the edge.
      * @return {yfiles.algorithms.Edge} the created connector edge.
      * @see {@link yfiles.multipage.EdgeType#CONNECTOR}
      * @see {@link yfiles.multipage.LayoutContext#createEdge}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createConnectorEdge}.
      */
      createConnectorEdge(context:yfiles.multipage.LayoutContext,connector:yfiles.algorithms.Node,opposite:yfiles.algorithms.Node,origEdgeId:Object,atTarget:boolean):yfiles.algorithms.Edge;
      /**
      * Callback method for creating an edge of type {@link yfiles.multipage.EdgeType#PROXY_REFERENCE}.
      * This (undirected) edge should connect the given proxy reference and opposite node.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createEdge}
      * to create the edge.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {yfiles.algorithms.Node} proxyReference 
      * the endpoint of the edge that represents the proxy
      * reference node.
      * @param {yfiles.algorithms.Node} opposite the other endpoint of the new edge.
      * @param {Object} referencingCopyId 
      * the id of the proxy node that is referenced by the
      * proxy reference node.
      * @return {yfiles.algorithms.Edge} the created proxy reference edge.
      * @see {@link yfiles.multipage.EdgeType#PROXY_REFERENCE}
      * @see {@link yfiles.multipage.NodeType#PROXY_REFERENCE}
      * @see {@link yfiles.multipage.LayoutContext#createEdge}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createProxyReferenceEdge}.
      */
      createProxyReferenceEdge(context:yfiles.multipage.LayoutContext,proxyReference:yfiles.algorithms.Node,opposite:yfiles.algorithms.Node,referencingCopyId:Object):yfiles.algorithms.Edge;
      /**
      * Callback method for creating an edge of type {@link yfiles.multipage.EdgeType#PROXY}.
      * The edge should connect the given proxy node and opposite node.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createEdge}
      * to create the edge.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {yfiles.algorithms.Node} proxyNode the endpoint of the edge that represents the proxy node.
      * @param {yfiles.algorithms.Node} opposite the other endpoint of the new edge.
      * @param {Object} replacingEdgeId the id of the related edge that is connected to the original node.
      * @param {Object} origNodeId the id of the original node to which the proxy node refers to.
      * @return {yfiles.algorithms.Edge} the created proxy edge.
      * @see {@link yfiles.multipage.EdgeType#PROXY}
      * @see {@link yfiles.multipage.NodeType#PROXY}
      * @see {@link yfiles.multipage.LayoutContext#createEdge}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createProxyEdge}.
      */
      createProxyEdge(context:yfiles.multipage.LayoutContext,proxyNode:yfiles.algorithms.Node,opposite:yfiles.algorithms.Node,replacingEdgeId:Object,origNodeId:Object):yfiles.algorithms.Edge;
    }
    var IElementFactory:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Interface that offers access to the information objects of graph elements.
    */
    export interface IElementInfoManager extends Object{
      /**
      * Returns the node information object of the given node.
      * @param {yfiles.algorithms.Node} n the node for which the information object should be returned.
      * @return {yfiles.multipage.INodeInfo} the node information object of the given node.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getNodeInfo}.
      */
      getNodeInfo(n:yfiles.algorithms.Node):yfiles.multipage.INodeInfo;
      /**
      * Returns the edge information object of the given edge.
      * @param {yfiles.algorithms.Edge} e the edge for which the information object should be returned.
      * @return {yfiles.multipage.IEdgeInfo} the edge information object of the given edge.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getEdgeInfo}.
      */
      getEdgeInfo(e:yfiles.algorithms.Edge):yfiles.multipage.IEdgeInfo;
      /**
      * Returns the node label layout information object of the given node label layout.
      * @param {yfiles.layout.INodeLabelLayout} nll the node label layout for which the information object should be returned.
      * @return {yfiles.multipage.INodeLabelInfo} the node label information object of the given node label layout.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getNodeLabelInfo}.
      */
      getNodeLabelInfo(nll:yfiles.layout.INodeLabelLayout):yfiles.multipage.INodeLabelInfo;
      /**
      * Returns the edge label information object of the given edge label layout.
      * @param {yfiles.layout.IEdgeLabelLayout} ell the edge label layout for which the information object should be returned.
      * @return {yfiles.multipage.IEdgeLabelInfo} the edge label information object of the given edge label layout.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getEdgeLabelInfo}.
      */
      getEdgeLabelInfo(ell:yfiles.layout.IEdgeLabelLayout):yfiles.multipage.IEdgeLabelInfo;
    }
    var IElementInfoManager:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * A class that holds all information related to an edge label.
    */
    export interface IEdgeLabelInfo extends Object{
      /**
      * The unique id of the related edge label.
      * @see Specified by {@link yfiles.multipage.IEdgeLabelInfo#id}.
      */
      id:Object;
    }
    var IEdgeLabelInfo:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Callback that is invoked when a {@link yfiles.multipage.MultiPageLayouter} has calculated
    * a new multi-page layout.
    */
    export interface ILayoutCallback extends Object{
      /**
      * Invoked from {@link yfiles.multipage.MultiPageLayouter#doLayout}
      * when a new multi-page layout has been calculated.
      * @param {yfiles.multipage.MultiPageLayout} result the result of the layout calculation.
      * @see Specified by {@link yfiles.multipage.ILayoutCallback#layoutDone}.
      */
      layoutDone(result:yfiles.multipage.MultiPageLayout):void;
    }
    var ILayoutCallback:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Represents the result of a layout run of the {@link yfiles.multipage.MultiPageLayouter}.
    */
    export interface MultiPageLayout extends Object,yfiles.multipage.IElementInfoManager{
      /**
      * Returns the number of pages available in this <code>MultiPageLayout</code>.
      * @return {number} the number of available pages.
      * @see {@link yfiles.multipage.MultiPageLayout#getPage}
      */
      pageCount():number;
      /**
      * Returns the layout graph on the given page.
      * @param {number} pageNo 
      * the page for which the layout graph.
      * Allowed value range is <code>0 &lt;= pageNo &lt; pageCount</code>.
      * @return {yfiles.layout.LayoutGraph} the layout graph on the given page.
      * @throws {yfiles.system.IndexOutOfRangeException} 
      * if <code>pageNo &gt;= pageCount</code> or
      * <code>pageNo &lt; 0</code>.
      * @see {@link yfiles.multipage.MultiPageLayout#pageCount}
      */
      getPage(pageNo:number):yfiles.layout.LayoutGraph;
      /**
      * Returns the edge information object of the given edge.
      * @param {yfiles.algorithms.Edge} e the edge for which the information object should be returned.
      * @return {yfiles.multipage.IEdgeInfo} the edge information object of the given edge.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getEdgeInfo}.
      */
      getEdgeInfo(e:yfiles.algorithms.Edge):yfiles.multipage.IEdgeInfo;
      /**
      * Returns the node information object of the given node.
      * @param {yfiles.algorithms.Node} n the node for which the information object should be returned.
      * @return {yfiles.multipage.INodeInfo} the node information object of the given node.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getNodeInfo}.
      */
      getNodeInfo(n:yfiles.algorithms.Node):yfiles.multipage.INodeInfo;
      /**
      * Returns the node label layout information object of the given node label layout.
      * @param {yfiles.layout.INodeLabelLayout} nll the node label layout for which the information object should be returned.
      * @return {yfiles.multipage.INodeLabelInfo} the node label information object of the given node label layout.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getNodeLabelInfo}.
      */
      getNodeLabelInfo(nll:yfiles.layout.INodeLabelLayout):yfiles.multipage.INodeLabelInfo;
      /**
      * Returns the edge label information object of the given edge label layout.
      * @param {yfiles.layout.IEdgeLabelLayout} ell the edge label layout for which the information object should be returned.
      * @return {yfiles.multipage.IEdgeLabelInfo} the edge label information object of the given edge label layout.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getEdgeLabelInfo}.
      */
      getEdgeLabelInfo(ell:yfiles.layout.IEdgeLabelLayout):yfiles.multipage.IEdgeLabelInfo;
    }
    var MultiPageLayout:{
      $class:yfiles.lang.Class;
    };
    /**
    * Layout algorithm that subdivides the input graph into several
    * {@link yfiles.layout.LayoutGraph}s (called page graphs) such that the layout of each graph
    * fits the {@link yfiles.multipage.MultiPageLayouter#maxPageSize 
    *  specified maximum page
    * size
    * }.
    * <p>
    * To guarantee that no information is lost, the layout algorithm replaces edges
    * between nodes on different pages by so-called connector nodes
    * (see {@link yfiles.multipage.NodeType#CONNECTOR}).
    * Furthermore, it may replicate (proxy) nodes and insert elements called proxy
    * reference nodes to refers to such proxies (see {@link yfiles.multipage.NodeType#PROXY}
    * and {@link yfiles.multipage.NodeType#PROXY_REFERENCE}).
    * </p><p>
    * Unlike other yFiles layout algorithms, <code>MultiPageLayouter</code> does
    * not modify its input graph but returns its result as a
    * {@link yfiles.multipage.MultiPageLayout}. To be able to profit as much as
    * possible from existing layout support, <code>MultiPageLayouter</code>
    * implements the {@link yfiles.layout.ILayouter} interface although method
    * {@link yfiles.layout.ILayouter#doLayout  doLayout} does not specify a
    * return value. Therefore client code has to
    * {@link yfiles.multipage.MultiPageLayouter#layoutCallback  register} a {@link yfiles.multipage.ILayoutCallback}
    * that is notified of <code>MultiPageLayouter</code> results.
    * </p><p>
    * <b>Note:</b>
    * Client code must register data providers for keys {@link yfiles.multipage.MultiPageLayouter#NODE_ID_DP_KEY},
    * {@link yfiles.multipage.MultiPageLayouter#EDGE_ID_DP_KEY}, {@link yfiles.multipage.MultiPageLayouter#NODE_LABEL_ID_DP_KEY}, and
    * {@link yfiles.multipage.MultiPageLayouter#EDGE_LABEL_ID_DP_KEY} before calling
    * {@link yfiles.multipage.MultiPageLayouter#doLayout} or
    * {@link yfiles.multipage.MultiPageLayouter#calcLayout}.
    * </p>
    */
    export interface MultiPageLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * Specifies whether or not the specified labeling stage is enabled.
      * By default it is disabled.
      * @see {@link yfiles.multipage.MultiPageLayouter#labelLayouter}
      * @see {@link yfiles.multipage.MultiPageLayouter#labelLayouter}
      */
      labelLayouterEnabled:boolean;
      /**
      * Creates an element factory for multi-page layouts.
      * Called from {@link yfiles.multipage.MultiPageLayouter#elementFactory} if no factory has been explicitly
      * set using {@link yfiles.multipage.MultiPageLayouter#elementFactory}.
      * @return {yfiles.multipage.IElementFactory} 
      * a {@link yfiles.multipage.DefaultElementFactory} instance.
      */
      createElementFactory():yfiles.multipage.IElementFactory;
      /**
      * The element factory that is used to create special nodes and edges
      * in a multi-page layout.
      * @see {@link yfiles.multipage.MultiPageLayouter#createElementFactory}
      * @see {@link yfiles.multipage.IElementFactory}
      * @see {@link yfiles.multipage.MultiPageLayouter#createElementFactory}
      * @see {@link yfiles.multipage.IElementFactory}
      */
      elementFactory:yfiles.multipage.IElementFactory;
      /**
      * The callback that is notified upon completion of multi-page layout
      * calculation runs.
      */
      layoutCallback:yfiles.multipage.ILayoutCallback;
      /**
      * The bit mask that is used to define edge bundles.
      * All multi-edges (edges with same endpoints) belonging to the same edge bundle are
      * split by the same connector pair (see {@link yfiles.multipage.NodeType#CONNECTOR}).
      * Possible values are {@link yfiles.multipage.EdgeBundleMode#DISTINGUISH_TYPES}, {@link yfiles.multipage.EdgeBundleMode#DISTINGUISH_DIRECTIONS} and
      * {@link yfiles.multipage.EdgeBundleMode#DISTINGUISH_MULTI_EDGES}.
      */
      edgeBundleModeMask:yfiles.multipage.EdgeBundleMode;
      /**
      * How to handle node grouping.
      * Possible values are {@link yfiles.multipage.GroupingMode#IGNORE}, {@link yfiles.multipage.GroupingMode#ALL_NODES} and
      * {@link yfiles.multipage.GroupingMode#ORIGINAL_NODES_ONLY}.
      */
      groupMode:yfiles.multipage.GroupingMode;
      /**
      * The preferred time limit (in milliseconds) set for the layout algorithm.
      * Note that restricting the maximal duration may result in a worse layout quality.
      * Furthermore, the actual runtime may exceed the maximal duration since the layout algorithm
      * still has to find a valid solution.
      */
      preferredMaximalDuration:number;
      /**
      * The algorithm that is used for placing labels.
      * <b>Getter:</b>By default an instance of class {@link yfiles.labeling.GreedyMISLabeling} will be returned that considers edge labels only.
      * <b>Setter:</b>Note that assigning a new layout stage will not automatically
      * activate it. To activate this stage use {@link yfiles.multipage.MultiPageLayouter#labelLayouterEnabled}.
      */
      labelLayouter:yfiles.layout.ILayoutStage;
      /**
      * Calculates a new multi-page layout for the specified graph.
      * This method calls {@link yfiles.multipage.MultiPageLayouter#calcLayout} and notifies
      * the registered {@link yfiles.multipage.MultiPageLayouter#layoutCallback  layout callback} of the
      * calculated result.
      * <p>
      * <b>Warning:</b>
      * Unlike other implementations of the
      * {@link yfiles.layout.ILayouter#doLayout} method, the result
      * of the layout calculation will <b>not</b> be applied to the input graph.
      * </p>
      * @param {yfiles.layout.LayoutGraph} graph the input graph.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Calculates a new multi-page layout for the specified graph.
      * @param {yfiles.layout.LayoutGraph} graph the input graph.
      * @return {yfiles.multipage.MultiPageLayout} an object that represents the results of the layout run.
      * @see {@link yfiles.multipage.MultiPageLayout}
      */
      calcLayout(graph:yfiles.layout.LayoutGraph):yfiles.multipage.MultiPageLayout;
      /**
      * Called during a postprocessing step that reduces the number of connectors.
      * A pair of connectors can be removed
      * if both connector nodes are placed on the same page.
      * This method removes both connector nodes and restores the original edges. It calls method
      * {@link yfiles.multipage.MultiPageLayouter#routeRestoredEdges} to route these edges.
      * @param {yfiles.algorithms.Node} connector1 the first connector of the connector pair.
      * @param {yfiles.algorithms.Node} connector2 the second connector of the connector pair.
      * @param {yfiles.algorithms.YList} originalEdgeIds the ids of the original edges that have to be restored.
      * @param {yfiles.multipage.LayoutContext} context the current layout context.
      * @return {boolean} 
      * whether or not the removal of the connector pair was successful.
      * If the method returns false the graph was not changed, i.e., the connector pair was not removed.
      * @see {@link yfiles.multipage.MultiPageLayouter#routeRestoredEdges}
      */
      removeConnectorPair(connector1:yfiles.algorithms.Node,connector2:yfiles.algorithms.Node,originalEdgeIds:yfiles.algorithms.YList,context:yfiles.multipage.LayoutContext):boolean;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * The maximum size allowed for a single page.
      * The default value is width = height = 1000.
      * Note that a large page size may increase runtime significantly.
      * To limit runtime use method {@link yfiles.multipage.MultiPageLayouter#preferredMaximalDuration}.
      * @see {@link yfiles.multipage.MultiPageLayouter#preferredMaximalDuration}
      */
      maxPageSize:yfiles.algorithms.YDimension;
      /**
      * Called to improve layout results.
      * The marked nodes have to be placed without changing the coordinates of the fixed (non-marked) elements,
      * without exceeding the specified maximum page size and without violating basic layout properties.
      * @param {yfiles.layout.LayoutGraph} graph the graph to layout.
      * @param {yfiles.algorithms.IDataProvider} incrementalNodesDP 
      * a DataProvider that marks nodes that should be placed (nodes for which getBool()
      * returns true). The position of the other nodes is not allowed to change.
      * @param {yfiles.multipage.LayoutContext} context the current layout context.
      * @see {@link yfiles.multipage.LayoutContext}
      */
      doIncrementalLayout(graph:yfiles.layout.LayoutGraph,incrementalNodesDP:yfiles.algorithms.IDataProvider,context:yfiles.multipage.LayoutContext):void;
      /**
      * Called by method {@link yfiles.multipage.MultiPageLayouter#removeConnectorPair}
      * to route the restored edges.
      * @param {yfiles.layout.LayoutGraph} graph the relevant graph.
      * @param {yfiles.algorithms.IDataProvider} selectedEdgesDP marks the edges that should be rerouted.
      * @param {yfiles.algorithms.YRectangle} boundingRectangle the edge routes should be fully contained within this rectangle.
      * @see {@link yfiles.multipage.MultiPageLayouter#removeConnectorPair}
      */
      routeRestoredEdges(graph:yfiles.layout.LayoutGraph,selectedEdgesDP:yfiles.algorithms.IDataProvider,boundingRectangle:yfiles.algorithms.YRectangle):void;
    }
    var MultiPageLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Allows to specify a cluster id (an object) for each node.
      * Nodes with the same cluster id should preferably be
      * placed on the same page.
      */
      NODE_CLUSTER_ID_DP_KEY:Object;
      /**
      * Used to map each node of the input graph to a unique id.
      * Note: this DataProvider has to be specified by the user!
      */
      NODE_ID_DP_KEY:Object;
      /**
      * Used to map each edge of the input graph to a unique id.
      * Note: this DataProvider has to be specified by the user!
      */
      EDGE_ID_DP_KEY:Object;
      /**
      * Used to map each edge label of the input graph to a unique id.
      * Note: this DataProvider has to be specified by the user!
      */
      EDGE_LABEL_ID_DP_KEY:Object;
      /**
      * Used to map each node label of the input graph to a unique id.
      * Note: this DataProvider has to be specified by the user!
      */
      NODE_LABEL_ID_DP_KEY:Object;
      /**
      * Allows to specify the edge kind (an object).
      * Multi-edges (edges with same endpoints) of different kind are distinguished if
      * {@link yfiles.multipage.MultiPageLayouter#edgeBundleModeMask} &amp; {@link yfiles.multipage.EdgeBundleMode#DISTINGUISH_TYPES} == 1.
      * @see {@link yfiles.multipage.EdgeBundleMode#DISTINGUISH_TYPES}
      * @see {@link yfiles.multipage.MultiPageLayouter#edgeBundleModeMask}
      */
      EDGE_TYPE_DP_KEY:Object;
      /**
      * Creates an instance of this layouter.
      * @param {yfiles.layout.ILayouter} core the layouter used to layout a page.
      */
      new (core:yfiles.layout.ILayouter):yfiles.multipage.MultiPageLayouter;
    };
    /**
    * Class that represents the layout context.
    */
    export interface LayoutContext extends Object,yfiles.multipage.IElementInfoManager{
      /**
      * All methods of the {@link yfiles.multipage.IElementFactory} have to use this method to create an edge.
      * @param {yfiles.algorithms.Node} source the source of the edge.
      * @param {yfiles.algorithms.Node} target the target of the edge.
      * @param {Object} sameDataElementId 
      * the id of the edge whose data should be copied to the created edge
      * (or null if no data should be copied).
      * @return {yfiles.algorithms.Edge} the created edge.
      * @see {@link yfiles.multipage.IElementFactory}
      */
      createEdge(source:yfiles.algorithms.Node,target:yfiles.algorithms.Node,sameDataElementId:Object):yfiles.algorithms.Edge;
      /**
      * All methods of the {@link yfiles.multipage.IElementFactory} have to use this method to create a node.
      * @param {Object} sameDataElementId 
      * the id of the node whose data should be copied to the created node
      * (or null if no data should be copied).
      * @return {yfiles.algorithms.Node} the created node.
      * @see {@link yfiles.multipage.IElementFactory}
      */
      createNode(sameDataElementId:Object):yfiles.algorithms.Node;
      /**
      * Adds a label to a node.
      * @param {yfiles.layout.INodeLabelLayout} label the label that should be added to the node.
      * @param {yfiles.algorithms.Node} labeledElement the node the label should be added to.
      */
      addNodeLabel(label:yfiles.layout.INodeLabelLayout,labeledElement:yfiles.algorithms.Node):void;
      /**
      * Adds a label to an edge.
      * @param {yfiles.layout.IEdgeLabelLayout} label the label that should be added to the edge.
      * @param {yfiles.algorithms.Edge} labeledElement the edge the label should be added to.
      */
      addEdgeLabel(label:yfiles.layout.IEdgeLabelLayout,labeledElement:yfiles.algorithms.Edge):void;
      /**
      * Removes a label from a node.
      * @param {yfiles.layout.INodeLabelLayout} label the label that should be removed.
      * @param {yfiles.algorithms.Node} labeledElement the node owning the label.
      */
      removeNodeLabel(label:yfiles.layout.INodeLabelLayout,labeledElement:yfiles.algorithms.Node):boolean;
      /**
      * Removes a label from an edge.
      * @param {yfiles.layout.IEdgeLabelLayout} label the label that should be removed.
      * @param {yfiles.algorithms.Edge} labeledElement the edge owning the label.
      */
      removeEdgeLabel(label:yfiles.layout.IEdgeLabelLayout,labeledElement:yfiles.algorithms.Edge):boolean;
      /**
      * The relevant graph.
      */
      graph:yfiles.layout.LayoutGraph;
      /**
      * The layouter object that belongs to this layout context.
      */
      layouter:yfiles.multipage.MultiPageLayouter;
      /**
      * Returns the node of a page graph (a graph that represents the result of the multi page layout)
      * with the given id or null if there is no such node.
      * @param {Object} id the id of the node that should be returned.
      * @return {yfiles.algorithms.Node} the node of a page graph with the given id or null if there is no such node.
      */
      getPageNode(id:Object):yfiles.algorithms.Node;
      /**
      * Returns the edge of a page graph (a graph that represents the result of the multi page layout)
      * with the given id or null if there is no such edge.
      * @param {Object} id the id of the edge that should be returned.
      * @return {yfiles.algorithms.Edge} the edge of a page graph with the given id or null if there is no such edge.
      */
      getPageEdge(id:Object):yfiles.algorithms.Edge;
      /**
      * Returns the node of the input graph with the given id or null if there is no such node.
      * @param {Object} id the id of the node that should be returned.
      * @return {yfiles.algorithms.Node} the node of the input graph with the given id or null if there is no such node.
      */
      getOriginalNode(id:Object):yfiles.algorithms.Node;
      /**
      * Returns the edge of the input graph with the given id or null if there is no such edge.
      * @param {Object} id the id of the edge that should be returned.
      * @return {yfiles.algorithms.Edge} the edge of the input graph with the given id or null if there is no such edge.
      */
      getOriginalEdge(id:Object):yfiles.algorithms.Edge;
      /**
      * Returns the edge label information object of the given edge label layout.
      * @param {yfiles.layout.IEdgeLabelLayout} ell the edge label layout for which the information object should be returned.
      * @return {yfiles.multipage.IEdgeLabelInfo} the edge label information object of the given edge label layout.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getEdgeLabelInfo}.
      */
      getEdgeLabelInfo(ell:yfiles.layout.IEdgeLabelLayout):yfiles.multipage.IEdgeLabelInfo;
      /**
      * Returns the node label layout information object of the given node label layout.
      * @param {yfiles.layout.INodeLabelLayout} nll the node label layout for which the information object should be returned.
      * @return {yfiles.multipage.INodeLabelInfo} the node label information object of the given node label layout.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getNodeLabelInfo}.
      */
      getNodeLabelInfo(nll:yfiles.layout.INodeLabelLayout):yfiles.multipage.INodeLabelInfo;
      /**
      * Returns the node information object of the given node.
      * @param {yfiles.algorithms.Node} n the node for which the information object should be returned.
      * @return {yfiles.multipage.INodeInfo} the node information object of the given node.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getNodeInfo}.
      */
      getNodeInfo(n:yfiles.algorithms.Node):yfiles.multipage.INodeInfo;
      /**
      * Returns the edge information object of the given edge.
      * @param {yfiles.algorithms.Edge} e the edge for which the information object should be returned.
      * @return {yfiles.multipage.IEdgeInfo} the edge information object of the given edge.
      * @see Specified by {@link yfiles.multipage.IElementInfoManager#getEdgeInfo}.
      */
      getEdgeInfo(e:yfiles.algorithms.Edge):yfiles.multipage.IEdgeInfo;
    }
    var LayoutContext:{
      $class:yfiles.lang.Class;
    };
    /**
    * A class that holds all information related to a node.
    */
    export interface INodeInfo extends Object{
      /**
      * The represented node (always a node of the input graph).
      * That is,
      * if the related node has type {@link yfiles.multipage.NodeType#CONNECTOR  connector} this method returns the neighbor of the matching connector node,
      * if the related node has type {@link yfiles.multipage.NodeType#PROXY  proxy} it returns the corresponding original node,
      * if the related node has type {@link yfiles.multipage.NodeType#PROXY_REFERENCE  proxy reference} it returns <code>null</code>,
      * and, otherwise, it returns the corresponding node in the input graph.
      * @see Specified by {@link yfiles.multipage.INodeInfo#representedNode}.
      */
      representedNode:yfiles.algorithms.Node;
      /**
      * The page of the related node.
      * This information is available after the layout.
      * @see Specified by {@link yfiles.multipage.INodeInfo#pageNo}.
      */
      pageNo:number;
      /**
      * The type of the related node.
      * @see Specified by {@link yfiles.multipage.INodeInfo#type}.
      */
      type:yfiles.multipage.NodeType;
      /**
      * The unique id of the related node.
      * @see Specified by {@link yfiles.multipage.INodeInfo#id}.
      */
      id:Object;
      /**
      * The referencing node.
      * That is, if the related node has type {@link yfiles.multipage.NodeType#CONNECTOR  connector}
      * this method returns the opposite connector node, if the related node has
      * type {@link yfiles.multipage.NodeType#PROXY_REFERENCE  proxy reference} it returns the
      * corresponding proxy node, if the related node has type
      * {@link yfiles.multipage.NodeType#PROXY  proxy} it returns the corresponding proxy reference
      * node; otherwise it returns <code>null</code>.
      * @see Specified by {@link yfiles.multipage.INodeInfo#referencingNode}.
      */
      referencingNode:yfiles.algorithms.Node;
    }
    var INodeInfo:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * A class that holds all information related to a node label.
    */
    export interface INodeLabelInfo extends Object{
      /**
      * The unique id of the related node label.
      * @see Specified by {@link yfiles.multipage.INodeLabelInfo#id}.
      */
      id:Object;
    }
    var INodeLabelInfo:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Default implementation of an ElementFactory.
    * @see {@link yfiles.multipage.IElementFactory}
    */
    export interface DefaultElementFactory extends Object,yfiles.multipage.IElementFactory{
      /**
      * Callback method for creating an edge of type {@link yfiles.multipage.EdgeType#CONNECTOR}.
      * The edge should connect the given connector and opposite node.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createEdge}
      * to create the edge.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {yfiles.algorithms.Node} connector the endpoint of the edge that represents the connector node.
      * @param {yfiles.algorithms.Node} opposite the other endpoint of the edge.
      * @param {Object} origEdgeId the id of the edge that is split by the connector edge.
      * @param {boolean} atTarget whether or not the connector node is the target of the edge.
      * @return {yfiles.algorithms.Edge} the created connector edge.
      * @see {@link yfiles.multipage.EdgeType#CONNECTOR}
      * @see {@link yfiles.multipage.LayoutContext#createEdge}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createConnectorEdge}.
      */
      createConnectorEdge(context:yfiles.multipage.LayoutContext,connector:yfiles.algorithms.Node,opposite:yfiles.algorithms.Node,origEdgeId:Object,atTarget:boolean):yfiles.algorithms.Edge;
      /**
      * Callback method for creating a node of type {@link yfiles.multipage.NodeType#CONNECTOR}.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createNode} to create the node.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {yfiles.algorithms.YList} edgesIds 
      * a list that contains the ids of edges that are split by this connector. Note: multi-edges
      * (edges connecting the same nodes) may be split by the same connector pair.
      * @param {Object} representedNodeId the id of the node that is represented by this connector.
      * @return {yfiles.algorithms.Node} the created connector node
      * @see {@link yfiles.multipage.NodeType#CONNECTOR}
      * @see {@link yfiles.multipage.LayoutContext#createNode}
      * @see {@link yfiles.multipage.INodeInfo#representedNode}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createConnectorNode}.
      */
      createConnectorNode(context:yfiles.multipage.LayoutContext,edgeIds:yfiles.algorithms.YList,representedNodeId:Object):yfiles.algorithms.Node;
      /**
      * Callback method for creating a node of type {@link yfiles.multipage.NodeType#PROXY_REFERENCE}.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createNode} to create the node.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {Object} referringProxyId the id of the proxy to which the created node refers to.
      * @return {yfiles.algorithms.Node} the new proxy reference node.
      * @see {@link yfiles.multipage.NodeType#PROXY_REFERENCE}
      * @see {@link yfiles.multipage.LayoutContext#createNode}
      * @see {@link yfiles.multipage.NodeType#PROXY}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createProxyReferenceNode}.
      */
      createProxyReferenceNode(context:yfiles.multipage.LayoutContext,referringProxyId:Object):yfiles.algorithms.Node;
      /**
      * Callback method for creating a node of type {@link yfiles.multipage.NodeType#PROXY}.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createNode} to create the node.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {Object} origNodeId the id of the node for which a proxy has to be created.
      * @return {yfiles.algorithms.Node} the proxy.
      * @see {@link yfiles.multipage.LayoutContext#createNode}
      * @see {@link yfiles.multipage.NodeType#PROXY}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createProxyNode}.
      */
      createProxyNode(context:yfiles.multipage.LayoutContext,origNodeId:Object):yfiles.algorithms.Node;
      /**
      * Callback method for creating an edge of type {@link yfiles.multipage.EdgeType#PROXY_REFERENCE}.
      * This (undirected) edge should connect the given proxy reference and opposite node.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createEdge}
      * to create the edge.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {yfiles.algorithms.Node} proxyReference 
      * the endpoint of the edge that represents the proxy
      * reference node.
      * @param {yfiles.algorithms.Node} opposite the other endpoint of the new edge.
      * @param {Object} referencingCopyId 
      * the id of the proxy node that is referenced by the
      * proxy reference node.
      * @return {yfiles.algorithms.Edge} the created proxy reference edge.
      * @see {@link yfiles.multipage.EdgeType#PROXY_REFERENCE}
      * @see {@link yfiles.multipage.NodeType#PROXY_REFERENCE}
      * @see {@link yfiles.multipage.LayoutContext#createEdge}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createProxyReferenceEdge}.
      */
      createProxyReferenceEdge(context:yfiles.multipage.LayoutContext,proxyReference:yfiles.algorithms.Node,opposite:yfiles.algorithms.Node,referencingCopyId:Object):yfiles.algorithms.Edge;
      /**
      * Callback method for creating an edge of type {@link yfiles.multipage.EdgeType#PROXY}.
      * The edge should connect the given proxy node and opposite node.
      * Note: all implementations have to use method {@link yfiles.multipage.LayoutContext#createEdge}
      * to create the edge.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information, e.g., the current graph as well as
      * various information about the graph elements.
      * @param {yfiles.algorithms.Node} proxyNode the endpoint of the edge that represents the proxy node.
      * @param {yfiles.algorithms.Node} opposite the other endpoint of the new edge.
      * @param {Object} replacingEdgeId the id of the related edge that is connected to the original node.
      * @param {Object} origNodeId the id of the original node to which the proxy node refers to.
      * @return {yfiles.algorithms.Edge} the created proxy edge.
      * @see {@link yfiles.multipage.EdgeType#PROXY}
      * @see {@link yfiles.multipage.NodeType#PROXY}
      * @see {@link yfiles.multipage.LayoutContext#createEdge}
      * @see Specified by {@link yfiles.multipage.IElementFactory#createProxyEdge}.
      */
      createProxyEdge(context:yfiles.multipage.LayoutContext,proxyNode:yfiles.algorithms.Node,opposite:yfiles.algorithms.Node,replacingEdgeId:Object,origNodeId:Object):yfiles.algorithms.Edge;
      /**
      * Returns the default size for nodes created by this factory.
      * Called from
      * {@link yfiles.multipage.DefaultElementFactory#createConnectorNode},
      * {@link yfiles.multipage.DefaultElementFactory#createProxyReferenceNode}, and/or
      * {@link yfiles.multipage.DefaultElementFactory#createProxyNode}.
      * Must return a non-<code>null</code> size with positive width and height.
      * @param {yfiles.multipage.LayoutContext} context 
      * an object providing relevant layout information,
      * e.g., the current graph as well as various information about the graph
      * elements.
      * @param {Object} id 
      * the element ID that was passed to the calling <code>create</code>
      * method.
      * @param {number} type the type of node to be created.
      * @return {yfiles.algorithms.YDimension} the default size of the new node.
      */
      getDefaultNodeSize(context:yfiles.multipage.LayoutContext,id:Object,type:number):yfiles.algorithms.YDimension;
    }
    var DefaultElementFactory:{
      $class:yfiles.lang.Class;
    };
    export enum EdgeType{
      /**
      * Edge type specifier.
      * This value specifies that the edge is a normal edge, i.e., it does not belong to another type.
      * @see {@link yfiles.multipage.IEdgeInfo#type}
      */
      NORMAL,
      /**
      * Edge type specifier.
      * This value specifies that the edge is connected to a connector node (a node of type
      * {@link yfiles.multipage.NodeType#CONNECTOR}), i.e., it represents an edge of the input graph
      * whose endpoints lie on different pages.
      * @see {@link yfiles.multipage.IEdgeInfo#representedEdge}
      * @see {@link yfiles.multipage.IEdgeInfo#type}
      * @see {@link yfiles.multipage.NodeType#CONNECTOR}
      */
      CONNECTOR,
      /**
      * Edge type specifier.
      * This value specifies that the edge is connected to a proxy reference node
      * (a node of type {@link yfiles.multipage.NodeType#PROXY_REFERENCE}), i.e., a node that
      * refers to a proxy of an original node lying on another page.
      * @see {@link yfiles.multipage.IEdgeInfo#type}
      * @see {@link yfiles.multipage.NodeType#PROXY_REFERENCE}
      */
      PROXY_REFERENCE,
      /**
      * Edge type specifier.
      * This value specifies that the edge is connected to a proxy node (a node of
      * type {@link yfiles.multipage.NodeType#PROXY}), i.e., a node that is a proxy of an
      * original node lying on another page.
      * @see {@link yfiles.multipage.IEdgeInfo#type}
      * @see {@link yfiles.multipage.NodeType#PROXY}
      */
      PROXY
    }
    export enum GroupingMode{
      /**
      * Node grouping specifier.
      * This value specifies that group nodes are completely ignored.
      * @see {@link yfiles.multipage.MultiPageLayouter#groupMode}
      * @see {@link yfiles.multipage.MultiPageLayouter#groupMode}
      */
      IGNORE,
      /**
      * Node grouping specifier.
      * This value specifies that only original nodes are assigned in group nodes.
      * @see {@link yfiles.multipage.MultiPageLayouter#groupMode}
      * @see {@link yfiles.multipage.MultiPageLayouter#groupMode}
      */
      ORIGINAL_NODES_ONLY,
      /**
      * Node grouping specifier.
      * This value specifies that special nodes like, e.g., connector and proxy
      * nodes are assigned to group nodes, too.
      * @see {@link yfiles.multipage.MultiPageLayouter#groupMode}
      * @see {@link yfiles.multipage.MultiPageLayouter#groupMode}
      */
      ALL_NODES
    }
    export enum EdgeBundleMode{
      /**
      * Edge bundle mode specifier.
      * Used to define edge bundles. All multi-edges (edges with same endpoints) belonging to the same edge bundle are
      * split by the same connector pair (see {@link yfiles.multipage.NodeType#CONNECTOR}).
      * This value specifies that all multi-edges should be distinguished, i.e., a separate connector pair is used for each
      * multi-edge.
      * @see {@link yfiles.multipage.MultiPageLayouter#edgeBundleModeMask}
      * @see {@link yfiles.multipage.MultiPageLayouter#edgeBundleModeMask}
      */
      DISTINGUISH_MULTI_EDGES,
      /**
      * Edge bundle mode specifier.
      * Used to define edge bundles. All multi-edges (edges with same endpoints) belonging to the same edge bundle are
      * split by the same connector pair (see {@link yfiles.multipage.NodeType#CONNECTOR}).
      * This value specifies that multi-edges should be distinguished if the have different directions.
      * @see {@link yfiles.multipage.MultiPageLayouter#edgeBundleModeMask}
      * @see {@link yfiles.multipage.MultiPageLayouter#edgeBundleModeMask}
      */
      DISTINGUISH_DIRECTIONS,
      /**
      * Edge bundle mode specifier.
      * Used to define edge bundles. All multi-edges (edges with same endpoints) belonging to the same edge bundle are
      * split by the same connector pair (see {@link yfiles.multipage.NodeType#CONNECTOR}).
      * This value specifies that multi-edges should be distinguished if they are of different (user specified) type, see
      * {@link yfiles.multipage.MultiPageLayouter#EDGE_TYPE_DP_KEY}.
      * @see {@link yfiles.multipage.MultiPageLayouter#edgeBundleModeMask}
      * @see {@link yfiles.multipage.MultiPageLayouter#edgeBundleModeMask}
      */
      DISTINGUISH_TYPES
    }
    export enum NodeType{
      /**
      * Node type specifier.
      * This value specifies that the node is a normal node, i.e., it does not belong to another type.
      * @see {@link yfiles.multipage.INodeInfo#type}
      */
      NORMAL,
      /**
      * Node type specifier.
      * This value specifies that the node is a group node, i.e., a node that contains other nodes.
      * @see {@link yfiles.multipage.INodeInfo#type}
      */
      GROUP,
      /**
      * Node type specifier.
      * This value specifies that the node is a proxy node, i.e., it is a copy of a normal node.
      * @see {@link yfiles.multipage.INodeInfo#type}
      * @see {@link yfiles.multipage.NodeType#NORMAL}
      */
      PROXY,
      /**
      * Node type specifier.
      * This value specifies that the node is a proxy reference node, i.e., it refers to a proxy node.
      * @see {@link yfiles.multipage.INodeInfo#type}
      * @see {@link yfiles.multipage.NodeType#PROXY}
      */
      PROXY_REFERENCE,
      /**
      * Node type specifier.
      * This value specifies that the node is a connector node, i.e., a node that represents a jump mark to another connector node.
      * Such a connector pair is used to represent edges that connects two nodes on different pages.
      * @see {@link yfiles.multipage.INodeInfo#type}
      */
      CONNECTOR
    }
  }
  export module objectcollections{
    /**
    * An {@link yfiles.objectcollections.IEnumerator} which allows to iterate over an {@link yfiles.objectcollections.IDictionary}'s key/value pairs.
    */
    export interface IDictionaryEnumerator extends Object,yfiles.objectcollections.IEnumerator{
      /**
      * The key of the {@link yfiles.objectcollections.IEnumerator#currentObject current key/value pair}.
      * @see Specified by {@link yfiles.objectcollections.IDictionaryEnumerator#key}.
      */
      key:Object;
      /**
      * The value of the {@link yfiles.objectcollections.IEnumerator#currentObject current key/value pair}.
      * @see Specified by {@link yfiles.objectcollections.IDictionaryEnumerator#value}.
      */
      value:Object;
    }
    var IDictionaryEnumerator:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * A collection of value objects which are mapped to key objects and can be queried using their keys.
    * The keys must have a well defined <code>hashCode</code> method that must not change between registering a value for the key
    * and retrieving a value using the key.
    * Thus it is advisable to use stable, i.e. immutable, objects as the key.
    */
    export interface IDictionary extends Object,yfiles.objectcollections.ICollection{
      /**
      * Adds the given <code>key</code> / <code>value</code> pair to this dictionary.
      * @param {Object} key The key to which the given value should be mapped.
      * @param {Object} value The value which should be mapped to the given key.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#addWithKeyAndValue}.
      */
      addWithKeyAndValue(key:Object,value:Object):void;
      /**
      * Whether this dictionary's key collection contains the given value.
      * @param {Object} value The value to search for.
      * @return {boolean} <code>true</code> if this dictionary contains the given <code>value</code>.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#containsWithValue}.
      */
      containsWithValue(value:Object):boolean;
      /**
      * Removes the key/value pair which is represented by the given <code>key</code>.
      * @param {Object} key The key of the key/value pair to remove.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#removeWithKey}.
      */
      removeWithKey(key:Object):void;
      /**
      * An {@link yfiles.objectcollections.ICollection} with the keys of the {@link yfiles.objectcollections.IDictionary}.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#objectKeys}.
      */
      objectKeys:yfiles.objectcollections.ICollection;
      /**
      * Gets or sets the value of the key/value pair with the given key.
      * Setter: if there is already a key/value pair with the given key in the dictionary its value will be overridden. If not
      * a new key/value pair will be added.
      * Getter: if there is no key/value pair with the given key in this dictionary an exception will be thrown.
      * @param {Object} key 
      * @return {Object} 
      * @throws {yfiles.system.KeyNotFoundException} (Getter only): The given <code>key</code> cannot be found in this dictionary.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#getObject}.
      */
      getObject(key:Object):Object;
      /**
      * Gets or sets the value of the key/value pair with the given key.
      * Setter: if there is already a key/value pair with the given key in the dictionary its value will be overridden. If not
      * a new key/value pair will be added.
      * Getter: if there is no key/value pair with the given key in this dictionary an exception will be thrown.
      * @param {Object} key 
      * @return {Object} 
      * @throws {yfiles.system.KeyNotFoundException} (Getter only): The given <code>key</code> cannot be found in this dictionary.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#getObject}.
      */
      putObject(key:Object,value:Object):void;
      /**
      * An {@link yfiles.objectcollections.ICollection} with the values in the {@link yfiles.objectcollections.IDictionary}.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#objectValues}.
      */
      objectValues:yfiles.objectcollections.ICollection;
      /**
      * Removes all key/value pairs from this dictionary.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#clear}.
      */
      clear():void;
      /**
      * Whether this dictionary is read-only.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#isReadOnly}.
      */
      isReadOnly:boolean;
      /**
      * Whether this dictionary has a fixed size.
      * @see Specified by {@link yfiles.objectcollections.IDictionary#isFixedSize}.
      */
      isFixedSize:boolean;
      /**
      * Gets an {@link yfiles.objectcollections.IEnumerator} which allows to iterate over this dictionary's key/value pairs.
      * @return {yfiles.objectcollections.IDictionaryEnumerator} 
      * @see Specified by {@link yfiles.objectcollections.IDictionary#getDictionaryEnumerator}.
      */
      getDictionaryEnumerator():yfiles.objectcollections.IDictionaryEnumerator;
    }
    var IDictionary:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Defines methods to manipulate collections.
    */
    export interface ICollection extends Object,yfiles.objectcollections.IEnumerable{
      /**
      * The number of elements in this collection.
      * @see Specified by {@link yfiles.objectcollections.ICollection#count}.
      */
      count:number;
      /**
      * Copies the elements of this collection into the given <code>array</code> starting at the given <code>arrayIndex</code>.
      * @param {Object} array The array to copy the elements to.
      * @param {number} arrayIndex The index in the given array where the first element should be copied to.
      * @see Specified by {@link yfiles.objectcollections.ICollection#copyTo}.
      */
      copyTo(array:Object,arrayIndex:number):void;
      /**
      * @see Specified by {@link yfiles.objectcollections.ICollection#isSynchronized}.
      */
      isSynchronized:boolean;
      /**
      * @see Specified by {@link yfiles.objectcollections.ICollection#syncRoot}.
      */
      syncRoot:Object;
    }
    var ICollection:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * A read-write collection of objects.
    */
    export interface IList extends Object,yfiles.objectcollections.ICollection{
      /**
      * Determines the index of the given item in the {@link yfiles.objectcollections.IList}.
      * @param {Object} item The object to get the index for
      * @return {number} The index of the given item. -1 if the item is not in the list.
      * @see Specified by {@link yfiles.objectcollections.IList#indexOfItem}.
      */
      indexOfItem(item:Object):number;
      /**
      * Inserts the given <code>item</code> at the given <code>index</code>.
      * @param {number} index The index at which the item should be inserted.
      * @param {Object} item The item to insert.
      * @see Specified by {@link yfiles.objectcollections.IList#insertAt}.
      */
      insertAt(index:number,item:Object):void;
      /**
      * Removes the item at the given <code>index</code> from the list.
      * @param {number} index The index of the item which should be removed.
      * @see Specified by {@link yfiles.objectcollections.IList#removeAt}.
      */
      removeAt(index:number):void;
      /**
      * Removes the given object from the list.
      * @param {Object} value The object to remove.
      * @see Specified by {@link yfiles.objectcollections.IList#removeValue}.
      */
      removeValue(value:Object):void;
      /**
      * Whether this list contains the given object.
      * @param {Object} value The object to search for.
      * @return {boolean} <code>true</code> if the given object is contained in the list.
      * @see Specified by {@link yfiles.objectcollections.IList#containsValue}.
      */
      containsValue(value:Object):boolean;
      /**
      * Removes all elements from the list.
      * @see Specified by {@link yfiles.objectcollections.IList#clear}.
      */
      clear():void;
      /**
      * Adds the given object at the end of the list.
      * @param {Object} value The object to add.
      * @return {number} The index of the added object.
      * @see Specified by {@link yfiles.objectcollections.IList#addWithValue}.
      */
      addWithValue(value:Object):number;
      /**
      * Gets or sets the object at the given index.
      * @param {number} index The index of the object to access.
      * @return {Object} The object at the given index.
      * @see Specified by {@link yfiles.objectcollections.IList#getObject}.
      */
      getObject(index:number):Object;
      /**
      * Gets or sets the object at the given index.
      * @param {number} index The index of the object to access.
      * @return {Object} The object at the given index.
      * @see Specified by {@link yfiles.objectcollections.IList#getObject}.
      */
      setObject(index:number,value:Object):void;
      /**
      * Whether the collection is read-only.
      * @see Specified by {@link yfiles.objectcollections.IList#isReadOnly}.
      */
      isReadOnly:boolean;
      /**
      * Whether the collection has a fixed size.
      * @see Specified by {@link yfiles.objectcollections.IList#isFixedSize}.
      */
      isFixedSize:boolean;
    }
    var IList:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Provides methods to iterate over a collection or list.
    */
    export interface IEnumerator extends Object{
      /**
      * Moves this enumerator to the next element.
      * A newly created enumerator's {@link yfiles.objectcollections.IEnumerator#currentObject current position} is before the first element. Thus, this method
      * must be called before first access to the {@link yfiles.objectcollections.IEnumerator#currentObject} property. The same applies to the state after 
      * calling {@link yfiles.objectcollections.IEnumerator#reset}.
      * @return {boolean} <code>true</code> if the enumerator was moved to a valid position
      * @see Specified by {@link yfiles.objectcollections.IEnumerator#moveNext}.
      */
      moveNext():boolean;
      /**
      * Resets the enumerator to its starting state.
      * In other words: sets the current position before the first element.
      * @see Specified by {@link yfiles.objectcollections.IEnumerator#reset}.
      */
      reset():void;
      /**
      * Gets the element at the enumerator's current position.
      * This value is undefined if the enumerator is in initial state (after creation or {@link yfiles.objectcollections.IEnumerator#reset}) or has been moved past the
      * end of the represented collection.
      * @see Specified by {@link yfiles.objectcollections.IEnumerator#currentObject}.
      */
      currentObject:Object;
    }
    var IEnumerator:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Defines ways to iterate over the items contained in this type by providing a method to get an {@link yfiles.objectcollections.IEnumerator}.
    * This interface exists for internal purposes, if possible the {@link yfiles.collections.IEnumerable} interface should be used instead.
    */
    export interface IEnumerable extends Object{
      /**
      * Gets an {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
      * This method exists for internal purposes mainly, if available the {@link yfiles.collections.IEnumerable#getEnumerator} should be used instead.
      * @return {yfiles.objectcollections.IEnumerator} The {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
      * @see Specified by {@link yfiles.objectcollections.IEnumerable#getObjectEnumerator}.
      */
      getObjectEnumerator():yfiles.objectcollections.IEnumerator;
      /**
      * Converts a untyped enumerable into an enumerable with the given type.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#ofType}.
      * @return {yfiles.collections.IEnumerable.<TSource>} A typed enumerable.
      */
      getEnumerableOfType<TSource>(type:yfiles.lang.Class):yfiles.collections.IEnumerable<TSource>;
      /**
      * Casts the elements of the enumerable to the specified type and returns a typed {@link yfiles.collections.IEnumerable}.
      * This is a bridge method that delegates to {@link yfiles.collections.EnumerableExtensions#cast}.
      * @return {yfiles.collections.IEnumerable.<TResult>} This implementation returns the original enumerable.
      */
      getCastedEnumerable<TResult>():yfiles.collections.IEnumerable<TResult>;
    }
    var IEnumerable:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Provides a method to compare two objects.
    */
    export interface IComparer extends Object{
      /**
      * Compares two objects.
      * @param {Object} x The first object.
      * @param {Object} y The second object.
      * @return {number} <ul>
      * <li>-1: <code>x</code> is less than <code>y</code></li>
      * <li>0: <code>x</code> is equal to <code>y</code></li>
      * <li>1: <code>x</code> is greater than <code>y</code></li>
      * </ul>
      * @see Specified by {@link yfiles.objectcollections.IComparer#compare}.
      */
      compare(x:Object,y:Object):number;
    }
    var IComparer:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
  }
  export module organic{
    export enum GroupsPolicy{
      /**
      * Node group policy specifier. This layouter will consider grouping
      * information of an input graph. It will layout the contents of groups
      * in a way that highlights their togetherness.
      */
      LAYOUT,
      /**
      * Node group policy specifier. This layouter will keep the relative positions
      * of nodes that belong to the same group. The layouter will take the
      * fixed groups into account when placing the other nodes of the graph.
      */
      FIXED,
      /**
      * Node group policy specifier. This layouter will ignore all grouping related
      * information when laying out the graph.
      */
      IGNORE
    }
    export enum SphereOfAction{
      /**
      * Sphere of action specifier. Displace all nodes.
      */
      ALL,
      /**
      * Sphere of action specifier. Displace mainly selected nodes, but allow 
      * minor movement of unselected nodes as well.
      * A node is considered to be selected if the LayoutGraph DataProvider 
      * registered with the key 
      * returns <code>true</code> for that node.
      */
      MAINLY_SELECTION,
      /**
      * Sphere of action specifier. Displace only selected nodes 
      * A node is considered to be selected if the LayoutGraph DataProvider 
      * registered with the key 
      * returns <code>true</code> for that node.
      */
      ONLY_SELECTION
    }
    /**
    * This layout stage removes node overlaps in a layout graph by using a method
    * which is based on a famous russian arcade game.
    */
    export interface ShuffleLayouter extends Object,yfiles.layout.ILayoutStage{
      /**
      * Performs the force transfer algorithm on the given graph
      * after the core layouter has performed its job.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * The core layouter.
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
      /**
      * The horizontal overlap criterion.
      * One of {@link yfiles.organic.HorizontalOverlapCriterion#INTERSECTION_BOX},
      * {@link yfiles.organic.HorizontalOverlapCriterion#LESS_MOVEMENT} and
      * {@link yfiles.organic.HorizontalOverlapCriterion#NODE_CENTER}
      */
      horizontalOverlapCriterium:yfiles.organic.HorizontalOverlapCriterion;
      /**
      * The minimal distance between nodes that has to be obeyed by this
      * layouter.
      */
      minimalNodeDistance:number;
      /**
      * Specifies whether or not simple mode is active.
      * When in simple mode the algorithm is very fast
      * but the quality of the resulting layout may be poor.
      * When not active the resulting layout is better and
      * the running time is higher.
      * By default simple mode is not active.
      */
      simpleModeActive:boolean;
      /**
      * <code>true</code> if this layouter uses a barycenter based
      * node shuffling strategy and <code>false</code> otherwise.
      */
      barycenterModeActive:boolean;
    }
    var ShuffleLayouter:{
      $class:yfiles.lang.Class;
      /**
      * This key can be used to specify a minimal distance for each single node in the graph
      * using a data provider.
      * Note that values must be strictly positive.
      */
      MINIMAL_DISTANCE_DP_KEY:Object;
      /**
      * This key can be used to specify whether or not a node's position should
      * remain fixed.
      * The corresponding data provider's
      * {@link yfiles.algorithms.IDataProvider#getBool} method is used to determine which
      * nodes are fixed.
      */
      FIXED_NODE_DP_KEY:Object;
      /**
      * Creates a new instance of ShuffleLayouter.
      */
      new ():yfiles.organic.ShuffleLayouter;
    };
    export enum HorizontalOverlapCriterion{
      /**
      * Horizontal overlap criteria enumeration constant.
      */
      INTERSECTION_BOX,
      /**
      * Horizontal overlap criteria enumeration constant.
      */
      NODE_CENTER,
      /**
      * Horizontal overlap criteria enumeration constant.
      */
      LESS_MOVEMENT
    }
    export enum Scope{
      /**
      * Scope constant - used for laying out all nodes.
      */
      ALL,
      /**
      * Scope constant - used for laying out the subset of nodes only.
      * The above mentioned subset has to be specified by registering an
      * appropriate {@link yfiles.algorithms.IDataProvider} for key .
      */
      SUBSET,
      /**
      * Scope constant - used for laying out mainly the subset of the nodes.
      * The above mentioned subset has to be specified by registering an
      * appropriate {@link yfiles.algorithms.IDataProvider} for key .
      */
      MAINLY_SUBSET
    }
    /**
    * This layout stage replaces edges by a path of nodes before it calls
    * a core layouter.
    * After the core layouter is finished this stage transforms
    * the substituted path of nodes back to the original edge.  For each node in the path
    * there will be a bend in the original edge. The coordinate of the bend will be the
    * center coordinate of the corresponding path node.
    */
    export interface SplitEdgeLayoutStage extends Object,yfiles.layout.ILayoutStage{
      /**
      * The <code>DataProvider</code> key that determines which edges
      * are to be split.
      * <p>
      * By default, {@link yfiles.layout.LayouterKeys#SELECTED_EDGES_DP_KEY} is used.
      * </p>
      * <p>
      * If no <code>DataProvider</code> is registered with this key, all edges will be split.
      * </p>
      * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
      */
      splitEdgesDpKey:Object;
      /**
      * The <code>DataProvider</code> key to mark the nodes, that were
      * created by splitting edges, for the core layouter.
      * <p>
      * By default, {@link yfiles.layout.LayouterKeys#SELECTED_NODES_DP_KEY} is used.
      * </p>
      * <p>
      * The layout algorithm ignores any previous information stored in this <code>DataProvider</code> during the layout
      * process but restores it after the core layouter has finished.
      * </p>
      * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
      */
      splitNodesDpKey:Object;
      /**
      * The split segment length.
      * The split segment length determines
      * the length of the path that will replace an original edge in the graph.
      * The length of the original edge path divided by the given split segment length
      * yields the number of nodes on the new node path.
      */
      splitSegmentLength:number;
      /**
      * The size used as width/height for proxy nodes, i.e.
      * nodes inserted by this layout stage.
      */
      proxyNodeSize:number;
      /**
      * Returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Assigns a new graph layout to the given layout graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The core layouter.
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
    }
    var SplitEdgeLayoutStage:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of SplitEdgeLayouter.
      */
      new ():yfiles.organic.SplitEdgeLayoutStage;
    };
    export enum InitialPlacement{
      /**
      * Initial placement strategy. Start with randomly chosen positions.
      */
      RANDOM,
      /**
      * Initial placement strategy. Start with all positions set to (0,0,0).
      */
      ZERO,
      /**
      * Initial placement strategy. Start with given positions.
      */
      AS_IS
    }
    /**
    * This class implements a variant of the GRIP algorithm by
    * P Gajer and SG Kobourov: "Graph Drawing with
    * Intelligent Placement".
    * It implements ideas of the GUIDE algorithm,
    * and fixes some bugs from the original algorithm and implementation.
    * Additionally several important parts of the algorithm have been drastically
    * improved.
    * This layout is especially suited for huge diagrams, that would normally
    * be laid out using an Organic layout. It leads to perfect results for
    * mesh-like graph structures.
    */
    export interface GRIP extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * Subclasses have to provide information whether or not they
      * can layout the given graph.
      */
      canLayoutCore(g:yfiles.layout.LayoutGraph):boolean;
      /**
      * The number of the initial rounds.
      */
      rounds:number;
      /**
      * The number of the final rounds.
      */
      finalRounds:number;
      /**
      * The desired edge length.
      */
      preferredEdgeLength:number;
      /**
      * The initial temperature.
      * This value should lie somewhere in [10..80].
      */
      initialTemperature:number;
      /**
      * Subclasses have to provide core layout code in this method.
      */
      doLayoutCore(g:yfiles.layout.LayoutGraph):void;
      /**
      * Specifies whether or not initial placements are determined in a smart way.
      */
      smartInitialPlacement:boolean;
      /**
      * Specifies whether or not GRIP works in a deterministic manner.
      */
      deterministic:boolean;
      /**
      * The current laxity value.
      */
      laxity:number;
      /**
      * Specifies whether or not GRIP takes average node sizes into account.
      */
      nodeSizeAware:boolean;
    }
    var GRIP:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of the GRIP layout algorithm.
      */
      new ():yfiles.organic.GRIP;
    };
    /**
    * This class uses a customizable shuffle layout algorithm to recursively remove node
    * overlaps from grouped graph structures.
    * This class can be used as a LayoutStage in which case it will perform its work
    * after the core layouter instance has performed its work.
    */
    export interface GroupedShuffleLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The currently installed GroupBoundsCalculator instance.
      */
      groupBoundsCalculator:yfiles.layout.IGroupBoundsCalculator;
      /**
      * The layouter instance, that will be used for shuffling (removing node overlaps).
      */
      shuffleLayouter:yfiles.layout.ILayouter;
    }
    var GroupedShuffleLayouter:{
      $class:yfiles.lang.Class;
      new ():yfiles.organic.GroupedShuffleLayouter;
      /**
      * Creates a new instance of GroupedShuffleLayouter
      * The given core layouter instance will get to perform its work before the
      * actual shuffling takes place.
      */
      WithCoreLayouter:{
        new (core:yfiles.layout.ILayouter):yfiles.organic.GroupedShuffleLayouter;
      };
    };
    /**
    * Implementations of this class can be set via a <code>setOutputRestriction(OutputRestriction)</code> method, e.g.
    * {@link yfiles.organic.SmartOrganicLayouter#outputRestriction}
    * in <code>SmartOrganicLayouter</code> to restrict the output area and shape of the layout.
    * Instances of this class can only be retrieved from the factory methods or from the static field.
    * @see {@link yfiles.organic.OutputRestriction#NONE}
    * @see {@link yfiles.organic.OutputRestriction#createAspectRatioRestriction}
    * @see {@link yfiles.organic.OutputRestriction#createCircularCageRestriction}
    * @see {@link yfiles.organic.OutputRestriction#createEllipticalCageRestriction}
    * @see {@link yfiles.organic.OutputRestriction#createRectangularCageRestriction}
    */
    export interface OutputRestriction extends Object{
    }
    var OutputRestriction:{
      $class:yfiles.lang.Class;
      /**
      * This restriction actually does not restrict the output.
      * It is a no-op.
      * It can be used in for use in
      * {@link yfiles.organic.SmartOrganicLayouter#outputRestriction}
      */
      NONE:yfiles.organic.OutputRestriction;
      /**
      * This factory method creates a restriction object that can be used
      * to restrict the result of a layout run of {@link yfiles.organic.SmartOrganicLayouter} so
      * that the nodes lie within the given rectangle.
      * @param {number} x x coordinate of the upper-left corner of the restriction rectangle
      * @param {number} y y coordinate of the upper-left corner of the restriction rectangle
      * @param {number} w width of the restriction rectangle
      * @param {number} h height of the restriction rectangle
      * @return {yfiles.organic.OutputRestriction} 
      * an instance for use in {@link yfiles.organic.SmartOrganicLayouter#outputRestriction}
      */
      createRectangularCageRestriction(x:number,y:number,w:number,h:number):yfiles.organic.OutputRestriction;
      /**
      * This factory method creates a restriction object that can be used
      * to restrict the result of a layout run of {@link yfiles.organic.SmartOrganicLayouter} so
      * that the nodes lie within a circle.
      * @param {number} x x coordinate of the center of the restriction circle
      * @param {number} y y coordinate of the center of the restriction circle
      * @param {number} radius the radius of the restriction circle
      * @return {yfiles.organic.OutputRestriction} 
      * an instance for use in {@link yfiles.organic.SmartOrganicLayouter#outputRestriction}
      */
      createCircularCageRestriction(x:number,y:number,radius:number):yfiles.organic.OutputRestriction;
      /**
      * This factory method creates a restriction object that can be used
      * to restrict the result of a layout run of {@link yfiles.organic.SmartOrganicLayouter} so
      * that the nodes lie within an ellipse whose main axes are parallel to the coordinate axes.
      * @param {number} x x coordinate of the upper left corner
      * @param {number} y y coordinate of the upper left corner
      * @param {number} w width of the bounding box of the ellipse
      * @param {number} h the height of the bounding box of the ellipse
      * @return {yfiles.organic.OutputRestriction} 
      * an instance for use in {@link yfiles.organic.SmartOrganicLayouter#outputRestriction}
      */
      createEllipticalCageRestriction(x:number,y:number,w:number,h:number):yfiles.organic.OutputRestriction;
      /**
      * This factory method creates a restriction object that can be used
      * to restrict the result of a layout run of {@link yfiles.organic.SmartOrganicLayouter} so
      * that the bounding box roughly has the given aspect ratio.
      * @param {number} ratio the preferred aspect ratio (width/height) of the output
      * @return {yfiles.organic.OutputRestriction} 
      * an instance for use in {@link yfiles.organic.SmartOrganicLayouter#outputRestriction}
      */
      createAspectRatioRestriction(ratio:number):yfiles.organic.OutputRestriction;
    };
    /**
    * This LayoutStage removes node overlaps considering the specified minimal node distance.
    * Unlike the approach implemented in class {@link yfiles.organic.RemoveOverlapsLayoutStage}, this approach tries
    * to keep the original layout structure, i.e., it tries to keep the geometric distance between the nodes.
    * Therefore, it uses a similar strategy than organic layout algorithms.
    * Thus, it is especially suited to remove node overlaps
    * in undirected graph drawings with straight-line edge routes, e.g., layouts produced by the organic layouter.
    */
    export interface OrganicRemoveOverlapsStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * The time limit (in milliseconds) set for the layout stage
      * (not including the time required by the core layouter).
      * <p> Note that restricting the maximum duration may result in a worse layout quality,
      * i.e., there could be still some node overlaps. Furthermore, the actual
      * runtime may exceed the maximum duration since the layout algorithm still has to find a valid solution. </p>
      */
      maximumDuration:number;
      /**
      * The current minimal node distance this layout stage should enforce.
      * <p> The default value is <code>10</code>. </p>
      */
      minimumNodeDistance:number;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var OrganicRemoveOverlapsStage:{
      $class:yfiles.lang.Class;
      /**
      * This key can be used to specify a boolean value that can be used to mark fixed nodes.
      */
      FIXED_NODE_DP_KEY:Object;
      /**
      * Creates a new instance of OrganicRemoveOverlapsStage.
      */
      WithCoreLayouter:{
        new (core:yfiles.layout.ILayouter):yfiles.organic.OrganicRemoveOverlapsStage;
      };
      /**
      * Creates a new instance of OrganicRemoveOverlapsStage.
      */
      new ():yfiles.organic.OrganicRemoveOverlapsStage;
    };
    /**
    * This class can be used as a convenience class to gain access to a variety of
    * organic layout algorithms.
    * Its strength lies in being able to conveniently
    * specify a ratio between quality and running time, as well as the ability to
    * specify the degree of the compactness of the drawing and
    * to guarantee non-overlapping nodes.
    * Note: This class is able to consider a partition grid structure (see {@link yfiles.layout.PartitionGrid}).
    * However, for common nodes (i.e., non-group nodes) it only considers single partition cells.
    * Furthermore, the layout algorithm throws an {@link yfiles.algorithms.InvalidGraphStructureException} if there is a partition grid
    * and the descendants of a group node are assigned to different partition grid cells or if there
    * are group nodes that are associated with group node mode data
    * (see {@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_DP_KEY})
    * that is not equal to {@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_NORMAL}.
    */
    export interface SmartOrganicLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * The group node compactness factor.
      * Values should be in the range [0..1], where 0 results in group nodes not
      * affecting the overall layout too much, whereas a value of 1 forces nodes in the same group to be clustered
      * tightly.
      * Note: the specified value is only considered if option {@link yfiles.organic.SmartOrganicLayouter#automaticGroupNodeCompactionEnabled}
      * is disabled and if there is no partition grid structure.
      * <p>By default this value is <code>0.4</code>.</p>
      * @see {@link yfiles.organic.SmartOrganicLayouter#automaticGroupNodeCompactionEnabled}
      * @throws {yfiles.system.ArgumentException} if compactness value does not lie in [0..1]
      * @see {@link yfiles.organic.SmartOrganicLayouter#automaticGroupNodeCompactionEnabled}
      */
      groupNodeCompactness:number;
      /**
      * Specifies whether or not the automatic group node compaction is used.
      * If this option is enabled the group node compactness
      * is determined automatically, i.e., it only depends on the general compactness specified by option
      * {@link yfiles.organic.SmartOrganicLayouter#compactness}). The value specified by option {@link yfiles.organic.SmartOrganicLayouter#groupNodeCompactness} is
      * ignored.
      * <p>
      * By default this option is enabled.
      * </p>
      * @see {@link yfiles.organic.SmartOrganicLayouter#groupNodeCompactness}
      * @see {@link yfiles.organic.SmartOrganicLayouter#compactness}
      * @see {@link yfiles.organic.SmartOrganicLayouter#groupNodeCompactness}
      * @see {@link yfiles.organic.SmartOrganicLayouter#compactness}
      */
      automaticGroupNodeCompactionEnabled:boolean;
      /**
      * Specifies whether or not a clustering algorithm should be applied.
      * If this option is enabled, the following steps are performed during the layout:
      * <ul>
      * <li>a clustering algorithm is applied to the input graph.</li>
      * <li>all nodes of the same cluster are put into a new group node.</li>
      * <li>the common layout is applied to the modified graph.</li>
      * <li>group nodes denoting clusters (inserted during step 2) are removed.</li>
      * </ul>
      * The user can also specify customized clusters by defining appropriate groups.
      * <p>
      * By default, automatic clustering is not enabled.
      * </p><p>
      * Note: the runtime of the clustering algorithm does not depend on the specified maximal duration (see method {@link yfiles.organic.SmartOrganicLayouter#maximumDuration}).
      * </p>
      */
      clusterNodes:boolean;
      /**
      * The quality ratio of the clustering algorithm.
      * The higher d the higher the clustering quality.
      * Default value is 1.
      * <p>
      * Note: the expected runtime of the clustering algorithm increases with d.
      * The runtime does not depend on the specified maximal duration (see method {@link yfiles.organic.SmartOrganicLayouter#maximumDuration}).
      * </p>
      */
      clusteringQuality:number;
      /**
      * Specifies whether or not node labels are considered for the next layout run.
      * Enabling this setting overrides the value of {@link yfiles.organic.SmartOrganicLayouter#nodeSizeAware}, i.e.
      * node sizes are always considered.
      * <p>
      * Default value is <code>false</code>.
      * </p>
      * <p>
      * Note that this option only works correctly if the {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation}
      * is set to {@link yfiles.layout.LayoutOrientation#TOP_TO_BOTTOM} (which is the default).
      * Changing the layout orientation for an undirected layout algorithm like the
      * {@link yfiles.organic.SmartOrganicLayouter} doesn't make sense.
      * </p>
      */
      considerNodeLabels:boolean;
      /**
      * The{@link yfiles.layout.IGroupBoundsCalculator} instance used for calculating the size of group nodes.
      * The default is {@link yfiles.layout.MinimumSizeGroupBoundsCalculator}.
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      */
      groupBoundsCalculator:yfiles.layout.IGroupBoundsCalculator;
      /**
      * Determines whether this instance should configure the {@link yfiles.layout.CanonicMultiStageLayouter#componentLayouter  ComponentLayouter}
      * in such a way that it respects the {@link yfiles.organic.SmartOrganicLayouter#scope  scope's} settings {@link yfiles.organic.Scope#SUBSET} and
      * {@link yfiles.organic.Scope#MAINLY_SUBSET} by keeping other nodes pinned, even if they reside in different components.
      * <p>
      * The default is <code>false</code>.
      * </p>
      */
      smartComponentLayout:boolean;
      /**
      * Specifies whether or not the layouter tries to avoid node/edge overlaps.
      * Note that the current implementation does not guarantee the non-existence
      * of overlaps but tries to avoid them. Furthermore, the post-processing step that removes node overlaps
      * ignores node/edge overlaps, i.e., the number of node/edge overlaps may increase if option
      * {@link yfiles.organic.SmartOrganicLayouter#nodeOverlapsAllowed} is disabled.
      * <p>
      * By default, this option is not enabled.
      * </p>
      * @see {@link yfiles.organic.SmartOrganicLayouter#nodeOverlapsAllowed}
      * @see {@link yfiles.organic.SmartOrganicLayouter#nodeOverlapsAllowed}
      */
      nodeEdgeOverlapAvoided:boolean;
      /**
      * Configures the {@link yfiles.layout.CanonicMultiStageLayouter#componentLayouter  ComponentLayouter}
      * and graph instance to adhere to the {@link yfiles.organic.SmartOrganicLayouter#NODE_SUBSET_DP_KEY} in case
      * {@link yfiles.organic.Scope#ALL} is not set, and to use {@link yfiles.organic.SmartOrganicLayouter#minimalNodeDistance} also for distances between components.
      * This will result in the component layouter not rearranging components if they contain
      * pinned-down nodes.
      * @param {yfiles.layout.LayoutGraph} graph the graph that will be arranged
      * @param {yfiles.layout.ComponentLayouter} layouter the layouter to reconfigure
      * @see {@link yfiles.organic.SmartOrganicLayouter#unconfigureComponentLayouter}
      * @see {@link yfiles.organic.SmartOrganicLayouter#smartComponentLayout}
      */
      configureComponentLayouter(graph:yfiles.layout.LayoutGraph,layouter:yfiles.layout.ComponentLayouter):void;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(layoutGraph:yfiles.layout.LayoutGraph):void;
      /**
      * Resets the {@link yfiles.layout.CanonicMultiStageLayouter#componentLayouter  ComponentLayouter} from the previous
      * {@link yfiles.organic.SmartOrganicLayouter#configureComponentLayouter}
      * call.
      * @param {yfiles.layout.LayoutGraph} graph the graph that has been arranged
      * @param {yfiles.layout.ComponentLayouter} layouter the layouter to reset.
      * @see {@link yfiles.organic.SmartOrganicLayouter#configureComponentLayouter}
      * @see {@link yfiles.organic.SmartOrganicLayouter#smartComponentLayout}
      */
      unconfigureComponentLayouter(graph:yfiles.layout.LayoutGraph,layouter:yfiles.layout.ComponentLayouter):void;
      /**
      * Subclasses have to provide information whether or not they
      * can layout the given graph.
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Subclasses have to provide core layout code in this method.
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The quality to time ratio.
      * <b>Getter:</b>This setting determines the ratio of layout quality versus time consumption.
      * The higher the ratio, the better the quality of the resulting layout but
      * the longer it may take to perform the layout.
      * <p>
      * The default value is <code>0.6</code>.
      * </p>
      * <b>Setter:</b>This setting determines the ratio of layout quality versus time consumption.
      * <p>
      * The default value is <code>0.6</code>.
      * </p>
      * @throws {yfiles.system.ArgumentException} 
      * if the specified ratio is less than
      * <code>0</code> or greater than <code>1</code>.
      */
      qualityTimeRatio:number;
      /**
      * The maximum duration this algorithm is allowed to run.
      * This is a soft limit
      * <p>
      * By default, the maximum duration is set to 30 seconds.
      * </p>
      * @throws {yfiles.system.ArgumentException} 
      * if the specified duration is less than
      * <code>0</code>.
      */
      maximumDuration:number;
      /**
      * The scope of the layout.
      * The scope determines which of the nodes
      * should be affected and how they should be affected by the layout run.
      * <p>
      * Defaults to {@link yfiles.organic.Scope#ALL}.
      * </p><p>
      * <b>Note:</b>
      * For all scopes but {@link yfiles.organic.Scope#ALL}, a data provider for key
      * {@link yfiles.organic.SmartOrganicLayouter#NODE_SUBSET_DP_KEY} <em>has</em> to be registered.
      * </p>
      * @see {@link yfiles.organic.SmartOrganicLayouter#NODE_SUBSET_DP_KEY}
      */
      scope:yfiles.organic.Scope;
      /**
      * The property for the compactness of the resulting layout.
      * <b>Getter:</b>Lower values result in less compact drawings.
      * <p>
      * The default value is <code>0.5</code>.
      * </p>
      * <b>Setter:</b>Smaller values result in less compact drawings, greater values result in more compact drawings
      * with <code>0.5d</code> being a "normal" compactness.
      * <p>
      * The default value is <code>0.5</code>.
      * </p>
      * @throws {yfiles.system.ArgumentException} 
      * if the specified value is less than
      * <code>0</code> or greater than <code>1</code>.
      */
      compactness:number;
      /**
      * The currently set default preferred edge length.
      * The algorithm will
      * try to find a drawing where most of the edges have this length. This default
      * is applied to all edges where there is no specific edge length given using the
      * <code>double</code> DataProvider instance bound to the graph using the
      * {@link yfiles.organic.SmartOrganicLayouter#PREFERRED_EDGE_LENGTH_DP_KEY} key.
      */
      preferredEdgeLength:number;
      /**
      * The current preferred minimal node distance this algorithm should use for
      * pairs of nodes that are not directly connected by adjacent edges.
      */
      preferredMinimalNodeDistance:number;
      /**
      * Determines whether the algorithm should consider the size of the nodes for the layout.
      * <b>Getter:</b>If set to <code>true</code> the algorithm will take the node size into account
      * for given preferred edge lengths.
      * <b>Setter:</b>These settings do not affect the hard minimal node distance property.
      */
      nodeSizeAware:boolean;
      /**
      * Specifies whether the algorithm will behave deterministically in the next layout run.
      * If set to <code>true</code>, the algorithm will yield
      * the same results if given the exact same input and same settings.
      */
      deterministic:boolean;
      /**
      * The current minimal node distance this algorithm should enforce if the
      * node overlaps allowance property is set to <code>true</code>.
      * <p>
      * The default value is <code>0</code>.
      * </p>
      * @see {@link yfiles.organic.SmartOrganicLayouter#nodeOverlapsAllowed}
      */
      minimalNodeDistance:number;
      /**
      * Specifies whether node overlaps are allowed (but not encouraged) for the next run.
      * The
      * minimal distance between each pair of nodes is determined by the minimal
      * node distance property.
      * <p>
      * By default, node overlaps are not allowed.
      * </p>
      * <p>
      * <b>Note:</b> if scope is set to SCOPE_SUBSET or SCOPE_MAINLY_SUBSET, there might be some overlapping nodes even if
      * this option is set to false.
      * </p>
      * @see {@link yfiles.organic.SmartOrganicLayouter#minimalNodeDistance}
      * @see {@link yfiles.organic.SmartOrganicLayouter#scope}
      */
      nodeOverlapsAllowed:boolean;
      /**
      * The current OutputRestriction instance set for this instance.
      * The default is {@link yfiles.organic.OutputRestriction#NONE}.
      * @see {@link yfiles.organic.OutputRestriction#NONE}
      * @see {@link yfiles.organic.OutputRestriction}
      */
      outputRestriction:yfiles.organic.OutputRestriction;
    }
    var SmartOrganicLayouter:{
      $class:yfiles.lang.Class;
      /**
      * The data provider key for specifying the node subset to be laid out.
      * The algorithm expects for each node in the graph to find a
      * {@link yfiles.algorithms.IDataProvider#getBool  boolean} that indicates whether the node belongs
      * to the "sphere of action".
      * @see {@link yfiles.organic.SmartOrganicLayouter#scope}
      */
      NODE_SUBSET_DP_KEY:Object;
      /**
      * The data provider key for specifying how to handle group nodes.
      * The algorithm expects for each node to find one of the following constants or
      * <code>null</code>:
      * <ul>
      * <li>{@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_NORMAL}</li>
      * <li>{@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_FIX_BOUNDS}</li>
      * <li>{@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_FIX_CONTENTS}</li>
      * </ul>
      * <code>null</code> will be treated like {@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_NORMAL}.
      */
      GROUP_NODE_MODE_DP_KEY:Object;
      /**
      * Group node mode constant that can be used to tag a group node.
      * Use the {@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_DP_KEY} DataProvider key to associate this constant
      * with a group node to indicate that it should be treated like an ordinary group node.
      */
      GROUP_NODE_MODE_NORMAL:Object;
      /**
      * Group node mode constant that can be used to tag a group node.
      * Use the {@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_DP_KEY} DataProvider key to associate this constant
      * with a group node to indicate that its bounds should be treated as fixed an
      * its contents should never exceed those bounds.
      */
      GROUP_NODE_MODE_FIX_BOUNDS:Object;
      /**
      * Group node mode constant that can be used to tag a group node.
      * Use the {@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_DP_KEY} DataProvider key to associate this constant
      * with a group node to indicate that it can be moved like an ordinary group node however its
      * contents should remain fixed relative to the position of the group node.
      * Note that this implicitly fixes all descendants of the group node.
      */
      GROUP_NODE_MODE_FIX_CONTENTS:Object;
      /**
      * The data provider key for specifying the preferred edge lengths for each edge
      * The algorithm expects to find {@link yfiles.algorithms.IDataProvider#getInt} integer values associated with
      * each edge.
      */
      PREFERRED_EDGE_LENGTH_DP_KEY:Object;
      /**
      * Creates a new SmartOrganicLayouter instance.
      */
      new ():yfiles.organic.SmartOrganicLayouter;
    };
    /**
    * This LayoutStage removes node overlaps and guarantees a certain minimal
    * node distance.
    */
    export interface RemoveOverlapsLayoutStage extends Object,yfiles.layout.ILayoutStage{
      /**
      * the graph.
      */
      graph:yfiles.layout.LayoutGraph;
      /**
      * the source of randomness.
      */
      random:yfiles.algorithms.YRandom;
      /**
      * x coordinates based on node-indices.
      */
      x:number[];
      /**
      * y coordinates based on node-indices.
      */
      y:number[];
      /**
      * widths based on node-indices.
      */
      w:number[];
      /**
      * heights based on node-indices.
      */
      h:number[];
      /**
      * the node array.
      */
      nodes:yfiles.algorithms.Node[];
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Assigns a new graph layout to the given layout graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * updates arrays x and y according to the current centers of the nodes.
      */
      updatePos():void;
      /**
      * The core layouter.
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
    }
    var RemoveOverlapsLayoutStage:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of RemoveOverlapsLayoutStage.
      */
      new (minDist:number):yfiles.organic.RemoveOverlapsLayoutStage;
      /**
      * Creates a new instance of RemoveOverlapsLayoutStage.
      */
      WithRandom:{
        new (random:yfiles.algorithms.YRandom,minDist:number):yfiles.organic.RemoveOverlapsLayoutStage;
      };
    };
    /**
    * Layout stage that is used for handling a given partition grid structure that is
    * attached to a graph with DataProvider {@link yfiles.layout.PartitionGrid#PARTITION_GRID_DP_KEY}.
    * Note: the {@link yfiles.organic.SmartOrganicLayouter} automatically uses this stage if required.
    * Note: if there is a partition grid structure,
    * this layout stage throws an <code>WrongGraphStructure</code> if there are group nodes whose content
    * span multiple grid cells or if the associated group node mode data
    * (see {@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_DP_KEY})
    * is equals to {@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_FIX_BOUNDS}
    * or {@link yfiles.organic.SmartOrganicLayouter#GROUP_NODE_MODE_FIX_CONTENTS}.
    * @see {@link yfiles.layout.PartitionGrid}
    */
    export interface OrganicPartitionGridLayoutStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var OrganicPartitionGridLayoutStage:{
      $class:yfiles.lang.Class;
      new (core:yfiles.layout.ILayouter):yfiles.organic.OrganicPartitionGridLayoutStage;
    };
    /**
    * The InteractiveOrganicLayouter is a special organic layouter that offers functionality to change the
    * laid out graph while the layouter is running.
    * If a {@link yfiles.layout.CopiedLayoutGraph} is being laid out, structural changes (node and edge additions/removals)
    * in the original graph are automatically scheduled and executed on the copy.
    * The method {@link yfiles.organic.InteractiveOrganicLayouter#addStructureUpdate} may be used to schedule a Runnable that is executed in a
    * synchronized context and may safely update the structure of the graph.
    * The layouter can also run in a single-threaded mode that is provided by a
    * {@link yfiles.organic.InteractiveOrganicLayouter  single-threaded context}. The {@link yfiles.organic.InteractiveOrganicLayouter.ISingleThreadContext} provides methods to
    * control layout calculation.
    * @see {@link yfiles.organic.InteractiveOrganicLayouter#startLayout}
    * @see {@link yfiles.organic.InteractiveOrganicLayouter#stop}
    * @see {@link yfiles.organic.InteractiveOrganicLayouter#stopAndWait}
    */
    export interface InteractiveOrganicLayouter extends Object,yfiles.layout.ILayouter{
      /**
      * Makes sure that the core of this layouter will not use the usual {@link yfiles.layout.ILayoutStage}s,
      * like {@link yfiles.layout.ComponentLayouter}, {@link yfiles.layout.ParallelEdgeLayouter}, etc.
      * If you really need this feature, override this method and return silently.
      */
      enableOnlyCore():void;
      /**
      * Determines whether this algorithm performs automatic structure updates.
      * If set to <code>true</code> this algorithm will register a listener
      * on the graph to be laid out to automatically update internal data structures
      * as soon as the structure of the original graph changes.
      * <p>
      * The default is <code>false</code>.
      * </p>
      */
      automaticStructureUpdateEnabled:boolean;
      /**
      * Returns whether this layouter can layout the given graph.
      * @return {boolean} <code>true</code> if the graph may be laid out, <code>false</code> otherwise.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Calculates the layout for the graph.
      * The calculated layout is *NOT AUTOMATICALLY APPLIED*.
      * The graph has to be updated with the actual calculated positions automatically.
      * Attention: It is recommended to use a CopiedLayoutGraph to buffer the original graph.
      * If {@link yfiles.organic.InteractiveOrganicLayouter#automaticStructureUpdateEnabled} is set to true, structural changes
      * to the original graph are automatically transferred to the copy.
      * If an instance of CopiedLayoutGraph is laid out, the setters and getters having a node or edge
      * as parameter may be used with instances from the original graph *or* the copied graph.
      * This call will not return until {@link yfiles.organic.InteractiveOrganicLayouter#stop} is called.
      * @param {yfiles.layout.LayoutGraph} graph the graph that is laid out
      * @see {@link yfiles.organic.InteractiveOrganicLayouter#startLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Prepares the graph for layout and creates a context object that provides methods for
      * {@link yfiles.organic.InteractiveOrganicLayouter.ISingleThreadContext#continueLayout continuing}
      * and
      * {@link yfiles.organic.InteractiveOrganicLayouter.ISingleThreadContext#stopLayout stop}
      * the layout calculation.
      * Note that simply calling this method will not perform any layout. Repeated calls to {@link yfiles.organic.InteractiveOrganicLayouter.ISingleThreadContext}
      * need to be made in order for the layout calculation to be performed.
      * @param {yfiles.layout.LayoutGraph} graph the graph that gets layouted.
      * @return {yfiles.organic.InteractiveOrganicLayouter.ISingleThreadContext} the context object to control layout calculation.
      */
      startLayout(graph:yfiles.layout.LayoutGraph):yfiles.organic.InteractiveOrganicLayouter.ISingleThreadContext;
      /**
      * This method writes the calculated positions (represented by the internal data structure of this layouter) to
      * the LayoutGraph.
      * This method must only be called while the layouter is running {@link yfiles.organic.InteractiveOrganicLayouter#running}.
      * There may occur synchronization issues, if {@link yfiles.organic.InteractiveOrganicLayouter#doLayout} is not called
      * using a CopiedLayoutGraph.
      */
      commitPositions():void;
      /**
      * This method transfers the calculated positions (represented by the internal data structure of this layouter) to
      * the LayoutGraph.
      * This method must only be called while the layouter is running {@link yfiles.organic.InteractiveOrganicLayouter#running}.
      * The positions are not transferred directly.
      * Instead the nodes are moved towards the calculated position in each step.
      * "Good" values for this method may be about 50 for the maxMovement and about 0.15 as factor (when the
      * positions are updates about 25 times a second).
      * @param {number} maxMovement the maximal distance a node is moved
      * @param {number} factor determines the node movement (movement = factor * distance between calculated and actual location)
      * @return {number} 
      * the biggest movement. This value can be used to estimate the difference between calculated layout
      * and actual positions. If the return value is "0" the calculated layout has been transferred completely.
      */
      commitPositionsSmoothly(maxMovement:number,factor:number):number;
      /**
      * This method may be called if something has "changed" and the layouter shall restart/continue layout calculation.
      * This is e.g. useful if the layouter is sleeping and some user interaction has occurred.
      */
      wakeUp():void;
      /**
      * The time when the last wake-up has occurred.
      */
      lastWakeupTime:number;
      /**
      * Adds a structural update to the queue.
      * The given Runnable will be queued and executed at a specific time. Within this Runnable structural
      * changes (like edge/node removals or adds) may be done. They are synchronized with the layouter.
      * This method should only be used when changes to the structure of the graph are done. Every structural
      * change involves a rebuild of the internal data structure.
      * So "lightweight" changes like modifications of the positions of the nodes should be done using the corresponding
      * methods {@link yfiles.organic.InteractiveOrganicLayouter#setCenter}.
      * @param {function(Object, yfiles.system.EventArgs)} handler The handler delegate that will be invoked using <code>null</code> as the sender and <code>args</code> as the event arguments
      * @param {yfiles.system.EventArgs} args The event argument that will be piped to the <code>handler</code> invocation.
      */
      addStructureUpdate(handler:(sender:Object,e:yfiles.system.EventArgs)=> void,args:yfiles.system.EventArgs):void;
      /**
      * Stops the layouter.
      * The layouter will stop after the actual round. This means that the layouter cannot be awakened again.
      */
      stop():void;
      /**
      * Specifies whether the layouter has been stopped.
      */
      stopped:boolean;
      /**
      * Specifies whether the layouter is sleeping.
      * A sleeping layouter can be awakened using {@link yfiles.organic.InteractiveOrganicLayouter#wakeUp} and will continue its work.
      */
      sleeping:boolean;
      /**
      * Specifies whether the layouter is running at the moment.
      */
      running:boolean;
      /**
      * The actual working ratio.
      * <b>Getter:</b>The working ratio is the planned ratio of working time to waiting time.
      * <b>Setter:</b>The working ratio represents the amount of processor time the layouter tries to
      * grab.
      * If the working ratio is set to 1 the layouter will try to run as fast as possible. Lower values will lead
      * to small breaks after each round.
      */
      workingRatio:number;
      /**
      * The preferred edge length.
      * The edges should not become smaller than this amount.
      */
      preferredEdgeLength:number;
      /**
      * The preferred node distance.
      */
      preferredNodeDistance:number;
      /**
      * Sets the preferred edge length for the given edge.
      * @param {yfiles.algorithms.Edge} edge 
      * @param {number} newEdgeLength 
      */
      setPreferredEdgeLength(edge:yfiles.algorithms.Edge,newEdgeLength:number):void;
      /**
      * Set the inertia for the node.
      * The inertia represents how "easy" a node will move.
      * Inertia "1.0": The node will not move
      * Inertia "0.5": The node will only move half as wide as it would with an inertia of "0.0"
      * Inertia "0.0": The node will move as fast as possible
      * @param {yfiles.algorithms.Node} node 
      * @param {number} inertia 
      */
      setInertia(node:yfiles.algorithms.Node,inertia:number):void;
      /**
      * Sets the center for the node.
      * This method does not affect the graph itself. Instead the internal
      * data structure of the layouter is changed.
      * This method may be used to update node positions due to user interaction (e.g. dragging).
      * @param {yfiles.algorithms.Node} node 
      * @param {number} x 
      * @param {number} y 
      */
      setCenter(node:yfiles.algorithms.Node,x:number,y:number):void;
      /**
      * Sets the radius for the given node.
      * @param {yfiles.algorithms.Node} node 
      * @param {number} radius 
      */
      setRadius(node:yfiles.algorithms.Node,radius:number):void;
      /**
      * Sets the stress for the given node.
      * The higher the stress of a node is, the farther this node will be moved.
      * @param {yfiles.algorithms.Node} node 
      * @param {number} stress a value between 0 and 1
      */
      setStress(node:yfiles.algorithms.Node,stress:number):void;
      /**
      * Gets the stress for the given node.
      * The higher the stress of a node is, the farther this node will be moved.
      * @param {yfiles.algorithms.Node} node 
      */
      getStress(node:yfiles.algorithms.Node):number;
      /**
      * Sets the center of the node.
      * @param {yfiles.algorithms.Node} node 
      * @param {number} x 
      */
      setCenterX(node:yfiles.algorithms.Node,x:number):void;
      /**
      * Sets the center of the node.
      * @param {yfiles.algorithms.Node} node 
      * @param {number} y 
      */
      setCenterY(node:yfiles.algorithms.Node,y:number):void;
      /**
      * Return the actual center of the node.
      * @param {yfiles.algorithms.Node} node 
      * @return {yfiles.algorithms.YPoint} the center of the node or null if the layouter does not know anything about the node.
      */
      getCenter(node:yfiles.algorithms.Node):yfiles.algorithms.YPoint;
      /**
      * Return the actual center of the node.
      * @param {yfiles.algorithms.Node} node 
      * @return {number} the center of the node.
      */
      getCenterX(node:yfiles.algorithms.Node):number;
      /**
      * Return the actual center of the node.
      * @param {yfiles.algorithms.Node} node 
      * @return {number} the center of the node.
      */
      getCenterY(node:yfiles.algorithms.Node):number;
      /**
      * The maximal time the layouter will run (in milliseconds).
      * After this time it will sleep - independent of the actual result.
      */
      maxTime:number;
      /**
      * The quality time ratio set.
      */
      quality:number;
      /**
      * This method synchronizes the CopiedLayoutGraph given as parameter to {@link yfiles.organic.InteractiveOrganicLayouter#doLayout} with
      * the original graph.
      */
      syncStructure():void;
      /**
      * The current OutputRestriction instance set for this instance.
      * The default is {@link yfiles.organic.OutputRestriction#NONE}.
      * @see {@link yfiles.organic.OutputRestriction#NONE}
      * @see {@link yfiles.organic.OutputRestriction}
      */
      outputRestriction:yfiles.organic.OutputRestriction;
      /**
      * Stops a previously
      * {@link yfiles.organic.InteractiveOrganicLayouter#startLayout started}
      * layout calculation.
      */
      stopAndWait():void;
    }
    export module InteractiveOrganicLayouter{
      /**
      * Context object that provides controls of layout calculation in case the layouter runs single-threaded.
      */
      export interface ISingleThreadContext extends Object{
        /**
        * Do layout calculation for the given amount of time where it has stopped before.
        * @param {number} duration the duration of continuing layout calculation in milliseconds.
        * @see Specified by {@link yfiles.organic.InteractiveOrganicLayouter.ISingleThreadContext#continueLayout}.
        */
        continueLayout(duration:number):void;
        /**
        * Stops layout calculation.
        * After this call, this context cannot continue layout calculation again.
        * @see Specified by {@link yfiles.organic.InteractiveOrganicLayouter.ISingleThreadContext#stopLayout}.
        */
        stopLayout():void;
      }
    }
    var InteractiveOrganicLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Create a new instance of the InteractiveOrganicLayouter.
      */
      new ():yfiles.organic.InteractiveOrganicLayouter;
    };
    /**
    * A graph layout algorithm that is based on a force directed model.
    * Here is a sample output of the layouter:
    * <center><img src="doc-files/y.layout.organic.OrganicLayouter.gif" border="1"/></center>
    */
    export interface OrganicLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * The current repulsion.
      */
      repulsion:number;
      /**
      * The current attraction.
      */
      attraction:number;
      /**
      * The GroupBoundsCalculator instance that is used for the
      * calculation of the group nodes' bounds if a hierarchically grouped graph is
      * being laid out.
      * By default a {@link yfiles.layout.MinimumSizeGroupBoundsCalculator} instance
      * is registered with this instance.
      */
      groupBoundsCalculator:yfiles.layout.IGroupBoundsCalculator;
      /**
      * The group node compactness factor.
      * Values should be in the range [0..1],
      * where 0 results in group nodes not affecting the overall layout too much, whereas
      * a value of 1 forces nodes in the same group to be clustered tightly.
      * @throws {yfiles.system.ArgumentException} if compactness value does not lie in [0..1]
      */
      groupNodeCompactness:number;
      /**
      * The policy for group nodes.
      * <b>Getter:</b>This policy controls the behavior
      * of this layouter when acting on hierarchically grouped graphs.
      * The default is {@link yfiles.organic.GroupsPolicy#LAYOUT}.
      * <b>Setter:</b>This policy controls the behavior
      * of this layouter when acting on hierarchically grouped graphs.
      * This should be one of {@link yfiles.organic.GroupsPolicy#FIXED}, {@link yfiles.organic.GroupsPolicy#LAYOUT}, or
      * {@link yfiles.organic.GroupsPolicy#IGNORE}.
      */
      groupNodePolicy:yfiles.organic.GroupsPolicy;
      /**
      * The initial temperature.
      * The temperature will be multiplied with the <code>preferredEdgeLength</code>
      * and then assigned as the initial node heat.
      * <p>
      * The default is <code>0.1d</code>.
      * </p>
      */
      initialTemperature:number;
      /**
      * The final temperature.
      * This is an absolute temperature. If the average temperature falls
      * under this value, the layout process comes to a halt.
      * The default is <code>1.0d</code>.
      */
      finalTemperature:number;
      /**
      * Specifies whether or not this layouter is in deterministic mode.
      * In a deterministic mode this layouter produces the
      * same layouts for the same input graph and layout parameters.
      * <p>
      * By default deterministic mode is inactive.
      * </p>
      */
      activateDeterministicMode:boolean;
      /**
      * Specifies whether or not to activate the subtree beautifier.
      * Activating this feature lays out subtrees within the
      * given graph structure in an optimized way.
      * <p>
      * By default this feature is inactive.
      * </p>
      */
      activateTreeBeautifier:boolean;
      /**
      * The gravity factor.
      * The magnitude of the gravity factor
      * determines the strength of the force towards the barycenter of the graph.
      * A high factor layout tends to cluster nodes
      * around the barycenter of the graph. A low factor stretches the outskirts
      * of the graph far away from the center.
      * <p>
      * By default a value of <code>0.0</code> is assumed.
      * </p>
      */
      gravityFactor:number;
      /**
      * The sphere of action for this layouter.
      * <p>
      * The default value is {@link yfiles.organic.SphereOfAction#ALL}.
      * </p>
      * @see {@link yfiles.organic.OrganicLayouter#SPHERE_OF_ACTION_NODES_DP_KEY}
      */
      sphereOfAction:yfiles.organic.SphereOfAction;
      /**
      * The initial placement strategy.
      * <p>
      * The default value is {@link yfiles.organic.InitialPlacement#AS_IS}.
      * </p>
      */
      initialPlacement:yfiles.organic.InitialPlacement;
      /**
      * The maximum duration granted to this layouter.
      */
      maximumDuration:number;
      /**
      * The iteration factor of this layouter.
      * A higher iteration factor usually means better layout results and longer
      * running times.
      * <p>
      * By default an iteration factor of <code>3</code> is set.
      * </p>
      */
      iterationFactor:number;
      /**
      * The general edge length that should be attained by this
      * layouter.
      * <p>
      * By default an edge length of <code>80</code> is set.
      * </p>
      */
      preferredEdgeLength:number;
      /**
      * Specifies whether or not node sizes should be considered by this layouter.
      * If you want to layout a diagram with big nodes in it you can reduce
      * node overlaps by setting this feature to <code>true</code>.
      * <p>
      * Defaults to <code>true</code>.
      * </p>
      */
      obeyNodeSize:boolean;
      /**
      * Returns always <code>true</code> because this algorithms has no
      * preconditions.
      * @return {boolean} <code>true</code>.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Invokes the core layout algorithm.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Frees resources.
      */
      dispose():void;
    }
    var OrganicLayouter:{
      $class:yfiles.lang.Class;
      /**
      * DataProvider key used in conjunction with the sphere-of-action feature.
      * If this
      * data provider key is being used, then it
      * must return for each node in the input graph a boolean value indicating whether
      * or not it should be handled by this layouter.
      * @see {@link yfiles.algorithms.Graph#addDataProvider}
      * @see {@link yfiles.organic.OrganicLayouter#sphereOfAction}
      */
      SPHERE_OF_ACTION_NODES_DP_KEY:Object;
      /**
      * DataProvider key used in conjunction with hierarchically grouped graphs.
      * If this data provider key is registered with the LayoutGraph, then its associated
      * data provider must return for each group node node in the input graph
      * a boolean value indicating whether its contents/children should be treated
      * as fixed or not.
      * @see {@link yfiles.algorithms.Graph#addDataProvider}
      * @see {@link yfiles.organic.OrganicLayouter#groupNodePolicy}
      * @see {@link yfiles.organic.GroupsPolicy#FIXED}
      */
      FIXED_GROUP_NODES_DP_KEY:Object;
      /**
      * Key used to associate a {@link yfiles.algorithms.IDataProvider} with a
      * LayoutGraph.
      * The associated DataProvider must return
      * an <code>int</code> values for each edge of the LayoutGraph.
      * The value returned for a specific edge will be interpreted as
      * its preferred edge length.
      * If a DataProvider is bound to this key, then the global
      * preferredEdgeLength for all edges (see {@link yfiles.organic.OrganicLayouter#preferredEdgeLength})
      * will be ignored.
      * <b>Example:</b> Assuming that the edge.tag property contains 
      * for each edge a double value between 0.0 and 1.0 that should 
      * be translated to edge length preferences between 0 and 200 for the OrganicLayouter.
      * <pre><code>
      * // register an adequate mapper
      * graph.mapperRegistry.addMapperGetter(
      *     yfiles.graph.IEdge.$class, yfiles.lang.Number.$class,
      *     yfiles.organic.OrganicLayouter.PREFERRED_EDGE_LENGTH_DP_KEY,
      *     function(edge) { 
      *         return edge.tag * 200; 
      *     });
      * // launch the layouter
      * graph.applyLayout(layouter);
      * </code></pre>
      */
      PREFERRED_EDGE_LENGTH_DP_KEY:Object;
      /**
      * Returns a new organic Layouter.
      */
      new ():yfiles.organic.OrganicLayouter;
    };
  }
  export module orthogonal{
    export enum LayoutStyle{
      /**
      * Layout style specifier. In this layout style the size of the nodes will not
      * be changed by the algorithm. All edges will be routed orthogonally.
      */
      NORMAL,
      /**
      * Layout style specifier. In this layout style a uniform size will be assigned to all
      * nodes. All edges will be routed orthogonally.
      */
      UNIFORM,
      /**
      * Layout style specifier. In this layout style the size of the original nodes will
      * be enlarged in order to save some bends.
      * All edges will be routed orthogonally.
      */
      BOX,
      /**
      * Layout style specifier. In this layout style not all edges will be routed orthogonally.
      * Edge segments that directly connect to a node may be routed non-vertically and
      * non-horizontally.
      * A small uniform size will be assigned to all nodes.
      */
      MIXED,
      /**
      * Layout style specifier. Like {@link yfiles.orthogonal.LayoutStyle#NORMAL} but all directed subtree structures
      * of the graph will be laid out in an optimized way.  All edges will be routed orthogonally.
      * The tree edges will be routed in a bus-like fashion.
      */
      NORMAL_TREE,
      /**
      * Layout style specifier. In this layout style not all edges will be routed orthogonally.
      * Edge segments that directly connect to a node may be routed non-vertically and
      * non-horizontally.
      * The size of nodes will not be altered.
      */
      FIXED_MIXED,
      /**
      * Layout style specifier. Nodes will be placed
      * at the same location as with {@link yfiles.orthogonal.LayoutStyle#FIXED_MIXED}
      * but edges will be routed strictly orthogonally.
      * The size of nodes will not be altered.
      */
      FIXED_BOX
    }
    /**
    * This class provides a layout algorithm which produces
    * orthogonal drawings of hierarchically grouped graphs.
    * Here is a sample output of the layouter.
    * <center><img border="0" src="doc-files/y.layout.orthogonal.OrthogonalGroupLayouter.gif"/></center>
    */
    export interface OrthogonalGroupLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * Specifies whether the algorithm should try to align degree-one nodes that have the same neighbour.
      * The default is <code>false</code>.
      */
      alignDegreeOneNodes:boolean;
      /**
      * Determines if an additional postprocessing step is used that improves compactness and reduces the number of edge bends.
      * The postprocessing is enabled by default.
      */
      postprocessingEnabled:boolean;
      /**
      * Specifies whether the algorithm should perform a post processing algorithm
      * to reduce perceived bends in the drawing.
      * The default is <code>false</code>.
      */
      optimizePerceivedBends:boolean;
      /**
      * Factory method that creates the default EdgeLayoutDescriptor.
      * May not return <code>null</code>!
      * @return {yfiles.orthogonal.EdgeLayoutDescriptor} a new EdgeLayoutDescriptor (<code>new EdgeLayoutDescriptor()</code>)
      */
      createEdgeLayoutDescriptor():yfiles.orthogonal.EdgeLayoutDescriptor;
      /**
      * The <code>EdgeLayoutDescriptor</code> instance used for all those
      * edges, that do not have a specific layout descriptor assigned.
      * @see {@link yfiles.orthogonal.OrthogonalLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      * @see {@link yfiles.orthogonal.OrthogonalGroupLayouter#createEdgeLayoutDescriptor}
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      * @see {@link yfiles.orthogonal.OrthogonalLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      */
      edgeLayoutDescriptor:yfiles.orthogonal.EdgeLayoutDescriptor;
      /**
      * Specifies whether or not node labels are taken into account when calculating node positions (thereby preventing
      * possible node/node label or node label/node label overlaps).
      * <b>Setter:</b>This method is a convenience method that assures that the
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter} is of type {@link yfiles.layout.LabelLayoutTranslator} and {@link yfiles.layout.LabelLayoutTranslator#translateNodeLabels} is set to
      * <code>true</code>.
      * Note that setting this option may overwrite the currently set label layouter. Hence, to combine this option with
      * a generic edge labeling algorithm, the generic labeling has to be applied in an additional step after calculating the layout. 
      * <b>Getter:</b>This method is a convenience method checks whether the
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter} is of type {@link yfiles.layout.LabelLayoutTranslator} and {@link yfiles.layout.LabelLayoutTranslator#translateNodeLabels} returns <code>true</code>.
      *  The default is <code>false</code>.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current label layouter is not of type {@link yfiles.layout.LabelLayoutTranslator}.
      */
      considerNodeLabels:boolean;
      /**
      * Specifies whether integrated edge labeling is enabled.
      * This method is a convenience method that checks if the {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter} is of type {@link yfiles.layout.LabelLayoutTranslator} and
      * {@link yfiles.layout.LabelLayoutTranslator#translateEdgeLabels} returns <code>true</code>. 
      *  The default is
      * <code>false</code>.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current label layouter is not of type {@link yfiles.layout.LabelLayoutTranslator}.
      */
      integratedEdgeLabeling:boolean;
      /**
      * The currently set layout quality.
      * Higher quality means less connection
      * crossings and smaller layout area, but also increased computation time.
      * By default best layout quality (value <code>1</code>) is set.
      */
      layoutQuality:number;
      /**
      * The grid distance.
      */
      grid:number;
      /**
      * Note that the component layouter set here should work in such a way that
      * isolated components inside groups should be reported separately.
      * E.g. instances of {@link yfiles.layout.IsolatedGroupComponentLayouter} can be set here.
      * If the component layouter should be customized, the suggested way of doing this is to
      * {@link yfiles.layout.CanonicMultiStageLayouter#componentLayouter} and cast it to {@link yfiles.layout.ComponentLayouter}.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#componentLayouter}
      */
      componentLayouter:yfiles.layout.ILayoutStage;
      /**
      * Subclasses have to provide information whether or not they
      * can layout the given graph.
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Subclasses have to provide core layout code in this method.
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var OrthogonalGroupLayouter:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to retrieve {@link yfiles.orthogonal.EdgeLayoutDescriptor}
      * instances for each edge in the graph.
      * Different settings will affect the routing of the edges during the layout.
      */
      EDGE_LAYOUT_DESCRIPTOR_DP_KEY:Object;
      /**
      * Creates a new instance of OrthogonalGroupLayouter.
      */
      new ():yfiles.orthogonal.OrthogonalGroupLayouter;
    };
    /**
    * This class is a variant of {@link yfiles.orthogonal.OrthogonalLayouter} that tries to arrange nodes in a more
    * compact way, even allowing to specify a desired aspect ratio for the bounds of the
    * calculated layout.
    * This is especially important if you want to print the layout
    * on a paper with predefined size. As a disadvantage, this algorithm will usually produce
    * less elegant edge routes than {@link yfiles.orthogonal.OrthogonalLayouter} does.
    * <p>
    * The algorithm is realized as a {@link yfiles.layout.PartitionLayouter}, that uses {@link yfiles.layout.PartitionLayouter.EdgeBetweennessPartitionFinder}
    * to partition the graph, {@link yfiles.orthogonal.OrthogonalLayouter} to layout the graph partitions, {@link yfiles.layout.PartitionLayouter.ComponentPartitionPlacer}
    * to place the partitions, and finally {@link yfiles.layout.PartitionLayouter.ChannelInterEdgeRouter} to route the edges between partitions.
    * Each of these strategies can be individually configured and/or replaced.
    * </p>
    * <p>
    * Here is a sample output of the layouter with aspect ratio of the resulting layout bounds set to <code>1</code>.
    * </p>
    * <p>
    * <center><img src="doc-files/y.layout.orthogonal.CompactOrthogonalLayouter.gif" border="1"/></center>
    * </p>
    */
    export interface CompactOrthogonalLayouter extends yfiles.layout.PartitionLayouter{
      /**
      * The grid spacing used to place the nodes.
      * By default, a value of <code>20</code> is set.
      * Setting the grid spacing will only have an effect if the configurable stages
      * have not been replaced by other implementations.
      * <b>Note</b>: When setting configurable stages <em>after</em> specifying
      * grid spacing, it is assumed that the aforementioned stages are already
      * properly configured and the previously set grid spacing will not be passed
      * to these stages.
      */
      gridSpacing:number;
      /**
      * The desired aspect ratio of the resulting layout bounds.
      * the quotient width/height) of the
      * resulting layout bounds. By default a value of <code>1</code> is set.
      * This setting will only have an effect if the set {@link yfiles.layout.PartitionLayouter.IPartitionPlacer}
      * is of the pre-configured type {@link yfiles.layout.PartitionLayouter.ComponentPartitionPlacer}.
      * <b>Note</b>: When setting configurable stages <em>after</em> specifying
      * aspect ratio, it is assumed that the aforementioned stages are already
      * properly configured and the previously set aspect ratio will not be passed
      * to these stages.
      */
      aspectRatio:number;
    }
    var CompactOrthogonalLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Create a new instance of this class with a default aspect ratio of 1 and a
      * default grid spacing of 20.
      */
      new ():yfiles.orthogonal.CompactOrthogonalLayouter;
    };
    /**
    * This class provides a layout algorithm which produces
    * orthogonal drawings.
    * OrthogonalLayouter can consider edge label data when laying out a graph.
    * That means that the the layout of edge labels will be part of the resulting
    * layout and the layout of nodes and edges is chosen in such a way that the
    * edge labels do not conflict with the rest of the layout.
    * See classes {@link yfiles.layout.LabelLayoutData},
    * {@link yfiles.layout.LabelLayoutKeys} and {@link yfiles.layout.LabelLayoutTranslator} on how
    * to setup the integrated edge label layout feature.
    * Here is an sample output of the layouter using the layout style {@link yfiles.orthogonal.LayoutStyle#NORMAL}.
    * <center><img src="doc-files/y.layout.orthogonal.OrthogonalLayouter.gif" border="1"/></center>
    */
    export interface OrthogonalLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      nodeModel:number;
      /**
      * Factory method that creates the default EdgeLayoutDescriptor.
      * May not return <code>null</code>!
      * @return {yfiles.orthogonal.EdgeLayoutDescriptor} a new EdgeLayoutDescriptor (<code>new EdgeLayoutDescriptor()</code>)
      */
      createEdgeLayoutDescriptor():yfiles.orthogonal.EdgeLayoutDescriptor;
      /**
      * The <code>EdgeLayoutDescriptor</code> instance used for all those
      * edges, that do not have a specific layout descriptor assigned.
      * @see {@link yfiles.orthogonal.OrthogonalLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      * @see {@link yfiles.orthogonal.OrthogonalLayouter#createEdgeLayoutDescriptor}
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      * @see {@link yfiles.orthogonal.OrthogonalLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      */
      edgeLayoutDescriptor:yfiles.orthogonal.EdgeLayoutDescriptor;
      /**
      * Specifies whether or not node labels are taken into account when calculating node positions (thereby preventing
      * possible node/node label or node label/node label overlaps).
      * <b>Setter:</b>This method is a convenience method that assures that the
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter} label layouter is of type {@link yfiles.layout.LabelLayoutTranslator} and {@link yfiles.layout.LabelLayoutTranslator#translateNodeLabels} is set to
      * <code>true</code>.
      * Note that setting this option may overwrite the currently set label layouter. Hence, to combine this option with
      * a generic edge labeling algorithm, the generic labeling has to be applied in an additional step after calculating the layout.
      * Furthermore, node labels can only be considered if the layout style is set to {@link yfiles.orthogonal.LayoutStyle#NORMAL}.
      * <b>Getter:</b>This method is a convenience method checks whether the
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter} is of type {@link yfiles.layout.LabelLayoutTranslator} and {@link yfiles.layout.LabelLayoutTranslator#translateNodeLabels} returns <code>true</code>.
      *  The default is <code>false</code>.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current label layouter is not of type {@link yfiles.layout.LabelLayoutTranslator}.
      */
      considerNodeLabels:boolean;
      /**
      * Specifies whether integrated edge labeling is enabled.
      * <b>Setter:</b>This method is a convenience method that assures that the
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter} is of type {@link yfiles.layout.LabelLayoutTranslator} and {@link yfiles.layout.LabelLayoutTranslator#translateEdgeLabels} is set to
      * <code>true</code>
      * Note: edge labels can only be considered if the layout style is set to {@link yfiles.orthogonal.LayoutStyle#NORMAL}.
      * <b>Getter:</b>This method is a convenience method that checks if the {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter} is of type {@link yfiles.layout.LabelLayoutTranslator} and
      * {@link yfiles.layout.LabelLayoutTranslator#translateEdgeLabels} returns <code>true</code>. 
      *  The default is
      * <code>false</code>.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current label layouter is not of type {@link yfiles.layout.LabelLayoutTranslator}.
      */
      integratedEdgeLabeling:boolean;
      /**
      * If a randomization strategy is used.
      * The randomization usually improves the result but it may be disabled to
      * get a deterministic behavior of the algorithm.
      * Default is <code>true</code>.
      */
      useRandomization:boolean;
      /**
      * Specifies whether the algorithm should try to align degree-one nodes that have the same neighbour.
      * The default is <code>false</code>.
      */
      alignDegreeOneNodes:boolean;
      /**
      * If the layouter should try to maximize one face of the embedding.
      * Default is <code>false</code>.
      */
      useFaceMaximization:boolean;
      /**
      * If post-processing is used to reduce the number of crossings.
      * This post-processing may decrease the number of crossings significantly
      * but it may slows down the algorithm, too.
      * Default is <code>true</code>.
      */
      useCrossingPostprocessing:boolean;
      /**
      * Specifies whether the algorithm should perform a post processing algorithm
      * to reduce perceived bends in the drawing.
      * The default is <code>false</code>.
      */
      optimizePerceivedBends:boolean;
      /**
      * The size of the grid on which the nodes and edges are placed.
      * Default is 20.
      */
      grid:number;
      /**
      * The layout style of this layouter.
      * By default the layout style {@link yfiles.orthogonal.LayoutStyle#NORMAL} is set.
      */
      layoutStyle:yfiles.orthogonal.LayoutStyle;
      /**
      * If post-processing is used to reduce the space used by the drawing.
      * This post-processing may decrease space significantly
      * but it slows the algorithm down.
      * Default is <code>true</code>.
      */
      useSpacePostprocessing:boolean;
      /**
      * If the algorithm optimizes over the length of the edges.
      * This may decrease the length of some edges significantly
      * but it slows the algorithm down.
      * Default is <code>true</code>.
      */
      useLengthReduction:boolean;
      /**
      * If the existing drawing should be used as sketch.
      */
      useSketchDrawing:boolean;
      /**
      * Returns always <code>true</code>.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Assigns an orthogonal graph layout to the given layout graph.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
    }
    var OrthogonalLayouter:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to retrieve {@link yfiles.orthogonal.EdgeLayoutDescriptor}
      * instances for each edge in the graph.
      * Different settings will affect the routing of the edges during the layout.
      * Note: minimum edge length constraints are only considered for layout style {@link yfiles.orthogonal.LayoutStyle#NORMAL},
      * {@link yfiles.orthogonal.LayoutStyle#NORMAL_TREE} and {@link yfiles.orthogonal.LayoutStyle#UNIFORM} (see {@link yfiles.orthogonal.OrthogonalLayouter#layoutStyle}).
      * @see {@link yfiles.orthogonal.OrthogonalLayouter#layoutStyle}
      */
      EDGE_LAYOUT_DESCRIPTOR_DP_KEY:Object;
      /**
      * Returns a new instance.
      */
      new ():yfiles.orthogonal.OrthogonalLayouter;
    };
    /**
    * This class is a variant of {@link yfiles.orthogonal.OrthogonalLayouter} that can route edges in a way that
    * they point to a main layout direction.
    * Also, this class can route edges that connect to the same
    * node in a shared bus-structure. A typical use case for this layout algorithm are UML class diagrams
    * that contain some relationships like generalization or realization which are best expressed by
    * upward-pointing edges.
    * Directed edges are marked by a boolean data provider that is registered with the key
    * {@link yfiles.orthogonal.DirectedOrthogonalLayouter#DIRECTED_EDGE_DP_KEY} to the input graph. Edge groups at a common node can be specified
    * by registering data providers with the keys {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY}
    * and {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}.
    * Like {@link yfiles.orthogonal.OrthogonalLayouter} this layout algorithm can consider edge label data when
    * laying out a graph. That means that the layout of edge labels will be part of the resulting
    * layout and the layout of nodes and edges is chosen in such a way that the
    * edge labels do not conflict with the rest of the layout.
    * See classes {@link yfiles.layout.LabelLayoutData},
    * {@link yfiles.layout.LabelLayoutKeys} and {@link yfiles.layout.LabelLayoutTranslator} on how
    * to setup the integrated edge label layout feature.
    * Here is an sample output of the layout algorithm. Note that all edges painted in blue
    * are marked as directed edges. Also, the directed edges at each node have been put into the
    * same edge group.
    * <center><img src="doc-files/y.layout.orthogonal.DirectedOrthogonalLayouter.gif" border="1"/></center>
    */
    export interface DirectedOrthogonalLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * Specifies whether the algorithm should try to align degree-one nodes that have the same neighbour.
      * The default is <code>false</code>.
      */
      alignDegreeOneNodes:boolean;
      /**
      * Factory method that creates the default EdgeLayoutDescriptor.
      * May not return <code>null</code>!
      * @return {yfiles.orthogonal.EdgeLayoutDescriptor} a new EdgeLayoutDescriptor (<code>new EdgeLayoutDescriptor()</code>)
      */
      createEdgeLayoutDescriptor():yfiles.orthogonal.EdgeLayoutDescriptor;
      /**
      * The <code>EdgeLayoutDescriptor</code> instance used for all those
      * edges, that do not have a specific layout descriptor assigned.
      * @see {@link yfiles.orthogonal.OrthogonalLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      * @see {@link yfiles.orthogonal.DirectedOrthogonalLayouter#createEdgeLayoutDescriptor}
      * @throws {yfiles.system.ArgumentNullException} if the argument is <code>null</code>
      * @see {@link yfiles.orthogonal.OrthogonalLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      */
      edgeLayoutDescriptor:yfiles.orthogonal.EdgeLayoutDescriptor;
      /**
      * Specifies whether or not node labels are taken into account when calculating node positions (thereby preventing
      * possible node/node label or node label/node label overlaps).
      * <b>Setter:</b>This method is a convenience method that assures that the
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter} is of type {@link yfiles.layout.LabelLayoutTranslator} and {@link yfiles.layout.LabelLayoutTranslator#translateNodeLabels} is set to
      * <code>true</code>.
      * Note that setting this option may overwrite the currently set label layouter. Hence, to combine this option with
      * a generic edge labeling algorithm, the generic labeling has to be applied in an additional step after calculating the layout. 
      * <b>Getter:</b>This method is a convenience method checks whether the
      * {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter} is of type {@link yfiles.layout.LabelLayoutTranslator} and {@link yfiles.layout.LabelLayoutTranslator#translateNodeLabels} returns <code>true</code>.
      *  The default is <code>false</code>.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current label layouter is not of type {@link yfiles.layout.LabelLayoutTranslator}.
      */
      considerNodeLabels:boolean;
      /**
      * Specifies whether the algorithm should perform a post processing algorithm
      * to reduce perceived bends in the drawing.
      * The default is <code>false</code>.
      */
      optimizePerceivedBends:boolean;
      /**
      * Specifies whether integrated edge labeling is enabled.
      * This method is a convenience method that checks if the {@link yfiles.layout.CanonicMultiStageLayouter#labelLayouter  label layouter} is of type {@link yfiles.layout.LabelLayoutTranslator} and
      * {@link yfiles.layout.LabelLayoutTranslator#translateEdgeLabels} returns <code>true</code>. 
      *  The default is
      * <code>false</code>.
      * @throws {yfiles.system.InvalidOperationException} 
      * if the current label layouter is not of type {@link yfiles.layout.LabelLayoutTranslator}.
      */
      integratedEdgeLabeling:boolean;
      /**
      * The currently set grid spacing.
      * By default a value of <code>20</code> is set.
      */
      grid:number;
      /**
      * If the existing drawing should be used as sketch.
      */
      useSketchDrawing:boolean;
      /**
      * If an additional postprocessing step is used that improves compactness and reduces the number of edge bends.
      * The postprocessing is enabled by default.
      */
      usePostprocessing:boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Subclasses have to provide core layout code in this method.
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Subclasses have to provide information whether or not they
      * can layout the given graph.
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
    }
    var DirectedOrthogonalLayouter:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to retrieve {@link yfiles.orthogonal.EdgeLayoutDescriptor}
      * instances for each edge in the graph.
      * Different settings will affect the routing of the edges during the layout.
      */
      EDGE_LAYOUT_DESCRIPTOR_DP_KEY:Object;
      /**
      * DataProvider key that is used to mark edges that should be routed in a way that
      * point in the main layout direction.
      * The main layout direction can be set
      * by using method {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation} .
      */
      DIRECTED_EDGE_DP_KEY:Object;
      /**
      * Creates a new instance of this class.
      */
      new ():yfiles.orthogonal.DirectedOrthogonalLayouter;
    };
    /**
    * This class is used by {@link yfiles.orthogonal.OrthogonalLayouter}, {@link yfiles.orthogonal.DirectedOrthogonalLayouter} and
    * {@link yfiles.orthogonal.OrthogonalGroupLayouter} to determine the routing details of the graph's edges.
    * @see {@link yfiles.orthogonal.OrthogonalLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
    * @see {@link yfiles.orthogonal.DirectedOrthogonalLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
    * @see {@link yfiles.orthogonal.OrthogonalGroupLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
    */
    export interface EdgeLayoutDescriptor extends Object{
      /**
      * The minimum length of the first segment (at the source).
      * <b>Setter:</b>Note: the resulting segment length also depends on the given grid size
      * (see {@link yfiles.orthogonal.OrthogonalLayouter#grid}),
      * i.e., segment length >= (int) Math.ceil(length / grid size).
      * <b>Getter:</b>Default is <code>15.0d</code>.
      */
      minimumFirstSegmentLength:number;
      /**
      * The minimum length of the last segment (at the target).
      * <b>Setter:</b>Note: the resulting segment length also depends on the given grid size
      * (see {@link yfiles.orthogonal.OrthogonalLayouter#grid}),
      * i.e., segment length >= (int) Math.ceil(length / grid size).
      * <b>Getter:</b>Default is <code>15.0d</code>.
      */
      minimumLastSegmentLength:number;
      /**
      * The minimum segment length of the edge.
      * <b>Setter:</b>Note: the resulting segment length also depends on the given grid size
      * (see {@link yfiles.orthogonal.OrthogonalLayouter#grid}),
      * i.e., segment length >= (int) Math.ceil(length / grid size).
      * <b>Getter:</b>Default is <code>15.0d</code>.
      */
      minimumSegmentLength:number;
      /**
      * Creates a copy of this instance.
      * @return {yfiles.orthogonal.EdgeLayoutDescriptor} the copy.
      */
      createCopy():yfiles.orthogonal.EdgeLayoutDescriptor;
    }
    var EdgeLayoutDescriptor:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of an EdgeLayoutDescriptor using the
      * default values.
      */
      new ():yfiles.orthogonal.EdgeLayoutDescriptor;
    };
  }
  export module partial{
    /**
    * This class represents a partial layouter.
    * A partial layouter is a layout algorithm that changes the coordinates for a
    * given set of graph elements (called partial elements). The location or size of the remaining elements (called fixed
    * elements) is not allowed to be changed. The layout algorithm tries to place the partial elements such that the
    * resulting drawing (including the fixed elements) has a good quality with respect to common graph drawing aesthetics.
    * <p>This layouter can be applied to plain graphs as well as to grouped graphs.
    * Note: when a partial node should be placed inside a fixed group node,
    * it is important that there is enough free space inside the group. Otherwise, there may be overlapping node elements.</p>
    * <p>The layouter handles each selected graph element as partial element. Therefore it looks up the data provider keys
    * {@link yfiles.partial.PartialLayouter#PARTIAL_NODES_DP_KEY} and {@link yfiles.partial.PartialLayouter#PARTIAL_EDGES_DP_KEY}. Partial node elements can be
    * assigned to so called subgraph components. During the layout process each subgraph induced by the nodes of a
    * component is first laid out using the specified core layouter {@link yfiles.partial.PartialLayouter#coreLayouter}. Then, the
    * different components are placed one-by-one onto the drawing area such that the number of overlaps among graph
    * elements is small. The user can specify different objectives for finding 'good' positions for subgraph components
    * ({@link yfiles.partial.PartialLayouter#positioningStrategy}), e.g., {@link yfiles.partial.SubgraphPositioningStrategy#BARYCENTER} specifies that the
    * component should be placed close to the barycenter of its graph neighbors and {@link yfiles.partial.SubgraphPositioningStrategy#FROM_SKETCH} specifies that the component should be placed close to its original
    * position. </p>
    * <p> Method {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy} allows to specify the strategy that is used
    * to assign partial nodes to subgraph components. Possible values are {@link yfiles.partial.ComponentAssignmentStrategy#CLUSTERING},
    * {@link yfiles.partial.ComponentAssignmentStrategy#CONNECTED}, {@link yfiles.partial.ComponentAssignmentStrategy#SINGLE} and {@link yfiles.partial.ComponentAssignmentStrategy#CUSTOMIZED}. The last value allows to use a customized component assignment. Note:
    * nodes of a component cannot be assigned to different group nodes. </p>
    * <p> Furthermore, the user can specify the edge
    * routing strategy (method {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}) that is used for routing partial edges and edges
    * between different subgraph components (so-called inter-edges). Possible values are {@link yfiles.partial.EdgeRoutingStrategy#ORGANIC}, {@link yfiles.partial.EdgeRoutingStrategy#ORTHOGONAL}, {@link yfiles.partial.EdgeRoutingStrategy#STRAIGHTLINE}, {@link yfiles.partial.EdgeRoutingStrategy#OCTILINEAR} and {@link yfiles.partial.EdgeRoutingStrategy#AUTOMATIC}. </p>
    */
    export interface PartialLayouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * The core layouter, i.e., the layout algorithm that is applied to the subgraph components.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#coreLayouter}
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
      /**
      * The time limit (in milliseconds) set for the layout algorithm.
      * Note that restricting the maximal duration
      * may result in a worse layout quality. Furthermore, the real runtime may exceed the maximal duration since the
      * layout algorithm still have to find a valid solution.
      * By default the time limit is Integer.MAX_VALUE.
      */
      maximalDuration:number;
      /**
      * Specifies whether or not edges between different subgraph components should be routed immediately.
      * If this option is enabled, edges are routed during the placement of the subgraph components, i.e., immediately
      * after a component is placed, its edges to other, already placed components are routed.
      * Otherwise these edges are routed in a separate step after placing all subgraph components.
      * By default this option is disabled.
      * @see {@link yfiles.partial.PartialLayouter#routeInterEdges}
      * @see {@link yfiles.partial.PartialLayouter#placeSubgraphs}
      */
      routeInterEdgesImmediately:boolean;
      /**
      * If enabled, the bounding boxes of subgraph components may overlap (elements of different components will still not
      * overlap).
      * If set to true, the bounding boxes of subgraph
      * components may overlap (elements of different components will still not overlap).
      */
      packComponents:boolean;
      /**
      * Specifies whether or not fixed group nodes may be resized.
      */
      fixedGroupResizingEnabled:boolean;
      /**
      * The objective used for finding 'good' positions for subgraph components.
      */
      positioningStrategy:yfiles.partial.SubgraphPositioningStrategy;
      /**
      * The minimum distance between two adjacent nodes.
      */
      minimalNodeDistance:number;
      /**
      * True, if node alignment is enabled, that is the algorithm tries to
      * align partial nodes with other nodes.
      * If set to true, the algorithm tries to align the center of
      * partial nodes with other nodes.
      */
      considerNodeAlignment:boolean;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * The strategy that is used to assign partial nodes to subgraph components.
      */
      componentAssignmentStrategy:yfiles.partial.ComponentAssignmentStrategy;
      /**
      * Specifies whether or not a postprocessing step should be applied to reduce
      * the number of edges that do not comply with the desired orientation.
      * <p>
      * By default, this feature is disabled.
      * </p>
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      */
      optimizeLayoutOrientation:boolean;
      /**
      * The edge router used for routing partial edges as well as edges
      * between different subgraph components (so-called inter-edges).
      * The specified edge router is used for routing partial edges as well as
      * edges between different subgraph components (so-called inter-edges).
      * Edges that have to be routed with the specified router will be marked
      * using this algorithm's {@link yfiles.partial.PartialLayouter#ROUTE_EDGE_DP_KEY} data provider key.
      * <p>
      * Note: the customized edge router is disabled when method {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy} is called
      * afterwards.
      * </p>
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      * @see {@link yfiles.partial.PartialLayouter#ROUTE_EDGE_DP_KEY}
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      */
      edgeRouter:yfiles.layout.ILayouter;
      /**
      * The specified edge routing strategy.
      * <p>
      * Note: calling this method disables a previously set customized edge router (see method
      * {@link yfiles.partial.PartialLayouter#edgeRouter}).
      * </p>
      * @see {@link yfiles.partial.PartialLayouter#edgeRouter}
      */
      edgeRoutingStrategy:yfiles.partial.EdgeRoutingStrategy;
      /**
      * The layout orientation.
      * @see {@link yfiles.partial.LayoutOrientation#TOP_TO_BOTTOM}
      * @see {@link yfiles.partial.LayoutOrientation#BOTTOM_TO_TOP}
      * @see {@link yfiles.partial.LayoutOrientation#LEFT_TO_RIGHT}
      * @see {@link yfiles.partial.LayoutOrientation#RIGHT_TO_LEFT}
      * @see {@link yfiles.partial.LayoutOrientation#AUTO_DETECT}
      * @see {@link yfiles.partial.LayoutOrientation#NONE}
      * @see {@link yfiles.partial.LayoutOrientation#TOP_TO_BOTTOM}
      * @see {@link yfiles.partial.LayoutOrientation#BOTTOM_TO_TOP}
      * @see {@link yfiles.partial.LayoutOrientation#LEFT_TO_RIGHT}
      * @see {@link yfiles.partial.LayoutOrientation#RIGHT_TO_LEFT}
      * @see {@link yfiles.partial.LayoutOrientation#AUTO_DETECT}
      * @see {@link yfiles.partial.LayoutOrientation#NONE}
      */
      layoutOrientation:yfiles.partial.LayoutOrientation;
      /**
      * Specifies whether or not subgraph components may be mirrored to improve the layout quality, i.e., for each component
      * the algorithm checks which of the four possible mirrorings minimizes the edge length.
      */
      allowMirroring:boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * This method calculates the partial layout.
      * Therefore, it calls the following methods: 1. {@link yfiles.partial.PartialLayouter#routeEdgesBetweenFixedElements} 2. {@link yfiles.partial.PartialLayouter#layoutSubgraph} for each subgraph component 3. {@link yfiles.partial.PartialLayouter#placeSubgraphs} 4. {@link yfiles.partial.PartialLayouter#routeInterEdges}
      * Note: the method is called after applying the {@link yfiles.layout.OrientationLayouter}. Hence, the called methods
      * always assume that the graph is drawn from top to bottom.
      * @param {yfiles.layout.LayoutGraph} graph the input graph.
      */
      doPartialLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Calculates the layout for the subgraph component.
      * @param {yfiles.layout.LayoutGraph} subGraph the subgraph component
      */
      layoutSubgraph(subGraph:yfiles.layout.LayoutGraph):void;
      /**
      * This method places the subgraph components one-by-one onto the drawing area.
      * Therefore, it considers the specified
      * objective for finding a 'good' position, see ({@link yfiles.partial.PartialLayouter#positioningStrategy}).
      * @param {yfiles.layout.LayoutGraph} graph the input graph
      * @param {yfiles.algorithms.NodeList[]} subgraphComponents each entry contains a NodeList that defines a subgraph component
      */
      placeSubgraphs(graph:yfiles.layout.LayoutGraph,subgraphComponents:yfiles.algorithms.NodeList[]):void;
      /**
      * This method routes all inter-edges, that is edges between different
      * subgraph components (including edges between fixed and partial elements).
      * Therefore, it uses the edge router set with method
      * {@link yfiles.partial.PartialLayouter#edgeRouter}. If no edge router was specified
      * by the user, it uses an internal edge router with routing strategy
      * {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}.
      * @param {yfiles.layout.LayoutGraph} graph the relevant graph.
      * @param {yfiles.algorithms.EdgeList} interEdges the edges to route.
      */
      routeInterEdges(graph:yfiles.layout.LayoutGraph,interEdges:yfiles.algorithms.EdgeList):void;
      /**
      * This method routes all partial edges that connect two fixed elements.
      * Therefore, it uses the edge router set with
      * method {@link yfiles.partial.PartialLayouter#edgeRouter}. If no edge router was specified by the user, it uses an internal
      * edge router with routing strategy {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}.
      * @param {yfiles.layout.LayoutGraph} graph the subgraph of the original graph induced on the fixed nodes.
      * @param {yfiles.algorithms.EdgeList} partialEdges the edges to route.
      */
      routeEdgesBetweenFixedElements(graph:yfiles.layout.LayoutGraph,partialEdges:yfiles.algorithms.EdgeList):void;
      /**
      * This method is called each time edges are routed with an edge router instance.
      * Hence, it offers a way to
      * modify the used settings.
      * <p>
      * The type of the given instance depends on the edge routing strategy, i.e.,
      * if the routing strategy is set to {@link yfiles.partial.EdgeRoutingStrategy#OCTILINEAR} or
      * {@link yfiles.partial.EdgeRoutingStrategy#ORTHOGONAL} it's an instance of {@link yfiles.router.polyline.EdgeRouter}, if the routing strategy is set
      * to {@link yfiles.partial.EdgeRoutingStrategy#ORGANIC} it's an instance of {@link yfiles.organic.SmartOrganicLayouter}, and, if the routing
      * strategy is set to {@link yfiles.partial.EdgeRoutingStrategy#STRAIGHTLINE} it's an instance of {@link yfiles.partial.PartialLayouter.StraightLineEdgeRouter}.
      * If the edge routing strategy is set to {@link yfiles.partial.EdgeRoutingStrategy#AUTOMATIC} one of the above strategies is used.
      * </p>
      * <p>
      * Note: if a customized edge router is set (see {@link yfiles.partial.PartialLayouter#edgeRouter}),
      * the edge router instance is of this type.
      * </p>
      * @param {yfiles.layout.ILayouter} edgeRouter the instance used for routing the edges.
      * @see {@link yfiles.partial.PartialLayouter#edgeRouter}
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      */
      configureEdgeRouter(edgeRouter:yfiles.layout.ILayouter):void;
    }
    export module PartialLayouter{
      /**
      * Simple Edge Router that draws edges straight-line.
      */
      export interface StraightLineEdgeRouter extends yfiles.router.StraightLineEdgeRouter{
        /**
        * Main layout routine that assigns new layout information to the given graph.
        * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
        */
        doLayout(graph:yfiles.layout.LayoutGraph):void;
      }
    }
    var PartialLayouter:{
      $class:yfiles.lang.Class;
      /**
      * The data provider key used to look up the partial nodes of the graph.
      * The looked up data provider should provide boolean values
      * for the nodes of that graph. The boolean value should signal
      * whether a node is to be considered as partial or not.
      */
      PARTIAL_NODES_DP_KEY:Object;
      /**
      * If a layout orientation (see {@link yfiles.partial.PartialLayouter#layoutOrientation}) is specified
      * (i.e., {@link yfiles.partial.PartialLayouter#layoutOrientation} != {@link yfiles.partial.LayoutOrientation#NONE}),
      * this data provider key can be used to distinguish between directed and undirected edges.
      * The layout orientation is only considered for directed edges.
      * The registered data provider's {@link yfiles.algorithms.IDataProvider#getBool getBool} method should return <code>true</code> for directed edges and <code>false</code> for undirected edges.
      * Note: if this data provider is not registered, all edges are considered to be directed.
      */
      DIRECTED_EDGES_DP_KEY:Object;
      /**
      * The data provider key used to look up the partial edges of the graph.
      * The looked up data provider should provide
      * boolean values for the edges of that graph. The boolean value should signal whether an edge is to be considered as
      * partial or not.
      */
      PARTIAL_EDGES_DP_KEY:Object;
      /**
      * This key is used by this algorithm to temporarily add a DataProvider that marks edges that should be routed
      * by the edge router.
      * <p>
      * Note that this DataProvider must not be set by the user! It is automatically set during the layout
      * and should only be used by the specified edge router (see {@link yfiles.partial.PartialLayouter#edgeRouter}).
      * </p>
      * The added data provider's {@link yfiles.algorithms.IDataProvider#getBool}
      * method will return <code>true</code> for edges that have to be
      * routed and <code>false</code> for all other edges.
      * @see {@link yfiles.partial.PartialLayouter#edgeRouter}
      */
      ROUTE_EDGE_DP_KEY:string;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to store an object for each partial node of the graph.
      * All partial nodes
      * associated with the same object are assigned to the same subgraph component. Note: nodes of a component cannot be
      * assigned to different group nodes as well as different partition cells.
      * @see {@link yfiles.partial.ComponentAssignmentStrategy#CUSTOMIZED}
      * @see {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy}
      * @see {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy}
      */
      COMPONENT_ASSIGNMENT_DP_KEY:Object;
      /**
      * Creates a new instance of the PartialLayouter.
      */
      new ():yfiles.partial.PartialLayouter;
      /**
      * Creates a new instance of the PartialLayouter.
      * The parameter specifies the layout algorithm that is used for the
      * subgraph components.
      * @param {yfiles.layout.ILayouter} subgraphLayouter the layout algorithm that is applied to the subgraph components.
      */
      WithCoreLayouter:{
        new (subgraphLayouter:yfiles.layout.ILayouter):yfiles.partial.PartialLayouter;
      };
      StraightLineEdgeRouter:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new StraightLineEdgeRouter.
        */
        new ():yfiles.partial.PartialLayouter;
      };
    };
    export enum EdgeRoutingStrategy{
      /**
      * Specifier for the routing strategy of inter-edges (edges between fixed and partial nodes as well as edges between
      * different subgraph components). The algorithm will use orthogonal routes for inter-edges, i.e., each edge only
      * consists of vertical and horizontal segments.
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      */
      ORTHOGONAL,
      /**
      * Specifier for the routing strategy of inter-edges (edges between fixed and partial nodes as well as edges between
      * different subgraph components). The algorithm will use straight-line routes for inter-edges.
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      */
      STRAIGHTLINE,
      /**
      * Specifier for the routing strategy of inter-edges (edges between fixed and partial nodes as well as edges between
      * different subgraph components). The algorithm automatically chooses a suitable routing strategy.
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      */
      AUTOMATIC,
      /**
      * Specifier for the routing strategy of inter-edges (edges between fixed and partial nodes as well as edges between
      * different subgraph components). The algorithm will use organic routes for inter-edges.
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      */
      ORGANIC,
      /**
      * Specifier for the routing strategy of inter-edges (edges between fixed and partial nodes as well as edges between
      * different subgraph components). The algorithm will use octilinear routes for inter-edges (the slope of each segment
      * is a multiple of 45 degree).
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      * @see {@link yfiles.partial.PartialLayouter#edgeRoutingStrategy}
      */
      OCTILINEAR
    }
    export enum ComponentAssignmentStrategy{
      /**
      * Specifier for the strategy that is used to assign partial nodes to subgraph components. This value specifies that
      * each partial node is assigned to a separate component.
      * @see {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy}
      * @see {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy}
      */
      SINGLE,
      /**
      * Specifier for the strategy that is used to assign partial nodes to subgraph components. This value specifies that
      * all partial nodes of a connected component are assigned to the same subgraph component.
      * @see {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy}
      * @see {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy}
      */
      CONNECTED,
      /**
      * Specifier for the strategy that is used to assign partial nodes to subgraph components. This value specifies that
      * the algorithm should use a natural clustering algorithm to determine the subgraph components (nodes of the same
      * cluster are in the same subgraph component).
      * @see {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy}
      * @see {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy}
      */
      CLUSTERING,
      /**
      * Specifier for the strategy that is used to assign partial nodes to subgraph components. This value allows to use a
      * customized component assignment, see {@link yfiles.partial.PartialLayouter#COMPONENT_ASSIGNMENT_DP_KEY}.
      * @see {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy}
      * @see {@link yfiles.partial.PartialLayouter#componentAssignmentStrategy}
      */
      CUSTOMIZED
    }
    export enum LayoutOrientation{
      /**
      * Specifies the orientation of the drawing. This value specifies that the algorithm should try to place partial nodes
      * (subgraph components) such that each predecessor of a node v is placed above v and each successor below v.
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      */
      TOP_TO_BOTTOM,
      /**
      * Specifies the orientation of the drawing. This value specifies that the algorithm should try to place partial nodes
      * (subgraph components) such that each predecessor of a node v is placed below v and each successor above v.
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      */
      BOTTOM_TO_TOP,
      /**
      * Specifies the orientation of the drawing. This value specifies that the algorithm should try to place partial nodes
      * (subgraph components) such that each predecessor of a node v is placed to the left of v and each successor to the
      * right of v.
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      */
      LEFT_TO_RIGHT,
      /**
      * Specifies the orientation of the drawing. This value specifies that the algorithm should try to place partial nodes
      * (subgraph components) such that each predecessor of a node v is placed to the right of v and each successor to the
      * left of v.
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      */
      RIGHT_TO_LEFT,
      /**
      * Specifies the orientation of the drawing. This value specifies that the layout algorithm should detect the
      * orientation automatically. Therefore it analysis the current drawing.
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      */
      AUTO_DETECT,
      /**
      * Specifies the orientation of the drawing.
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      * @see {@link yfiles.partial.PartialLayouter#layoutOrientation}
      */
      NONE
    }
    export enum SubgraphPositioningStrategy{
      /**
      * Specifies the objective used for finding 'good' positions for subgraph components. This values specifies that each
      * component should be placed close to the barycenter of its graph neighbors.
      * @see {@link yfiles.partial.PartialLayouter#positioningStrategy}
      * @see {@link yfiles.partial.PartialLayouter#positioningStrategy}
      */
      BARYCENTER,
      /**
      * Specifies the objective used for finding 'good' positions for subgraph components. This values specifies that each
      * component should be placed close to its original position.
      * @see {@link yfiles.partial.PartialLayouter#positioningStrategy}
      * @see {@link yfiles.partial.PartialLayouter#positioningStrategy}
      */
      FROM_SKETCH
    }
  }
  export module planar{
  }
  export module radial{
    export enum CenterNodesPolicy{
      /**
      * Specifier for a center nodes policy which chooses all nodes with indegree 0 as center nodes.
      * If no node with that property is present, an arbitrary node is chosen.
      * @see {@link yfiles.radial.RadialLayouter#centerNodesPolicy  }
      */
      DIRECTED,
      /**
      * Specifier for a center nodes policy which chooses the node with the highest centrality as center node.
      * @see {@link yfiles.radial.RadialLayouter#centerNodesPolicy  }
      * @see {@link yfiles.algorithms.Trees#getCenterRoot}
      */
      CENTRALITY,
      /**
      * Specifier for a center nodes policy which chooses the node with the highest weighted centrality as center node.
      * @see {@link yfiles.radial.RadialLayouter#centerNodesPolicy  }
      * @see {@link yfiles.algorithms.Trees#getWeightedCenterNode  }
      */
      WEIGHTED_CENTRALITY,
      /**
      * Specifier for a center nodes policy which uses user specified center nodes. The center nodes have to be specified 
      * using a data provider registered with the
      * {@link yfiles.radial.RadialLayouter#centerNodesDpKey} key that returns <code>true</code> for these nodes.
      * <p>
      * If there are several center nodes, they are placed on the first circle while the center position stays empty.
      * </p>
      * @see {@link yfiles.radial.RadialLayouter#centerNodesPolicy}
      * @see {@link yfiles.radial.RadialLayouter#centerNodesDpKey}
      */
      SELECTION
    }
    export enum EdgeRoutingStrategy{
      /**
      * Specifier for an edge routing strategy that will route edges as a polyline from source to target with one bend on
      * each spanned circle.
      * @see {@link yfiles.radial.RadialLayouter#edgeRoutingStrategy}
      */
      POLYLINE,
      /**
      * Specifier for an edge routing strategy that will route edges as an arc.
      * The source and target of an edge as well as one bend on each spanned circle are used as main control points.
      * An easing function is used to calculate additional control points between the polar
      * coordinates of the main control points.
      * @see {@link yfiles.radial.RadialLayouter#edgeRoutingStrategy}
      */
      ARC
    }
    export enum LayeringStrategy{
      /**
      * Specifier for a layering strategy that uses breadth first search (bfs) to determine a layering for the graph.
      * All edges will span at most one layer in
      * the resulting drawing. Edges between nodes that belong to the same layer are possible.
      * @see {@link yfiles.radial.RadialLayouter#layeringStrategy}
      */
      BFS,
      /**
      * Specifier for a layering strategy that uses an optimal hierarchical layering strategy.
      * The layer distance of an edge is the absolute difference between the layer numbers
      * of its source and target node.
      * Layer assignment will be done in such a way that the overall sum of the layer distances
      * of all edges in the layout is minimal.
      * @see {@link yfiles.radial.RadialLayouter#layeringStrategy}
      */
      HIERARCHICAL
    }
    /**
    * Radial style layouter.
    * This layouter places all nodes on circles around a common center.
    * <p>
    * <center><img src="doc-files/y.layout.radial.RadialLayouter.gif" border="1"/></center>
    * </p>
    * <p>
    * A virtual tree structure is created for the graph whose root node is placed on the center of the circles. All
    * children of a tree node are on a higher layer (i.e. larger circles) than their parent. A sector is calculated for
    * each node so the sector of each child in the virtual tree is a sub-sector of its parent's sector. The radii of the
    * circles are calculated taking the sector size needed by the whole subtree into account.
    * </p>
    * <p>
    * There are different {@link yfiles.radial.RadialLayouter#centerNodesPolicy  center nodes policies} that can be used to  determine which
    * nodes shall be placed on the center (single center node) or on the innermost circle (several center nodes). How the
    * nodes are distributed over the circles can be specified by a {@link yfiles.radial.RadialLayouter#layeringStrategy  layering strategy}.
    * </p>
    * <p>
    * The way in which edges are routed in this layout is specified by an
    * {@link yfiles.radial.RadialLayouter#edgeRoutingStrategy  edge routing strategy}.
    * Note that the edge routing cannot always prevent node-edge overlaps.
    * </p>
    */
    export interface RadialLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * The minimum distance between two neighboring nodes on a circle.
      * The default is <code>10.0d</code>.
      * @throws {yfiles.system.ArgumentException} when setting a negative distance.
      */
      minimalNodeToNodeDistance:number;
      /**
      * The spacing value for the circles.
      * The radius of each circle will be a multiple of this value.
      * <p>
      * If the spacing value is set <code>0</code>, no spacing will be considered.
      * </p>
      * Default value is <code>25.0d</code>
      * @throws {yfiles.system.ArgumentException} when setting a negative spacing value.
      */
      layerSpacing:number;
      /**
      * The minimal distance between two circles.
      * Default value is <code>100.0d</code>.
      * @throws {yfiles.system.ArgumentException} when setting a negative distance.
      */
      minimalLayerDistance:number;
      /**
      * The maximal sector angle in degrees around a node where the children of the node may be placed.
      * <p>
      * The child sector of a node has the node's center as center. The sector points away from the center of the
      * circle the node is placed on.
      * </p>
      * Valid values range from <code>0</code> to <code>360</code>.
      * @throws {yfiles.system.ArgumentException} when setting a negative angle or an angle greater than 360 degrees.
      */
      maximalChildSectorAngle:number;
      /**
      * The minimal kink angle in degrees between two adjacent edge segments.
      * <b>Getter:</b><p>
      * Increasing this value reduces the number of bends so the edge path gets less smooth.
      * </p>
      * Valid values are between <code>0.0d</code> and <code>90.0d</code>.
      * <b>Setter:</b><p>
      * Increasing this value reduces the number of bends so the edge path gets less smooth.
      * </p>
      * Default value is <code>5.0d</code>. Valid angles range from 0 to 90 degrees.
      * @throws {yfiles.system.ArgumentException} when setting a negative angle or an angle greater than 90 degrees.
      */
      minimalBendAngle:number;
      /**
      * The center node policy that determines which node is chosen as (virtual) tree root for the layout process
      * and is set in the center of the circles.
      * By default {@link yfiles.radial.CenterNodesPolicy#WEIGHTED_CENTRALITY} is set.
      * @throws {yfiles.system.ArgumentException} when setting an invalid center node policy.
      */
      centerNodesPolicy:yfiles.radial.CenterNodesPolicy;
      /**
      * The data provider key used to look up the selected nodes that shall be placed in the center with
      * {@link yfiles.radial.RadialLayouter#centerNodesPolicy  center node policy} set to {@link yfiles.radial.CenterNodesPolicy#SELECTION}.
      * By default, {@link yfiles.layout.LayouterKeys#SELECTED_NODES_DP_KEY} is used.
      * @throws {yfiles.system.ArgumentException} when the new key is <code>null</code>
      */
      centerNodesDpKey:Object;
      /**
      * The layering strategy that determines how nodes are distributed to different layers.
      * <b>Getter:</b>All nodes of one layer will be placed on the same circle later.
      * By default, {@link yfiles.radial.LayeringStrategy#BFS} is set.
      * <b>Setter:</b>All nodes of one layer will be placed on the same circle later.
      * <p>
      * Must be either {@link yfiles.radial.LayeringStrategy#BFS} or {@link yfiles.radial.LayeringStrategy#HIERARCHICAL}.
      * By default, {@link yfiles.radial.LayeringStrategy#BFS} is set.
      * </p>
      * @throws {yfiles.system.ArgumentException} when setting an invalid layering strategy.
      */
      layeringStrategy:yfiles.radial.LayeringStrategy;
      /**
      * The edge routing strategy.
      * <p>
      * Must be one of {@link yfiles.radial.EdgeRoutingStrategy#POLYLINE} or {@link yfiles.radial.EdgeRoutingStrategy#ARC}.
      * By default {@link yfiles.radial.EdgeRoutingStrategy#ARC} is used.
      * </p>
      * <p>
      * Note that the edge routing cannot always prevent node-edge overlaps.
      * </p>
      * @throws {yfiles.system.ArgumentException} when setting an invalid edge routing strategy.
      */
      edgeRoutingStrategy:yfiles.radial.EdgeRoutingStrategy;
      /**
      * Specifies whether or not node labels are taken into account when calculating
      * node positions.
      * Thereby preventing possible node/node label or
      * node label/node label overlaps.
      * <p>
      * Default value is <code>false</code>.
      * </p>
      * <p>
      * Note that this option only works correctly if the {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation}
      * is set to {@link yfiles.layout.LayoutOrientation#TOP_TO_BOTTOM} (which is the default).
      * Changing the layout orientation for an undirected layout algorithm like the
      * {@link yfiles.radial.RadialLayouter} doesn't make sense.
      * </p>
      */
      considerNodeLabels:boolean;
      /**
      * Specifies whether or not ComponentLayouter is enabled.
      * By default it is disabled.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#componentLayouterEnabled}
      */
      componentLayouterEnabled:boolean;
      /**
      * Subclasses have to provide information whether or not they
      * can layout the given graph.
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Subclasses have to provide core layout code in this method.
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Determines the center nodes of the graph according to the chosen center node policy.
      * <p>
      * This method may be overwritten to introduce a custom policy to choose center nodes.
      * </p>
      * @param {yfiles.layout.LayoutGraph} graph The graph to return the central node for.
      * @return {yfiles.algorithms.NodeList} A list of center nodes of the given graph.
      * @see {@link yfiles.radial.RadialLayouter#centerNodesPolicy}
      * @see {@link yfiles.radial.RadialLayouter#centerNodesPolicy}
      */
      determineCenter(graph:yfiles.layout.LayoutGraph):yfiles.algorithms.NodeList;
      /**
      * Returns the diameter of the circular space around the given node's center that shall be reserved for the node.
      * <p>
      * By default the actual diameter of the given node extended by
      * {@link yfiles.radial.RadialLayouter#minimalNodeToNodeDistance  minimalNodeToNodeDistance} is used as diameter of the space to reserve.
      * That way the nodes keep enough distance to the nodes around.
      * </p>
      * <p>
      * This method may be overwritten to keep more or different amounts of space around each node in the graph.
      * </p>
      * @param {yfiles.layout.LayoutGraph} graph The graph to which the node belongs.
      * @param {yfiles.algorithms.Node} node The node to return the diameter for.
      * @return {number} The diameter of the circle around the given node's center that shall be reserved for the node.
      */
      getNodeDiameter(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):number;
    }
    export module RadialLayouter{
      /**
      * Info object describing on which circle and in which sector the node is placed.
      * This object can be registered for every node using the data provider key {@link yfiles.radial.RadialLayouter#NODE_INFO_DP_KEY}. The layouter
      * will update its fields when the layout is calculated.
      * <p>
      * Note that this info object only delivers additional data which was calculated during the layout run and has no
      * influence on layout calculation.
      * </p>
      */
      export interface NodeInfo extends Object{
        /**
        * The index of the circle the node is placed on.
        * The circles used by the RadialLayouter are indexed from the innermost to the outermost circle. Index <code>0</code>
        * represents the center, i.e. the circle with radius <code>0</code>.
        */
        circleIndex:number;
        /**
        * The radius of the circle the node is placed on.
        */
        radius:number;
        /**
        * The offset from the center of the circle, the node is placed on, to the center of the node.
        */
        centerOffset:yfiles.algorithms.YPoint;
        /**
        * The start angle in degrees of the sector the node is placed in.
        * The angle refers to a counter-clockwise rotation starting at the 3&nbsp;o'clock position.
        * @see {@link yfiles.radial.RadialLayouter.NodeInfo#sectorSize}
        */
        sectorStart:number;
        /**
        * The size in degrees of the sector the node is placed in.
        * @see {@link yfiles.radial.RadialLayouter.NodeInfo#sectorStart}
        */
        sectorSize:number;
      }
    }
    var RadialLayouter:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to provide additional data for nodes about the circle they are placed on as
      * well as the sector they are placed in.
      * <p>
      * Only if a data provider with this key is registered at the graph and returns a {@link yfiles.radial.RadialLayouter.NodeInfo} object for each node,
      * the properties of these {@link yfiles.radial.RadialLayouter.NodeInfo} objects will be updated during the layout.
      * </p>
      */
      NODE_INFO_DP_KEY:Object;
      /**
      * Creates a new instance.
      */
      new ():yfiles.radial.RadialLayouter;
    };
  }
  export module random{
    /**
    * This class generates a layout, where the nodes are placed
    * randomly.
    * Edges have no bends and ports.
    * The layout is placed inside a box.
    */
    export interface RandomLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * Specifies whether or not ComponentLayouter is enabled.
      * By default it is disabled.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#componentLayouterEnabled}
      */
      componentLayouterEnabled:boolean;
      /**
      * The rectangle, inside which the layout should be placed.
      */
      layoutBounds:yfiles.algorithms.Rectangle;
      /**
      * Returns always <code>true</code>, because every graph can be drawn.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Perform the layout.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The randomization seed, with which the layout will be generated.
      */
      seed:number;
    }
    var RandomLayouter:{
      $class:yfiles.lang.Class;
      new ():yfiles.random.RandomLayouter;
    };
  }
  export module router{
    export enum RoutingStyle{
      /**
      * Routing style specifier. Edge segments are drawn ad hoc, i.e., rather crude.
      */
      ADHOC,
      /**
      * Routing style specifier. Edge segments are drawn the short way, i.e., with the global way of the edge in mind.
      */
      SHORTPATH,
      /**
      * Routing style specifier. Edge segments are drawn with the most distance to already known obstacles such as nodes or
      * other edge segments.
      */
      PREFERMIDDLE,
      /**
      * Routing style specifier. Similar to {@link yfiles.router.RoutingStyle#PREFERMIDDLE} for the two end segments and segments between bends
      * of different directions. Segments between bends of the same direction (u-shaped turns) are drawn the short way.
      * This style achieves a well-balanced routing and is used by default.
      */
      BALANCED
    }
    /**
    * Class that routes edges within a vertical or horizontal channel
    * All edges will then be routed in an orthogonal fashion.
    * This class basically assigns subchannels to each each key (normally edges)
    * so that the
    * overall number of subchannels is small.
    */
    export interface ChannelRouter extends Object{
      /**
      * Sets the channel bounds and direction.
      * A call to this method
      * implies that all previously added segments will be removed.
      * @param {number} min the smallest assignable coordinate within the channel
      * @param {number} max the largest assignable  coordinate within the channel
      * @param {yfiles.router.ChannelOrientation} orientation 
      * the orientation of the channel. One of
      * {@link yfiles.router.ChannelOrientation#VERTICAL} and {@link yfiles.router.ChannelOrientation#HORIZONTAL}
      */
      setChannel(min:number,max:number,orientation:yfiles.router.ChannelOrientation):void;
      /**
      * Adds an edge object with source and target coordinates
      * to the set of edges that have to be routed within the channel.
      */
      addSegment(key:Object,p1:yfiles.algorithms.YPoint,p2:yfiles.algorithms.YPoint):void;
      /**
      * Adds an edge object that belongs to a group of edges
      * with source and target coordinates
      * to the set of edges that have to be routed within the channel
      * Edges sharing the same groupId will be placed on the same channel.
      */
      addGroupSegment(key:Object,groupId:Object,p1:yfiles.algorithms.YPoint,p2:yfiles.algorithms.YPoint):void;
      /**
      * Returns an iterator over all added segment keys.
      * For grouped edges, a {@link yfiles.algorithms.YList} instance will be returned.
      */
      segmentKeys():yfiles.algorithms.IIterator;
      /**
      * Determines if the given key has been registered already with this instance.
      * @param {Object} key 
      * the key which is used in {@link yfiles.router.ChannelRouter#addSegment}
      */
      containsKey(key:Object):boolean;
      /**
      * Determines if the given key has been registered as a grouping key with this instance.
      * @param {Object} groupKey 
      * the key which is used in {@link yfiles.router.ChannelRouter#addGroupSegment}
      */
      containsGroupKey(groupKey:Object):boolean;
      /**
      * Routes all added edges within the specified channel.
      * The resulting subchannels can then be queried using the {@link yfiles.router.ChannelRouter#getSubChannelRank}
      * method.
      */
      route():void;
      /**
      * Returns the calculated channel coordinate for an added edge object.
      * If for example the router was instantiated with the arguments
      * <code>ChannelRouter(100,200,ChannelRouter.ROUTE_HORIZONTAL)</code>
      * then the returned coordinate is an x-coordinate between 100 and
      * 200. This coordinate represents the x-coordinate of two additional
      * bends that are needed to route the edge orthogonally from
      * p1 to p2 (as specified in addSegment).
      * @param {Object} key 
      * an edge object added with {@link yfiles.router.ChannelRouter#addSegment}
      */
      getCoord(key:Object):number;
      /**
      * The number of subchannels within this channel.
      * The return value <code>0</code> indicates that there are no subchannels
      * present.
      */
      subChannelCount:number;
      /**
      * Returns the subchannel rank of this segment within the channel.
      * @param {Object} key 
      * an edge object added with {@link yfiles.router.ChannelRouter#addSegment}
      */
      getSubChannelRank(key:Object):number;
      /**
      * Returns the subchannel rank for the group indicated by the groupKey.
      * @see {@link yfiles.router.ChannelRouter#addGroupSegment}
      */
      getGroupSubChannelRank(groupKey:Object):number;
      /**
      * Specifies whether subchannels shorter than <code>epsilon</code> are ignored
      * by this instance.
      * Default is <code>true</code> with an epsilon value of 0.5d.
      * @see {@link yfiles.router.ChannelRouter#epsilon}
      */
      epsilonChannelIgnored:boolean;
      /**
      * The current epsilon value.
      * Subchannel lengths smaller than this
      * value will be ignored by this instance if the the <code>epsilonChannelIgnored</code>
      * property is set to <code>true</code>
      * @see {@link yfiles.router.ChannelRouter#epsilonChannelIgnored}
      */
      epsilon:number;
    }
    var ChannelRouter:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of ChannelRouter.
      * @param {number} min the smallest assignable coordinate within the channel
      * @param {number} max the largest assignable  coordinate within the channel
      * @param {yfiles.router.ChannelOrientation} orientation 
      * the direction of the channel. One of
      * {@link yfiles.router.ChannelOrientation#VERTICAL} and {@link yfiles.router.ChannelOrientation#HORIZONTAL}
      */
      WithOrientation:{
        new (min:number,max:number,orientation:yfiles.router.ChannelOrientation):yfiles.router.ChannelRouter;
      };
      /**
      * Creates a new instance of ChannelRouter for a horizontal channel.
      * @param {number} min the smallest assignable coordinate within the channel
      * @param {number} max the largest assignable  coordinate within the channel
      */
      new (min:number,max:number):yfiles.router.ChannelRouter;
    };
    export enum SphereOfAction{
      /**
      * Sphere of action specifier. Route all edges of the input graph.
      */
      ROUTE_ALL_EDGES,
      /**
      * Sphere of action specifier. Route only selected edges of the input graph.
      * The selection state of an edge is determined by a boolean value returned
      * by the data provider associated with the data provider key.
      * @see {@link yfiles.algorithms.Graph#addDataProvider}
      */
      ROUTE_SELECTED_EDGES,
      /**
      * Sphere of action specifier. Route only edges connected to selected nodes.
      * The selection state of a node is determined by a boolean value returned
      * by the data provider associated with the data provider key.
      * @see {@link yfiles.algorithms.Graph#addDataProvider}
      */
      ROUTE_EDGES_AT_SELECTED_NODES
    }
    export enum Scope{
      /**
      * Scope constant - used for routing all edges in the graph.
      */
      ALL,
      /**
      * Scope constant - used for routing only a subset of edges. This subset has to be specified by registering an
      * appropriate {@link yfiles.algorithms.IDataProvider}.
      */
      SUBSET
    }
    export enum MonotonicPathRestriction{
      /**
      * Constant that specifies monotonic path restrictions for edges.
      * This constant specifies that there are no restrictions.
      */
      NONE,
      /**
      * Constant that specifies monotonic path restrictions for edges.
      * This constant specifies restrictions for the vertical direction, i.e.,
      * each vertical edge segment is directed from the source to the target.
      */
      VERTICAL,
      /**
      * Constant that specifies monotonic path restrictions for edges.
      * This constant specifies restrictions for the horizontal direction, i.e.,
      * each horizontal edge segment is directed from the source to the target.
      */
      HORIZONTAL,
      /**
      * Constant that specifies monotonic path restrictions for edges. This constant specifies restrictions for the
      * horizontal and vertical direction, i.e., each horizontal as well as each vertical edge segment is directed from the
      * source to the target.
      */
      BOTH
    }
    export enum ChannelOrientation{
      /**
      * Channel orientation specifier. Used to route edges in a vertical channel.
      */
      VERTICAL,
      /**
      * Channel orientation specifier. Used to route edges in a horizontal channel.
      */
      HORIZONTAL
    }
    /**
    * Performance optimization stage for
    * {@link yfiles.router.OrthogonalEdgeRouter}.
    * This layout stage is applicable when only a subset of the edges
    * in the input graph should be
    * routed orthogonally.
    */
    export interface ReducedSphereOfActionStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Assigns orthogonal edge paths to the selected edges of a graph, efficiently.
      * Note that this
      * stage will only have an optimizing effect if not all edges of the graph
      * should be routed.
      * <b>Precondition:</b> a LayoutStage of getCoreLayouter() must be an instance of OrthogonalEdgeRouter.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#sphereOfAction}
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The activation threshold for this class.
      * This stage will perform its optimization
      * step only if the sum of the edges and nodes of the input graph is bigger than the activation threshold.
      * By default the threshold value is set to 200.
      */
      activationThreshold:number;
    }
    var ReducedSphereOfActionStage:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of ReducedSphereOfActionStage.
      * @param {yfiles.layout.ILayouter} coreLayouter 
      * the core layouter invoked by this stage. The coreLayouter must
      * contain an instance of {@link yfiles.router.OrthogonalEdgeRouter} its layout pipeline.
      */
      new (coreLayouter:yfiles.layout.ILayouter):yfiles.router.ReducedSphereOfActionStage;
    };
    /**
    * Simple edge router implementation that draws edges straight-line considering the specified port constraints.
    */
    export interface StraightLineEdgeRouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * The edge (sub-)set to be routed.
      * Defaults to {@link yfiles.router.SphereOfAction#ROUTE_ALL_EDGES}.
      * @throws {yfiles.system.ArgumentException} 
      * if the given argument is not one of the
      * above constants.
      * @see {@link yfiles.router.StraightLineEdgeRouter#selectedEdgesDpKey}
      */
      sphereOfAction:yfiles.router.SphereOfAction;
      /**
      * The data provider key used to look up the selected state of the
      * nodes of the graph to be laid out.
      * By default, {@link yfiles.layout.LayouterKeys#SELECTED_NODES_DP_KEY} is
      * used.
      * <p>
      * If the sphere of action is set to {@link yfiles.router.SphereOfAction#ROUTE_EDGES_AT_SELECTED_NODES},
      * only edges of selected nodes are routed while all other edges are
      * considered to have fixed routes.
      * </p>
      * @see {@link yfiles.router.StraightLineEdgeRouter#sphereOfAction}
      * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
      * @see {@link yfiles.router.StraightLineEdgeRouter#sphereOfAction}
      */
      selectedNodesDpKey:Object;
      /**
      * The data provider key used to look up the selected state of the
      * edges of the graph to be laid out.
      * By default, {@link yfiles.layout.LayouterKeys#SELECTED_EDGES_DP_KEY} is
      * used.
      * <p>
      * If the sphere of action is set to {@link yfiles.router.SphereOfAction#ROUTE_SELECTED_EDGES}, only the
      * selected keys are routed while all other edges are considered to have
      * fixed routes.
      * </p>
      * @see {@link yfiles.router.StraightLineEdgeRouter#sphereOfAction}
      * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
      * @see {@link yfiles.router.StraightLineEdgeRouter#sphereOfAction}
      */
      selectedEdgesDpKey:Object;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var StraightLineEdgeRouter:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new StraightLineEdgeRouter that uses the given layouter instance as core layouter.
      * @param {yfiles.layout.ILayouter} core a layouter instance that is used as core layouter.
      */
      WithCoreLayouter:{
        new (core:yfiles.layout.ILayouter):yfiles.router.StraightLineEdgeRouter;
      };
      /**
      * Creates a new StraightLineEdgeRouter.
      */
      new ():yfiles.router.StraightLineEdgeRouter;
    };
    /**
    * This class can be used to distribute overlapping edge segments of orthogonally routed edges.
    * The edge segments will
    * then be distributed in their so called channel according to the given settings. The channel in which the segments can
    * be distributed is defined by the surrounding graph elements, which will form borderlines for the channel.
    * The distance between the distributed edge segments can be determined by method {@link yfiles.router.OrthogonalSegmentDistributionStage#preferredDistance}.
    * The edge segments can also be forced to be distributed on a given grid ({@link yfiles.router.OrthogonalSegmentDistributionStage#gridEnabled} ) whose
    * origin ( {@link yfiles.router.OrthogonalSegmentDistributionStage#setGridOffset} ) and grid width ( {@link yfiles.router.OrthogonalSegmentDistributionStage#gridWidth} ) can be set.
    * Note: this LayoutStage is not capable of moving nodes. If the set conditions like preferred distance or the grid width
    * can not be satisfied, for example, because there is not enough space inside the channel, the set values will by
    * default be adjusted (reduced). Concerning the grid, it will be divided by 2 until all segments will fit. The
    * preferred distance will be adjusted so that the maximum possible distance near the given value will be taken. Also,
    * segments that are directly at a node (source or target) will be distributed, so that they are placed equidistant
    * all along the node's side.
    * Settings {@link yfiles.router.OrthogonalSegmentDistributionStage#gridWidthAdjustable} and {@link yfiles.router.OrthogonalSegmentDistributionStage#preferredDistanceAdjustable} can be used to
    * force the algorithm to distribute the edges with the exact given distances. If the segments will not fit into the
    * given channel, they then will not be distributed at all. So there is a guarantee that they will match the settings if
    * they are routed.
    * {@link yfiles.router.OrthogonalSegmentDistributionStage#lockFirstAndLastSegment} can be used to guarantee that the first and last segment of an edge
    * (connected to source or target), won't be distributed. So ports can easily be kept without setting explicit strong
    * port constraints or fixed PortCandidates.
    * The algorithm will not distribute the segments, whose end connect to a node at a strong port constraint or fixed
    * port candidate.
    */
    export interface OrthogonalSegmentDistributionStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The DataProvider key, which determines the edges, that shall be distributed by the algorithm.
      * <p>
      * By default, {@link yfiles.router.OrthogonalSegmentDistributionStage#DEFAULT_AFFECTED_EDGES_DP_KEY} is used.
      * </p>
      */
      affectedEdgesDpKey:Object;
      /**
      * What happens if the preferred distance can not be kept, because there is not enough space for the segments
      * to be distributed in that distance.
      * If set to <code>true</code> the algorithm is allowed to reduce the
      * distance to the next best value, that is possible. If set to <code>false</code> the algorithm will not at all
      * distribute those segments. By default the setting is <code>true</code> and therefore segments will be distributed.
      * Note: Preferred distances will not be kept for segments connecting to nodes (first and last segment of an edge).
      * The segments are distributed equidistant all along the node side, thus may lead to bigger distances between
      * segments.
      */
      preferredDistanceAdjustable:boolean;
      /**
      * Specifies whether or not the algorithm is allowed to reduce the grid width,
      * if segments cannot be distributed using the previously given grid width.
      * The algorithm will divide the given grid width by 2 as long as the segments
      * will not fit and thus will lead to nicer results than taking some other value.
      * Note: The grid width will only be adjusted for segments that cannot keep
      * the originally set grid width.
      * <p>
      * By default, the algorithm is allowed to reduce the grid width.
      * </p>
      */
      gridWidthAdjustable:boolean;
      /**
      * Specifies whether grid distribution is enabled or not.
      * If so, all segments will be distributed onto the grid. By
      * default grid distribution is not enabled.
      */
      gridEnabled:boolean;
      /**
      * The grid width that shall be used if grid distribution is enabled.
      * By default the grid width is 10.0.
      */
      gridWidth:number;
      /**
      * Can be used to set the grid origin.
      * By default the offset is (0, 0), so there is no offset.
      * @param {number} offsetX the offset in x direction.
      * @param {number} offsetY the offset in y direction
      */
      setGridOffset(offsetX:number,offsetY:number):void;
      /**
      * The grid offset in x direction.
      * by default this will be 0.
      */
      gridOffsetX:number;
      /**
      * The grid offset in y direction.
      * by default this will be 0.
      */
      gridOffsetY:number;
      /**
      * Specifies whether the first and last segment of an edge (connected to source or target), will be distributed.
      * So
      * ports can easily be kept without setting explicit strong port constraints or fixed PortCandidates.
      * Defaults to <code>false</code>, i.e. first and last segments are not locked.
      */
      lockFirstAndLastSegment:boolean;
      /**
      * The preferred distance, segments shall have to each other and to the channel's border.
      * <p>
      * Default value is <code>10.0</code>.
      * </p><p>
      * Note: if {@link yfiles.router.OrthogonalSegmentDistributionStage#preferredDistanceAdjustable} is set to <code>true</code> (which is the default), the
      * preferred distance might be adjusted so that the maximum possible distance near the given value will be taken. This
      * happens if the channel is not big enough to fit in all segments with the desired preferred distance.
      * </p>
      */
      preferredDistance:number;
    }
    var OrthogonalSegmentDistributionStage:{
      $class:yfiles.lang.Class;
      /**
      * DataProvider key that can be used to determine which edges the distribution stage will route.
      */
      DEFAULT_AFFECTED_EDGES_DP_KEY:Object;
      new ():yfiles.router.OrthogonalSegmentDistributionStage;
    };
    /**
    * This class represents an orthogonal edge router.
    * An orthogonal edge router is a layout algorithm that changes the
    * coordinates of the edge paths in a way that the resulting layout of the edges is made up of vertical and horizontal
    * segments only. The router does not change the location or the size of the nodes in a diagram in any way.
    * <p>
    * The edge router will not try to find a perfect route from source to edge like OrthogonalEdgeRouter does, but chooses
    * the best path out of several fixed paths it can choose from. The best path out of these possible paths is determined
    * by its cost. One can take influence on the costs by setting several cost factors. The distance, an edge will have
    * from its source and target node is determined by setMinimumDistance(double).
    * </p>
    * <p>
    * The edges whose paths are to be routed can be defined using method setSphereOfAction(byte)
    * or binding a data provider to the input graph with key {@link yfiles.router.ChannelEdgeRouter#AFFECTED_EDGES_DP_KEY}.
    * Note: If the DataProvider is registered on the graph, it will determine all affected edges, regardless of the set
    * sphere of action. So setting a sphere of action has lower priority than adding the specific DataProvider directly.
    * </p>
    * <p>
    * By default all edges are routed according to their best paths and afterwards overlapping edges will be redistributed.
    * This can be prevented by calling method setDistributeEdgesEnabled(boolean).
    * </p>
    * <p>
    * ChannelEdgeRouter does also support grid routing setGridRoutingEnabled(boolean).Therefore
    * the user can define the grid origin setGridOrigin(y.geom.YPoint) and the
    * grid width setGridWidth(double).
    * </p>
    * <p>
    * This edge router will obey strong and weak port constraints. It expects the port constraints to be bound to the input
    * graph by the data provider keys {@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY} and {@link yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY}. Furthermore, this class supports the more advanced port constraint
    * concept of {@link yfiles.layout.PortCandidate}s. It expects collections of port candidates to be bound to the input graph by the
    * data provider keys {@link yfiles.layout.PortCandidate#SOURCE_PC_LIST_DP_KEY} and {@link yfiles.layout.PortCandidate#TARGET_PC_LIST_DP_KEY}.
    * </p>
    */
    export interface OrthogonalPatternEdgeRouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * The specified kind of monotonic path restrictions.
      * Possible values are {@link yfiles.router.MonotonicPathRestriction#NONE}, {@link yfiles.router.MonotonicPathRestriction#VERTICAL}, {@link yfiles.router.MonotonicPathRestriction#HORIZONTAL}
      * and {@link yfiles.router.MonotonicPathRestriction#BOTH}.
      */
      monotonicPathRestriction:yfiles.router.MonotonicPathRestriction;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given node object is zero.
      * It is called by the {@link yfiles.router.OrthogonalPatternEdgeRouter#doLayout} method for each node object in the input graph.
      * @see {@link yfiles.router.OrthogonalPatternEdgeRouter#checkGroupNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the node object is zero.
      */
      checkNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given group node object is zero.
      * It is called by the {@link yfiles.router.OrthogonalPatternEdgeRouter#doLayout} method for each group node object in the input graph.
      * @see {@link yfiles.router.OrthogonalPatternEdgeRouter#checkNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the group node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the group node object is zero.
      */
      checkGroupNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * Calculates the edge cost of a possible edge path, to determine which path is the best (cheapest).
      * @param {yfiles.algorithms.Edge} edge the edge whose cost to calculate.
      * @param {yfiles.algorithms.YList} path the edge's path.
      * @param {yfiles.layout.PortCandidate} spc the source port candidate chosen for this path.
      * @param {yfiles.layout.PortCandidate} tpc the target port candidate chosen for this path.
      * @return {number} the sum of all costs for this edge's path
      */
      calculateCost(edge:yfiles.algorithms.Edge,path:yfiles.algorithms.YList,spc:yfiles.layout.PortCandidate,tpc:yfiles.layout.PortCandidate):number;
      /**
      * Calculates the costs for the chosen ports.
      * By default these costs are determined from set port
      * candidates. If no PortCandidates have been set on the given edge, the cost is 0. If PortConstraints have been set
      * for this edge, the cost is also 0.
      * @param {yfiles.algorithms.Edge} edge the edge the penalty is calculated for.
      * @param {yfiles.algorithms.YList} path the path this penalty is calculated for.
      * @param {yfiles.layout.PortCandidate} spc the used source PortCandidate for this path.
      * @param {yfiles.layout.PortCandidate} tpc the used target PortCandidate for this path.
      * @return {number} the costs for all bends of this path
      */
      calculatePortCandidateCost(edge:yfiles.algorithms.Edge,path:yfiles.algorithms.YList,spc:yfiles.layout.PortCandidate,tpc:yfiles.layout.PortCandidate):number;
      /**
      * Calculates the costs for all bends of the given path by simple multiplying
      * all bends with the {@link yfiles.router.OrthogonalPatternEdgeRouter#bendCost  bend costs}.
      * <p>
      * <b>Note:</b> Only bends are taken into account, not the source and target
      * ports, that are also part of the given path.
      * </p>
      * @param {yfiles.algorithms.Edge} edge the edge the penalty is calculated for.
      * @param {yfiles.algorithms.YList} path the path this penalty is calculated for.
      * @param {yfiles.layout.PortCandidate} spc the used source PortCandidate for this path.
      * @param {yfiles.layout.PortCandidate} tpc the used target PortCandidate for this path.
      * @return {number} the costs for all bends of this path
      */
      calculateBendCost(edge:yfiles.algorithms.Edge,path:yfiles.algorithms.YList,spc:yfiles.layout.PortCandidate,tpc:yfiles.layout.PortCandidate):number;
      /**
      * Calculates the extra penalty that is added to the paths cost if the edge is a selfloop and source and target
      * ports have the same direction.
      * By default this penalty is a bit more than adding another bend to the path so that patterns with different
      * source and target directions are cheaper and thus preferred.
      * @param {yfiles.algorithms.Edge} edge the edge the penalty is calculated for.
      * @param {yfiles.algorithms.YList} path the path this penalty is calculated for.
      * @param {yfiles.layout.PortCandidate} spc the used source PortCandidate for this path.
      * @param {yfiles.layout.PortCandidate} tpc the used target PortCandidate for this path.
      * @return {number} an extra penalty for paths
      */
      calculateSelfLoopSelfSidePenaltyCost(edge:yfiles.algorithms.Edge,path:yfiles.algorithms.YList,spc:yfiles.layout.PortCandidate,tpc:yfiles.layout.PortCandidate):number;
      /**
      * Calculates the costs for the length of the given path.
      * By default this cost is between 0 (short path) and 1 (long path) so this has very little impact on the
      * overall costs.
      * @param {yfiles.algorithms.Edge} edge the edge the penalty is calculated for.
      * @param {yfiles.algorithms.YList} path the path this penalty is calculated for.
      * @param {yfiles.layout.PortCandidate} spc the used source PortCandidate for this path.
      * @param {yfiles.layout.PortCandidate} tpc the used target PortCandidate for this path.
      * @return {number} the length costs of the given path between 0 and 1
      */
      calculateEdgeLength(edge:yfiles.algorithms.Edge,path:yfiles.algorithms.YList,spc:yfiles.layout.PortCandidate,tpc:yfiles.layout.PortCandidate):number;
      /**
      * Calculates the overall crossing costs of the given path including edge crossings, edge overlaps and node crossings.
      * @param {yfiles.algorithms.Edge} edge the edge the penalty is calculated for.
      * @param {yfiles.algorithms.YList} path the path this penalty is calculated for.
      * @param {yfiles.layout.PortCandidate} spc the used source PortCandidate for this path.
      * @param {yfiles.layout.PortCandidate} tpc the used target PortCandidate for this path.
      * @return {number} the overall crossing costs of the given path including edge crossings, edge overlaps and node crossings.
      */
      calculateCrossingCosts(edge:yfiles.algorithms.Edge,path:yfiles.algorithms.YList,spc:yfiles.layout.PortCandidate,tpc:yfiles.layout.PortCandidate):number;
      /**
      * The <code>DataProvider</code> key, which determines the edges, that shall be routed by the algorithm.
      * <p>
      * By default, {@link yfiles.router.OrthogonalPatternEdgeRouter#DEFAULT_AFFECTED_EDGES_DP_KEY} is used.
      * </p>
      */
      affectedEdgesDpKey:Object;
      /**
      * The minimum distance an edge will have to its source and target node.
      * Default value is 10.0.
      */
      minimumDistance:number;
      /**
      * The grid width, that defines the space between two grid lines.
      * <b>Setter:</b>Only takes effect if
      * {@link yfiles.router.OrthogonalPatternEdgeRouter#gridRoutingEnabled  grid routing is enabled}.
      * <p>Default value is <code>10.0</code>.</p>
      * <b>Getter:</b><p>Default value is <code>10.0</code></p>.
      * @throws {yfiles.system.ArgumentException} 
      * if the specified grid width is less than
      * <code>2</code>.
      */
      gridWidth:number;
      /**
      * The origin of the grid, which is used for grid routing if enabled.
      * <b>Setter:</b>Takes effect if grid routing is enabled {@link yfiles.router.OrthogonalPatternEdgeRouter#gridRoutingEnabled}.
      * Note that grid routing has lower priority than the minimum Distance setting {@link yfiles.router.OrthogonalPatternEdgeRouter#minimumDistance}.
      * Thus it is possible that edges are not routed on the grid if there is not enough space between two borders. Default
      * origin is at x = 0, y = 0
      * <b>Getter:</b>{@link yfiles.router.OrthogonalPatternEdgeRouter#gridRoutingEnabled}. Default origin is at x = 0, y = 0
      */
      gridOrigin:yfiles.algorithms.YPoint;
      /**
      * Specifies whether or not grid routing is enabled.
      * Grid routing means edges are routed on a grid's lines only. The grid can be defined
      * using method {@link yfiles.router.OrthogonalPatternEdgeRouter#gridOrigin} and {@link yfiles.router.OrthogonalPatternEdgeRouter#gridWidth}. Note that grid routing has
      * lower priority than the minimum Distance setting {@link yfiles.router.OrthogonalPatternEdgeRouter#minimumDistance}. Thus it is possible that
      * edges are not routed on the grid if there is not enough space between two borders.
      * <p>
      * Also, the edges source and target ports are not reassigned if they have fixed coordinates. Therefore, the first and
      * last segments of an edge might not be routed on the grid. Use weak ports or assign coordinates that already lie on
      * the grid for these ports, if grid routing is wanted.
      * </p>
      * By default grid routing is <b>not</b> enabled.
      */
      gridRoutingEnabled:boolean;
      /**
      * The edge cost an edge crossing will cause.
      * Used to find the best path out of the predefined paths the
      * router can choose from. Default value is 5.
      */
      edgeCrossingCost:number;
      /**
      * The node cost an edge node overlap will cause.
      * Used to find the best path out of the predefined paths the
      * router can choose from. Default value is 50.
      */
      nodeCrossingCost:number;
      /**
      * The edge cost a bend inside an edge's path will cause.
      * Used to find the best path out of the predefined paths
      * the router can choose from. Default value is 1.
      */
      bendCost:number;
      /**
      * The cost an edge overlap will cause.
      * By default this edge router is used in conjunction with a segment
      * distribution stage like {@link yfiles.router.OrthogonalSegmentDistributionStage}, so edge overlaps are wanted and
      * thus should not cause any costs. Default value is therefore 0.
      * If this edge router is used stand-alone, one can determine a higher cost to prevent edge overlaps.
      */
      edgeOverlapCost:number;
    }
    var OrthogonalPatternEdgeRouter:{
      $class:yfiles.lang.Class;
      /**
      * DataProvider key that can be used to determine which edges the edge router will route.
      */
      DEFAULT_AFFECTED_EDGES_DP_KEY:Object;
      new ():yfiles.router.OrthogonalPatternEdgeRouter;
    };
    /**
    * Performance optimization stage for
    * {@link yfiles.router.OrthogonalEdgeRouter}.
    * This layout stage decomposes
    * the input graph for the orthogonal edge router into several smaller graphs
    * on each of which the edge router will perform its action separately, hence
    * speeding up execution time and reducing peak memory consumption.
    */
    export interface PatchRouterStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * The activation threshold for this class.
      * The patch router will perform its optimization
      * step only if the sum of the edges and nodes of the input graph is bigger than the activation threshold.
      * By default the threshold value is set to 1000.
      */
      activationThreshold:number;
      /**
      * Assigns orthogonal edge paths to the edges of a big graph, efficiently.
      * Note that this
      * stage will only have an optimizing effect if the graph is bigger than the
      * activation threshold and the sphere of action of the core router includes all edges.
      * <b>Precondition:</b> a LayoutStage of getCoreLayouter() must be an instance of OrthogonalEdgeRouter.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var PatchRouterStage:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of PatchRouterStage.
      * @param {yfiles.layout.ILayouter} coreLayouter 
      * the core layouter invoked by this stage. The coreLayouter must
      * contain an instance of {@link yfiles.router.OrthogonalEdgeRouter} its layout pipeline.
      */
      new (coreLayouter:yfiles.layout.ILayouter):yfiles.router.PatchRouterStage;
    };
    /**
    * Layout stage for {@link yfiles.router.OrthogonalEdgeRouter} that should be
    * applied when routing edges in a partition grid.
    * Note: This stage can only be applied if all nodes are contained within a single partition grid, i.e., edges can
    * never cross the border of the partition grid.
    * @see {@link yfiles.layout.PartitionGrid}
    */
    export interface PartitionGridRouterStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine.
      * <b>Precondition:</b> 
      * the coreLayouter must contain an instance of
      * {@link yfiles.router.OrthogonalEdgeRouter} in its layout pipeline.
      * Furthermore all elements have to lie inside the partition grid.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var PartitionGridRouterStage:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of this class.
      */
      new ():yfiles.router.PartitionGridRouterStage;
      /**
      * Creates a new instance of this class.
      * @param {yfiles.layout.ILayouter} coreLayouter 
      * the core layouter invoked by this stage.
      * The coreLayouter must contain an instance of
      * {@link yfiles.router.OrthogonalEdgeRouter} in its layout pipeline.
      */
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.router.PartitionGridRouterStage;
      };
    };
    /**
    * This LayoutStage will move edge ports, that are outside the corresponding nodes border, to the border.
    * Thus guarantees ports are not outside of nodes.
    */
    export interface SnapOuterPortsToNodeBorderStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var SnapOuterPortsToNodeBorderStage:{
      $class:yfiles.lang.Class;
      new ():yfiles.router.SnapOuterPortsToNodeBorderStage;
    };
    /**
    * Temporarily hides collinear bends on edge paths.
    */
    export interface CollinearBendHider extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var CollinearBendHider:{
      $class:yfiles.lang.Class;
      /**
      * DataProvider key for boolean edge data.
      * Only selected edges
      * will be considered by this stage. If this key is not bound
      * to the graph, then all edges will be considered.
      */
      SELECTED_EDGES_DP_KEY:Object;
      new (coreLayouter:yfiles.layout.ILayouter):yfiles.router.CollinearBendHider;
    };
    /**
    * This class provides helpers to convert between buses given by complete subgraphs and buses represented by specific
    * <em>hub</em> nodes.
    * <p> In a representation by means of hubs, each connected subgraph induced by hubs establishes a
    * bus. All regular nodes (non-hubs) which are connected to hubs of the same component are end-nodes of the same bus. In
    * other words, nodes which are reachable on paths consisting of only hubs belong to the same bus. Of course, a node can
    * be an end-node of more than one bus. </p> <p> Since a bus models a group of nodes in which every node is connected to
    * every other node, it can be represented as a complete subgraph of these nodes. To distinguish buses in this
    * representation, each edge must be associated with a unique ID which identifies the bus it is associated to. This is
    * the representation expected by {@link yfiles.router.BusRouter}. </p>
    */
    export interface BusRepresentations extends Object{
    }
    var BusRepresentations:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to transfer a user-defined object from each original edge to the respective
      * newly created edge.
      * Algorithms which respect this key expect the associated data provider to be also an instance of
      * {@link yfiles.algorithms.IDataAcceptor} to enable the storage of the data object for the new edge. Since there is no one-to-one
      * mapping between original and new edges, the data provider of this key is responsible for the edges whose source end
      * is a regular node.
      */
      SOURCE_ID_DP_KEY:Object;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to transfer a user-defined object from each original edge to the respective
      * newly created edge.
      * Algorithms which respect this key expect the associated data provider to be also an instance of
      * {@link yfiles.algorithms.IDataAcceptor} to enable the storage of the data object for the new edge. Since there is no one-to-one
      * mapping between original and new edges, the data provider of this key is responsible for the edges whose target end
      * is a regular node.
      */
      TARGET_ID_DP_KEY:Object;
      /**
      * Calculates for every bus represented by hubs a list of all of its edges.
      * Note that this method cannot return
      * isolated hubs and that each edge between two regular nodes establishes a separate bus.
      * @param {yfiles.algorithms.Graph} graph the graph
      * @param {yfiles.algorithms.IDataProvider} hubMarker a <code>DataProvider</code> which returns <code>true</code> if and only if a node is a hub
      * @return {yfiles.algorithms.EdgeList[]} an array of <code>EdgeList</code>s. Each list contains all edges of a bus.
      */
      toEdgeLists(graph:yfiles.algorithms.Graph,hubMarker:yfiles.algorithms.IDataProvider):yfiles.algorithms.EdgeList[];
      /**
      * Changes the representation of buses from hubs to complete subgraphs.
      * This method calls
      * <code>ReplaceHubsBySubgraph(graph, calculateBusEdgeLists(graph, hubMarker), hubMarker, false,
      * busDescriptors)</code>.
      * @see {@link yfiles.router.BusRepresentations#replaceHubsBySubgraphWithEdgeList}
      * @see {@link yfiles.router.BusRepresentations#toEdgeLists}
      */
      replaceHubsBySubgraph(graph:yfiles.layout.LayoutGraph,hubMarker:yfiles.algorithms.IDataProvider,descriptorAcceptor:yfiles.algorithms.IDataAcceptor):yfiles.algorithms.EdgeList;
      /**
      * Changes the representation of buses from hubs to complete subgraphs by creating new edges between regular nodes and
      * removing the hubs.
      * This method respects multiple connections of nodes and creates appropriate {@link yfiles.router.BusDescriptor}s consisting of the bus ID and source and target group IDs.
      * The path of each new edge follows the route defined by the component of the hubs. If the subgraph of hubs is not a
      * tree, these paths are ambiguous. In this case, an arbitrary tree is computed from the hub's subgraph which defines
      * all the paths.
      * @param {yfiles.layout.LayoutGraph} graph the graph of the bus
      * @param {yfiles.algorithms.EdgeList[]} hubEdgesLists an <code>EdgeList</code> for each bus
      * @param {yfiles.algorithms.IDataProvider} hubMarker 
      * a <code>DataProvider</code> that returns <code>true</code> if and only if a node is a
      * hub
      * @param {yfiles.algorithms.IDataProvider} fixedMarker 
      * a <code>DataProvider</code> that returns <code>true</code> if and only if an edge is
      * fixed
      * @param {yfiles.algorithms.IDataAcceptor} descriptorAcceptor a <code>DataAcceptor</code> to which the created bus descriptors are set
      * @return {yfiles.algorithms.EdgeList} a list of the created edges
      */
      replaceHubsBySubgraphWithEdgeList(graph:yfiles.layout.LayoutGraph,hubEdgesLists:yfiles.algorithms.EdgeList[],hubMarker:yfiles.algorithms.IDataProvider,fixedMarker:yfiles.algorithms.IDataProvider,descriptorAcceptor:yfiles.algorithms.IDataAcceptor):yfiles.algorithms.EdgeList;
      /**
      * Changes the representation of buses from complete subgraphs to hubs by replacing intersection points by hubs.
      * The
      * edges must form an orthogonal, cycle-free bus, otherwise an {@link yfiles.system.InvalidOperationException} is thrown.
      * @param {yfiles.layout.LayoutGraph} graph the graph of the bus
      * @param {yfiles.algorithms.IEdgeCursor} edgeCursor an <code>EdgeCursor</code> of the regular edges
      * @param {yfiles.algorithms.IDataProvider} descriptorProvider 
      * a <code>DataProvider</code> that provides a {@link yfiles.router.BusDescriptor} for each edge
      * @param {yfiles.algorithms.IDataAcceptor} busIDAcceptor 
      * an optional <code>DataAcceptor</code>. If specified, the bus ID for each new edge is set
      * to this data acceptor
      * @throws {yfiles.system.InvalidOperationException} if the path of an edge is not orthogonal or if some paths form a cycle
      */
      replaceSubgraphByHubs(graph:yfiles.layout.LayoutGraph,edgeCursor:yfiles.algorithms.IEdgeCursor,descriptorProvider:yfiles.algorithms.IDataProvider,busIDAcceptor:yfiles.algorithms.IDataAcceptor):void;
    };
    /**
    * An orthogonal bus-style edge routing algorithm which combines the large number of edges of complete subgraphs in a
    * concise, tree-like structure that consists of vertical and horizontal line segments.
    * A complete (sub)graph is a set
    * of nodes, in which each node is connected to every other node.  The positions of the nodes in a graph are not
    * altered by this algorithm.
    * <p>
    * <center><img src="doc-files/y.layout.router.BusRouter.gif" border="1"/></center>
    * </p>
    * <p>
    * In a drawing of this algorithm, each edge path is orthogonal and there are no cycles induced by any two edge paths of
    * the same bus, that is, the combination of all edge routes looks like an orthogonal tree. Besides these strict
    * requirements, the algorithm aims to find routes where shared paths of edges with different end-nodes are drawn on top
    * of each other and form long straight lines, so-called <b>backbone segments</b>. From these
    * backbone segments, short connections of grouped edges branch off to each node (<b>bus
    * connections</b>).
    * </p><p>
    * This routing algorithm uses a two-phase process. First, in <b>backbone selection</b>, a set
    * of good initial backbone segments is determined. In <b>routing and recombination</b>, each
    * initial backbone segment is connected to all others and also to each node by using orthogonal edge paths. Then, the
    * set of resulting structures is reduced to the most optimal structure where backbone segments are long and connections
    * to the nodes are short. Note that the calculated paths can join before reaching an initial backbone segment and,
    * thus, establish additional backbone segments. Contrariwise, initial backbone segments of low overall profit are
    * discarded and connections to them are rerouted to other backbone segments.
    * </p><p>
    * To determine which edges belong to a common bus, a mapping that assigns a bus ID to each edge must be specified using
    * {@link yfiles.router.BusDescriptor}s. A data provider holding bus descriptor objects is expected to be registered
    * with the graph using the {@link yfiles.router.BusRouter#EDGE_DESCRIPTOR_DP_KEY} look-up key. In the absence of an individual bus ID for an
    * edge, a bus consisting only of the single edge is created. Additionally, a bus descriptors allows to mark its
    * associated edge as fixed or movable, which is required for incremental routing, and to specify an optional group ID
    * for an edge's source end and target end, respectively.
    * </p><p>
    * Incremental routing means extending or updating an already existing bus-style representation. This can be used to
    * rearrange existing edges or to include additional edges in an existing bus. The paths of edges not marked as fixed by
    * their associated {@link yfiles.router.BusDescriptor#fixed  BusDescriptor} are calculated anew. The structure induced by the
    * fixed edges must be orthogonal and cycle-free.
    * </p>
    */
    export interface BusRouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * Factory method that creates an appropriate OrthogonalEdgeRouter implementation.
      * @return {yfiles.router.OrthogonalEdgeRouter} an appropriate OrthogonalEdgeRouter
      */
      createOrthogonalEdgeRouter():yfiles.router.OrthogonalEdgeRouter;
      /**
      * Returns <code>true</code> if the specified graph can be routed by this algorithm.
      * Calling {@link yfiles.router.BusRouter#doLayout} with
      * the specified graph as its argument will only succeed if this method returns <code>true</code>.
      * If there is no fixed edge in the graph, routing is always possible. Otherwise, the route of each fixed edge must be
      * orthogonal.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Calculates a new bus layout for the specified graph.
      * @param {yfiles.layout.LayoutGraph} graph the graph to lay out
      * PointlessBooleanExpression, ConstantConditions@see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The grid spacing that is used when grid routing is enabled.
      * By default, a spacing of <code>10</code> is set.
      * @see {@link yfiles.router.BusRouter#gridRouting}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#gridSpacing}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#gridSpacing}
      */
      gridSpacing:number;
      /**
      * Specifies whether or not to route edge segments on grid lines.
      * By default, this feature is disabled.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#gridRouting}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#gridRouting}
      */
      gridRouting:boolean;
      /**
      * The minimum distance between edge segments and nodes.
      * By default, a distance of <code>10</code> is set.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#minimumDistanceToNode}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#minimumDistanceToNode}
      */
      minimumDistanceToNode:number;
      /**
      * The minimum distance between edge segments.
      * By default, a distance of <code>5</code> is set.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#minimumDistance}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#minimumDistance}
      */
      minimumDistanceToEdge:number;
      /**
      * The cost for each edge crossing of a routed path.
      * A cost of <code>n</code> means that a path rather changes
      * direction <code>n</code> times than crossing the path of an edge. If the cost is set to <code>0.0</code>, no global
      * crossing optimization is performed. Setting a higher value will activate global crossing minimization. A good
      * trade-off between the number of direction changes and few crossings of a path is achieved by values between
      * <code>1.0</code> and <code>3.0</code>. By default, a cost of <code>1.0</code> is set.
      * This setting is taken into account only in the routing and recombination phase and does not affect the selection of
      * the initial backbone segments.
      */
      crossingCost:number;
      /**
      * Specifies whether rerouting of edges with many crossings is enabled.
      * By default, this feature is disabled. Activating this feature only makes sense if the global crossing
      * cost is set to a value greater than <code>0.0</code>.
      * This setting is taken into account only in the routing and recombination phase and does not affect the selection of
      * the initial backbone segments.
      * @see {@link yfiles.router.BusRouter#crossingCost}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#rerouting}
      * @see {@link yfiles.router.BusRouter#crossingCost}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#rerouting}
      */
      rerouting:boolean;
      /**
      * The preferred number of backbone segments with the same orientation.
      * The more initial backbone
      * segments, the longer the running time. By default, a count of <code>2</code> is set.
      * This count defines the number of backbone segments of the same orientation which are computed by the backbone
      * selection phase. The final number of backbone segments may be different due to changes in the routing and
      * recombination phase.
      */
      preferredBackboneSegmentCount:number;
      /**
      * The preferred minimum length of a backbone segment.
      * This should be at least as large as the typical distance
      * between nodes to avoid small backbone segments. It is reasonable to set this according to the dimension of the
      * graph's bounding box. By default, a minimum length of <code>100.0</code> is set.
      * This number defines the minimum length of backbone segments which are computed by the backbone selection phase.
      * Some of the final backbone segments may be shorter due to changes in the routing and recombination phase.
      */
      minimumBackboneSegmentLength:number;
      /**
      * The minimum number of bus connections each backbone segment must have.
      * If a backbone segment has less
      * connections, it is removed and the affected nodes connect to another backbone segment. Three or four is a good
      * choice for small graphs, for larger graphs a much larger count can be reasonable. By default, a minimum count of
      * <code>3</code> is set.
      * This setting is taken into account only in the routing and recombination phase and does not affect the selection of
      * the initial backbone segments.
      */
      minimumBusConnectionsCount:number;
      /**
      * Specifies whether or not collinear bends are removed from the layout.
      * If an edge has a collinear bend, there is
      * another edge which has a real bend at this point, i.e. the bend location is an intersection of the bus. Therefore,
      * it is advantageous for some applications to keep such bends. By default, this feature is enabled.
      */
      removeCollinearBends:boolean;
      /**
      * The <code>DataProvider</code> key to mark edges as <em>selected</em>.
      * <p> By default, {@link yfiles.router.BusRouter#EDGE_SUBSET_DP_KEY} is used. </p>
      * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
      */
      selectedEdgesDpKey:Object;
      /**
      * The scope set for this router.
      * The scope determines which edges are routed. Defaults to {@link yfiles.router.Scope#ALL}.
      */
      scope:yfiles.router.Scope;
      /**
      * Provides access to implementation specific properties of the algorithms used internally.
      * Used for internal
      * purposes.
      * @param {string} key the key to a property
      * @param {Object} value the value to associate with the key
      */
      setProperty(key:string,value:Object):boolean;
    }
    var BusRouter:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to store the {@link yfiles.router.BusDescriptor} of every edge.
      * A bus descriptor provides the
      * edge's bus ID, its optional group IDs and whether or not the edge is fixed.
      */
      EDGE_DESCRIPTOR_DP_KEY:Object;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used for specifying the edge subset to be laid out.
      * This key is used if no custom key is
      * set. The algorithm expects for each edge in the graph to find a {@link yfiles.algorithms.IDataProvider#getBool  boolean} that
      * indicates whether the node belongs to the scope.
      * @see {@link yfiles.router.BusRouter#scope}
      * @see {@link yfiles.router.BusRouter#selectedEdgesDpKey}
      */
      EDGE_SUBSET_DP_KEY:Object;
      /**
      * Creates a new instance of <code>BusRouter</code>.
      * ThisEscapedInObjectConstruction
      */
      new ():yfiles.router.BusRouter;
    };
    /**
    * A descriptor for bus-related information to be associated with an edge.
    * It consists of a bus ID defining the bus
    * of the associated edge, two optional edge group IDs for specifying the edge grouping at the source and target side,
    * respectively, and an optional boolean flag to mark the edge as fixed.
    * Every object except <code>null</code> can be used as valid bus ID. Every edge of ID <code>null</code> forms a group
    * of its own. Also, every object except <code>null</code> can be used as valid edge group ID. If there is no group ID
    * defined for an edge or if <code>null</code> is set, a default group ID is used. Therefore, all such edges ending at
    * the same node belong to the same group.
    */
    export interface BusDescriptor extends Object{
      /**
      * Indicates whether some other object is "equal to" this one.
      * @param {Object} obj the reference object with which to compare.
      * @return {boolean} <code>true</code> if all corresponding parameters are equal; <code>false</code> otherwise.
      */
      equals(obj:Object):boolean;
      hashCode():number;
      /**
      * The bus ID.
      */
      busId:Object;
      /**
      * The group ID for the source side of the edge.
      */
      sourceGroupId:Object;
      /**
      * The group ID for the target side of the edge.
      */
      targetGroupId:Object;
      /**
      * Specifies whether the associated edge is fixed or not.
      */
      fixed:boolean;
      /**
      * Returns a string consisting of the bus ID, the fixed flag, and both group IDs.
      * @return {string} a string consisting of the bus ID, the fixed flag, and both group IDs
      */
      toString():string;
    }
    var BusDescriptor:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of <code>BusDescriptor</code> for the specified bus ID which is marked as not fixed and uses
      * the default edge group IDs.
      * @param {Object} busID the ID of the bus the associated edge belongs to
      */
      WithId:{
        new (busID:Object):yfiles.router.BusDescriptor;
      };
      /**
      * Creates a new instance of <code>BusDescriptor</code> for the specified parameters and marks it as not fixed.
      * @param {Object} busID the ID of the bus the associated edge belongs to
      * @param {Object} sourceGroupID the group ID of the source side
      * @param {Object} targetGroupID the group ID of the target side
      */
      ForSourceAndTarget:{
        new (busID:Object,sourceGroupID:Object,targetGroupID:Object):yfiles.router.BusDescriptor;
      };
      /**
      * Creates a new instance of <code>BusDescriptor</code> for the specified parameters and default group IDs.
      * @param {Object} busID the ID of the bus the associated edge belongs to
      * @param {boolean} fixed whether the associated edge is fixed or not
      */
      WithFixed:{
        new (busID:Object,fixed:boolean):yfiles.router.BusDescriptor;
      };
      /**
      * Creates a new instance of <code>BusDescriptor</code> for the specified parameters.
      * @param {Object} busID the ID of the bus the associated edge belongs to
      * @param {boolean} fixed whether the associated edge is fixed or not
      * @param {Object} sourceGroupID the group ID of the source side
      * @param {Object} targetGroupID the group ID of the target side
      */
      ForSourceAndTargetWithFixed:{
        new (busID:Object,fixed:boolean,sourceGroupID:Object,targetGroupID:Object):yfiles.router.BusDescriptor;
      };
    };
    /**
    * This class represents an edge router.
    * It combines two strategic steps of edge routing and executes them after each
    * other. The first strategy is called path finder strategy and will route the edges, potentially with edge overlaps.
    * The second strategy will then split overlapping edge segments inside their channels and distribute them according to
    * the specific distribution strategy.
    * For path finding strategies you can for example use {@link yfiles.router.ChannelEdgeRouter.OrthogonalShortestPathPathFinder} or
    * {@link yfiles.router.OrthogonalPatternEdgeRouter}. By default the latter will be used.
    * One possible implementation of an edge distribution strategy is
    * {@link yfiles.router.OrthogonalSegmentDistributionStage}, which is also used by default.
    * Note: when exchanging only one of the strategies, make sure, that their algorithms will use the same (sub)set
    * of graph objects. The strategies bound to this router by default will use key {@link yfiles.router.ChannelEdgeRouter#AFFECTED_EDGES_DP_KEY} to determine
    * the affected edges.
    */
    export interface ChannelEdgeRouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given node object is zero.
      * It is called by the {@link yfiles.router.ChannelEdgeRouter#doLayout} method for each node object in the input graph.
      * @see {@link yfiles.router.ChannelEdgeRouter#checkGroupNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the node object is zero.
      */
      checkNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given group node object is zero.
      * It is called by the {@link yfiles.router.ChannelEdgeRouter#doLayout} method for each group node object in the input graph.
      * @see {@link yfiles.router.ChannelEdgeRouter#checkNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the group node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the group node object is zero.
      */
      checkGroupNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * The currently used path finder strategy of this router.
      * Path finding means routing the edges in a first approach.
      * Note: when exchanging only one of the strategies, make sure, that their algorithms will use the same (sub)set
      * of graph objects. The strategies bound to this router by default will us key {@link yfiles.router.ChannelEdgeRouter#AFFECTED_EDGES_DP_KEY} to determine the
      * affected edges.
      */
      pathFinderStrategy:yfiles.layout.ILayouter;
      /**
      * The currently used edge distribution strategy of this router.
      * Note: when exchanging only one of the strategies, make sure, that their algorithms will use the same (sub)set
      * of graph objects. The strategies bound to this router by default will us key {@link yfiles.router.ChannelEdgeRouter#AFFECTED_EDGES_DP_KEY} to determine the
      * affected edges.
      */
      edgeDistributionStrategy:yfiles.layout.ILayouter;
    }
    export module ChannelEdgeRouter{
      /**
      * This layouter is a s special version of {@link yfiles.router.OrthogonalEdgeRouter} that can be used as a path
      * finding strategy in {@link yfiles.router.ChannelEdgeRouter}.
      * It takes a bit longer than using the default path finding strategy
      * {@link yfiles.router.OrthogonalPatternEdgeRouter} but therefore will create no node crossings. It can be
      * configured like OrthogonalEdgeRouter.
      */
      export interface OrthogonalShortestPathPathFinder extends yfiles.router.OrthogonalEdgeRouter{
        /**
        * Returns <code>true</code> iff the given graph can be laid
        * out by this algorithm.
        * Calling <code>doLayout</code> with
        * the given graph as its argument will only success if
        * this method returns <code>true</code>.
        * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
        */
        canLayout(graph:yfiles.layout.LayoutGraph):boolean;
        /**
        * Main layout routine that assigns new layout information to the given graph.
        * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
        */
        doLayout(graph:yfiles.layout.LayoutGraph):void;
        /**
        * The key of a DataProvider that defines the edges, that shall be affected.
        */
        affectedEdgesDpKey:Object;
      }
    }
    var ChannelEdgeRouter:{
      $class:yfiles.lang.Class;
      /**
      * This field is used as the key to add a DataProvider to the graph, which specifies the edges, that are affected by
      * the edge routing.
      */
      AFFECTED_EDGES_DP_KEY:Object;
      new ():yfiles.router.ChannelEdgeRouter;
      OrthogonalShortestPathPathFinder:{
        $class:yfiles.lang.Class;
        /**
        * Initializes a new instance of the OrthogonalShortestPathPathFinder class.
        */
        new ():yfiles.router.ChannelEdgeRouter;
      };
    };
    /**
    * Layout stage for {@link yfiles.router.OrthogonalEdgeRouter} that adds support for a bus-like routing style.
    * Edges that connect to a
    * common node can be marked as grouped by using the data provider keys {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY} or
    * {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}. This stage tries to route grouped edges on a vertical or horizontal
    * bus. The edges will connect to their common node at the same port coordinate. There are some limitations to this
    * stage: <ul> <li>If at least one edge of a specific edge group is part of the sphere of action of
    * OrthogonalEdgeRouter, then all of the edges belonging to that group will be part of the sphere of action of the
    * router. </li> <li> Edges can either be source or target grouped but not both at the same time. </li> <li> Not all
    * edges belonging to a group will be placed on a common bus. Only edges that connect to nodes which lie in the same
    * direction relative to their common node will be routed on a bus. </li> </ul>
    */
    export interface EdgeGroupRouterStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * The minimal distance between a bus formed by an edge group and the nodes the grouped edges connect to.
      * By
      * default this value is set to <code>15.0</code>.
      */
      minimalBusDistance:number;
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var EdgeGroupRouterStage:{
      $class:yfiles.lang.Class;
      new (coreLayouter:yfiles.layout.ILayouter):yfiles.router.EdgeGroupRouterStage;
    };
    /**
    * This algorithm routes edges using an organic-like layout approach and style.
    * It is implemented as a LayoutStage so that it can easily be appended to
    * another stage, by setting the other stage as the core of this one.
    * Note that this algorithm only works correctly if it is guaranteed that nodes are at
    * least approximately twice as far away from each other as the minimal edge
    * distance, which has been set for this algorithm. This can be achieved by using
    * the {@link yfiles.router.OrganicEdgeRouter#createNodeEnlargementStage} layout stage in combination with a stage
    * that removes node overlaps as the core of this layouter.
    * Here is a sample output of the router using as input a straight-line drawing
    * created by :
    * <p>
    * <center><img src="doc-files/y.layout.router.OrganicEdgeRouter.star.gif" border="1"/></center></p>
    */
    export interface OrganicEdgeRouter extends Object,yfiles.layout.ILayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Specifies whether or not edge-node overlaps are allowed.
      * <b>Getter:</b>Enabling this option often leads to better results if the {@link yfiles.router.OrganicEdgeRouter#createNodeEnlargementStage} LayoutStage is not used
      * (e.g. because the nodes are not allowed to move) and the distances between some nodes are small.
      * However enabling this option may produce edge-node overlaps. Furthermore, the minimal distance (set with
      * {@link yfiles.router.OrganicEdgeRouter#minimalDistance} cannot always be maintained in that case.
      * <b>Setter:</b>because the nodes are not allowed to move) and the distances between some nodes are small.
      * However enabling this option may produce edge-node overlaps. Furthermore, the minimal distance (set with
      * {@link yfiles.router.OrganicEdgeRouter#minimalDistance}) cannot always be maintained in that case.
      * @see {@link yfiles.router.OrganicEdgeRouter#createNodeEnlargementStage}
      * @see {@link yfiles.router.OrganicEdgeRouter#minimalDistance}
      * @see {@link yfiles.router.OrganicEdgeRouter#createNodeEnlargementStage}
      * @see {@link yfiles.router.OrganicEdgeRouter#minimalDistance}
      */
      edgeNodeOverlapAllowed:boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given node object is zero.
      * It is called by the {@link yfiles.router.OrganicEdgeRouter#doLayout} method for each node object in the input graph.
      * @see {@link yfiles.router.OrganicEdgeRouter#checkGroupNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the node object is zero.
      */
      checkNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given group node object is zero.
      * It is called by the {@link yfiles.router.OrganicEdgeRouter#doLayout} method for each group node object in the input graph.
      * @see {@link yfiles.router.OrganicEdgeRouter#checkNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the group node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the group node object is zero.
      */
      checkGroupNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * The core layouter.
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
      /**
      * The minimal distance between nodes and non-incident edges.
      * Values should be larger than 10.
      */
      minimalDistance:number;
      /**
      * Specifies whether given bend coordinates are taken into account when
      * determining initial bend positions.
      */
      usingBends:boolean;
      /**
      * Specifies whether edges should be rerouted even if they do not obey all
      * constraints initially.
      * This flag is initially set to <code>false</code>
      * so that if edges that do not intersect with other nodes will not be rerouted
      * by this algorithm.
      */
      routingAll:boolean;
      /**
      * Returns a layout stage which can be used to ensure that the nodes do not overlap.
      * Note that overlapping nodes may lead to bad routing results.
      */
      createNodeEnlargementStage():yfiles.layout.ILayoutStage;
    }
    var OrganicEdgeRouter:{
      $class:yfiles.lang.Class;
      /**
      * Use this key to provide the algorithm with boolean values for each edge,
      * specifying the ones which should be rerouted.
      */
      ROUTE_EDGE_DP_KEY:Object;
      /**
      * Creates a new instance of OrganicEdgeRouter with an
      * initial minimal distance of <code>10</code>.
      */
      new ():yfiles.router.OrganicEdgeRouter;
      /**
      * Creates a new instance of OrganicEdgeRouter using the given
      * initial minimal distance.
      */
      WithMinDistance:{
        new (minNodeDistance:number):yfiles.router.OrganicEdgeRouter;
      };
    };
    /**
    * Layout stage for {@link yfiles.router.OrthogonalEdgeRouter} that should be
    * applied when routing edges in hierarchically grouped graphs.
    * {@link yfiles.router.OrthogonalEdgeRouter} itself is not well suited
    * to route edges that connect to grouped nodes, since it considers
    * all nodes (also group nodes!) as obstacles that should be avoided
    * when determining the route of an edge.
    */
    export interface GroupNodeRouterStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine.
      * <b>Precondition:</b> 
      * the coreLayouter must contain an instance of
      * {@link yfiles.router.OrthogonalEdgeRouter} in its layout pipeline.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
    }
    var GroupNodeRouterStage:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of this class.
      */
      new ():yfiles.router.GroupNodeRouterStage;
      /**
      * Creates a new instance of this class.
      * @param {yfiles.layout.ILayouter} coreLayouter 
      * the core layouter invoked by this stage.
      * The coreLayouter must contain an instance of
      * {@link yfiles.router.OrthogonalEdgeRouter} in its layout pipeline.
      */
      WithCoreLayouter:{
        new (coreLayouter:yfiles.layout.ILayouter):yfiles.router.GroupNodeRouterStage;
      };
    };
    /**
    * This class represents an orthogonal edge router.
    * An orthogonal edge router is a layout algorithm that changes the
    * coordinates of the edge paths in a way that the resulting layout of the edges is made up of vertical and horizontal
    * segments only. The router does not change the location or the size of the nodes in a diagram in any way.
    * <p>
    * Several LayoutStages can be used to enhance performance and/or functionality of this class, e.g. {@link yfiles.router.EdgeGroupRouterStage}, {@link yfiles.router.GroupNodeRouterStage}, {@link yfiles.router.ReducedSphereOfActionStage} or {@link yfiles.router.PatchRouterStage}.
    * </p>
    * <p>
    * This edge router will obey strong and weak port constraints. It expects the port constraints to be bound to the input
    * graph by the data provider keys {@link yfiles.layout.PortConstraintKeys#SOURCE_PORT_CONSTRAINT_DP_KEY} and {@link yfiles.layout.PortConstraintKeys#TARGET_PORT_CONSTRAINT_DP_KEY}. Furthermore, this class supports the more advanced port constraint
    * concept of {@link yfiles.layout.PortCandidate}s. It expects collections of port candidates to be bound to the input graph by the
    * data provider keys {@link yfiles.layout.PortCandidate#SOURCE_PC_LIST_DP_KEY} and {@link yfiles.layout.PortCandidate#TARGET_PC_LIST_DP_KEY}.
    * </p>
    * <p>
    * The router often finds ideal routes in difficult situations like the one depicted below. </p>
    * <p>
    * <center><img
    * src="doc-files/y.layout.router.OrthogonalEdgeRouter.maze.gif" border="1"/></center></p>
    */
    export interface OrthogonalEdgeRouter extends yfiles.layout.AbstractLayoutStage{
      /**
      * The <code>DataProvider</code> key to mark nodes as
      * <em>selected</em>.
      * <p>
      * By default, {@link yfiles.layout.LayouterKeys#SELECTED_NODES_DP_KEY} is used.
      * </p>
      * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
      */
      selectedNodesDpKey:Object;
      /**
      * The <code>DataProvider</code> key to mark edges as
      * <em>selected</em>.
      * <p>
      * By default, {@link yfiles.layout.LayouterKeys#SELECTED_EDGES_DP_KEY} is used.
      * </p>
      * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
      */
      selectedEdgesDpKey:Object;
      /**
      * Specifies whether or not node labels are taken into account when calculating edge paths (thereby preventing
      * possible edge/node label overlaps).
      * The default is <code>false</code>.
      */
      considerNodeLabels:boolean;
      /**
      * The specified kind of monotonic path restrictions.
      * Possible values are {@link yfiles.router.MonotonicPathRestriction#NONE}, {@link yfiles.router.MonotonicPathRestriction#VERTICAL}, {@link yfiles.router.MonotonicPathRestriction#HORIZONTAL}
      * and {@link yfiles.router.MonotonicPathRestriction#BOTH}.
      */
      monotonicPathRestriction:yfiles.router.MonotonicPathRestriction;
      /**
      * Specifies whether monotonic path restrictions (set with{@link yfiles.router.OrthogonalEdgeRouter#monotonicPathRestriction}) should be enforced.
      * Enabling this option guarantees monotonic edge paths even if this results in additional overlaps between edges and nodes.
      */
      enforceMonotonicPathRestrictions:boolean;
      /**
      * Returns <code>true</code> if the specified core layouter does, and also when there is no core layouter.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main entrance to orthogonal edge routing.
      * Routes the edges of the given graph.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#doLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given node object is zero.
      * It is called by the {@link yfiles.router.OrthogonalEdgeRouter#doLayout} method for each node object in the input graph.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#checkGroupNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the node object is zero.
      */
      checkNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given group node object is zero.
      * It is called by the {@link yfiles.router.OrthogonalEdgeRouter#doLayout} method for each group node object in the input graph.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#checkNodeSize}
      * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
      * @param {Object} node the group node object to test.
      * @throws {yfiles.system.ArgumentException} thrown if the width/height of the group node object is zero.
      */
      checkGroupNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
      /**
      * For internal use only.
      * @deprecated For internal use only. Might be changed or removed in the future.
      */
      setProperty(key:string,value:Object):boolean;
      /**
      * The cost for each edge crossing of a routed path.
      * A cost of <code>n</code> means that a path rather changes
      * direction <code>n</code> times than crossing the path of an edge. By default the cost is set to <code>0</code> and
      * therefore no global crossing optimization is performed. Setting a higher value will activate global crossing
      * minimization. A good trade-off between the number of direction changes and few crossings of a path is achieved by
      * values between <code>1</code> and <code>3</code>.
      */
      crossingCost:number;
      /**
      * Specifies whether rerouting bad edges is enabled.
      * By default this feature is not enabled.
      * Activating this feature only makes sense if the global crossing cost
      * is set to a value greater an <code>0</code>.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#crossingCost}
      */
      rerouting:boolean;
      /**
      * The currently set sphere of action specifier.
      * Default setting is {@link yfiles.router.SphereOfAction#ROUTE_ALL_EDGES}.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#selectedEdgesDpKey}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#selectedNodesDpKey}
      */
      sphereOfAction:yfiles.router.SphereOfAction;
      /**
      * Specifies whether or not to route edge segments on grid lines.
      * By default this feature is disabled, i.e., "free" routing is enabled.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#setGridOrigin}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#gridSpacing}
      */
      gridRouting:boolean;
      /**
      * Sets a grid point coordinate used when grid routing is enabled.
      * By default <code>(0, 0)</code> is set.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#gridRouting}
      */
      setGridOrigin(x:number,y:number):void;
      /**
      * A grid point coordinate used when grid routing is enabled.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#setGridOrigin}
      */
      gridOrigin:yfiles.algorithms.YPoint;
      /**
      * The grid spacing that is used when grid routing is enabled.
      * By default a spacing of <code>2</code> is set,
      * which is also the minimum allowed spacing.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#gridRouting}
      */
      gridSpacing:number;
      /**
      * The minimum distance between edge segments.
      * By default a distance of <code>4</code> is set, which is also the
      * minimum allowed distance.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#coupledDistances}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#minimumDistanceToNode}
      */
      minimumDistance:number;
      /**
      * Specifies whether the minimum distances are coupled.
      * I.e., whether half the value set for the minimum distance between edge
      * segments should automatically be used as the minimum distance between edge
      * segments and nodes, or a custom value should be used instead.
      * <p>
      * By default the minimum distances are coupled.
      * </p>
      * @see {@link yfiles.router.OrthogonalEdgeRouter#minimumDistance}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#minimumDistanceToNode}
      */
      coupledDistances:boolean;
      /**
      * The minimum distance between edge segments and nodes.
      * @see {@link yfiles.router.OrthogonalEdgeRouter#coupledDistances}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#minimumDistance}
      */
      minimumDistanceToNode:number;
      /**
      * Specifies whether the local crossing minimization strategy is enabled.
      * By default this feature is enabled.
      */
      localCrossingMinimization:boolean;
      /**
      * The currently set ratio between the two complementary weighting strategies center driven and space driven.
      * <ul> <li>Center driven means that those edge paths should be preferred
      * that are closer to the edge's center. (Where the edge's center is an equidistant point between source node and
      * target node.)</li> <li>Space driven means that those edge paths should be preferred that are evenly distributed
      * over the available space.</li> </ul>
      */
      centerToSpaceRatio:number;
      /**
      * The currently set routing style.
      * The default setting is {@link yfiles.router.RoutingStyle#BALANCED}.
      */
      routingStyle:yfiles.router.RoutingStyle;
      /**
      * Specifies whether bad edges should be drawn in an orthogonal fashion.
      * If set, edge paths are drawn in an orthogonal
      * fashion. Otherwise the edge path is drawn as a straight line.
      * <p>
      * Default setting is <code>true</code>. </p>
      */
      badOrthogonal:boolean;
      /**
      * Specifies whether a custom value for the capacity of the routing border is used.
      * <p>
      * Default setting is <code>false</code>. </p>
      * @see {@link yfiles.router.OrthogonalEdgeRouter#customBorderCapacity}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#customBorderCapacity}
      */
      useCustomBorderCapacity:boolean;
      /**
      * The currently set custom value for the capacity of the routing border around the graph's bounding box.
      * The routing
      * border means the space left of the leftmost node, right of the rightmost node, above the topmost node, and below
      * the bottommost node. By default this value is set to 5, i.e., the routing border accommodates up to 5 parallel edge
      * paths left of the leftmost node, right of the rightmost node, etc.
      */
      customBorderCapacity:number;
      /**
      * Specifies whether edge ports (that do not have a strong port constraint set) should lie inside the node's bounding
      * box or on the node's border.
      * More specifically, "inside" means on the node's meridian for edges
      * connecting to the left and right, and on the node's equator for edges
      * connecting to the upper and lower side.
      * <p>
      * Default setting is <code>false</code>.
      * </p>
      */
      innerPorts:boolean;
    }
    var OrthogonalEdgeRouter:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of the Orthogonal Edge Router.
      * The initial settings (the default values) make up an instance
      * that: <ul> <li>processes all edges,</li> <li>applies "free" routing with a minimum distance between edge segments
      * of 4 [pixel],</li> <li>uses an automatically derived minimum distance between edge segments and nodes of 2
      * [pixel],</li> <li>obeys port constraints (if previously set),</li> <li>uses an edge routing style, where edge
      * segments are drawn with the most distance to already known obstacles (i.e., nodes and other edge segments),</li>
      * <li>draws edges, which cannot be routed, in an orthogonal fashion, and</li> <li>places edge ports along the node's
      * bounding box.</li> </ul>
      * @see {@link yfiles.router.OrthogonalEdgeRouter#sphereOfAction}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#gridRouting}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#routingStyle}
      * @see {@link yfiles.router.OrthogonalEdgeRouter#badOrthogonal}
      */
      new ():yfiles.router.OrthogonalEdgeRouter;
      /**
      * Convenience constructor to simultaneously set a core layout algorithm which will run before the orthogonal edge
      * router.
      */
      WithCoreLayouter:{
        new (core:yfiles.layout.ILayouter):yfiles.router.OrthogonalEdgeRouter;
      };
    };
    export module polyline{
      export enum Alignment{
        /**
        * Specifies that the segment prefers to be placed close to the lower bound of its location range.
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#preferredAlignment}
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#preferredAlignment}
        */
        MIN,
        /**
        * Specifies that the segment prefers to be placed close to the upper bound of its location range.
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#preferredAlignment}
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#preferredAlignment}
        */
        MAX,
        /**
        * Specifies that the segment can be placed somewhere in its location range.
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#preferredAlignment}
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#preferredAlignment}
        */
        ANY
      }
      /**
      * Partitions the bounding box of a graph in rectangles using graph elements as obstacles.
      * <p>
      * All {@link yfiles.router.polyline.Obstacle}s used during the partitioning are {@link yfiles.router.polyline.GraphPartition#createObstacle  created}
      * by {@link yfiles.router.polyline.IGraphPartitionExtension}s, that have been
      * {@link yfiles.router.polyline.GraphPartition#addDynamicDecompositionListener  registered} before,
      * in their {@link yfiles.router.polyline.IGraphPartitionExtension#preparePartition  prepare} method
      * which is called during the <code>GraphPartition</code>s {@link yfiles.router.polyline.GraphPartition#init  initialization}.
      * </p>
      * <p>
      * The core partitioning is delegated to an {@link yfiles.router.polyline.IObstaclePartition} that is
      * {@link yfiles.router.polyline.IObstaclePartition#init  initialized} with these <code>Obstacle</code>s.
      * </p>
      * <p>
      * If the {@link yfiles.router.polyline.IObstaclePartition} implements {@link yfiles.router.polyline.IDynamicDecomposition}, <code>GraphPartition</code> redispatches
      * the decomposition notifications to its extensions.
      * </p>
      * @see {@link yfiles.router.polyline.IGraphPartitionExtension}
      */
      export interface GraphPartition extends Object,yfiles.router.polyline.IPartition,yfiles.router.polyline.IDynamicDecomposition,yfiles.router.polyline.DynamicDecompositionCompanion.IListener{
        /**
        * The inner obstacle partition.
        */
        partition:yfiles.router.polyline.IObstaclePartition;
        /**
        * Adds the given listener to the {@link yfiles.router.polyline.IPartition}.
        * @param {yfiles.router.polyline.DynamicDecompositionCompanion.IListener} listener 
        * The listener that shall be notified upon dynamic decomposition events. If it is a
        * {@link yfiles.router.polyline.IGraphPartitionExtension}, its
        * {@link yfiles.router.polyline.IGraphPartitionExtension#preparePartition  preparePartition}
        * method is called during {@link yfiles.router.polyline.GraphPartition#init  initialization}.
        * @see Specified by {@link yfiles.router.polyline.IDynamicDecomposition#addDynamicDecompositionListener}.
        */
        addDynamicDecompositionListener(listener:yfiles.router.polyline.DynamicDecompositionCompanion.IListener):void;
        /**
        * Removes the given listener from the {@link yfiles.router.polyline.IPartition}.
        * @param {yfiles.router.polyline.DynamicDecompositionCompanion.IListener} listener The listener that shall not be notified anymore upon dynamic decomposition events.
        * @see Specified by {@link yfiles.router.polyline.IDynamicDecomposition#removeDynamicDecompositionListener}.
        */
        removeDynamicDecompositionListener(listener:yfiles.router.polyline.DynamicDecompositionCompanion.IListener):void;
        /**
        * Initializes the partition with the given graph instance.
        * <p>
        * After {@link yfiles.router.polyline.GraphPartition#clear  clearing} any old partitioning information, the {@link yfiles.router.polyline.IGraphPartitionExtension#preparePartition}
        * method of all registered extensions is called. Finally the inner {@link yfiles.router.polyline.IObstaclePartition} is initialized passing
        * all {@link yfiles.router.polyline.GraphPartition#createObstacle  added} obstacles as well as the given graph's bounds
        * extended by a small padding.
        * </p>
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration 
        */
        init(configuration:yfiles.router.polyline.PathSearchConfiguration):void;
        /**
        * Returns a list of all {@link yfiles.router.polyline.PartitionCell}s that are neighbors of the given cell, this means those cells have a
        * common border segment with the given cell.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell to get the neighbors for.
        * @return {yfiles.algorithms.IList} 
        * A list of {@link yfiles.router.polyline.PartitionCell}s that are neighbors of the given cell.
        * @see Specified by {@link yfiles.router.polyline.IPartition#getNeighbors}.
        */
        getNeighbors(cell:yfiles.router.polyline.PartitionCell):yfiles.algorithms.IList;
        /**
        * Returns a list of all {@link yfiles.algorithms.Node}s whose bounds intersect or cover the bounds of the given cell.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell to get the nodes for.
        * @return {yfiles.algorithms.IList} 
        * A list of {@link yfiles.algorithms.Node}s that are intersected by the given cell.
        */
        getNodes(cell:yfiles.router.polyline.PartitionCell):yfiles.algorithms.IList;
        /**
        * Returns all obstacles covering the given {@link yfiles.router.polyline.PartitionCell} by delegating to the inner partition's
        * {@link yfiles.router.polyline.IObstaclePartition#getObstacles} method.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell to get the obstacles for.
        * @return {yfiles.algorithms.IList} 
        * A list of {@link yfiles.router.polyline.Obstacle}s that cover the given cell.
        */
        getObstacles(cell:yfiles.router.polyline.PartitionCell):yfiles.algorithms.IList;
        /**
        * Returns all cells that are completely covered by the bounds of the given
        * node.
        * @param {yfiles.algorithms.Node} node The node to get the covered cells for.
        * @return {yfiles.algorithms.IList} 
        * An unmodifiable list of {@link yfiles.router.polyline.PartitionCell} instances that are
        * completely covered by the bounds of the given node.
        */
        getCellsWithNode(node:yfiles.algorithms.Node):yfiles.algorithms.IList;
        /**
        * <inheritDoc/>
        * Note: this call is delegated to {@link yfiles.router.polyline.IPartition#getCells}.
        * @see Specified by {@link yfiles.router.polyline.IPartition#getCells}.
        */
        getCells(rect:yfiles.algorithms.YRectangle):yfiles.algorithms.IList;
        /**
        * The rectangular area that is partitioned.
        * @see Specified by {@link yfiles.router.polyline.IPartition#bounds}.
        */
        bounds:yfiles.algorithms.YRectangle;
        /**
        * Clears the partition data so the <code>GraphPartition</code> can be reused and
        * {@link yfiles.router.polyline.GraphPartition#init  initialized} with a new configuration.
        */
        clear():void;
        /**
        * Callback after a {@link yfiles.router.polyline.PartitionCell} has been subdivided into several sub cells.
        * <p>
        * This class redispatches this event to all registered
        * {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener}s.
        * </p>
        * @param {yfiles.router.polyline.PartitionCell} cell The cell that has been subdivided.
        * @param {yfiles.algorithms.IList} subCells The new sub cells of the divided cell.
        * @see Specified by {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener#onCellSubdivided}.
        */
        onCellSubdivided(cell:yfiles.router.polyline.PartitionCell,subCells:yfiles.algorithms.IList):void;
        /**
        * Callback after a {@link yfiles.router.polyline.PartitionCell} has been decided to be final and won't be subdivided further.
        * <p>
        * This class redispatches this event to all registered
        * {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener}s.
        * </p>
        * @param {yfiles.router.polyline.PartitionCell} finalizedCell The cell that has been finalized.
        * @see Specified by {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener#onCellFinalized}.
        */
        onCellFinalized(finalizedCell:yfiles.router.polyline.PartitionCell):void;
        /**
        * Callback after a new {@link yfiles.router.polyline.PartitionCell} has been created.
        * <p>
        * This class redispatches this event to all registered
        * {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener}s.
        * </p>
        * @param {yfiles.router.polyline.PartitionCell} createdCell The newly created cell.
        * @see Specified by {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener#onCellCreated}.
        */
        onCellCreated(createdCell:yfiles.router.polyline.PartitionCell):void;
        /**
        * Creates and returns a new {@link yfiles.router.polyline.Obstacle} using the given bounds and data.
        * All obstacles created via this
        * method are given to the inner {@link yfiles.router.polyline.IObstaclePartition} upon initialization.
        * @param {yfiles.algorithms.YRectangle} bounds The bounds of the obstacle.
        * @param {Object} data The additional data that shall be associated with the obstacle.
        * @return {yfiles.router.polyline.Obstacle} 
        * A new {@link yfiles.router.polyline.Obstacle} using the given bounds and data.
        */
        createObstacle(bounds:yfiles.algorithms.YRectangle,data:Object):yfiles.router.polyline.Obstacle;
        /**
        * Returns the obstacle that has earlier been created for the given data object.
        * @param {Object} data The data to get the obstacle for.
        * @return {yfiles.router.polyline.Obstacle} The obstacle that has been created for the given data object.
        */
        getObstacle(data:Object):yfiles.router.polyline.Obstacle;
      }
      var GraphPartition:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        * @param {yfiles.router.polyline.IObstaclePartition} partition The inner obstacle partition used by this graph partition to delegate the partitioning to.
        */
        new (partition:yfiles.router.polyline.IObstaclePartition):yfiles.router.polyline.GraphPartition;
      };
      export enum RoutingType{
        /**
        * Routing type information representing a straight crossing of the cell, i.e. a single orthogonal segment of
        * edge enters and exits the cell.
        * @see {@link yfiles.router.polyline.EdgeCellInfo#type}
        */
        STRAIGHT,
        /**
        * Routing type information representing a crossing of the cell with three segments, i.e. the edge enters and exits
        * the cell using the same direction but has an orthogonal middle segment between the entering and exiting segment.
        * @see {@link yfiles.router.polyline.EdgeCellInfo#type}
        */
        STRAIGHT_BENDING,
        /**
        * Routing type information representing a crossing of the cell with a single bend, i.e. the edge enters the cell
        * in one direction, makes a bend and exits the cell in an orthogonal direction.
        * @see {@link yfiles.router.polyline.EdgeCellInfo#type}
        */
        BENDING,
        /**
        * Routing type information representing a crossing of the cell by making a u-turn, i.e. the edge enters and exits
        * the cell on the same side using two turns and an orthogonal middle segment.
        * @see {@link yfiles.router.polyline.EdgeCellInfo#type}
        */
        U_TURN,
        /**
        * Routing type information representing the source or target end of an edge being in the cell, i.e. the enter and/or
        * exit interval is <code>null</code>.
        * @see {@link yfiles.router.polyline.EdgeCellInfo#type}
        */
        END
      }
      /**
      * This abstract adapter provides an empty implementation of {@link yfiles.router.polyline.IGraphPartitionExtension}.
      * <p>
      * The only real functionality is contained in the
      * {@link yfiles.router.polyline.IGraphPartitionExtension#preparePartition  prepare} method which stores the
      * given {@link yfiles.router.polyline.PathSearchConfiguration} and {@link yfiles.router.polyline.GraphPartition} in properties..
      * </p>
      * @see {@link yfiles.router.polyline.GraphPartitionExtensionAdapter#configuration}
      * @see {@link yfiles.router.polyline.GraphPartitionExtensionAdapter#graphPartition}
      */
      export interface GraphPartitionExtensionAdapter extends Object,yfiles.router.polyline.IGraphPartitionExtension{
        /**
        * The bridge passed in{@link yfiles.router.polyline.IGraphPartitionExtension#preparePartition}.
        */
        graphPartition:yfiles.router.polyline.GraphPartition;
        /**
        * The configuration of the{@link yfiles.router.polyline.PathSearch} passed in
        * {@link yfiles.router.polyline.IGraphPartitionExtension#preparePartition}.
        */
        configuration:yfiles.router.polyline.PathSearchConfiguration;
        /**
        * Callback after a new {@link yfiles.router.polyline.PartitionCell} has been created.
        * @param {yfiles.router.polyline.PartitionCell} createdCell The newly created cell.
        * @see Specified by {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener#onCellCreated}.
        */
        onCellCreated(createdCell:yfiles.router.polyline.PartitionCell):void;
        /**
        * Callback after a {@link yfiles.router.polyline.PartitionCell} has been subdivided into several sub cells.
        * <p>
        * Listener may not modify the list of sub cells.
        * </p>
        * @param {yfiles.router.polyline.PartitionCell} cell The cell that has been subdivided.
        * @param {yfiles.algorithms.IList} subCells The new sub cells of the divided cell.
        * @see Specified by {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener#onCellSubdivided}.
        */
        onCellSubdivided(cell:yfiles.router.polyline.PartitionCell,subCells:yfiles.algorithms.IList):void;
        /**
        * Callback after a {@link yfiles.router.polyline.PartitionCell} has been decided to be final and won't be subdivided further.
        * @param {yfiles.router.polyline.PartitionCell} finalizedCell The cell that has been finalized.
        * @see Specified by {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener#onCellFinalized}.
        */
        onCellFinalized(finalizedCell:yfiles.router.polyline.PartitionCell):void;
        /**
        * This method is called by the given {@link yfiles.router.polyline.GraphPartition} upon initialization before its
        * {@link yfiles.router.polyline.IObstaclePartition} gets initialized.
        * <p>
        * Implementations may use the given <code>graph</code> the {@link yfiles.router.polyline.GraphPartition} is based upon to initialize themselves
        * and/or {@link yfiles.router.polyline.GraphPartition#createObstacle  add obstacles} to the list
        * that {@link yfiles.router.polyline.IObstaclePartition} is initialized with.
        * </p>
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration used for the path search.
        * @param {yfiles.router.polyline.GraphPartition} graphPartition The graph partition using this extension.
        * @see Specified by {@link yfiles.router.polyline.IGraphPartitionExtension#preparePartition}.
        */
        preparePartition(configuration:yfiles.router.polyline.PathSearchConfiguration,graphPartition:yfiles.router.polyline.GraphPartition):void;
        /**
        * Cleans the extension up from the last partitioning with the current configuration and graphPartition.
        * @see Specified by {@link yfiles.router.polyline.IGraphPartitionExtension#cleanup}.
        */
        cleanup():void;
      }
      var GraphPartitionExtensionAdapter:{
        $class:yfiles.lang.Class;
      };
      /**
      * Provides support for routing edges on equidistant grid lines.
      * <p>
      * The grid is defined by its origin and the spacing between the equidistant grid lines.
      * </p>
      */
      export interface Grid extends Object{
        /**
        * The horizontal coordinate of the origin.
        */
        originX:number;
        /**
        * The vertical coordinate of the origin.
        */
        originY:number;
        /**
        * The spacing between the horizontal and vertical grid lines.
        */
        spacing:number;
        /**
        * Returns a <code>String</code> representation of <code>Grid</code>.
        * @return {string} A <code>String</code> representation of <code>Grid</code>.
        */
        toString():string;
      }
      var Grid:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        * The spacing between the grid lines must be at least <code>1</code>. If spacing is smaller,
        * 1 is assumed.
        * @param {number} originX The horizontal coordinate of the origin.
        * @param {number} originY The vertical coordinate of the origin.
        * @param {number} spacing The spacing between the grid lines. Must be at least <code>1</code>.
        */
        new (originX:number,originY:number,spacing:number):yfiles.router.polyline.Grid;
      };
      /**
      * A {@link yfiles.router.polyline.IPartition} that takes a list of {@link yfiles.router.polyline.Obstacle}s as input to subdivide an area into {@link yfiles.router.polyline.PartitionCell}s.
      * <p>
      * Implementations have to satisfy the following condition for each pair of obstacle and partition cell:
      * Obstacles either completely cover partition cells or do not intersect partition cells at all.
      * </p>
      * <p>
      * <center>
      * <img src="doc-files/y.layout.router.polyline.ObstaclePartition.example.gif" border="0" height="569"/>
      * </center>
      * <center>
      * Fig 1: Example of an obstacle partition of a graph consisting of two gray colored nodes connected by one edge.
      * The two nodes are considered to be obstacles. The blue colored partition cells subdivide the area such that
      * each obstacle either completely covers a partition cell or do not intersect with a partition cell.
      * </center>
      * </p>
      */
      export interface IObstaclePartition extends Object,yfiles.router.polyline.IPartition{
        /**
        * Initializes a new partition of the area with the given <code>bounds</code> using the list of {@link yfiles.router.polyline.Obstacle}s.
        * @param {yfiles.algorithms.IList} obstacles 
        * A list of {@link yfiles.router.polyline.Obstacle}s that shall be considered by the partition.
        * @param {yfiles.algorithms.YRectangle} bounds The bounds of the partition.
        * @see Specified by {@link yfiles.router.polyline.IObstaclePartition#init}.
        */
        init(obstacles:yfiles.algorithms.IList,bounds:yfiles.algorithms.YRectangle):void;
        /**
        * Returns all obstacles that cover the given partition cell.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell to get the obstacles for.
        * @return {yfiles.algorithms.IList} 
        * An unmodifiable list of {@link yfiles.router.polyline.Obstacle} instances that cover the given cell.
        * @see Specified by {@link yfiles.router.polyline.IObstaclePartition#getObstacles}.
        */
        getObstacles(cell:yfiles.router.polyline.PartitionCell):yfiles.algorithms.IList;
        /**
        * Returns all cells that are completely covered by the given obstacle.
        * @param {yfiles.router.polyline.Obstacle} obstacle The obstacle to get the covered cells for.
        * @return {yfiles.algorithms.IList} 
        * An unmodifiable list of {@link yfiles.router.polyline.PartitionCell} instances that are
        * completely covered by the given obstacle.
        * @see Specified by {@link yfiles.router.polyline.IObstaclePartition#getCellsWithObstacle}.
        */
        getCellsWithObstacle(obstacle:yfiles.router.polyline.Obstacle):yfiles.algorithms.IList;
        /**
        * Clears the partition data so the <code>ObstaclePartition</code> can be reused and
        * {@link yfiles.router.polyline.IObstaclePartition#init  initialized} with new <code>Obstacle</code>s.
        * @see Specified by {@link yfiles.router.polyline.IObstaclePartition#clear}.
        */
        clear():void;
      }
      var IObstaclePartition:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * This class represents a one-dimensional, closed interval.
      */
      export interface Interval extends Object{
        /**
        * The lower bound of the interval.
        */
        min:number;
        /**
        * The upper bound of the interval.
        */
        max:number;
        /**
        * The midpoint of the interval.
        */
        center:number;
        /**
        * Checks if the given value is inside the interval.
        * @param {number} value the value to check
        * @return {boolean} <code>true</code>, if the value is inside the interval, <code>false</code> otherwise.
        */
        contains(value:number):boolean;
        /**
        * The size of the interval.
        */
        size:number;
        /**
        * Checks if this interval intersects the given interval.
        * This means that both intervals have at least one common
        * value.
        * @param {yfiles.router.polyline.Interval} other the other interval to check
        * @return {boolean} <code>true</code>, if the intervals have at least one common value, <code>false</code> otherwise.
        */
        intersects(other:yfiles.router.polyline.Interval):boolean;
        /**
        * Checks if this interval intersects the given interval and the intersection has a length of at least
        * <code>minIntersection</code>.
        * @param {yfiles.router.polyline.Interval} other the other interval to check
        * @param {number} minIntersection the minimal length the intervals have to intersect
        * @return {boolean} 
        * <code>true</code>, if the intervals intersect by at least <code>minIntersection</code>, <code>false</code>
        * otherwise.
        */
        intersectsWithOtherAndMinIntersection(other:yfiles.router.polyline.Interval,minIntersection:number):boolean;
        /**
        * Returns the distance between the value and the interval.
        * <p>
        * If this interval contains the specified value, the distance is 0. Otherwise, it is the minimum of dist(value, lower
        * bound) and dist(value, upper bound).
        * </p>
        * @param {number} value the value to calculate the distance to
        * @return {number} the distance between the value and the interval
        */
        distanceTo(value:number):number;
        /**
        * Returns the distance between this interval and the given interval.
        * <p>
        * If the intervals {@link yfiles.router.polyline.Interval#intersects}, the distance is 0. Otherwise, it is dist(minimum of upper bounds, maximum of
        * lower bounds)."
        * </p>
        * @param {yfiles.router.polyline.Interval} other the other interval to calculate the distance to
        * @return {number} the distance between this interval and the given interval
        */
        distanceToWithOther(other:yfiles.router.polyline.Interval):number;
        /**
        * Checks if the given interval covers this interval fully.
        * <p>
        * The given interval covers this interval, if <code>lower bound other - epsilon &lt;= lower bound this</code> and
        * <code>upper bound this &lt;= upper bound other + epsilon</code> where <code>epsilon</code> is a small value.
        * </p>
        * @param {yfiles.router.polyline.Interval} other the other interval
        * @return {boolean} <code>true</code> if this interval is fully covered by the other interval, <code>false</code> otherwise.
        */
        coveredBy(other:yfiles.router.polyline.Interval):boolean;
        /**
        * Checks if the given interval covers this interval fully.
        * <p>
        * The given interval covers this interval, if <code>lower bound other - epsilon &lt;= lower bound this</code> and
        * <code>upper bound this &lt;= upper bound other + epsilon</code>.
        * </p>
        * @param {yfiles.router.polyline.Interval} other the other interval
        * @param {number} eps The epsilon value the range of the other interval is extended.
        * @return {boolean} <code>true</code> if this interval is fully covered by the other interval, <code>false</code> otherwise.
        */
        coveredByWithOtherAndEps(other:yfiles.router.polyline.Interval,eps:number):boolean;
        /**
        * Returns the interval bound that is closest to the given value.
        * @param {number} value the value to get the closest interval bound for
        * @return {number} 
        * <code>value</code>, if the given value is inside the interval, the lower bound if the given value is
        * lesser than or equal the lower bound and the upper bound if the given value is greater than or equal the upper
        * bound.
        */
        getClosest(value:number):number;
        /**
        * Checks if the upper bound of this interval is lesser than the lower bound of the given interval.
        * @param {yfiles.router.polyline.Interval} other the interval to compare.
        * @return {boolean} <code>true</code> if the current interval is left of the given one, <code>false</code> otherwise.
        */
        isLessThan(other:yfiles.router.polyline.Interval):boolean;
        /**
        * Checks if the lower bound of this interval is greater than the upper bound of the given interval.
        * @param {yfiles.router.polyline.Interval} other the interval to compare.
        * @return {boolean} <code>true</code> if the current interval is right of the given one, <code>false</code> otherwise.
        */
        isGreaterThan(other:yfiles.router.polyline.Interval):boolean;
        /**
        * Returns a string representation of this interval.
        * @return {string} a string representation of this interval
        */
        toString():string;
        /**
        * Checks if this interval and the given interval cover about the same range.
        * <p>
        * The intervals are considered to cover the same range, if their minimum values as well as their maximum values differ
        * only in an epsilon value.
        * </p>
        * @param {yfiles.router.polyline.Interval} other the other interval
        * @return {boolean} <code>true</code> if the intervals cover the same range, <code>false</code> otherwise.
        */
        hasSameRange(other:yfiles.router.polyline.Interval):boolean;
        /**
        * Checks if this interval and the given interval cover the same range.
        * @param {yfiles.router.polyline.Interval} other the other interval
        * @param {number} eps The maximum distance between the two minimum and the two maximum values.
        * @return {boolean} <code>true</code> if the intervals cover the same range, <code>false</code> otherwise.
        */
        hasSameRangeWithOtherAndEps(other:yfiles.router.polyline.Interval,eps:number):boolean;
        /**
        * Checks if this interval equals the given interval.
        * <p>
        * Two intervals are equal if the have the same lower and upper bounds.
        * </p>
        * @param {Object} other the other interval
        * @return {boolean} <code>true</code> if this and the given interval are equal, <code>false</code> otherwise.
        */
        equals(other:Object):boolean;
        /**
        * Returns the hash code for this interval.
        * @return {number} the hash code for this interval.
        */
        hashCode():number;
      }
      var Interval:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new interval between the given bounds.
        * Determines automatically the upper and lower bound of the two
        * given values.
        * @param {number} bound1 the first interval bound
        * @param {number} bound2 the second interval bound
        */
        new (bound1:number,bound2:number):yfiles.router.polyline.Interval;
        /**
        * Returns the intersection of the given intervals.
        * <p>
        * The intersection is <code>null</code> if the given intervals do not intersect. Otherwise the intersection is
        * [maximum lower bounds, minimum upper bounds].
        * </p>
        * @param {yfiles.router.polyline.Interval} i1 the first interval
        * @param {yfiles.router.polyline.Interval} i2 the second interval
        * @return {yfiles.router.polyline.Interval} the intersection of the given intervals or <code>null</code> if the intervals do not intersect.
        */
        calculateIntersection(i1:yfiles.router.polyline.Interval,i2:yfiles.router.polyline.Interval):yfiles.router.polyline.Interval;
        /**
        * Returns the union of the given intervals.
        * <p>
        * The union is [minimum lower bounds, maximum upper bounds].
        * </p>
        * @param {yfiles.router.polyline.Interval} i1 the first interval
        * @param {yfiles.router.polyline.Interval} i2 the second interval
        * @return {yfiles.router.polyline.Interval} the union of the given intervals.
        */
        calculateUnionWithIntervalAndInterval(i1:yfiles.router.polyline.Interval,i2:yfiles.router.polyline.Interval):yfiles.router.polyline.Interval;
        /**
        * Returns the union of the given interval and the given value.
        * <p>
        * The union is between the
        * minimal of the lower bound of <code>interval</code> and <code>value</code> and the maximum of the upper bound of
        * <code>interval</code> and <code>value</code>.
        * </p>
        * @param {yfiles.router.polyline.Interval} interval the interval to extend
        * @param {number} value the value to be in the union
        * @return {yfiles.router.polyline.Interval} the union of the given interval and the given value.
        */
        calculateUnion(interval:yfiles.router.polyline.Interval,value:number):yfiles.router.polyline.Interval;
        /**
        * Returns the bridging interval between the given intervals.
        * <p>
        * The bridging interval is <code>null</code> if the given intervals intersect. Otherwise the bridging interval is
        * [minimum upper bounds, maximum lower bounds].
        * </p>
        * @param {yfiles.router.polyline.Interval} i1 the first interval
        * @param {yfiles.router.polyline.Interval} i2 the second interval
        * @return {yfiles.router.polyline.Interval} the bridging interval between the given intervals or <code>null</code> if the intervals intersect.
        */
        calculateBridge(i1:yfiles.router.polyline.Interval,i2:yfiles.router.polyline.Interval):yfiles.router.polyline.Interval;
        /**
        * Returns the spanning rectangle between the given intervals.
        * <p>
        * The first interval spans the rectangle in horizontal dimension, the second interval in vertical dimension.
        * </p>
        * @param {yfiles.router.polyline.Interval} horizontal the interval that defines the location and length of the rectangle in horizontal dimension
        * @param {yfiles.router.polyline.Interval} vertical the interval that defines the location and length of the rectangle in vertical dimension
        * @return {yfiles.algorithms.YRectangle} the spanning rectangle between the given intervals.
        */
        calculateSpanningRectangle(horizontal:yfiles.router.polyline.Interval,vertical:yfiles.router.polyline.Interval):yfiles.algorithms.YRectangle;
      };
      /**
      * Divides a rectangular area into one or more {@link yfiles.router.polyline.PartitionCell}s.
      * Partition cells have to be disjoint. The union of all partition cells covers the original area.
      */
      export interface IPartition extends Object{
        /**
        * Returns a list of all {@link yfiles.router.polyline.PartitionCell}s that are neighbors of the given cell, this means those cells have a
        * common border segment with the given cell.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell to get the neighbors for.
        * @return {yfiles.algorithms.IList} 
        * A list of {@link yfiles.router.polyline.PartitionCell}s that are neighbors of the given cell.
        * @see Specified by {@link yfiles.router.polyline.IPartition#getNeighbors}.
        */
        getNeighbors(cell:yfiles.router.polyline.PartitionCell):yfiles.algorithms.IList;
        /**
        * Returns a list of all {@link yfiles.router.polyline.PartitionCell}s that intersect or cover the given rectangle.
        * @param {yfiles.algorithms.YRectangle} rect The rectangular area to get (partially) covered cells for.
        * @return {yfiles.algorithms.IList} 
        * A list containing (partially) covered {@link yfiles.router.polyline.PartitionCell}s.
        * @see Specified by {@link yfiles.router.polyline.IPartition#getCells}.
        */
        getCells(rect:yfiles.algorithms.YRectangle):yfiles.algorithms.IList;
        /**
        * The rectangular area that is partitioned.
        * @see Specified by {@link yfiles.router.polyline.IPartition#bounds}.
        */
        bounds:yfiles.algorithms.YRectangle;
      }
      var IPartition:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      export interface PartitionCellKeysCompanion extends Object{
      }
      var PartitionCellKeysCompanion:{
        $class:yfiles.lang.Class;
        /**
        * The key references a {@link yfiles.algorithms.IList} of nodes whose bounds are covering a certain {@link yfiles.router.polyline.PartitionCell}.
        */
        NODES_KEY:Object;
        /**
        * The key references a {@link yfiles.algorithms.IList} of nodes being in node to edge distance to a certain {@link yfiles.router.polyline.PartitionCell}.
        */
        NODES_IN_NODE_TO_EDGE_DISTANCE_KEY:Object;
        /**
        * The key references a {@link yfiles.algorithms.IList} of {@link yfiles.layout.INodeLabelLayout}s covering a certain {@link yfiles.router.polyline.PartitionCell}.
        */
        NODE_LABEL_LAYOUTS_KEY:Object;
        /**
        * The key references a {@link yfiles.algorithms.IList} of {@link Number}s representing factors that are multiplied
        * with an edge's {@link yfiles.router.polyline.PenaltySettings#nodeLabelCrossingPenalty  node label crossing cost}s if the edge crosses
        * the corresponding {@link yfiles.layout.INodeLabelLayout} registered by the key {@link yfiles.router.polyline.PartitionCellKeysCompanion#NODE_LABEL_LAYOUTS_KEY}.
        */
        NODE_LABEL_CROSSING_COST_FACTORS_KEY:Object;
        /**
        * The key references a {@link yfiles.algorithms.IList} of {@link yfiles.layout.IEdgeLabelLayout}s covering a certain {@link yfiles.router.polyline.PartitionCell}.
        */
        EDGE_LABEL_LAYOUTS_KEY:Object;
        /**
        * The key references a {@link yfiles.algorithms.IList} of {@link Number}s representing factors that are multiplied
        * with an edge's {@link yfiles.router.polyline.PenaltySettings#edgeLabelCrossingPenalty  edge label crossing cost}s
        * if the edge crosses the corresponding {@link yfiles.layout.IEdgeLabelLayout} registered by the key {@link yfiles.router.polyline.PartitionCellKeysCompanion#EDGE_LABEL_LAYOUTS_KEY}.
        */
        EDGE_LABEL_CROSSING_COST_FACTORS_KEY:Object;
        /**
        * The key references the {@link yfiles.layout.PartitionCellId} of the partition grid cell covering
        * a certain {@link yfiles.router.polyline.PartitionCell}.
        */
        PARTITION_GRID_CELL_ID_KEY:Object;
        /**
        * The key references the row index of the partition grid cell covering a certain {@link yfiles.router.polyline.PartitionCell}.
        */
        PARTITION_GRID_ROW_INDEX_KEY:Object;
        /**
        * The key references the column index of the partition grid cell covering a certain {@link yfiles.router.polyline.PartitionCell}.
        */
        PARTITION_GRID_COLUMN_INDEX_KEY:Object;
      };
      /**
      * This interface defines keys to obtain additional information about a {@link yfiles.router.polyline.PartitionCell}.
      * Use {@link yfiles.router.polyline.PartitionCell#getData} to get the data associated to a given key for the current
      * partition cell.
      */
      export interface IPartitionCellKeys extends Object{
      }
      var IPartitionCellKeys:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      export interface DynamicDecompositionCompanion extends Object{
      }
      export module DynamicDecompositionCompanion{
        /**
        * Interface for classes that want to be notified about changes in partitions.
        * Implementations are notified when
        * {@link yfiles.router.polyline.PartitionCell}s are created, divided, and/or finalized.
        */
        export interface IListener extends Object{
          /**
          * Callback after a new {@link yfiles.router.polyline.PartitionCell} has been created.
          * @param {yfiles.router.polyline.PartitionCell} createdCell The newly created cell.
          * @see Specified by {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener#onCellCreated}.
          */
          onCellCreated(createdCell:yfiles.router.polyline.PartitionCell):void;
          /**
          * Callback after a {@link yfiles.router.polyline.PartitionCell} has been subdivided into several sub cells.
          * <p>
          * Listener may not modify the list of sub cells.
          * </p>
          * @param {yfiles.router.polyline.PartitionCell} cell The cell that has been subdivided.
          * @param {yfiles.algorithms.IList} subCells The new sub cells of the divided cell.
          * @see Specified by {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener#onCellSubdivided}.
          */
          onCellSubdivided(cell:yfiles.router.polyline.PartitionCell,subCells:yfiles.algorithms.IList):void;
          /**
          * Callback after a {@link yfiles.router.polyline.PartitionCell} has been decided to be final and won't be subdivided further.
          * @param {yfiles.router.polyline.PartitionCell} finalizedCell The cell that has been finalized.
          * @see Specified by {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener#onCellFinalized}.
          */
          onCellFinalized(finalizedCell:yfiles.router.polyline.PartitionCell):void;
        }
      }
      var DynamicDecompositionCompanion:{
        $class:yfiles.lang.Class;
      };
      /**
      * This interface should be implemented by classes that dispatch notifications about changes in partitions.
      * Interested
      * parties are notified when {@link yfiles.router.polyline.PartitionCell}s are created, divided, and/or finalized.
      * @see {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener}
      */
      export interface IDynamicDecomposition extends Object{
        /**
        * Adds the given listener to the {@link yfiles.router.polyline.IPartition}.
        * @param {yfiles.router.polyline.DynamicDecompositionCompanion.IListener} listener The listener that shall be notified upon dynamic decomposition events.
        * @see Specified by {@link yfiles.router.polyline.IDynamicDecomposition#addDynamicDecompositionListener}.
        */
        addDynamicDecompositionListener(listener:yfiles.router.polyline.DynamicDecompositionCompanion.IListener):void;
        /**
        * Removes the given listener from the {@link yfiles.router.polyline.IPartition}.
        * @param {yfiles.router.polyline.DynamicDecompositionCompanion.IListener} listener The listener that shall not be notified anymore upon dynamic decomposition events.
        * @see Specified by {@link yfiles.router.polyline.IDynamicDecomposition#removeDynamicDecompositionListener}.
        */
        removeDynamicDecompositionListener(listener:yfiles.router.polyline.DynamicDecompositionCompanion.IListener):void;
      }
      var IDynamicDecomposition:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Interface providing additional intervals to traverse from one {@link yfiles.router.polyline.PartitionCell} into an adjacent one.
      * <p>
      * To find a {@link yfiles.router.polyline.Path} for an edge, the {@link yfiles.router.polyline.PathSearch} algorithm traverses from the current partition cell to
      * an adjacent partition cell. By default, the orthogonal interval shared by these two cells is used. Implementations
      * of this interface may be added to the <code>PathSearch</code> to calculate additional enter intervals that might
      * accumulate lower costs for entering the adjacent cell.
      * </p>
      * @see {@link yfiles.router.polyline.PartitionCell}
      * @see {@link yfiles.router.polyline.PathSearch#addAdditionalEnterIntervalCalculator}
      */
      export interface IEnterIntervalCalculator extends Object{
        /**
        * Appends additional enter intervals for traversing from partition cell of <code>currentEntrance</code> to
        * <code>enteredCell</code> to the given list <code>enteredCell</code>.
        * @param {yfiles.router.polyline.CellEntrance} currentEntrance The current CellEntrance that is left.
        * @param {yfiles.router.polyline.PartitionCell} enteredCell The neighbor cell that shall be entered.
        * @param {yfiles.router.polyline.OrthogonalInterval} commonInterval The common interval of the left and entered partition cells.
        * @param {yfiles.algorithms.IList} allEnterIntervals The list to which additional enter intervals have to be appended.
        * @param {yfiles.router.polyline.PathSearchContext} context The context of the path search.
        * @see Specified by {@link yfiles.router.polyline.IEnterIntervalCalculator#appendEnterIntervals}.
        */
        appendEnterIntervals(currentEntrance:yfiles.router.polyline.CellEntrance,enteredCell:yfiles.router.polyline.PartitionCell,commonInterval:yfiles.router.polyline.OrthogonalInterval,allEnterIntervals:yfiles.algorithms.IList,context:yfiles.router.polyline.PathSearchContext):void;
      }
      var IEnterIntervalCalculator:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Implementations are extending the functionality of a {@link yfiles.router.polyline.GraphPartition}.
      * <p>
      * A <code>GraphPartitionExtension</code> can be used to {@link yfiles.router.polyline.GraphPartition#createObstacle  create}
      * new {@link yfiles.router.polyline.Obstacle}s that will be given to the initializer
      * of the {@link yfiles.router.polyline.IObstaclePartition} and react to its decomposition events if the {@link yfiles.router.polyline.IObstaclePartition} is
      * a {@link yfiles.router.polyline.IDynamicDecomposition}.
      * </p>
      * <p>
      * A <code>GraphPartitionExtension</code> has to be
      * {@link yfiles.router.polyline.GraphPartition#addDynamicDecompositionListener  added}
      * to the {@link yfiles.router.polyline.GraphPartition} which will call its {@link yfiles.router.polyline.IGraphPartitionExtension#preparePartition  preparePartition}
      * method before the <code>ObstaclePartition</code> is initialized.
      * </p>
      */
      export interface IGraphPartitionExtension extends Object,yfiles.router.polyline.DynamicDecompositionCompanion.IListener{
        /**
        * This method is called by the given {@link yfiles.router.polyline.GraphPartition} upon initialization before its
        * {@link yfiles.router.polyline.IObstaclePartition} gets initialized.
        * <p>
        * Implementations may use the given <code>graph</code> the {@link yfiles.router.polyline.GraphPartition} is based upon to initialize themselves
        * and/or {@link yfiles.router.polyline.GraphPartition#createObstacle  add obstacles} to the list
        * that {@link yfiles.router.polyline.IObstaclePartition} is initialized with.
        * </p>
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration used for the path search.
        * @param {yfiles.router.polyline.GraphPartition} graphPartition The graph partition using this extension.
        * @see Specified by {@link yfiles.router.polyline.IGraphPartitionExtension#preparePartition}.
        */
        preparePartition(configuration:yfiles.router.polyline.PathSearchConfiguration,graphPartition:yfiles.router.polyline.GraphPartition):void;
        /**
        * Cleans the extension up from the last partitioning with the current configuration and graphPartition.
        * @see Specified by {@link yfiles.router.polyline.IGraphPartitionExtension#cleanup}.
        */
        cleanup():void;
      }
      var IGraphPartitionExtension:{
        $class:yfiles.lang.Class;
        isInstance(o:Object):boolean;
      };
      /**
      * Describes where and from which direction a {@link yfiles.router.polyline.PartitionCell} has been entered during a path search.
      * The path to reach the cell can be reconstructed by traversing the {@link yfiles.router.polyline.CellEntrance#previousEntrance  previous entrances}.
      * The {@link yfiles.router.polyline.CellEntrance#enterInterval  enter interval} and {@link yfiles.router.polyline.CellEntrance#enterDirection  enter direction} determine how the
      * cell was entered.
      */
      export interface CellEntrance extends Object{
        toString():string;
        /**
        * This entrance's partition cell.
        */
        cell:yfiles.router.polyline.PartitionCell;
        /**
        * The previous{@link yfiles.router.polyline.CellEntrance} in the path that reached this cell.
        */
        previousEntrance:yfiles.router.polyline.CellEntrance;
        /**
        * The{@link yfiles.router.polyline.OrthogonalInterval} that was used to enter this cell.
        */
        enterInterval:yfiles.router.polyline.OrthogonalInterval;
        /**
        * The direction from which this cell was entered.
        */
        enterDirection:yfiles.layout.Direction;
        /**
        * The costs for the implicit path given by the{@link yfiles.router.polyline.CellEntrance#previousEntrance  previous entrances}.
        */
        costs:number;
        heuristicCosts:number;
        /**
        * The{@link yfiles.router.polyline.EdgeCellInfo} describing how the previous cell was crossed.
        */
        previousEdgeCellInfo:yfiles.router.polyline.EdgeCellInfo;
      }
      var CellEntrance:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        * @param {yfiles.router.polyline.PartitionCell} cell The entered partition cell.
        */
        new (cell:yfiles.router.polyline.PartitionCell):yfiles.router.polyline.CellEntrance;
        /**
        * Creates a copy of the given <code>CellEntrance</code>.
        * @param {yfiles.router.polyline.CellEntrance} other the <code>CellEntrance</code>, of which a copy is to be made
        */
        FromCellEntrance:{
          new (other:yfiles.router.polyline.CellEntrance):yfiles.router.polyline.CellEntrance;
        };
      };
      /**
      * Stores information about the part of an edge segment that lies inside a specified {@link yfiles.router.polyline.PartitionCell}.
      */
      export interface CellSegmentInfo extends yfiles.router.polyline.AbstractSegmentInfo{
        /**
        * The direction this segment part points to.
        * @see Overrides {@link yfiles.router.polyline.AbstractSegmentInfo#direction}
        */
        direction:yfiles.layout.Direction;
        /**
        * The partition cell this part of the edge segment lies in.
        */
        cell:yfiles.router.polyline.PartitionCell;
      }
      var CellSegmentInfo:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        * @param {yfiles.algorithms.Edge} edge The edge the segment of this info belongs to.
        * @param {number} segmentIndex The index of the segment this info belongs to.
        * @param {yfiles.layout.Direction} direction The direction the segment points to.
        * @param {yfiles.router.polyline.Interval} locationRange The range the common location of this segment has to be inside.
        * @param {yfiles.router.polyline.Interval} minExtension The minimal interval in extension direction this segment part is known to intersect.
        * @param {yfiles.router.polyline.Interval} maxExtension The maximum interval in extension direction this segment part will span.
        * @param {yfiles.router.polyline.PartitionCell} cell The partition cell this part of the edge segment lies inside.
        */
        new (edge:yfiles.algorithms.Edge,segmentIndex:number,direction:yfiles.layout.Direction,locationRange:yfiles.router.polyline.Interval,minExtension:yfiles.router.polyline.Interval,maxExtension:yfiles.router.polyline.Interval,cell:yfiles.router.polyline.PartitionCell):yfiles.router.polyline.CellSegmentInfo;
      };
      /**
      * Routes edges using their pre-calculated {@link yfiles.router.polyline.Path} information.
      * <p>
      * {@link yfiles.router.polyline.ChannelBasedPathRouting#initialize  Initialize} must be called before the edges can be
      * {@link yfiles.router.polyline.ChannelBasedPathRouting#route  route}d.
      * </p>
      * <p>
      * The basic approach of this router is to bundle edge {@link yfiles.router.polyline.SegmentInfo  segment}s into so-called {@link yfiles.router.polyline.Channel}s
      * and route each channel individually.
      * </p>
      * @see {@link yfiles.router.polyline.EdgeInfo#getSegmentInfo}
      * @see {@link yfiles.layout.LayoutGraph#setPathWithPointList}
      */
      export interface ChannelBasedPathRouting extends Object{
        /**
        * Initializes this class for routing paths that were found with the given <code>configuration</code>.
        * Must be called
        * before {@link yfiles.router.polyline.ChannelBasedPathRouting#route}.
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration to use for the following path routings.
        * @see {@link yfiles.router.polyline.ChannelBasedPathRouting#route}
        */
        initialize(configuration:yfiles.router.polyline.PathSearchConfiguration):void;
        /**
        * Resets all channel information and the reference to the PathSearchConfiguration.
        * So,
        * <code>ChannelBasedPathRouting</code> is ready to calculate paths for a new layout.
        */
        cleanup():void;
        /**
        * The configuration this class was initialized with.
        * @see {@link yfiles.router.polyline.ChannelBasedPathRouting#initialize}
        */
        configuration:yfiles.router.polyline.PathSearchConfiguration;
        /**
        * Routes the given edges.
        * {@link yfiles.router.polyline.ChannelBasedPathRouting#initialize} must be called first.
        * <p>
        * As a first step, the {@link yfiles.router.polyline.SegmentInfo}s of all edge paths are distributed to {@link yfiles.router.polyline.Channel}s.
        * After that, the segments in each of these <code>Channel</code>s are sorted and locations are assigned respecting
        * the segment's location ranges by calling the subsequent methods:
        * <ul>
        * <li>{@link yfiles.router.polyline.ChannelBasedPathRouting#optimizeSegmentOrder}</li>
        * <li>{@link yfiles.router.polyline.ChannelBasedPathRouting#calculateSegmentLocations}</li>
        * <li>{@link yfiles.router.polyline.ChannelBasedPathRouting#adjustSegmentLocations}</li>
        * </ul>
        * </p>
        * <p>
        * Finally the control points for the paths are calculated.
        * </p>
        * @param {yfiles.algorithms.EdgeList} edges The edges to route.
        * @param {yfiles.router.polyline.PathSearchResult} pathSearchResult The path search results containing the <code>Path</code> objects for the edges.
        * @see {@link yfiles.router.polyline.PathSearchResult#getPath}
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#locationRange}
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#location}
        * @throws {yfiles.system.InvalidOperationException} If the locations are not inside of the segment's location range.
        */
        route(edges:yfiles.algorithms.EdgeList,pathSearchResult:yfiles.router.polyline.PathSearchResult):void;
        /**
        * Creates a comparator for {@link yfiles.router.polyline.SegmentInfo}s that can be used to sort the segment infos in a {@link yfiles.router.polyline.Channel} from
        * left to right (for vertical segments) or top to bottom (for horizontal segments), respectively.
        * @param {yfiles.algorithms.YList} channels The channels this comparator will be used for later.
        * @param {yfiles.router.polyline.PathSearchResult} pathSearchResult 
        * The path search result containing the {@link yfiles.router.polyline.EdgeInfo}s with the <code>SegmentInfo</code>s
        * this comparator that will be used for later.
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration used during this path search.
        * @return {yfiles.objectcollections.IComparer} 
        * A comparator for <code>SegmentInfo</code>s that can be used to sort the segment infos in a
        * <code>Channel</code>.
        */
        createSegmentInfoComparator(channels:yfiles.algorithms.YList,pathSearchResult:yfiles.router.polyline.PathSearchResult,configuration:yfiles.router.polyline.PathSearchConfiguration):yfiles.objectcollections.IComparer;
        /**
        * Sorts the given list of SegmentInfos using the given comparator.
        * @param {yfiles.algorithms.IList} segmentInfos The list of SegmentInfos to sort.
        * @param {yfiles.objectcollections.IComparer} segmentInfoComparator The comparator to use for the sorting.
        */
        sortSegmentInfos(segmentInfos:yfiles.algorithms.IList,segmentInfoComparator:yfiles.objectcollections.IComparer):void;
        /**
        * Optimizes the order of the segments in the given channel.
        * <p>
        * After the segments in the channel have been sorted using the
        * {@link yfiles.router.polyline.ChannelBasedPathRouting#createSegmentInfoComparator  segment info comparator},
        * segment infos having a common {@link yfiles.router.polyline.SegmentGroup} are replaced by their common
        * {@link yfiles.router.polyline.SegmentGroup#commonSegmentInfo  representative segment info}.
        * </p>
        * This method further improves the order of the resulting segment info list is to make sure that the subsequent
        * {@link yfiles.router.polyline.ChannelBasedPathRouting#calculateSegmentLocations  location calculation} is able to respect the segment infos
        * {@link yfiles.router.polyline.AbstractSegmentInfo#locationRange  location ranges} and if possible the
        * minimal edge to edge distances and possible grid constraints for the segments.
        * @param {yfiles.router.polyline.Channel} channel The channel to optimize the segment info order for.
        */
        optimizeSegmentOrder(channel:yfiles.router.polyline.Channel):void;
        /**
        * Calculates locations for the segment infos in the given channel.
        * <p>
        * <b>Precondition:</b> The locations of the segments are {@link yfiles.router.polyline.Channel#setCurrentLocation stored} in the Channel. They should respect minimal edge to edge distances and grid constraints and must lie in the
        * respective {@link yfiles.router.polyline.AbstractSegmentInfo#locationRange  location range}s.
        * </p>
        * @param {yfiles.router.polyline.Channel} channel The channel to calculate locations for the segment infos for.
        * @see {@link yfiles.router.polyline.Channel#setCurrentLocation}
        */
        calculateSegmentLocations(channel:yfiles.router.polyline.Channel):void;
        /**
        * Tries to adjust the location set for a segment info in the channel to consider the preferred alignment of the
        * segment.
        * This method is called after the segments have been distributed in the channel but before the final
        * locations of the segments are assigned to the segment infos.
        * @param {yfiles.router.polyline.Channel} channel The channel of the segment infos to consider the alignments for.
        * @see {@link yfiles.router.polyline.Channel#getCurrentLocation}
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#preferredAlignment}
        */
        adjustSegmentLocations(channel:yfiles.router.polyline.Channel):void;
      }
      var ChannelBasedPathRouting:{
        $class:yfiles.lang.Class;
        /**
        * Initializes a new instance of the ChannelBasedPathRouting class.
        */
        new ():yfiles.router.polyline.ChannelBasedPathRouting;
      };
      /**
      * A channel is a set of vertical or horizontal edge segments whose locations depend on each other.
      * Channels are used
      * by the {@link yfiles.router.polyline.ChannelBasedPathRouting} to route edges using {@link yfiles.router.polyline.SegmentInfo}s describing their path.
      */
      export interface Channel extends Object{
        /**
        * Adds a new segment info to the channel.
        * @param {yfiles.router.polyline.SegmentInfo} segment The segment info to add to this channel.
        * @throws {yfiles.system.ArgumentException} 
        * If the given segment has a different orientation then the segments already
        * contained in the channel.
        */
        addSegment(segment:yfiles.router.polyline.SegmentInfo):void;
        /**
        * An interval spanning the union of the segment infos' location ranges.
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#locationRange}
        */
        widthInterval:yfiles.router.polyline.Interval;
        /**
        * An interval spanning the union of the segment infos' maximum extension.
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#maxExtension}
        */
        lengthInterval:yfiles.router.polyline.Interval;
        /**
        * Returns the number of segment infos in this channel.
        * @return {number} The number of segment infos in this channel.
        */
        segmentCount():number;
        /**
        * Determines whether or not the segments in this channel are vertical.
        */
        vertical:boolean;
        /**
        * Returns the SegmentInfo with the given index in the segments list.
        * @param {number} index The index of the segment in the list.
        * @return {yfiles.router.polyline.SegmentInfo} The SegmentInfo with the given index in the segments list.
        */
        getSegment(index:number):yfiles.router.polyline.SegmentInfo;
        /**
        * Returns the number of segment groups in this channel.
        * @return {number} the number of segment groups in this channel
        */
        segmentGroupCount():number;
        /**
        * Adds a segment group to this channel.
        * @param {yfiles.router.polyline.SegmentGroup} group segment group to add
        */
        addSegmentGroup(group:yfiles.router.polyline.SegmentGroup):void;
        /**
        * Returns the segment group with the given index of this channel.
        * @param {number} index index of the segment group to return
        * @return {yfiles.router.polyline.SegmentGroup} the segment group with the given index of this channel
        */
        getSegmentGroup(index:number):yfiles.router.polyline.SegmentGroup;
        /**
        * Returns the current location the given {@link yfiles.router.polyline.SegmentInfo} is assigned inside its {@link yfiles.router.polyline.AbstractSegmentInfo#locationRange  location range}.
        * @param {yfiles.router.polyline.SegmentInfo} segmentInfo The segmentInfo to return the current location for.
        * @return {number} The current location of the segment info or <code>Double.NaN</code> if no location was set before.
        */
        getCurrentLocation(segmentInfo:yfiles.router.polyline.SegmentInfo):number;
        /**
        * Sets the current location the given {@link yfiles.router.polyline.SegmentInfo} is assigned inside its {@link yfiles.router.polyline.AbstractSegmentInfo#locationRange  location range}.
        * <p>
        * During the distribution of the segments in the channel, different locations can be assigned and only the last one
        * is finally set at the segment info.
        * </p>
        * @param {yfiles.router.polyline.SegmentInfo} segmentInfo The segment info to set the current location for.
        * @param {number} location The current location of the segment info in its location range.
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#location}
        */
        setCurrentLocation(segmentInfo:yfiles.router.polyline.SegmentInfo,location:number):void;
        /**
        * The bounds of this channel.
        * These bounds are determined by the channel's {@link yfiles.router.polyline.Channel#widthInterval  width}
        * and {@link yfiles.router.polyline.Channel#lengthInterval  length}.
        * @see {@link yfiles.router.polyline.Channel#widthInterval}
        * @see {@link yfiles.router.polyline.Channel#lengthInterval}
        */
        bounds:yfiles.algorithms.YRectangle;
        toString():string;
      }
      var Channel:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new channel containing the given segment info.
        * @param {yfiles.router.polyline.SegmentInfo} segment The segment info the channel shall be created for.
        */
        new (segment:yfiles.router.polyline.SegmentInfo):yfiles.router.polyline.Channel;
      };
      /**
      * Stores location information for orthogonal edge segments.
      * <p>
      * Most notably, AbstractSegmentInfo stores direction, segment points and intervals describing possible location and extension of a segment.
      * </p>
      */
      export interface AbstractSegmentInfo extends Object{
        toString():string;
        /**
        * The minimal known extension of the segment, that is the minimal interval this segment will cover in any case.
        * <p>
        * For horizontal intervals, this is the minimal horizontal extension; for vertical intervals, this is the minimal
        * vertical extension.
        * </p>
        */
        minExtension:yfiles.router.polyline.Interval;
        /**
        * The maximum extension this segment will stretch.
        * <p>
        * For horizontal intervals, this is the maximum horizontal extension; for vertical intervals, this is the maximum
        * vertical extension.
        * </p>
        */
        maxExtension:yfiles.router.polyline.Interval;
        /**
        * The range, the location of the segment shall be placed in.
        * <p>
        * For horizontal segments, this is the range containing the vertical location; for vertical segment this is the
        * range containing the horizontal location.
        * </p>
        */
        locationRange:yfiles.router.polyline.Interval;
        /**
        * Specifies whether this segment prefers to be placed close to the{@link yfiles.router.polyline.Alignment#MIN  lower bound}, {@link yfiles.router.polyline.Alignment#MAX  upper bound} or {@link yfiles.router.polyline.Alignment#ANY  somewhere} of its location range.
        * @see {@link yfiles.router.polyline.Alignment#MIN}
        * @see {@link yfiles.router.polyline.Alignment#MAX}
        * @see {@link yfiles.router.polyline.Alignment#ANY}
        * @see {@link yfiles.router.polyline.Alignment#MIN}
        * @see {@link yfiles.router.polyline.Alignment#MAX}
        * @see {@link yfiles.router.polyline.Alignment#ANY}
        */
        preferredAlignment:yfiles.router.polyline.Alignment;
        /**
        * The fixed location inside the{@link yfiles.router.polyline.AbstractSegmentInfo#locationRange  location range} that has been set before.
        * <b>Setter:</b>This location has to be inside the segment infos location range.
        * <b>Getter:</b><p>
        * For horizontal segments, this is the vertical location; for vertical segments, this is the horizontal location.
        * </p>
        * @throws {yfiles.lang.Exception} If the segment info already has a fixed location.
        * @throws {yfiles.system.ArgumentException} If the given location isn't inside the location range.
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#fixed}
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#locationRange}
        */
        location:number;
        /**
        * Determines whether or not this segment info is fixed, that means a fixed location has been determined inside its
        * {@link yfiles.router.polyline.AbstractSegmentInfo#locationRange  location range}.
        */
        fixed:boolean;
        /**
        * Determines whether or not the associated segment is vertical.
        */
        vertical:boolean;
        /**
        * The direction the segment of this info points to.
        */
        direction:yfiles.layout.Direction;
        /**
        * The edge this segment info belongs to.
        */
        edge:yfiles.algorithms.Edge;
        /**
        * The index of this info's segment.
        */
        segmentIndex:number;
        /**
        * The segment group this segment info belongs to or <code>null</code> if this segment info doesn't belong
        * to any group.
        * @see {@link yfiles.router.polyline.SegmentGroup#commonLocationRange}
        */
        segmentGroup:yfiles.router.polyline.SegmentGroup;
      }
      var AbstractSegmentInfo:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance for the segment.
        * @param {yfiles.algorithms.Edge} edge The edge the segment of this info belongs to.
        * @param {number} segmentIndex The index of the segment this info belongs to.
        * @param {yfiles.layout.Direction} direction The direction the segment points to.
        * @param {yfiles.router.polyline.Interval} locationRange The range the common location of this segment has to be inside.
        * @param {yfiles.router.polyline.Interval} minExtension The minimal interval in extension direction this segment is known to intersect.
        * @param {yfiles.router.polyline.Interval} maxExtension The maximum interval in extension direction this segment will span.
        */
        new (edge:yfiles.algorithms.Edge,segmentIndex:number,direction:yfiles.layout.Direction,locationRange:yfiles.router.polyline.Interval,minExtension:yfiles.router.polyline.Interval,maxExtension:yfiles.router.polyline.Interval):yfiles.router.polyline.AbstractSegmentInfo;
        /**
        * Creates a new instance using a line segment to describe the edge segment.
        * <p>
        * This constructor is meant to be used for fixed orthogonal edge segments.
        * </p>
        * @param {yfiles.algorithms.Edge} edge The edge this segment info belongs to.
        * @param {number} segmentNo The number of the segment this info belongs to.
        * @param {yfiles.algorithms.LineSegment} segment A line segment describing the edge segment.
        */
        FromLineSegment:{
          new (edge:yfiles.algorithms.Edge,segmentNo:number,segment:yfiles.algorithms.LineSegment):yfiles.router.polyline.AbstractSegmentInfo;
        };
      };
      /**
      * This class is used by {@link yfiles.router.polyline.EdgeRouter} to determine the routing details of the graph's edges.
      * @see {@link yfiles.router.polyline.EdgeRouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      */
      export interface EdgeLayoutDescriptor extends Object{
        /**
        * The minimal length of the first segment (at the source).
        * <b>Setter:</b>By default this value is set to <code>5.0</code>. The
        * value must be <code> &gt;= 0</code>, otherwise the default value will be assigned.
        * <p>
        * Note: the resulting segment length also depends on the given {@link yfiles.router.polyline.Grid#spacing 
        *  grid
        * spacing
        * }, i.e., <code>segment length &gt;= (int) Math.ceil(length / grid spacing)</code>.
        * </p>
        * <p>
        * Note: the first segment length starts, if present, at the halo of the source.
        * </p>
        * <b>Getter:</b>Default is <code>5.0</code>.
        * <p>
        * Note: the first segment length starts, if present, at the halo of the source.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalLastSegmentLength}
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalLastSegmentLength}
        */
        minimalFirstSegmentLength:number;
        /**
        * The minimal length of the last segment (at the target).
        * <b>Setter:</b>By default this value is set to <code>10.0</code>. The
        * value must be <code> &gt;= 0</code>, otherwise the default value will be assigned.
        * <p>
        * Note: the resulting segment length also depends on the given {@link yfiles.router.polyline.Grid#spacing 
        *  grid
        * spacing
        * }, i.e., <code>segment length &gt;= (int) Math.ceil(length / grid spacing)</code>.
        * </p>
        * <p>
        * Note: the last segment length ends, if present, at the halo of the target.
        * </p>
        * <b>Getter:</b>Default is <code>10.0</code>.
        * <p>
        * Note: the last segment length ends, if present, at the halo of the target.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalFirstSegmentLength}
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalFirstSegmentLength}
        */
        minimalLastSegmentLength:number;
        /**
        * The minimal distance between a pair of edges.
        * <b>Getter:</b>Default is <code>3.0</code>.
        * <b>Setter:</b>By default this value is set to <code>3.0</code>.The value must
        * be <code> &gt;= 0</code>, otherwise the default value will be assigned.
        */
        minimalEdgeToEdgeDistance:number;
        /**
        * The minimal distance the edge shall keep from node corners when entering or leaving the node.
        * <b>Getter:</b>Default is
        * <code>3.0</code>.
        * <b>Setter:</b>By default this
        * value is set to <code>3.0</code>. The value must be <code> &gt;= 0</code>, otherwise the default value will be
        * assigned.
        */
        minimalNodeCornerDistance:number;
        /**
        * The monotonic path restrictions for this edge.
        * The edge can be used with one of the following values:
        * {@link yfiles.router.MonotonicPathRestriction#HORIZONTAL}, {@link yfiles.router.MonotonicPathRestriction#VERTICAL}, {@link yfiles.router.MonotonicPathRestriction#BOTH}, or {@link yfiles.router.MonotonicPathRestriction#NONE}.
        * Default is {@link yfiles.router.MonotonicPathRestriction#NONE}.
        */
        monotonicPathRestriction:yfiles.router.MonotonicPathRestriction;
        /**
        * The penalty settings that should be used for this edge.
        * Besides specifying a completely customized setting, the user can choose
        * between four predefined optimization strategies: {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_BALANCED},
        * {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_EDGE_BENDS}, {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_EDGE_CROSSINGS}
        * and {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_EDGE_LENGTHS}.
        * @see {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_BALANCED}
        * @see {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_EDGE_BENDS}
        * @see {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_EDGE_CROSSINGS}
        * @see {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_EDGE_LENGTHS}
        */
        penaltySettings:yfiles.router.polyline.PenaltySettings;
        /**
        * Creates a copy of this instance.
        * @return {yfiles.router.polyline.EdgeLayoutDescriptor} the copy.
        */
        createCopy():yfiles.router.polyline.EdgeLayoutDescriptor;
      }
      var EdgeLayoutDescriptor:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance of an EdgeLayoutDescriptor using the
        * default values.
        */
        new ():yfiles.router.polyline.EdgeLayoutDescriptor;
      };
      /**
      * This class represents a polyline edge router which calculates an edge layout containing only straight segments.
      * The router does not change the location or the size of the nodes in a diagram in any way.
      * <p>
      * <h3>Features</h3>
      * Edges can be routed orthogonally, i.e. only horizontal and vertical segments, or with additional segments with
      * other slopes.
      * <center>
      * <img src="doc-files/y.layout.router.polyline.EdgeRouter.orthogonal.gif" border="1" vspace="10" hspace="10"/>
      * <img src="doc-files/y.layout.router.polyline.EdgeRouter.polyline.gif" border="1" vspace="10" hspace="10"/> <br/>
      * Fig. 1: The same graph with orthogonal (left) and polylinear (right) edge routing.
      * </center>
      * Polyline routing can be activated using {@link yfiles.router.polyline.EdgeRouter#polylineRouting}.
      * </p>
      * <p>
      * In both routing styles, edges can be grouped so they share common segments in the beginning or end of their routes.
      * <center>
      * <img src="doc-files/y.layout.router.polyline.EdgeRouter.polyline_edge_groups.gif" border="1" vspace="20" hspace="20"/> <br/>
      * Fig. 2: Same graph as in Fig. 1 with grouped edges.
      * </center>
      * Edges are marked as grouped by using the data provider keys
      * {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY} (for source grouped edges) or {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY} (for target grouped edges).
      * </p>
      * <p>
      * Many settings of the edge layout can be controlled individually for every edge using {@link yfiles.router.polyline.EdgeLayoutDescriptor}
      * instances. So, if at the time of the invocation a {@link yfiles.algorithms.IDataProvider} instance is bound to the graph using the
      * {@link yfiles.router.polyline.EdgeRouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY} key, the <code>EdgeLayoutDescriptor</code>s provided for the individual edges
      * are used. Whenever no descriptor is provided for an edge, a default edge layout descriptor is used as fall-back
      * value. This edge layout descriptor can be obtained with {@link yfiles.router.polyline.EdgeRouter#defaultEdgeLayoutDescriptor}.
      * </p>
      * <p>
      * EdgeRouter supports two approaches to connect edges on a specific side or even an exact location to a node.
      * {@link yfiles.layout.PortConstraint}s define a single constraint for the ports of an edge. To realize more complex port
      * restrictions, several {@link yfiles.layout.PortCandidate}s or {@link yfiles.layout.PortCandidateSet}s can be assigned to edges
      * or nodes.
      * If an edge with registered <code>PortCandidate</code>s connects to nodes with <code>PortCandidateSet</code>s,
      * the layouter
      * will try to match both collections to find an appropriate port. In case there is no matching port candidate, a
      * <code>PortCandidate</code> specified for the edge is preferred.
      * Since their simultaneous existence at the same node may be ambiguous, it is not recommended to use a combination of
      * <code>PortConstraint</code>s and <code>PortCandidate</code>s in the same layout.
      * </p>
      * <p>
      * <h3>Concept</h3>
      * {@link yfiles.router.polyline.EdgeRouter} coordinates all settings and steps that are needed to achieve a
      * polylinear or orthogonal edge routing. 
      * There are three steps that are executed in the following order:
      * <ul>
      * <li>Dividing the graph's area into several rectangular cells (see: {@link yfiles.router.polyline.IPartition},
      * {@link yfiles.router.polyline.GraphPartition}, {@link yfiles.router.polyline.PartitionCell}).
      * </li>
      * <li>Finding the shortest/cheapest paths for all edges through the <code>Partition</code> (see: {@link yfiles.router.polyline.PathSearch}, {@link yfiles.router.polyline.Path}).
      * </li>
      * <li>Assigning coordinates to the edges' segments based on the paths that were calculated before (see: {@link yfiles.router.polyline.ChannelBasedPathRouting}).
      * </li>
      * </ul>
      * It is possible to customize the first two steps by adding extensions {@link yfiles.router.polyline.EdgeRouter#registeredPartitionExtensions 
      *  for
      * Partition
      * } or {@link yfiles.router.polyline.EdgeRouter#registeredPathSearchExtensions  for PathSearch}, respectively. 
      * {@link yfiles.router.polyline.IGraphPartitionExtension}s add obstacles which the <code>PathSearch</code> will
      * consider. They also can add some information to <code>PartitionCells</code> that, for example, specifies whether or
      * not the <code>PartitionCell</code> belongs to a node. 
      * {@link yfiles.router.polyline.PathSearchExtension PathSearchExtension}s influence the
      * <code>PathSearch</code> by adding costs for traversing specified <code>PartitionCells</code> or narrowing their
      * intervals to allow a less expensive traversal of a <code>PartitionCell</code>. For example, the
      * <code>PathSearch</code> adds costs to a <code>PartitionCell</code> that was marked as an obstacle that belongs to a
      * node, so the edge will avoid the node.
      * </p>
      */
      export interface EdgeRouter extends yfiles.layout.AbstractLayoutStage{
        /**
        * The time limit (in milliseconds) set for the layout algorithm.
        * <p>
        * Note that restricting the maximum duration
        * may result in a worse layout quality. Furthermore, the actual runtime may exceed the maximum duration since the
        * layout algorithm still has to find a valid solution.
        * </p>
        * <p>
        * By default no time limit is set.
        * </p>
        */
        maximumDuration:number;
        /**
        * The{@link yfiles.router.polyline.EdgeLayoutDescriptor} instance used for all those edges, that do not have a specific
        * layout descriptor assigned.
        * @see {@link yfiles.router.polyline.EdgeRouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
        */
        defaultEdgeLayoutDescriptor:yfiles.router.polyline.EdgeLayoutDescriptor;
        /**
        * Returns the {@link yfiles.router.polyline.EdgeLayoutDescriptor} provided by the {@link yfiles.algorithms.IDataProvider} with the key
        * {@link yfiles.router.polyline.EdgeRouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY} for the given edge.
        * <p>
        * For all those edges, that do not have a specific layout descriptor assigned, the default descriptor is returned.
        * </p>
        * @param {yfiles.algorithms.Edge} edge The edge to return the layout descriptor for.
        * @return {yfiles.router.polyline.EdgeLayoutDescriptor} The layout descriptor used for the given edge.
        * @see {@link yfiles.router.polyline.EdgeRouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
        * @see {@link yfiles.router.polyline.EdgeRouter#defaultEdgeLayoutDescriptor}
        */
        getEdgeLayoutDescriptor(edge:yfiles.algorithms.Edge):yfiles.router.polyline.EdgeLayoutDescriptor;
        /**
        * Determines whether or not this edge router creates (non-orthogonal) polyline segments.
        * <p>
        * By default polyline edge routing is disabled.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#preferredPolylineSegmentLength}
        * @see {@link yfiles.router.polyline.EdgeRouter#maximumPolylineSegmentRatio}
        * @see {@link yfiles.router.polyline.EdgeRouter#preferredPolylineSegmentLength}
        * @see {@link yfiles.router.polyline.EdgeRouter#maximumPolylineSegmentRatio}
        */
        polylineRouting:boolean;
        /**
        * The preferred length of (non-orthogonal) polyline segments.
        * <p>
        * Note that this restriction isn't used for orthogonal segments.
        * </p>
        * <p>
        * By default the preferred polyline segment length is 30.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#polylineRouting}
        * @see {@link yfiles.router.polyline.EdgeRouter#maximumPolylineSegmentRatio}
        * @see {@link yfiles.router.polyline.EdgeRouter#polylineRouting}
        * @see {@link yfiles.router.polyline.EdgeRouter#maximumPolylineSegmentRatio}
        */
        preferredPolylineSegmentLength:number;
        /**
        * The maximum segment length ratio at each end of an orthogonal segment that may get converted into a
        * (non-orthogonal) polyline segment.
        * <p>
        * By default the maximum ratio for polyline segments is 0.3.
        * </p>
        */
        maximumPolylineSegmentRatio:number;
        /**
        * Determines whether or not the edge router uses an additional step to reroute those edges that are considered to
        * have the worst paths.
        * <p>
        * Rerouting is only used, if the {@link yfiles.router.polyline.EdgeRouter#maximumDuration} isn't exceeded, yet.
        * </p>
        * <p>
        * By default rerouting is disabled.
        * </p>
        */
        rerouting:boolean;
        /**
        * The currently set sphere of action specifier.
        * Default setting is {@link yfiles.router.SphereOfAction#ROUTE_ALL_EDGES}.
        * @see {@link yfiles.router.polyline.EdgeRouter#selectedEdgesDpKey}
        * @throws {yfiles.system.ArgumentException} if the given argument is not one of the above constants.
        * @see {@link yfiles.router.SphereOfAction#ROUTE_ALL_EDGES}
        * @see {@link yfiles.router.SphereOfAction#ROUTE_SELECTED_EDGES}
        * @see {@link yfiles.router.SphereOfAction#ROUTE_EDGES_AT_SELECTED_NODES}
        */
        sphereOfAction:yfiles.router.SphereOfAction;
        /**
        * The data provider key used to look up the selected state of the nodes of the graph to be laid out.
        * By default, {@link yfiles.layout.LayouterKeys#SELECTED_NODES_DP_KEY} is used.
        * <p>
        * If the sphere of action is set to {@link yfiles.router.SphereOfAction#ROUTE_EDGES_AT_SELECTED_NODES}, only edges of selected nodes are routed while all
        * other edges are considered to have fixed routes.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#sphereOfAction}
        * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
        * @see {@link yfiles.router.polyline.EdgeRouter#sphereOfAction}
        */
        selectedNodesDpKey:Object;
        /**
        * The data provider key used to look up the selected state of the edges of the graph to be laid out.
        * By default, {@link yfiles.layout.LayouterKeys#SELECTED_EDGES_DP_KEY} is used.
        * <p>
        * If the sphere of action is set to {@link yfiles.router.SphereOfAction#ROUTE_SELECTED_EDGES}, only the selected keys are routed while all
        * other edges are considered to have fixed routes.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#sphereOfAction}
        * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
        * @see {@link yfiles.router.polyline.EdgeRouter#sphereOfAction}
        */
        selectedEdgesDpKey:Object;
        /**
        * A custom{@link yfiles.objectcollections.IComparer} used to sort the edges of the graph to determine the processing order
        * of the edges.
        * <p>
        * The processing order may influence the quality of the individual edge paths. When routing an edge, only the paths
        * of already routed edges and fixed edges (that are not routed at all) can be considered. Therefore earlier edges
        * have to consider less other edge paths then later edges which might have to use less optimal alternative paths.
        * </p>
        * <p>
        * The default is <code>null</code> and the comparator returned by {@link yfiles.router.polyline.EdgeRouter#createDefaultEdgeOrderComparator}
        * is used.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#createDefaultEdgeOrderComparator}
        * @see {@link yfiles.router.polyline.EdgeRouter#createDefaultEdgeOrderComparator}
        */
        edgeOrderComparator:yfiles.objectcollections.IComparer;
        /**
        * Returns <code>true</code> iff the given graph can be laid
        * out by this algorithm.
        * Calling <code>doLayout</code> with
        * the given graph as its argument will only success if
        * this method returns <code>true</code>.
        * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
        */
        canLayout(graph:yfiles.layout.LayoutGraph):boolean;
        /**
        * Utility method that returns the selection state of the given edge.
        * <p>
        * If the sphere of action is {@link yfiles.router.SphereOfAction#ROUTE_ALL_EDGES}, <code>true</code> is returned for all edges.
        * </p>
        */
        isSelected(e:yfiles.algorithms.Edge,graph:yfiles.algorithms.Graph):boolean;
        /**
        * Determines whether or not this edge router considers node labels as obstacles for edge routes.
        * <p>
        * By default node labels are not considered.
        * </p>
        * @see {@link yfiles.router.polyline.PenaltySettings#nodeLabelCrossingPenalty}
        * @see {@link yfiles.router.polyline.PenaltySettings#nodeLabelCrossingPenalty}
        */
        considerNodeLabels:boolean;
        /**
        * Determines whether or not this edge router ignores node labels that are inside the bounds of their owner
        * as obstacles for edge routes.
        * <p>
        * This setting has only an effect if node labels shall be {@link yfiles.router.polyline.EdgeRouter#considerNodeLabels  considered} at all
        * and is especially useful to ignore inner node labels of group nodes.
        * </p>
        * <p>
        * Per default, this option is disabled.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#considerNodeLabels}
        * @see {@link yfiles.router.polyline.PenaltySettings#nodeLabelCrossingPenalty}
        * @see {@link yfiles.router.polyline.EdgeRouter#LABEL_CROSSING_COST_FACTOR_DP_KEY}
        * @see {@link yfiles.router.polyline.EdgeRouter#considerNodeLabels}
        * @see {@link yfiles.router.polyline.PenaltySettings#nodeLabelCrossingPenalty}
        * @see {@link yfiles.router.polyline.EdgeRouter#LABEL_CROSSING_COST_FACTOR_DP_KEY}
        */
        ignoreInnerNodeLabels:boolean;
        /**
        * Determines whether or not this edge router considers labels of edges that are not in the edge (sub-)set to
        * be routed (see {@link yfiles.router.polyline.EdgeRouter#sphereOfAction}.
        * <p>
        * By default edge labels are not considered.
        * </p>
        * @see {@link yfiles.router.polyline.PenaltySettings#nodeLabelCrossingPenalty}
        * @see {@link yfiles.router.polyline.EdgeRouter#sphereOfAction}
        * @see {@link yfiles.router.polyline.EdgeRouter#selectedEdgesDpKey}
        * @see {@link yfiles.router.polyline.PenaltySettings#nodeLabelCrossingPenalty}
        * @see {@link yfiles.router.polyline.EdgeRouter#sphereOfAction}
        * @see {@link yfiles.router.polyline.EdgeRouter#selectedEdgesDpKey}
        */
        considerEdgeLabels:boolean;
        /**
        * The{@link yfiles.router.polyline.Grid} the edge router tries to place the orthogonal segments on.
        * <p>
        * By default no grid is specified, so <code>null</code> will be returned.
        * </p>
        */
        grid:yfiles.router.polyline.Grid;
        /**
        * Determines the minimal distance between edges and node bounds.
        * <p>
        * By default the minimal node to edge distance is 10.
        * </p>
        * @see {@link yfiles.router.polyline.PenaltySettings#minimalNodeToEdgeDistancePenalty}
        * @see {@link yfiles.router.polyline.PenaltySettings#minimalNodeToEdgeDistancePenalty}
        */
        minimalNodeToEdgeDistance:number;
        /**
        * Creates a {@link yfiles.router.polyline.GraphPartition} that divides the area of the graph into several rectangles.
        * <p>
        * This implementation creates a <code>GraphPartition</code> using the current {@link yfiles.router.polyline.IObstaclePartition}. It may be
        * overridden to customize the partition used in <code>EdgeRouter</code>.
        * </p>
        * @return {yfiles.router.polyline.GraphPartition} a new <code>GraphPartition</code>
        * @see {@link yfiles.router.polyline.EdgeRouter#configureGraphPartition}
        * @see {@link yfiles.router.polyline.EdgeRouter#registeredPartitionExtensions}
        */
        createGraphPartition(decomposition:yfiles.router.polyline.IObstaclePartition):yfiles.router.polyline.GraphPartition;
        /**
        * Configures the given {@link yfiles.router.polyline.GraphPartition}.
        * <p>
        * This implementation gets all registered {@link yfiles.router.polyline.IGraphPartitionExtension}s and adds them to the given
        * <code>GraphPartition</code>. It may be overridden to adjust the configuration of the <code>GraphPartition</code>.
        * </p>
        * @param {yfiles.router.polyline.GraphPartition} partition the partition that shall be configured
        * @see {@link yfiles.router.polyline.EdgeRouter#configureGraphPartition}
        * @see {@link yfiles.router.polyline.EdgeRouter#registeredPartitionExtensions}
        */
        configureGraphPartition(partition:yfiles.router.polyline.GraphPartition):void;
        /**
        * Cleans up the given {@link yfiles.router.polyline.GraphPartition}.
        * <p>
        * This implementation gets all registered {@link yfiles.router.polyline.IGraphPartitionExtension}s and removes them from the given
        * <code>GraphPartition</code>. It may be overridden to adjust the configuration of the <code>GraphPartition</code>.
        * </p>
        * @param {yfiles.router.polyline.GraphPartition} partition the partition that shall be configured
        * @see {@link yfiles.router.polyline.EdgeRouter#configureGraphPartition}
        * @see {@link yfiles.router.polyline.EdgeRouter#registeredPartitionExtensions}
        */
        cleanupGraphPartition(partition:yfiles.router.polyline.GraphPartition):void;
        /**
        * A list containing all registered{@link yfiles.router.polyline.IGraphPartitionExtension}s.
        * <p>
        * <code>GraphPartitionExtensions</code> can be added and removed to change the composition of extensions used by the
        * {@link yfiles.router.polyline.GraphPartition}.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#createGraphPartition}
        * @see {@link yfiles.router.polyline.EdgeRouter#configureGraphPartition}
        */
        registeredPartitionExtensions:yfiles.algorithms.IList;
        /**
        * Creates a {@link yfiles.router.polyline.PathSearch} that finds the edges' paths through the {@link yfiles.router.polyline.GraphPartition}.
        * <p>
        * This implementation creates a new <code>PathSearch</code>. May be overridden to customize the path
        * search.
        * </p>
        * @return {yfiles.router.polyline.PathSearch} a new <code>PathSearch</code>
        * @see {@link yfiles.router.polyline.EdgeRouter#configurePathSearch}
        * @see {@link yfiles.router.polyline.EdgeRouter#registeredPathSearchExtensions}
        */
        createPathSearch():yfiles.router.polyline.PathSearch;
        /**
        * Configures the given {@link yfiles.router.polyline.PathSearch}.
        * <p>
        * This implementation gets all registered {@link yfiles.router.polyline.PathSearchExtension}s and adds them to
        * the given <code>PathSearch</code>. It may be overridden to adjust the configuration of the
        * <code>PathSearch</code>.
        * </p>
        * @param {yfiles.router.polyline.PathSearch} pathSearch the path search that shall be configured
        * @see {@link yfiles.router.polyline.EdgeRouter#createPathSearch}
        * @see {@link yfiles.router.polyline.EdgeRouter#registeredPathSearchExtensions}
        */
        configurePathSearch(pathSearch:yfiles.router.polyline.PathSearch):void;
        /**
        * A list containing all registered{@link yfiles.router.polyline.PathSearchExtension}s.
        * <p>
        * {@link yfiles.router.polyline.PathSearchExtension} can be added and removed to change the composition of extensions used by the
        * {@link yfiles.router.polyline.PathSearch}.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#createPathSearch}
        * @see {@link yfiles.router.polyline.EdgeRouter#configurePathSearch}
        */
        registeredPathSearchExtensions:yfiles.algorithms.IList;
        /**
        * Creates a {@link yfiles.router.polyline.ChannelBasedPathRouting} that routes the edges using pre-calculated {@link yfiles.router.polyline.Path} objects.
        * <p>
        * This implementation creates a new <code>ChannelBasedPathRouting</code>. May be overridden to customize
        * the path routing.
        * </p>
        * @return {yfiles.router.polyline.ChannelBasedPathRouting} A new <code>ChannelBasedPathRouting</code>
        */
        createPathRouting():yfiles.router.polyline.ChannelBasedPathRouting;
        /**
        * Creates a {@link yfiles.router.polyline.DynamicObstacleDecomposition} that is used by the {@link yfiles.router.polyline.GraphPartition} to divide the graph
        * area in rectangles.
        * <p>
        * This implementation creates a new <code>DynamicObstacleDecomposition</code>. May be overridden to
        * customize the area decomposition.
        * </p>
        * @return {yfiles.router.polyline.DynamicObstacleDecomposition} A new <code>DynamicObstacleDecomposition</code>
        * @see {@link yfiles.router.polyline.EdgeRouter#createGraphPartition}
        */
        createObstacleDecomposition():yfiles.router.polyline.DynamicObstacleDecomposition;
        /**
        * Creates a {@link yfiles.router.polyline.PathSearchContext} that provides context information for the path search algorithm.
        * <p>
        * This implementation creates a new <code>PathSearchContext</code>. May be overridden to customize the context
        * information providing.
        * </p>
        * @param {yfiles.router.polyline.PathSearch} pathSearch The path search that uses the context to be created.
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration used for the path search.
        * @return {yfiles.router.polyline.PathSearchContext} A new <code>PathSearchContext</code>
        */
        createPathSearchContext(pathSearch:yfiles.router.polyline.PathSearch,configuration:yfiles.router.polyline.PathSearchConfiguration):yfiles.router.polyline.PathSearchContext;
        /**
        * Creates the {@link yfiles.router.polyline.PathSearchConfiguration} that is used during the path search.
        * <p>
        * This implementation creates a new <code>PathSearchConfiguration</code>. May be overridden to use
        * a subclassed configuration.
        * </p>
        * @return {yfiles.router.polyline.PathSearchConfiguration} A new <code>PathSearchConfiguration</code>.
        */
        createConfiguration(graph:yfiles.layout.LayoutGraph,grouping:yfiles.layout.GraphGrouping):yfiles.router.polyline.PathSearchConfiguration;
        /**
        * Main layout routine that assigns new layout information to the given graph.
        * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
        */
        doLayout(graph:yfiles.layout.LayoutGraph):void;
        /**
        * Creates and returns the default {@link yfiles.objectcollections.IComparer} used to determine the order the edges of the graph
        * are laid out with.
        * @param {yfiles.layout.LayoutGraph} graph The graph that contains the edges to compare.
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration to use for the following path searches.
        * @return {yfiles.objectcollections.IComparer} A comparator ordering <code>edge</code>s to determine the order the edges of the graph are laid out with.
        */
        createDefaultEdgeOrderComparator(graph:yfiles.layout.LayoutGraph,configuration:yfiles.router.polyline.PathSearchConfiguration):yfiles.objectcollections.IComparer;
        /**
        * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given node object is zero.
        * It is called by the {@link yfiles.router.polyline.EdgeRouter#doLayout} method for each node object in the input graph.
        * @see {@link yfiles.router.polyline.EdgeRouter#checkGroupNodeSize}
        * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
        * @param {Object} node the node object to test.
        * @throws {yfiles.system.ArgumentException} thrown if the width/height of the node object is zero.
        */
        checkNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
        /**
        * This method throws an {@link yfiles.system.ArgumentException} if the width/height of the given group node object is zero.
        * It is called by the {@link yfiles.router.polyline.EdgeRouter#doLayout} method for each group node object in the input graph.
        * @see {@link yfiles.router.polyline.EdgeRouter#checkNodeSize}
        * @param {yfiles.layout.IGraphLayout} layout a graph layout object.
        * @param {Object} node the group node object to test.
        * @throws {yfiles.system.ArgumentException} thrown if the width/height of the group node object is zero.
        */
        checkGroupNodeSize(layout:yfiles.layout.IGraphLayout,node:Object):void;
        /**
        * The{@link yfiles.router.polyline.GraphPartition} used during the layout.
        */
        partition:yfiles.router.polyline.GraphPartition;
      }
      var EdgeRouter:{
        $class:yfiles.lang.Class;
        /**
        * {@link yfiles.algorithms.IDataProvider} key used to store the {@link yfiles.router.polyline.EdgeLayoutDescriptor} for each edge.
        * If there is no descriptor mapped for an edge, the default descriptor is used.
        * @see {@link yfiles.router.polyline.EdgeRouter#defaultEdgeLayoutDescriptor}
        */
        EDGE_LAYOUT_DESCRIPTOR_DP_KEY:string;
        /**
        * {@link yfiles.algorithms.IDataProvider} key used to store a cost factor for each label.
        * <p>
        * This factor is multiplied with the basic penalty for an edge crossing a
        * {@link yfiles.router.polyline.PenaltySettings#nodeLabelCrossingPenalty  node label} or
        * {@link yfiles.router.polyline.PenaltySettings#edgeLabelCrossingPenalty  edge label} to determine the
        * final costs to cross this label.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#defaultEdgeLayoutDescriptor}
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#penaltySettings}
        */
        LABEL_CROSSING_COST_FACTOR_DP_KEY:string;
        /**
        * Creates a new EdgeRouter instance with the given core Layouter.
        */
        WithCoreLayouter:{
          new (core:yfiles.layout.ILayouter):yfiles.router.polyline.EdgeRouter;
        };
        /**
        * Creates a new EdgeRouter instance.
        */
        new ():yfiles.router.polyline.EdgeRouter;
      };
      /**
      * Encapsulates the information required to route an edge with a path routing algorithm.
      * @see {@link yfiles.router.polyline.ChannelBasedPathRouting}
      */
      export interface EdgeInfo extends Object{
        /**
        * Determines whether the path of this {@link yfiles.router.polyline.EdgeInfo#edge  edge} is fixed or shall be routed by the path search
        * algorithm.
        */
        fixed:boolean;
        /**
        * The edge whose route is described by this info.
        */
        edge:yfiles.algorithms.Edge;
        /**
        * A list of{@link yfiles.router.polyline.EdgeCellInfo}s describing how the edge traverses each {@link yfiles.router.polyline.PartitionCell} on its path.
        */
        edgeCellInfos:yfiles.algorithms.IList;
        /**
        * Returns the {@link yfiles.router.polyline.EdgeCellInfo} of the given {@link yfiles.router.polyline.CellEntrance} in the path.
        * @param {yfiles.router.polyline.CellEntrance} entrance The entrance to get the edge cell info for.
        * @return {yfiles.router.polyline.EdgeCellInfo} The <code>EdgeCellInfo</code> of the given <code>CellEntrance</code> in the path.
        */
        getEdgeCellInfo(entrance:yfiles.router.polyline.CellEntrance):yfiles.router.polyline.EdgeCellInfo;
        /**
        * Returns the segment info the the segment with the given index.
        * @param {number} segmentIndex The index of the edge segment to return the segment info for.
        * @return {yfiles.router.polyline.SegmentInfo} The segment info the the segment with the given index.
        */
        getSegmentInfo(segmentIndex:number):yfiles.router.polyline.SegmentInfo;
        /**
        * Returns the segment info of the segment preceding the segment of the given segment info.
        * @param {yfiles.router.polyline.SegmentInfo} segment The segmentInfo for which the previous segment info shall be returned.
        * @return {yfiles.router.polyline.SegmentInfo} The segment info of the segment preceding the segment of the given segment info.
        */
        getPreviousSegment(segment:yfiles.router.polyline.SegmentInfo):yfiles.router.polyline.SegmentInfo;
        /**
        * Returns the segment info of the segment following the segment of the given segment info.
        * @param {yfiles.router.polyline.SegmentInfo} segment The segmentInfo for which the following segment info shall be returned.
        * @return {yfiles.router.polyline.SegmentInfo} The segment info of the segment following the segment of the given segment info.
        */
        getNextSegment(segment:yfiles.router.polyline.SegmentInfo):yfiles.router.polyline.SegmentInfo;
        /**
        * Returns the number of segments of the edge.
        * @return {number} The number of segments of the edge.
        */
        segmentCount():number;
        toString():string;
        /**
        * The location of the strong source port the edge uses.
        * @throws {yfiles.system.ArgumentException} 
        * If the first segment is already fixed and the given port location contradicts
        * the segments fixed location.
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#location}
        * @see {@link yfiles.router.polyline.SegmentInfo#atStrongPortConstraint}
        */
        strongSourcePort:yfiles.algorithms.YPoint;
        /**
        * The location of the strong target port the edge uses.
        * @throws {yfiles.system.ArgumentException} 
        * If the last segment is already fixed and the given port location contradicts
        * the segments fixed location.
        * @see {@link yfiles.router.polyline.AbstractSegmentInfo#location}
        * @see {@link yfiles.router.polyline.SegmentInfo#atStrongPortConstraint}
        */
        strongTargetPort:yfiles.algorithms.YPoint;
        /**
        * Returns an array of {@link yfiles.algorithms.LineSegment}s created from the {@link yfiles.router.polyline.EdgeInfo#calculatePathPoints  calculated path points}.
        * @return {yfiles.algorithms.LineSegment[]} An array of <code>LineSegment</code>s created from the calculated path points.
        */
        calculateLineSegments():yfiles.algorithms.LineSegment[];
        /**
        * Returns a list of {@link yfiles.algorithms.YPoint}s containing the source port, bend and target port locations.
        * @return {yfiles.algorithms.YList} A list of <code>YPoint</code>s containing the source port, bend and target port locations.
        */
        calculatePathPoints():yfiles.algorithms.YList;
      }
      var EdgeInfo:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        * @param {yfiles.router.polyline.Path} path The path that shall be used to route the edge.
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration of the path search algorithm.
        */
        new (path:yfiles.router.polyline.Path,configuration:yfiles.router.polyline.PathSearchConfiguration):yfiles.router.polyline.EdgeInfo;
      };
      /**
      * An {@link yfiles.router.polyline.IObstaclePartition} that decomposes its area dynamically and implements the {@link yfiles.router.polyline.IDynamicDecomposition} interface.
      * <p>
      * The partitioning strategy is based on binary space partitioning. It divides the partition space recursively in two
      * cells until each cell is completely covered from one or more obstacles or completely empty.
      * </p>
      */
      export interface DynamicObstacleDecomposition extends Object,yfiles.router.polyline.IObstaclePartition,yfiles.router.polyline.IDynamicDecomposition{
        /**
        * The costs incurred for every obstacle that must be cut in a subdivision.
        */
        cutObstacleCost:number;
        /**
        * The costs incurred if the distribution after a subdivision of obstacles is unbalanced in sub-cells.
        */
        unbalancedObstaclesCost:number;
        /**
        * The costs incurred if the subdivision produces unbalanced rectangles.
        */
        unbalancedRatioCost:number;
        /**
        * Adds the given dynamic decomposition listener to receive {@link yfiles.router.polyline.PartitionCell} subdivision and creation events from
        * this decomposition.
        * These events occur when the decomposition changes the partition by subdividing cells into
        * sub-cells or new cell are created.
        * @param {yfiles.router.polyline.DynamicDecompositionCompanion.IListener} listener the dynamic decomposition listener.
        * @see {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener}
        * @see Specified by {@link yfiles.router.polyline.IDynamicDecomposition#addDynamicDecompositionListener}.
        */
        addDynamicDecompositionListener(listener:yfiles.router.polyline.DynamicDecompositionCompanion.IListener):void;
        /**
        * Removes the given dynamic decomposition listener so that it no longer receives {@link yfiles.router.polyline.PartitionCell} subdivision
        * and creation  events from this decomposition.
        * @param {yfiles.router.polyline.DynamicDecompositionCompanion.IListener} listener the dynamic decomposition listener.
        * @see {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener}
        * @see Specified by {@link yfiles.router.polyline.IDynamicDecomposition#removeDynamicDecompositionListener}.
        */
        removeDynamicDecompositionListener(listener:yfiles.router.polyline.DynamicDecompositionCompanion.IListener):void;
        /**
        * Notifies all registered dynamic decomposition listeners about a subdivision.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell that has been subdivided.
        * @param {yfiles.algorithms.IList} subCells The new sub cells of the divided cell.
        * @see {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener}
        */
        fireSubdividedEvent(cell:yfiles.router.polyline.PartitionCell,subCells:yfiles.algorithms.IList):void;
        /**
        * Notifies all registered dynamic decomposition listeners about the finalized cell.
        * @param {yfiles.router.polyline.PartitionCell} finalizedCell The cell that has been finalized.
        * @see {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener}
        */
        fireFinalizeCellEvent(finalizedCell:yfiles.router.polyline.PartitionCell):void;
        /**
        * Notifies all registered dynamic decomposition listeners about the newly created cell.
        * @param {yfiles.router.polyline.PartitionCell} createdCell The newly created cell.
        * @see {@link yfiles.router.polyline.DynamicDecompositionCompanion.IListener}
        */
        fireCreateCellEvent(createdCell:yfiles.router.polyline.PartitionCell):void;
        /**
        * Initializes this dynamic obstacle decomposition with the given obstacles and partition bounds.
        * This method must be
        * called before any other method is invoked.
        * @param {yfiles.algorithms.IList} obstacles 
        * A list of {@link yfiles.router.polyline.Obstacle} objects.
        * @param {yfiles.algorithms.YRectangle} partitionBounds The bounds of the partition.
        * @see Specified by {@link yfiles.router.polyline.IObstaclePartition#init}.
        */
        init(obstacles:yfiles.algorithms.IList,partitionBounds:yfiles.algorithms.YRectangle):void;
        /**
        * Clears the partition data so the <code>ObstaclePartition</code> can be reused and
        * {@link yfiles.router.polyline.IObstaclePartition#init  initialized} with new <code>Obstacle</code>s.
        * @see Specified by {@link yfiles.router.polyline.IObstaclePartition#clear}.
        */
        clear():void;
        /**
        * Calculates the cost of a cut with respect to the subdivided obstacles.
        * The cost ranges between 0 and 1.
        * @param {number} numObstaclesInFirstHalf The number of obstacles that lie completely in the first half.
        * @param {number} numObstaclesInSecondHalf The number of obstacles that lie completely in the second half.
        * @param {number} numObstaclesOnCut The number of obstacles that lie on the cut.
        * @return {number} Costs of a cut with respect to the subdivided obstacles.
        */
        getObstacleCutCosts(numObstaclesInFirstHalf:number,numObstaclesInSecondHalf:number,numObstaclesOnCut:number):number;
        /**
        * Calculates the cost of a cut with respect to the geometry of the sub-cells.
        * The cost ranges between 0 and 1.
        * @param {number} cut The coordinate of the cut.
        * @param {number} min The left side of the subdivided cell.
        * @param {number} max The right side of the subdivided cell.
        * @param {number} orthogonalMin The upper side of the subdivided cell.
        * @param {number} orthogonalMax The lower side of the subdivided cell.
        * @return {number} Costs of a cut with respect to the geometry of the sub-cells.
        */
        getGeometricCutCosts(cut:number,min:number,max:number,orthogonalMin:number,orthogonalMax:number):number;
        /**
        * Returns the neighbor cells of the given cell.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell to get the neighbors for.
        * @return {yfiles.algorithms.IList} The neighbor cells of the given cell.
        * @see Specified by {@link yfiles.router.polyline.IPartition#getNeighbors}.
        */
        getNeighbors(cell:yfiles.router.polyline.PartitionCell):yfiles.algorithms.IList;
        /**
        * Returns all obstacles that cover the given partition cell.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell to get the obstacles for.
        * @return {yfiles.algorithms.IList} 
        * An unmodifiable list of {@link yfiles.router.polyline.Obstacle} instances that cover the given cell.
        * @see Specified by {@link yfiles.router.polyline.IObstaclePartition#getObstacles}.
        */
        getObstacles(cell:yfiles.router.polyline.PartitionCell):yfiles.algorithms.IList;
        /**
        * Returns all cells that are completely covered by the given obstacle.
        * @param {yfiles.router.polyline.Obstacle} obstacle The obstacle to get the covered cells for.
        * @return {yfiles.algorithms.IList} 
        * An unmodifiable list of {@link yfiles.router.polyline.PartitionCell} instances that are
        * completely covered by the given obstacle.
        * @see Specified by {@link yfiles.router.polyline.IObstaclePartition#getCellsWithObstacle}.
        */
        getCellsWithObstacle(obstacle:yfiles.router.polyline.Obstacle):yfiles.algorithms.IList;
        /**
        * Returns the {@link yfiles.router.polyline.PartitionCell}s in which the given rectangle lies.
        * @param {yfiles.algorithms.YRectangle} rect The rectangle to get the cells for.
        * @return {yfiles.algorithms.IList} The cells in which the given rectangle lies.
        * @see Specified by {@link yfiles.router.polyline.IPartition#getCells}.
        */
        getCells(rect:yfiles.algorithms.YRectangle):yfiles.algorithms.IList;
        /**
        * Returns the already existing (leaf) {@link yfiles.router.polyline.PartitionCell}s within the given rectangle.
        * @param {yfiles.algorithms.YRectangle} rect The rectangle to get the cells for.
        * @return {yfiles.algorithms.IList} The cells in which the given rectangle lies.
        */
        getExistingCells(rect:yfiles.algorithms.YRectangle):yfiles.algorithms.IList;
        /**
        * The bounds of the decomposition area.
        * @see Specified by {@link yfiles.router.polyline.IPartition#bounds}.
        */
        bounds:yfiles.algorithms.YRectangle;
      }
      var DynamicObstacleDecomposition:{
        $class:yfiles.lang.Class;
        /**
        * Constructs a dynamic obstacle decomposition.
        */
        new ():yfiles.router.polyline.DynamicObstacleDecomposition;
      };
      /**
      * Encapsulates the information that determines the route of a specific edge within a specific partition cell.
      */
      export interface EdgeCellInfo extends Object{
        /**
        * The number of bends the edge has inside this cell.
        */
        bendCount:number;
        /**
        * Returns a <code>String</code> representation of the shape in which the edge crosses the {@link yfiles.router.polyline.PartitionCell}.
        * @return {string} 
        * A <code>String</code> representation of the shape in which the edge crosses the {@link yfiles.router.polyline.PartitionCell}.
        */
        toString():string;
        /**
        * The routing type the edge uses in this cell.
        * This is one of:
        * <ul>
        * <li>{@link yfiles.router.polyline.RoutingType#STRAIGHT}</li>
        * <li>{@link yfiles.router.polyline.RoutingType#STRAIGHT_BENDING}</li>
        * <li>{@link yfiles.router.polyline.RoutingType#BENDING}</li>
        * <li>{@link yfiles.router.polyline.RoutingType#U_TURN}</li>
        * <li>{@link yfiles.router.polyline.RoutingType#END}</li>
        * </ul>
        */
        type:yfiles.router.polyline.RoutingType;
        /**
        * The index of the edge segment that enters this cell.
        */
        enterSegmentNo:number;
        /**
        * The index of the edge segment that exits this cell.
        */
        exitSegmentNo:number;
        /**
        * The segment group containing the entering segment.
        * @see {@link yfiles.router.polyline.SegmentGroup#commonLocationRange}
        */
        enterSegmentGroup:yfiles.router.polyline.SegmentGroup;
        /**
        * The segment group containing the exiting segment.
        * @see {@link yfiles.router.polyline.SegmentGroup#commonLocationRange}
        */
        exitSegmentGroup:yfiles.router.polyline.SegmentGroup;
        /**
        * The edge whose routing in the cell is described.
        */
        edge:yfiles.algorithms.Edge;
        /**
        * The cell the edge is routed in.
        */
        cell:yfiles.router.polyline.PartitionCell;
        /**
        * The interval, the edge uses to enter this cell.
        */
        enterInterval:yfiles.router.polyline.OrthogonalInterval;
        /**
        * The interval, the edge uses to exit this cell.
        */
        exitInterval:yfiles.router.polyline.OrthogonalInterval;
        /**
        * The direction, this edge uses to enter this cell.
        */
        enterDirection:yfiles.layout.Direction;
        /**
        * The direction, this edge uses to exit this cell.
        */
        exitDirection:yfiles.layout.Direction;
        /**
        * The{@link yfiles.router.polyline.CellSegmentInfo}s for the the segment parts of this edge that run inside this cell.
        */
        cellSegmentInfos:yfiles.algorithms.YList;
      }
      var EdgeCellInfo:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        * @param {yfiles.algorithms.Edge} edge The edge whose routing in the cell is described.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell the edge is routed in.
        * @param {yfiles.router.polyline.OrthogonalInterval} enterInterval The interval, the edge uses to enter the cell.
        * @param {yfiles.router.polyline.OrthogonalInterval} exitInterval The interval, the edge uses to exit the cell.
        * @param {yfiles.layout.Direction} enterDirection The direction, the edge enters the cell.
        * @param {yfiles.layout.Direction} exitDirection The direction, the edge exits the cell.
        * @param {number} enterSegmentNo The index of the edge segment that enters the cell.
        */
        new (edge:yfiles.algorithms.Edge,cell:yfiles.router.polyline.PartitionCell,enterInterval:yfiles.router.polyline.OrthogonalInterval,exitInterval:yfiles.router.polyline.OrthogonalInterval,enterDirection:yfiles.layout.Direction,exitDirection:yfiles.layout.Direction,enterSegmentNo:number):yfiles.router.polyline.EdgeCellInfo;
      };
      /**
      * Represents a rectangular part of the {@link yfiles.router.polyline.IPartition} as result of the decomposition process.
      * Each instance of
      * PartitionCell provides a data store ({@link yfiles.router.polyline.PartitionCell#putData}, {@link yfiles.router.polyline.PartitionCell#getData} and {@link yfiles.router.polyline.PartitionCell#removeData}) that could be used to bind additional information to it, e.g. what element of the graph is
      * covered by this PartitionCell.
      * @see {@link yfiles.router.polyline.IPartitionCellKeys}
      */
      export interface PartitionCell extends Object{
        /**
        * Stores additional data to which the given key is mapped for this partition cell.
        * @param {Object} key The key with which the given data is to be associated.
        * @param {Object} data The additional data.
        * @return {Object} The previous data associated with key, or null if there was no mapping for key.
        * @see {@link yfiles.router.polyline.PartitionCell#getData}
        * @see {@link yfiles.router.polyline.PartitionCell#removeData}
        * @see {@link yfiles.router.polyline.PartitionCell#clearData}
        * @see {@link yfiles.router.polyline.IPartitionCellKeys}
        */
        putData(key:Object,data:Object):Object;
        /**
        * Returns additional data to which the given key is mapped for this partition cell.
        * @param {Object} key The Key with which the given data is to be associated.
        * @return {Object} The additional data to which the given key is mapped, or null if there was no mapping for key.
        * @see {@link yfiles.router.polyline.PartitionCell#putData}
        * @see {@link yfiles.router.polyline.PartitionCell#removeData}
        * @see {@link yfiles.router.polyline.PartitionCell#clearData}
        * @see {@link yfiles.router.polyline.IPartitionCellKeys}
        */
        getData(key:Object):Object;
        /**
        * Removes additional data to which the given key is mapped for this partition cell.
        * @param {Object} key The Key with which the given data is to be associated.
        * @return {Object} The additional data to which the given key is mapped, or null if there was no mapping for key.
        * @see {@link yfiles.router.polyline.PartitionCell#getData}
        * @see {@link yfiles.router.polyline.PartitionCell#putData}
        * @see {@link yfiles.router.polyline.PartitionCell#clearData}
        * @see {@link yfiles.router.polyline.IPartitionCellKeys}
        */
        removeData(key:Object):Object;
        /**
        * Clears all additional data.
        * @see {@link yfiles.router.polyline.PartitionCell#getData}
        * @see {@link yfiles.router.polyline.PartitionCell#putData}
        * @see {@link yfiles.router.polyline.PartitionCell#removeData}
        */
        clearData():void;
        /**
        * The{@link yfiles.router.polyline.DynamicObstacleDecomposition  partition} to which this partition cell belongs.
        * @see {@link yfiles.router.polyline.IPartition}
        */
        partition:yfiles.router.polyline.IPartition;
        /**
        * A unique identifier of this partition cell.
        */
        id:number;
        /**
        * The bounds the partition cell.
        */
        bounds:yfiles.algorithms.YRectangle;
        /**
        * The x value of the left border of this partition cell.
        */
        minX:number;
        /**
        * The y value of the upper border of this partition cell.
        */
        minY:number;
        /**
        * The x value of the right border of this partition cell.
        */
        maxX:number;
        /**
        * The y value of the lower border of this partition cell.
        */
        maxY:number;
        /**
        * The width of this partition cell.
        */
        width:number;
        /**
        * The height of this partition cell.
        */
        height:number;
        /**
        * Returns an {@link yfiles.router.polyline.OrthogonalInterval} that defines location, size and orientation of the given border.
        * The values
        * defining the border are
        * <ul>
        * <li>{@link yfiles.router.polyline.PartitionCell.PartitionCellBorder#WEST}</li>
        * <li>{@link yfiles.router.polyline.PartitionCell.PartitionCellBorder#EAST}</li>
        * <li>{@link yfiles.router.polyline.PartitionCell.PartitionCellBorder#NORTH}</li>
        * <li>{@link yfiles.router.polyline.PartitionCell.PartitionCellBorder#SOUTH}</li>
        * </ul>
        * @param {yfiles.router.polyline.PartitionCell.PartitionCellBorder} border A border of this partition cell.
        * @return {yfiles.router.polyline.OrthogonalInterval} 
        * An {@link yfiles.router.polyline.OrthogonalInterval} that defines location, size and orientation of the given border.
        * @see {@link yfiles.router.polyline.PartitionCell.PartitionCellBorder}
        */
        createBorderInterval(border:yfiles.router.polyline.PartitionCell.PartitionCellBorder):yfiles.router.polyline.OrthogonalInterval;
      }
      export module PartitionCell{
        /**
        * Type-safe enumeration that is used to define the border of a partition cell.
        * @see {@link yfiles.router.polyline.PartitionCell#createBorderInterval}
        */
        export interface PartitionCellBorder extends Object{
          /**
          * The type of the border that is on the opposite side of the border defined by this type.
          */
          mirrorBorder:yfiles.router.polyline.PartitionCell.PartitionCellBorder;
        }
      }
      var PartitionCell:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new partition cell of the given partition with location and size of the given rectangle.
        * @param {yfiles.algorithms.YRectangle} bounds The bounds of the partition cell.
        * @param {yfiles.router.polyline.IPartition} partition The partition to which the partition cell belongs.
        * @see {@link yfiles.router.polyline.IPartition}
        */
        FromRectangle:{
          new (bounds:yfiles.algorithms.YRectangle,partition:yfiles.router.polyline.IPartition):yfiles.router.polyline.PartitionCell;
        };
        /**
        * Creates a new partition cell of the given partition with the given bounds.
        * @param {number} x The x-coordinate of upper left corner of the partition cell.
        * @param {number} y The y-coordinate of upper left corner of the partition cell.
        * @param {number} width The width of the partition cell.
        * @param {number} height The height of the partition cell.
        * @param {yfiles.router.polyline.IPartition} partition The partition to which the partition cell belongs.
        */
        new (x:number,y:number,width:number,height:number,partition:yfiles.router.polyline.IPartition):yfiles.router.polyline.PartitionCell;
        PartitionCellBorder:{
          $class:yfiles.lang.Class;
          /**
          * Type constant to define the upper border of a {@link yfiles.router.polyline.PartitionCell}.
          */
          NORTH:yfiles.router.polyline.PartitionCell.PartitionCellBorder;
          /**
          * Type constant to define the lower border of a {@link yfiles.router.polyline.PartitionCell}.
          */
          SOUTH:yfiles.router.polyline.PartitionCell.PartitionCellBorder;
          /**
          * Type constant to define the right border of a {@link yfiles.router.polyline.PartitionCell}.
          */
          EAST:yfiles.router.polyline.PartitionCell.PartitionCellBorder;
          /**
          * Type constant to define the left border of a {@link yfiles.router.polyline.PartitionCell}.
          */
          WEST:yfiles.router.polyline.PartitionCell.PartitionCellBorder;
          /**
          * Returns the type of the border that is passed through when leaving a {@link yfiles.router.polyline.PartitionCell} in the given
          * direction.
          * @param {yfiles.layout.Direction} direction 
          * The direction in which a {@link yfiles.router.polyline.PartitionCell} is left.
          * @return {yfiles.router.polyline.PartitionCell.PartitionCellBorder} The type of the border that is passed through.
          * @see {@link yfiles.router.polyline.PartitionCell}
          */
          valueOfExitDirection(direction:yfiles.layout.Direction):yfiles.router.polyline.PartitionCell.PartitionCellBorder;
          /**
          * Returns the type of the border that is passed through when entering a {@link yfiles.router.polyline.PartitionCell} in the given
          * direction.
          * @param {yfiles.layout.Direction} direction 
          * The direction in which a {@link yfiles.router.polyline.PartitionCell} is entered.
          * @return {yfiles.router.polyline.PartitionCell.PartitionCellBorder} The type of the border that is passed through.
          * @see {@link yfiles.router.polyline.PartitionCell}
          */
          valueOfEnterDirection(direction:yfiles.layout.Direction):yfiles.router.polyline.PartitionCell.PartitionCellBorder;
          /**
          * Returns the type of the border that is defined by the given port constraint.
          * @param {yfiles.layout.PortConstraint} pc The port constraint for that the border type is returned.
          * @return {yfiles.router.polyline.PartitionCell.PartitionCellBorder} The type of the border that is defined by the given port constraint.
          * @see {@link yfiles.layout.PortConstraint}
          */
          valueOfPortConstraint(pc:yfiles.layout.PortConstraint):yfiles.router.polyline.PartitionCell.PartitionCellBorder;
          /**
          * Returns the type of the border that is defined by the given port candidate.
          * @param {yfiles.layout.PortCandidate} pc The port candidate for that the border type is returned.
          * @return {yfiles.router.polyline.PartitionCell.PartitionCellBorder} The type of the border that is defined by the given port candidate.
          * @see {@link yfiles.layout.PortCandidate}
          */
          valueOfPortCandidate(pc:yfiles.layout.PortCandidate):yfiles.router.polyline.PartitionCell.PartitionCellBorder;
        };
      };
      /**
      * Contains the basic configuration used by path search algorithms.
      */
      export interface PathSearchConfiguration extends Object{
        /**
        * The graph of the edge whose path is searched.
        */
        graph:yfiles.layout.LayoutGraph;
        /**
        * The grouping information of the graph.
        */
        grouping:yfiles.layout.GraphGrouping;
        /**
        * The orthogonal layout algorithm using this configuration.
        */
        edgeRouter:yfiles.router.polyline.EdgeRouter;
        /**
        * The remaining time in that the calculation of the algorithm should be completed.
        */
        restOfComputingTime:number;
      }
      var PathSearchConfiguration:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new configuration used for a path search.
        * @param {yfiles.layout.LayoutGraph} graph The graph of the edges whose path will be searched.
        * @param {yfiles.layout.GraphGrouping} grouping The grouping information of the graph.
        * @param {yfiles.router.polyline.EdgeRouter} edgeRouter The orthogonal layout algorithm using this configuration.
        */
        new (graph:yfiles.layout.LayoutGraph,grouping:yfiles.layout.GraphGrouping,edgeRouter:yfiles.router.polyline.EdgeRouter):yfiles.router.polyline.PathSearchConfiguration;
      };
      /**
      * A pathfinding algorithm that calculates the shortest (that means the cheapest) paths for a set of edges through a
      * {@link yfiles.router.polyline.GraphPartition}.
      * <p>
      * It is based on an <a href="http://en.wikipedia.org/wiki/A*_search_algorithm">A*-algorithm</a> and uses
      * {@link yfiles.router.polyline.PartitionCell}s as steps between source node and target node.
      * In each step, the algorithm takes a {@link yfiles.router.polyline.CellEntrance}, that consists mainly of a <code>PartitionCell</code> and
      * from where it was entered, from a queue with all seen <code>CellEntrance</code>s, determines all possible neighbor
      * cells and their enter intervals and enqueues the resulting <code>CellEntrances</code>.
      * To influence the order in which the <code>CellEntrance</code>s will be processed, the path search assigns real
      * costs (like Dijkstra) as well as heuristic costs (A*-algorithm's heuristic) to the enqueued
      * <code>CellEntrance</code>s. The real costs arise from entering a neighbor cell, e.g. a bend has to be created,
      * while the heuristic costs are an estimation of how expensive it will be to reach the target node continuing the
      * path with this neighbor cell. Therefor, the path search prefers searching in the direction where the target node
      * lies. The <code>CellEntrance</code> with the lowest combined costs is processed next until a target cell is reached.
      * </p>
      * <p>
      * {@link yfiles.router.polyline.PathSearchExtension PathSearchExtension}s modify the path search as they are able to add start
      * entrances and weigh them with costs. They also add real and heuristic costs to <code>CellEntrance</code>s that are
      * created for the currently entered <code>PartitionCell</code> and calculate shorter enter intervals that are less
      * expensive to pass.
      * </p>
      * <p>
      * The algorithm gets a {@link yfiles.router.polyline.PathSearchContext} which provides information about the graph and the currently routed
      * edge. It also stores the results of the path search that can be retrieved calling
      * {@link yfiles.router.polyline.PathSearchContext#pathSearchResult}.
      * </p>
      * @see {@link yfiles.router.polyline.PathSearch#addPathSearchExtension}
      * @see {@link yfiles.router.polyline.PathSearch#addAdditionalEnterIntervalCalculator}
      */
      export interface PathSearch extends Object{
        /**
        * Adds the given extension to the list of path search extensions.
        * @param {yfiles.router.polyline.PathSearchExtension} extension The extension to add to this path search.
        * @return {boolean} <code>true</code>, if the extension has been added, <code>false</code> otherwise.
        */
        addPathSearchExtension(extension:yfiles.router.polyline.PathSearchExtension):boolean;
        /**
        * Removes the given extension from the list of path search extensions.
        * @param {yfiles.router.polyline.PathSearchExtension} extension The extension to remove from the path search.
        * @return {boolean} <code>true</code>, if an extension was removed as a result of this call.
        */
        removePathSearchExtension(extension:yfiles.router.polyline.PathSearchExtension):boolean;
        /**
        * Adds a new interval calculator to the list of registered interval calculators.
        * @param {yfiles.router.polyline.IEnterIntervalCalculator} enterIntervalCalculator The calculator to add.
        * @return {boolean} <code>true</code>, if the calculator could be added, <code>false</code> otherwise.
        */
        addAdditionalEnterIntervalCalculator(enterIntervalCalculator:yfiles.router.polyline.IEnterIntervalCalculator):boolean;
        /**
        * Removes the given interval calculator from the list of registered interval calculators.
        * @param {yfiles.router.polyline.IEnterIntervalCalculator} enterIntervalCalculator The calculator to remove.
        * @return {boolean} <code>true</code>, if an interval calculator was removed as a result of this call.
        */
        removeAdditionalEnterIntervalCalculator(enterIntervalCalculator:yfiles.router.polyline.IEnterIntervalCalculator):boolean;
        /**
        * Initializes the path search.
        * <p>
        * This method also calls {@link yfiles.router.polyline.PathSearchExtension#initialize} for all registered
        * path search extensions.
        * </p>
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration, the path search shall use.
        */
        init(configuration:yfiles.router.polyline.PathSearchConfiguration):void;
        /**
        * Resets all registered path search extensions and {@link yfiles.algorithms.DataProviders} added by <code>PathSearch</code>.
        * So,
        * <code>PathSearch</code> is ready to calculate paths for a new layout.
        * @see {@link yfiles.router.polyline.PathSearchExtension#cleanup}
        */
        clear():void;
        /**
        * Returns the path for the given edge, if it has been finalized already.
        * @param {yfiles.algorithms.Edge} edge The edge to return the path for.
        * @return {yfiles.router.polyline.Path} The finalized path for the given edge or <code>null</code> if no path has been found and finalized.
        */
        getFinalizedPath(edge:yfiles.algorithms.Edge):yfiles.router.polyline.Path;
        /**
        * Finds the path for the current edge in the given context.
        * This method:
        * <ul>
        * <li>calls {@link yfiles.router.polyline.PathSearchExtension#initializeCurrentEdge} for all extensions</li>
        * <li>collects and enqueues all start entrances</li>
        * <li>iteratively processes the next cheapest cell entrance and
        * <ul>
        * <li>adds a Path result after a {@link yfiles.router.polyline.PathSearch#finalizePath} call if it is a valid target entrance and/or</li>
        * <li>calls {@link yfiles.router.polyline.PathSearch#handleNeighbor} for all neighbor cells of the entered cell</li>
        * </ul>
        * </li>
        * <li>calls {@link yfiles.router.polyline.PathSearchExtension#finalizeCurrentEdge} for all extensions</li>
        * </ul>
        */
        findPathsForCurrentEdge(context:yfiles.router.polyline.PathSearchContext):void;
        /**
        * Decreases the given penalty settings for the current edge.
        * <p>
        * If finding a path for the current edge takes too long according to the maximum duration of the edge router,
        * the path search for the current edge is canceled and restarted using decreased penalties. The
        * <code>decreaseFactor</code> indicates, how strong the penalties shall be reduced.
        * </p>
        * <p>
        * If overriding this method please note that the penalty for creating bends should not be reduced as this results
        * in more possible turns of the edge path and therefore a longer runtime of the path search. Furthermore not all
        * penalties should be decreased equally as these decreases would neutralize each other.
        * </p>
        * @param {yfiles.router.polyline.PenaltySettings} penaltySettings The penalty settings whose penalties shall be reduced.
        * @param {number} decreaseFactor 
        * A factor with values between 0 and 1 that indicates how strong to reduce the penalties.
        * 0 means no reduction while 1 means to strongest reduction.
        * @param {yfiles.router.polyline.PathSearchContext} context The context of the current path search.
        */
        decreasePenaltySettings(penaltySettings:yfiles.router.polyline.PenaltySettings,decreaseFactor:number,context:yfiles.router.polyline.PathSearchContext):void;
        /**
        * Finds paths for the edges in the given context and stores them in its
        * {@link yfiles.router.polyline.PathSearchContext#pathSearchResult  PathSearchResult}.
        * <p>
        * It initializes its extensions using {@link yfiles.router.polyline.PathSearchExtension#initializeEdges} and
        * delegates the path search for each edge to {@link yfiles.router.polyline.PathSearch#findPathsForCurrentEdge}.
        * </p>
        * <p>
        * The paths calculations for all edges are finalized by calling the extensions'
        * {@link yfiles.router.polyline.PathSearchExtension#finalizeEdges} method and after that the path search result
        * if filled with the path for each edge.
        * </p>
        * <p>
        * At last the extensions are asked to finalize the path search result using their
        * {@link yfiles.router.polyline.PathSearchExtension#finalizePathSearchResult} callback.
        * </p>
        * @param {yfiles.router.polyline.PathSearchContext} context The context to use during the path search.
        * @see {@link yfiles.router.polyline.PathSearchContext#edges}
        * @see {@link yfiles.router.polyline.PathSearchContext#pathSearchResult}
        */
        findPaths(context:yfiles.router.polyline.PathSearchContext):void;
        /**
        * Informs all registered path search extensions about completing a path by calling their
        * {@link yfiles.router.polyline.PathSearchExtension#finalizePath  finalizePath(Path)} method.
        * That way, extensions can collect data about this
        * path to use it later in path search.
        * @param {yfiles.router.polyline.Path} path The path to finalize.
        */
        finalizePath(path:yfiles.router.polyline.Path):void;
        /**
        * Adds {@link yfiles.router.polyline.CellEntrance}s for every interval through which the neighbor cell can be entered from the current
        * entrance to the queue.
        * The algorithm calls this method in every step for every neighbor of the current cell to
        * collect all next possible entrances for the current path. This path consists of several entrances where each knows
        * the entrance they were entered through.
        * <p>
        * After calculating all possible enter intervals to the given neighbor cell, each interval gets rated with costs.
        * If there already is an entrance for the neighbor cell whose interval is the same as one of these intervals, this
        * entrance will be used and re-enqueued, so the path search can still reach it. The current entrance is set as its
        * predecessor within the current path and its enter interval and costs will be updated.
        * If there is an entrance for the neighbor cell whose interval is intersected by a current interval, new entrances
        * will be created with the new enter intervals and enqueued. The same happens if there is no entrance that matches
        * one of the current intervals, yet. Costs will be added.
        * If there are some entries afterwards, that are intersected by the current interval and have higher costs, they
        * will be removed from the queue.
        * </p>
        * @param {yfiles.router.polyline.CellEntrance} currentEntrance the current cell entrance
        * @param {yfiles.router.polyline.PartitionCell} neighborCell the neighbor cell that is handled.
        * @param {yfiles.router.polyline.PathSearchContext} context context information
        * @see {@link yfiles.router.polyline.PathSearch#calculateCosts}
        * @see {@link yfiles.router.polyline.PathSearch#calculateHeuristicCosts}
        */
        handleNeighbor(currentEntrance:yfiles.router.polyline.CellEntrance,neighborCell:yfiles.router.polyline.PartitionCell,context:yfiles.router.polyline.PathSearchContext):void;
        /**
        * Returns the costs for getting from the current {@link yfiles.router.polyline.CellEntrance} to the neighboring {@link yfiles.router.polyline.PartitionCell} using
        * different enter intervals.
        * It is called by {@link yfiles.router.polyline.PathSearch#handleNeighbor}
        * to determine the costs for all {@link yfiles.router.polyline.CellEntrance}s that it will create and enqueue afterwards.
        * <p>
        * The costs for the given enter intervals are retrieved from all registered {@link yfiles.router.polyline.PathSearchExtension PathSearchExtension}s. The calculation stops when it reaches the given maximum cost value.
        * </p>
        * @param {yfiles.router.polyline.CellEntrance} currentEntrance the current cell entrance.
        * @param {yfiles.router.polyline.PartitionCell} enteredCell the cell to enter.
        * @param {yfiles.router.polyline.OrthogonalInterval[]} enterIntervals the different entering intervals of the entered cell.
        * @param {yfiles.router.polyline.EdgeCellInfo[]} lastEdgeCellInfos information about how the last cell was crossed.
        * @param {yfiles.router.polyline.PathSearchContext} context context information.
        * @param {number[]} costs 
        * The array the calculated costs for entering the neighbor cell via the according enter intervals
        * shall be written to.
        * @param {number[]} maxAllowedCosts 
        * the maximum costs an enter interval may induce. If this cost is exceeded, no further
        * additional costs for this interval are calculated. Note that the entries in this
        * array get modified during cost calculation
        * @see {@link yfiles.router.polyline.PathSearchExtension#calculateCosts}
        */
        calculateCosts(currentEntrance:yfiles.router.polyline.CellEntrance,enteredCell:yfiles.router.polyline.PartitionCell,enterIntervals:yfiles.router.polyline.OrthogonalInterval[],lastEdgeCellInfos:yfiles.router.polyline.EdgeCellInfo[],context:yfiles.router.polyline.PathSearchContext,costs:number[],maxAllowedCosts:number[]):void;
        /**
        * Returns estimated costs for the rest of the path when using the given {@link yfiles.router.polyline.CellEntrance} for the next step in
        * path search.
        * It is called by {@link yfiles.router.polyline.PathSearch#handleNeighbor}
        * to determine the heuristic part of the costs the entrance will be enqueued with.
        * <p>
        * The heuristic costs for the given entrance are retrieved from all registered {@link yfiles.router.polyline.PathSearchExtension PathSearchExtension}s.
        * </p>
        * @param {yfiles.router.polyline.CellEntrance} entrance The current entrance.
        * @param {yfiles.router.polyline.PathSearchContext} context Context information.
        * @return {number} the heuristic costs for the rest of the past if using the given entrance.
        * @see {@link yfiles.router.polyline.PathSearchExtension#calculateHeuristicCosts}
        */
        calculateHeuristicCosts(entrance:yfiles.router.polyline.CellEntrance,context:yfiles.router.polyline.PathSearchContext):number;
      }
      var PathSearch:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        */
        new ():yfiles.router.polyline.PathSearch;
      };
      /**
      * A <code>Path</code> represents the result of a path search as a list of consecutive {@link yfiles.router.polyline.CellEntrance}s.
      * A Path
      * starts with an entrance into a {@link yfiles.router.polyline.PartitionCell} of the source node and ends with one into a {@link yfiles.router.polyline.PartitionCell} of the target node.
      * @see {@link yfiles.router.polyline.PathSearch}
      * @see {@link yfiles.router.polyline.PathSearchResult}
      */
      export interface Path extends Object{
        /**
        * The edge this path was calculated for.
        */
        edge:yfiles.algorithms.Edge;
        /**
        * The overall cost of this path.
        */
        cost:number;
        /**
        * Returns the {@link yfiles.router.polyline.CellEntrance} at the given position of this path.
        * @param {number} position 
        * position of the {@link yfiles.router.polyline.CellEntrance} to return
        * @return {yfiles.router.polyline.CellEntrance} 
        * the {@link yfiles.router.polyline.CellEntrance} at the given position of this path
        */
        getEntrance(position:number):yfiles.router.polyline.CellEntrance;
        /**
        * Replaces the {@link yfiles.router.polyline.CellEntrance} at the given position of this path with the given {@link yfiles.router.polyline.CellEntrance}.
        * @param {number} position 
        * position of the {@link yfiles.router.polyline.CellEntrance} to replace
        * @param {yfiles.router.polyline.CellEntrance} entrance 
        * {@link yfiles.router.polyline.CellEntrance} to be stored at the given position
        */
        setEntrance(position:number,entrance:yfiles.router.polyline.CellEntrance):void;
        /**
        * Returns the position of the first occurrence of the given {@link yfiles.router.polyline.CellEntrance} in this path, or -1 if this path
        * does not contain the {@link yfiles.router.polyline.CellEntrance}.
        * @param {yfiles.router.polyline.CellEntrance} entrance 
        * {@link yfiles.router.polyline.CellEntrance} to search for
        * @return {number} 
        * the position of the first occurrence of the given {@link yfiles.router.polyline.CellEntrance} in this path, or -1 if this path
        * does not contain the {@link yfiles.router.polyline.CellEntrance}
        */
        positionOf(entrance:yfiles.router.polyline.CellEntrance):number;
        /**
        * Returns the count of {@link yfiles.router.polyline.CellEntrance} objects this path consists of.
        * @return {number} 
        * The count of {@link yfiles.router.polyline.CellEntrance} objects this path consists of.
        */
        length():number;
      }
      var Path:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        * @param {yfiles.algorithms.Edge} edge The edge the path was calculated for.
        * @param {yfiles.algorithms.IList} entrances 
        * A list of {@link yfiles.router.polyline.CellEntrance} objects describing the edge path from source node to target node.
        * @param {number} cost The overall cost of this path.
        */
        new (edge:yfiles.algorithms.Edge,entrances:yfiles.algorithms.IList,cost:number):yfiles.router.polyline.Path;
      };
      /**
      * A horizontal or vertical {@link yfiles.router.polyline.Interval} that additionally stores a y- (in the horizontal case) or x-coordinate (in
      * the vertical case).
      * <p>
      * During a {@link yfiles.router.polyline.PathSearch}, orthogonal intervals are used to describe where an edge enters or leaves a
      * {@link yfiles.router.polyline.PartitionCell}.
      * </p>
      * @see {@link yfiles.router.polyline.PathSearch}
      */
      export interface OrthogonalInterval extends Object{
        /**
        * Determines whether the orthogonal interval is oriented vertically.
        */
        vertical:boolean;
        /**
        * The lower bound of the orthogonal interval.
        */
        min:number;
        /**
        * The upper bound of the orthogonal interval.
        */
        max:number;
        /**
        * The length of the orthogonal interval.
        * @see {@link yfiles.router.polyline.Interval#size}
        */
        size:number;
        /**
        * The range of this orthogonal interval.
        */
        range:yfiles.router.polyline.Interval;
        /**
        * The vertical coordinate for horizontal intervals or the horizontal coordinate for vertical intervals,
        * respectively.
        */
        location:number;
        /**
        * The center of this orthogonal interval in the 2d-coordinate system.
        */
        center:yfiles.algorithms.YPoint;
        /**
        * Determines whether this orthogonal interval crosses the given one.
        * <p>
        * The orthogonal intervals must have different orientations.
        * </p>
        * @param {yfiles.router.polyline.OrthogonalInterval} other The other orthogonal interval.
        * @return {boolean} <code>true</code> if this orthogonal interval crosses the given one, <code>false</code> otherwise.
        * @throws {yfiles.system.ArgumentException} if orthogonal intervals have same orientation
        */
        crosses(other:yfiles.router.polyline.OrthogonalInterval):boolean;
        /**
        * Returns the distance of the {@link yfiles.router.polyline.OrthogonalInterval#range}s of this orthogonal interval and the given orthogonal interval.
        * <p>
        * The orthogonal intervals must have same orientation.
        * </p>
        * @param {yfiles.router.polyline.OrthogonalInterval} other The second orthogonal interval.
        * @return {number} 
        * <code>0</code> if the orthogonal intervals {@link yfiles.router.polyline.OrthogonalInterval#intersects}, otherwise the
        * minimal distance between the orthogonal intervals.
        * @throws {yfiles.system.ArgumentException} if the orthogonal intervals have different orientations
        */
        distanceTo(other:yfiles.router.polyline.OrthogonalInterval):number;
        /**
        * Returns the manhattan distance of this orthogonal interval and the given orthogonal interval.
        * <p>
        * If both intervals have the same orientation, the manhattan distance is the sum of the distance between the intervals'
        * ranges and the distance between the intervals' locations.
        * </p>
        * <p>
        * If the intervals have different orientations, the manhattan distance is the sum of the distances between one
        * interval's range with the other interval's location.
        * </p>
        * @param {yfiles.router.polyline.OrthogonalInterval} other The second orthogonal interval.
        * @return {number} The manhattan distance between this interval and the given one.
        */
        manhattanDistanceTo(other:yfiles.router.polyline.OrthogonalInterval):number;
        /**
        * Checks if this orthogonal interval intersects the given orthogonal interval.
        * <p>
        * Orthogonal intervals intersect each other, if their ranges intersect each other. The location of both orthogonal
        * intervals is ignored. The orthogonal intervals must have same orientation.
        * </p>
        * @param {yfiles.router.polyline.OrthogonalInterval} other the second orthogonal interval.
        * @return {boolean} <code>true</code> if both orthogonal intervals intersect, <code>false</code> otherwise.
        * @throws {yfiles.system.ArgumentException} if the orthogonal intervals have different orientations
        * @see {@link yfiles.router.polyline.PartitionCell}
        */
        intersects(other:yfiles.router.polyline.OrthogonalInterval):boolean;
        /**
        * Checks if this orthogonal interval intersects the given orthogonal interval and the intersection has a minimal
        * size of <code>minIntersection</code>.
        * <p>
        * Orthogonal intervals intersect each other, if their ranges intersect each other by at least
        * <code>minIntersection</code>. The location of both orthogonal intervals is ignored. The orthogonal intervals must
        * have same orientation.
        * </p>
        * @param {yfiles.router.polyline.OrthogonalInterval} other the second orthogonal interval.
        * @param {number} minIntersection The minimal size of the intersection.
        * @return {boolean} <code>true</code> if both orthogonal intervals intersect, <code>false</code> otherwise.
        * @throws {yfiles.system.ArgumentException} if the orthogonal intervals have different orientations
        * @see {@link yfiles.router.polyline.PartitionCell}
        */
        intersectsWithOtherAndMinIntersection(other:yfiles.router.polyline.OrthogonalInterval,minIntersection:number):boolean;
        /**
        * Checks if the given orthogonal interval covers this one fully.
        * <p>
        * The given orthogonal interval covers this orthogonal interval, if this interval's range is covered by the given
        * interval's range. The location of both orthogonal intervals is ignored. The orthogonal intervals must have same
        * orientation.
        * </p>
        * @param {yfiles.router.polyline.OrthogonalInterval} other The other orthogonal interval
        * @return {boolean} 
        * <code>true</code>, if this orthogonal interval is fully covered by the other orthogonal interval,
        * <code>false</code> otherwise.
        * @throws {yfiles.system.ArgumentException} if the orthogonal intervals have different orientations
        * @see {@link yfiles.router.polyline.PartitionCell}
        */
        coveredBy(other:yfiles.router.polyline.OrthogonalInterval):boolean;
        /**
        * Checks if this orthogonal interval and the given orthogonal interval cover the same range.
        * <p>
        * If both orthogonal intervals cover the same range, they are considered same. The location of both orthogonal
        * intervals is ignored. The orthogonal intervals must have same orientation.
        * </p>
        * @param {yfiles.router.polyline.OrthogonalInterval} other The second orthogonal interval
        * @return {boolean} <code>true</code>, if the orthogonal intervals cover the same range, <code>false</code> otherwise.
        * @throws {yfiles.system.ArgumentException} if the orthogonal intervals have different orientations
        * @see {@link yfiles.router.polyline.PartitionCell}
        */
        hasSameRange(other:yfiles.router.polyline.OrthogonalInterval):boolean;
        toString():string;
      }
      var OrthogonalInterval:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance using the <code>from</code> and <code>to</code> value as interval bounds.
        * @param {number} from the start of the interval bounds
        * @param {number} to the end of the interval bounds
        * @param {number} location the location in the 2D coordinate system
        * @param {boolean} isVertical 
        * <code>true</code>, if the orthogonal interval is vertical; <code>false</code>, if it is
        * horizontal vertical.
        */
        FromCoordinates:{
          new (from:number,to:number,location:number,isVertical:boolean):yfiles.router.polyline.OrthogonalInterval;
        };
        /**
        * Creates a new instance using the <code>range</code> as interval bounds.
        * @param {yfiles.router.polyline.Interval} range the range
        * @param {number} location the location in the 2D coordinate system
        * @param {boolean} isVertical 
        * <code>true</code>, if the orthogonal interval is vertical; <code>false</code>, if it is
        * horizontal.
        * @throws {yfiles.system.ArgumentException} if range is <code>null</code>
        */
        new (range:yfiles.router.polyline.Interval,location:number,isVertical:boolean):yfiles.router.polyline.OrthogonalInterval;
        /**
        * Calculates the intersection of the given orthogonal intervals.
        * <p>
        * If the created orthogonal interval is vertical, it will have the same horizontal location as i2 and the shared
        * vertical range of both intervals. If it is horizontal, it will have the same vertical location as i2 and the shared
        * horizontal range of both intervals. The orthogonal intervals must have same orientation.
        * </p>
        * @param {yfiles.router.polyline.OrthogonalInterval} i1 The first orthogonal interval.
        * @param {yfiles.router.polyline.OrthogonalInterval} i2 The second orthogonal interval.
        * @return {yfiles.router.polyline.OrthogonalInterval} The shared orthogonal interval of both given orthogonal intervals.
        * @throws {yfiles.system.ArgumentException} if the orthogonal intervals have different orientations
        * @see {@link yfiles.router.polyline.OrthogonalInterval#intersectsWithOtherAndMinIntersection}
        */
        calculateIntersection(i1:yfiles.router.polyline.OrthogonalInterval,i2:yfiles.router.polyline.OrthogonalInterval):yfiles.router.polyline.OrthogonalInterval;
        /**
        * Calculates the union of the given orthogonal intervals.
        * <p>
        * If the created orthogonal interval is vertical, it will have the same horizontal location as i2 and the shared
        * vertical range of both orthogonal intervals. If it is horizontal, it will have the same vertical location as i2 and
        * the shared vertical range of both orthogonal intervals. The orthogonal intervals must have same orientation.
        * </p>
        * @param {yfiles.router.polyline.OrthogonalInterval} i1 The first orthogonal interval.
        * @param {yfiles.router.polyline.OrthogonalInterval} i2 The second orthogonal interval.
        * @return {yfiles.router.polyline.OrthogonalInterval} The union of both given orthogonal intervals.
        * @throws {yfiles.system.ArgumentException} if the orthogonal intervals have different orientations
        * @see {@link yfiles.router.polyline.OrthogonalInterval#intersectsWithOtherAndMinIntersection}
        */
        calculateUnion(i1:yfiles.router.polyline.OrthogonalInterval,i2:yfiles.router.polyline.OrthogonalInterval):yfiles.router.polyline.OrthogonalInterval;
      };
      /**
      * Provides the cost penalties that are applied for violating restrictions during a path search.
      * <p>
      * The {@link yfiles.router.polyline.PathSearch} calculates the 'shortest' path from a source to a target at which 'shortest' path means the
      * path with the lowest costs. Costs results from violations of restrictions that are defined by the different {@link yfiles.router.polyline.PathSearchExtension}s. This class defines penalties for the various violations. The path search can be
      * adapted to specific needs by varying these penalties. In order to avoid a certain violation, the appropriate penalty
      * must be increased.
      * </p>
      */
      export interface PenaltySettings extends Object{
        /**
        * The penalty for the edge length.
        * This penalty will make long routes more expensive than short routes so edges
        * will be routed preferably short.
        * <p>
        * Increasing edge length penalty will raise the importance of short edges in relation to  all other penalties while
        * decreasing this penalty will raise the importance of all other restrictions. A high edge length penalty will
        * result in routes that have less bends and more edge crossings to keep the edge as short as possible.
        * </p>
        * <p>
        * {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_EDGE_LENGTHS} is a predefined configuration of <code>PenaltySettings</code> where short
        * edges are preferred over a small amount of bends and edge crossings.
        * </p>
        * <p>
        * By default this value is set to <code>1</code>.
        * The value must be <code> &gt;= 0</code>, otherwise the default value will be assigned.
        * </p>
        */
        edgeLengthPenalty:number;
        /**
        * The penalty for an edge bend.
        * This penalty will make routes with many bends more expensive than routes with
        * few or no bends, so edges will have preferably few bends.
        * <p>
        * Increasing bend penalty will raise the importance of avoiding bends in relation to other penalties while
        * decreasing this penalty will raise the importance of all other restrictions. A high bend penalty will result in
        * routes that will preferably cross other edges instead of bending to avoid other edges.
        * When rising edge bend penalty, the resulting route will have more edge crossings. Note that a very low bend
        * penalty (less than 1) can lead to squiggles when the algorithm tries to avoid more expensive restrictions.
        * </p>
        * <p>
        * {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_EDGE_BENDS} is a predefined configuration of <code>PenaltySettings</code> where bends are
        * expensive and more other edges will be crossed to avoid bending.
        * </p>
        * <p>
        * By default this value is set to <code>3</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        */
        bendPenalty:number;
        /**
        * The penalty for a crossing of two edges.
        * This penalty will make routes that cross many other edges more
        * expensive than routes that only cross some other edges or no edges at all, so edges preferably won't cross other
        * edges.
        * <p>
        * Increasing edge crossing penalty will raise the importance of avoiding edge crossings in relation to other
        * penalties while decreasing this penalty will raise the importance of all other restrictions.
        * When rising edge crossing penalty, the resulting route will be longer and have more bends because crossing other edges
        * needs to be avoided.
        * </p>
        * <p>
        * {@link yfiles.router.polyline.PenaltySettings#OPTIMIZATION_EDGE_CROSSINGS} is a predefined configuration of <code>PenaltySettings</code> where edge
        * crossings are expensive and the routes get favourably longer with more bends to avoid crossing other edges.
        * </p>
        * <p>
        * By default this value is set to <code>1</code>.
        * The value must be <code> &gt;= 0</code>, otherwise the default value will be assigned.
        * </p>
        */
        edgeCrossingPenalty:number;
        /**
        * The penalty for an edge crossing a regular node.
        * This penalty will make routes that cross normal nodes
        * more expensive than routes that avoid crossing nodes, so edges won't preferably cross any nodes.
        * <p>
        * Increasing node crossing penalty will raise the importance of avoiding node crossings in relation to other
        * penalties while decreasing this penalty will raise the importance of all other restrictions.
        * </p>
        * <p>
        * Node crossing penalty should always be one of the highest penalties to make sure that edges go around nodes.
        * </p>
        * <p>
        * By default this value is set to <code>30</code>.
        * The value must be <code> &gt;= 0</code>, otherwise the default value will be assigned.
        * </p>
        */
        nodeCrossingPenalty:number;
        /**
        * The penalty for an edge crossing a group node.
        * This penalty will make routes that cross group nodes more
        * expensive than routes that avoid crossing group nodes, so edges won't preferably cross any group nodes.
        * <p>
        * Increasing group node crossing penalty will raise the importance of avoiding group node crossings in relation to
        * other penalties while decreasing this penalty will raise the importance of all other restrictions.
        * </p>
        * <p>
        * Like {@link yfiles.router.polyline.PenaltySettings#nodeCrossingPenalty  node crossing penalty}, this penalty should be one of the highest penalties
        * to make sure that these nodes are avoided. But as group nodes may be very large it might be useful to allow group
        * node crossings to achieve more direct edge routes.
        * </p>
        */
        groupNodeCrossingPenalty:number;
        /**
        * The penalty for an edge crossing a node label.
        * <b>Getter:</b>This penalty will make routes that cross node labels more
        * expensive than routes that avoid crossing node labels, so edges won't preferably cross any node labels.
        * <p>
        * Increasing node label crossing penalty will raise the importance of avoiding node labels crossings in relation to
        * other penalties while decreasing this penalty will raise the importance of all other restrictions. A high label
        * crossing penalty will cause edges to bend more often to avoid passing straight through the label.
        * </p>
        * <p>
        * The crossing penalty can be weighted for each label individually using the
        * {@link yfiles.router.polyline.EdgeRouter#LABEL_CROSSING_COST_FACTOR_DP_KEY}.
        * </p>
        * <p>
        * Use {@link yfiles.router.polyline.EdgeRouter#considerNodeLabels} to set whether node labels should be considered when
        * routing the edges at all.
        * </p>
        * <p>
        * Note that this only applies to labels that are placed outside the bounds of their owner nodes as long as the
        * {@link yfiles.router.polyline.PenaltySettings#nodeCrossingPenalty  node crossing penalty} is higher than the node label crossing penalty. Unless
        * the route connects from outside a group to one of its inner nodes, then the node label will also be considered.
        * </p>
        * <b>Setter:</b>This penalty will make routes that cross node labels more
        * expensive than routes that avoid crossing node labels, so edges won't preferably cross any node labels.
        * <p>
        * Increasing node label crossing penalty will raise the importance of avoiding node labels crossings in relation to
        * other penalties while decreasing this penalty will raise the importance of all other restrictions. A high label
        * crossing penalty will cause edges to bend more often to avoid passing straight through the label.
        * </p>
        * <p>
        * Use {@link yfiles.router.polyline.EdgeRouter#considerNodeLabels} to set whether node labels should be considered when
        * routing the edges.
        * </p>
        * <p>
        * Note that this only applies to labels that are placed outside the bounds of their owner nodes as long as the
        * {@link yfiles.router.polyline.PenaltySettings#nodeCrossingPenalty  node crossing penalty} is higher than the node label crossing penalty. Unless
        * the route connects from outside a group to one of its inner nodes, then the node label will also be considered.
        * </p>
        * <p>
        * By default this value is set to <code>13</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#considerNodeLabels}
        * @see {@link yfiles.router.polyline.EdgeRouter#considerNodeLabels}
        */
        nodeLabelCrossingPenalty:number;
        /**
        * The penalty for an edge crossing an edge label.
        * <b>Getter:</b>This penalty will make routes that cross edge labels of
        * fixed edges more expensive than routes that avoid crossing edge labels, so edges won't preferably cross any edge labels
        * that belong to fixed edges.
        * <p>
        * Increasing edge label crossing penalty will raise the importance of avoiding edge labels crossings in relation to
        * other penalties while decreasing this penalty will raise the importance of all other restrictions. A high label
        * crossing penalty will cause edges to bend more often to avoid passing straight through the label.
        * </p>
        * <p>
        * The crossing penalty can be weighted for each label individually using the
        * {@link yfiles.router.polyline.EdgeRouter#LABEL_CROSSING_COST_FACTOR_DP_KEY}.
        * </p>
        * <p>
        * Use {@link yfiles.router.polyline.EdgeRouter#considerEdgeLabels} to set whether edge labels should be considered when
        * routing the edges.
        * </p>
        * <b>Setter:</b>This penalty will make routes that cross edge labels of
        * fixed edges more expensive than routes that avoid crossing edge labels, so edges won't preferably cross any edge labels
        * that belong to fixed edges.
        * <p>
        * Increasing edge label crossing penalty will raise the importance of avoiding edge labels crossings in relation to
        * other penalties while decreasing this penalty will raise the importance of all other restrictions. A high label
        * crossing penalty will cause edges to bend more often to avoid passing straight through the label.
        * </p>
        * <p>
        * Use {@link yfiles.router.polyline.EdgeRouter#considerEdgeLabels} to set whether edge labels should be considered when
        * routing the edges.
        * </p>
        * <p>
        * By default this value is set to <code>13</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#considerEdgeLabels}
        * @see {@link yfiles.router.polyline.EdgeRouter#considerEdgeLabels}
        */
        edgeLabelCrossingPenalty:number;
        /**
        * The penalty for violations of the minimal distance between any edge and any normal node side.
        * This
        * penalty will make routes that pass normal nodes too close more expensive than routes that keep the specified
        * minimal node to edge distance.
        * <p>
        * Increasing minimal node to edge distance penalty will raise the importance of keeping the minimal distance to
        * nodes while decreasing this penalty will raise the importance of all other restrictions. A high penalty for
        * violating the minimal distance between edges and nodes will produce edges that rather use a long route around
        * nodes to keep the specified distance than pass through a small channel between two nodes.
        * </p>
        * <p>
        * By default this value is set to <code>10</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#minimalNodeToEdgeDistance}
        * @see {@link yfiles.router.polyline.EdgeRouter#minimalNodeToEdgeDistance}
        */
        minimalNodeToEdgeDistancePenalty:number;
        /**
        * The penalty for violations of the minimal distance between any edge and any group node side.
        * This penalty will
        * make routes that pass group nodes too close more expensive than routes that keep the specified minimal node to edge
        * distance.
        * <p>
        * Increasing minimal group node to edge distance penalty will raise the importance of keeping the minimal
        * distance to group nodes while decreasing this penalty will raise the importance of all other restrictions. A high
        * penalty for violating the minimal distance between edges and group nodes will produce edges that rather use a
        * long route around group nodes to keep the specified distance than pass through a small channel between two group
        * nodes.
        * </p>
        * <p>
        * Use {@link yfiles.router.polyline.EdgeRouter#minimalNodeToEdgeDistance} to set the minimal distance.
        * </p>
        * <p>
        * By default this value is set to <code>10</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#minimalNodeToEdgeDistance}
        * @see {@link yfiles.router.polyline.EdgeRouter#minimalNodeToEdgeDistance}
        */
        minimalGroupNodeToEdgeDistancePenalty:number;
        /**
        * The penalty for violations of the minimal distance between any two edges.
        * This penalty will make routes that
        * pass other edges too close more expensive than routes that keep the specified minimal edge to edge distance.
        * <p>
        * Increasing minimal edge to edge distance penalty will raise the importance of keeping the minimal distance to
        * other edges while decreasing this penalty will raise the importance of all other restrictions.
        * When this penalty has a high value, edges will keep the specified distance. This may also reduce the number of
        * edge that pass through a small channel between nodes. So, if such a channel is part of the shortest routes for
        * many edges, some of them will take a longer way.
        * </p>
        * <p>
        * Use {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalEdgeToEdgeDistance} to set the minimal distance for a certain
        * edge to any other edge.
        * </p>
        * <p>
        * By default this value is set to <code>5</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalEdgeToEdgeDistance}
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalEdgeToEdgeDistance}
        */
        minimalEdgeToEdgeDistancePenalty:number;
        /**
        * The penalty for violations of the minimal distance the edge shall keep from node corners when entering or
        * leaving the node.
        * This penalty will make routes that end too close to the corner of their source or target node
        * more expensive than routes that keep the specified minimal node corner distance.
        * <p>
        * Increasing node corner distance penalty will raise the importance of keeping the minimal distance to the corner
        * of the adjacent nodes while decreasing this penalty will raise the importance of all other restrictions.
        * </p>
        * <p>
        * Use {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalNodeCornerDistance} to set the minimal distance for a certain
        * edge.
        * </p>
        * <p>
        * By default this value is set to <code>6</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalNodeCornerDistance}
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalNodeCornerDistance}
        */
        minimalNodeCornerDistancePenalty:number;
        /**
        * The penalty for violations of the minimal length of the first and last segment of an edge.
        * This penalty
        * will make routes whose first/last bend is too close to their source or target node more expensive than routes that
        * keep the specified minimal first/last segment length.
        * <p>
        * Increasing minimal first last segment length penalty will raise the importance of keeping the first and last
        * segment as long as they fit the minimal first/last segment length while decreasing this penalty will raise the
        * importance of all other restrictions.
        * </p>
        * <p>
        * Use {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalFirstSegmentLength} to set the minimal length of the first
        * segment and {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalLastSegmentLength} to set the minimal length of the
        * last segment of a certain edge.
        * </p>
        * <p>
        * By default this value is set to <code>12</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalFirstSegmentLength}
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalLastSegmentLength}
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalFirstSegmentLength}
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#minimalLastSegmentLength}
        */
        minimalFirstLastSegmentLengthPenalty:number;
        /**
        * The penalty for an edge bend being closer to the border of the source node, the target node or one of their
        * ancestor group nodes than the minimal node to edge distance.
        * This penalty will make routes that bend too close to
        * their source or target node more expensive than routes that keep the specified minimal node to edge distance.
        * <p>
        * Increasing bends in node to edge distance penalty will raise the importance of avoiding bends that violate the
        * minimal node to edge distance while decreasing this penalty will raise the importance of all other restrictions.
        * This penalty supports {@link yfiles.router.polyline.EdgeRouter#minimalNodeToEdgeDistance}. In case the path search finally reaches
        * the target node, the minimal node to edge distance for this node must be violated. Punishing bends too close to
        * the node forces the edge to directly cross this distance and connect to the node.
        * </p>
        * <p>
        * By default this value is set to <code>10</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned. In principle, this penalty can always be set to the same value as
        * {@link yfiles.router.polyline.PenaltySettings#minimalNodeToEdgeDistancePenalty} since they are used for the same feature.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeRouter#minimalNodeToEdgeDistance}
        * @see {@link yfiles.router.polyline.EdgeRouter#minimalNodeToEdgeDistance}
        */
        bendsInNodeToEdgeDistancePenalty:number;
        /**
        * The penalty for violation the monotonic path restrictions of an edge.
        * This penalty will make routes with
        * detours more expensive than routes that stay monotone.
        * <p>
        * Increasing monotony violation penalty will raise the importance of avoiding detours in the specified direction
        * while decreasing this penalty will raise the importance of all other restrictions.
        * </p>
        * <p>
        * Use {@link yfiles.router.polyline.EdgeLayoutDescriptor#monotonicPathRestriction} to set the monotonic path restrictions of a
        * certain edge.
        * </p>
        * <p>
        * By default this value is set to <code>14</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#monotonicPathRestriction}
        * @see {@link yfiles.router.polyline.EdgeLayoutDescriptor#monotonicPathRestriction}
        */
        monotonyViolationPenalty:number;
        /**
        * The penalty for an edge leaving and reentering in the same partition grid cell.
        * This penalty will make
        * routes that reenter the same partition grid cell more expensive than routes taking a more direct way.
        * <p>
        * Increasing partition grid reentrance penalty will raise the importance of taking the most direct way through the
        * partition grid while decreasing this penalty will raise the importance of all other restrictions.
        * </p>
        * <p>
        * By default this value is set to <code>7</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        */
        partitionGridCellReentrancePenalty:number;
        /**
        * The penalty if an edge does not comply with its{@link yfiles.layout.PortCandidate}s or {@link yfiles.layout.PortConstraint}s.
        * This penalty will make routes that start or end on a point that doesn't answer to its
        * port constraints more expensive than routes that obey them.
        * <p>
        * Increasing port violation penalty will raise the importance of keeping port constraints while decreasing this
        * penalty will raise the importance of all other restrictions. It is recommended to have high penalties for port
        * violation since the constraints loose purpose if they are disregarded.
        * </p>
        * <p>
        * By default this value is set to <code>115</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        * @see {@link yfiles.layout.PortCandidate}
        * @see {@link yfiles.layout.PortConstraint}
        * @see {@link yfiles.layout.PortCandidate}
        * @see {@link yfiles.layout.PortConstraint}
        */
        portViolationPenalty:number;
        /**
        * The penalty for an edge with a group id that is not grouped at source or target side.
        * This penalty will make
        * routes for grouped edges that don't use partly the same path as the other edges in this group more expensive than
        * routes that stick to the group.
        * <p>
        * Increasing invalid edge grouping penalty will raise the importance of grouping edges with the same group id while
        * decreasing this penalty will raise the importance of all other restrictions.
        * As edge groups require that the route of an edge belonging to an edge group stays partly identical to the other
        * edges of the group, the route may not be the optimal way regarding the other restrictions. To keep the edges
        * together as long as possible this penalty should be higher than most others.
        * </p>
        * <p>
        * Grouped edges have the same source or target group id assigned in the data provider registered at the graph with
        * the {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY} or
        * {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY} key.
        * </p>
        * <p>
        * By default this value is set to <code>25</code>. The value must be <code> &gt;= 0</code>, otherwise the default
        * value will be assigned.
        * </p>
        * @see {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY}
        * @see {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}
        * @see {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY}
        * @see {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}
        */
        invalidEdgeGroupingPenalty:number;
        /**
        * Creates a copy of this instance.
        * Uses {@link yfiles.router.polyline.PenaltySettings#newInstance} to get a new instance.
        * @return {yfiles.router.polyline.PenaltySettings} a copy of this instance
        */
        createCopy():yfiles.router.polyline.PenaltySettings;
        /**
        * Factory method, which is used by {@link yfiles.router.polyline.PenaltySettings#createCopy}.
        * Subclasses can override this method in order to return a
        * more specialized version.
        * @return {yfiles.router.polyline.PenaltySettings} 
        * a specialized {@link yfiles.router.polyline.PenaltySettings}
        */
        newInstance():yfiles.router.polyline.PenaltySettings;
      }
      var PenaltySettings:{
        $class:yfiles.lang.Class;
        /**
        * Optimization strategy that balances bends and edge crossings in the edge routes.
        * These are the default settings.
        */
        OPTIMIZATION_BALANCED:yfiles.router.polyline.PenaltySettings;
        /**
        * Optimization strategy that minimizes bends in the edge routes.
        * Edges may cross other edges to prevent bending to
        * run around them.
        */
        OPTIMIZATION_EDGE_BENDS:yfiles.router.polyline.PenaltySettings;
        /**
        * Optimization strategy that minimizes edge crossings in the edge routes.
        * This may cause more bends.
        */
        OPTIMIZATION_EDGE_CROSSINGS:yfiles.router.polyline.PenaltySettings;
        /**
        * Optimization strategy that minimizes the length of the edge routes.
        * There may be more edge crossings.
        */
        OPTIMIZATION_EDGE_LENGTHS:yfiles.router.polyline.PenaltySettings;
        /**
        * Creates a new instance.
        */
        new ():yfiles.router.polyline.PenaltySettings;
      };
      /**
      * Obstacles are used by implementations of {@link yfiles.router.polyline.IObstaclePartition} to subdivide an area into {@link yfiles.router.polyline.PartitionCell}s.
      */
      export interface Obstacle extends Object{
        /**
        * The bounds of the obstacle.
        */
        bounds:yfiles.algorithms.YRectangle;
        /**
        * The additional data related to the obstacle.
        */
        data:Object;
      }
      var Obstacle:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        * @param {yfiles.algorithms.YRectangle} bounds The bounds of the obstacle.
        * @param {Object} data The additional data related to the obstacle.
        */
        new (bounds:yfiles.algorithms.YRectangle,data:Object):yfiles.router.polyline.Obstacle;
      };
      /**
      * Provides context information that is useful for the path search algorithm.
      * <p>
      * Most notably, the context provides access to the edge that is currently being routed (see {@link yfiles.router.polyline.PathSearchContext#currentEdge}).
      * </p>
      */
      export interface PathSearchContext extends Object{
        /**
        * The path search that uses this context.
        */
        pathSearch:yfiles.router.polyline.PathSearch;
        /**
        * The configuration used for the path search.
        */
        configuration:yfiles.router.polyline.PathSearchConfiguration;
        /**
        * The edges that are routed.
        */
        edges:yfiles.algorithms.IEdgeCursor;
        /**
        * Sets the list of edges that shall be routed.
        * @param {yfiles.algorithms.EdgeList} edges The list of edges that shall be routed.
        */
        setEdges(edges:yfiles.algorithms.EdgeList):void;
        /**
        * The edge that is routed.
        * <p>
        * This edge is one of those in {@link yfiles.router.polyline.PathSearchContext#edges}.
        * </p>
        */
        currentEdge:yfiles.algorithms.Edge;
        /**
        * The edge layout descriptor for the{@link yfiles.router.polyline.PathSearchContext#currentEdge} containing edge specific settings for the path
        * search.
        */
        currentEdgeLayoutDescriptor:yfiles.router.polyline.EdgeLayoutDescriptor;
        /**
        * Returns the number of all cells that are covered by the source node of the {@link yfiles.router.polyline.PathSearchContext#currentEdge}.
        * @return {number} 
        * the number of all cells that are covered by the source node of the {@link yfiles.router.polyline.PathSearchContext#currentEdge}
        */
        sourceCellCount():number;
        /**
        * Adds an additional source cell of the {@link yfiles.router.polyline.PathSearchContext#currentEdge} if it is not already contained in the list of
        * source cells.
        * @param {yfiles.router.polyline.PartitionCell} cell The new source cell to add.
        * @see {@link yfiles.router.polyline.PathSearchContext#sourceCellCount}
        * @see {@link yfiles.router.polyline.PathSearchContext#getSourceCell}
        */
        addSourceCell(cell:yfiles.router.polyline.PartitionCell):void;
        /**
        * Returns the source cell with the given index in the list of all cells that are covered by the source node of the
        * {@link yfiles.router.polyline.PathSearchContext#currentEdge}.
        * @return {yfiles.router.polyline.PartitionCell} 
        * the source cell with the given index in the list of all cells that are covered by the source node of the
        * {@link yfiles.router.polyline.PathSearchContext#currentEdge}.
        */
        getSourceCell(index:number):yfiles.router.polyline.PartitionCell;
        /**
        * Determines if the given cell is a source cell of the {@link yfiles.router.polyline.PathSearchContext#currentEdge}.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell to be tested.
        * @return {boolean} <code>true</code> if the given cell is in the list of source cells, <code>false</code> otherwise.
        * @see {@link yfiles.router.polyline.PathSearchContext#sourceCellCount}
        * @see {@link yfiles.router.polyline.PathSearchContext#getSourceCell}
        */
        isSourceCell(cell:yfiles.router.polyline.PartitionCell):boolean;
        /**
        * An artificial partition cell with the size of the bounding box of all source cells of the{@link yfiles.router.polyline.PathSearchContext#currentEdge}.
        */
        combinedSourceCell:yfiles.router.polyline.PartitionCell;
        /**
        * Returns the number of all cells that are covered by the target node of the {@link yfiles.router.polyline.PathSearchContext#currentEdge}.
        * @return {number} 
        * the number of all cells that are covered by the target node of the {@link yfiles.router.polyline.PathSearchContext#currentEdge}
        */
        targetCellCount():number;
        /**
        * Adds an additional target cell of the {@link yfiles.router.polyline.PathSearchContext#currentEdge} if it is not already contained in the list of
        * target cells.
        * @param {yfiles.router.polyline.PartitionCell} cell the new target cell to add
        * @see {@link yfiles.router.polyline.PathSearchContext#targetCellCount}
        * @see {@link yfiles.router.polyline.PathSearchContext#getTargetCell}
        */
        addTargetCell(cell:yfiles.router.polyline.PartitionCell):void;
        /**
        * Returns the target cell with the given index in the list of all cells that are covered by the target node of the
        * {@link yfiles.router.polyline.PathSearchContext#currentEdge}.
        * @return {yfiles.router.polyline.PartitionCell} 
        * the target cell with the given index in the list of all cells that are covered by the target node of the
        * {@link yfiles.router.polyline.PathSearchContext#currentEdge}.
        */
        getTargetCell(index:number):yfiles.router.polyline.PartitionCell;
        /**
        * Determines if the given cell is a target cell of the {@link yfiles.router.polyline.PathSearchContext#currentEdge}.
        * @param {yfiles.router.polyline.PartitionCell} cell The cell to be tested.
        * @return {boolean} <code>true</code> if the given cell is in the list of target cells, <code>false</code> otherwise.
        * @see {@link yfiles.router.polyline.PathSearchContext#targetCellCount}
        * @see {@link yfiles.router.polyline.PathSearchContext#getTargetCell}
        */
        isTargetCell(cell:yfiles.router.polyline.PartitionCell):boolean;
        /**
        * An artificial partition cell with the size of the bounding box of all target cells of the{@link yfiles.router.polyline.PathSearchContext#currentEdge}.
        */
        combinedTargetCell:yfiles.router.polyline.PartitionCell;
        /**
        * The results of the path search.
        */
        pathSearchResult:yfiles.router.polyline.PathSearchResult;
      }
      var PathSearchContext:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        * @param {yfiles.router.polyline.PathSearch} pathSearch The path search that uses this context.
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration used for the path search.
        */
        new (pathSearch:yfiles.router.polyline.PathSearch,configuration:yfiles.router.polyline.PathSearchConfiguration):yfiles.router.polyline.PathSearchContext;
      };
      /**
      * Represents a group of segments of different edges, that shall be combined at the common source or target side.
      * <p>
      * Grouped edges have the same source or target group id assigned in the data provider registered at the graph with
      * the {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY} or {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}
      * key.
      * </p>
      * The segment group contains the common location range for the edge group and provides a common segment info
      * representing the grouped segment infos.
      */
      export interface SegmentGroup extends Object{
        /**
        * The common location range for the segment infos in this group.
        */
        commonLocationRange:yfiles.router.polyline.Interval;
        /**
        * The segment infos contained in this group.
        */
        segmentInfos:yfiles.algorithms.IList;
        /**
        * The common segment info representing the grouped segment infos.
        */
        commonSegmentInfo:yfiles.router.polyline.SegmentInfo;
        hashCode():number;
      }
      var SegmentGroup:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new segment group.
        * @param {yfiles.router.polyline.Interval} commonLocationRange The location range of the segment infos.
        * @param {yfiles.algorithms.IList} segmentInfos A list containing the grouped segment infos.
        */
        new (commonLocationRange:yfiles.router.polyline.Interval,segmentInfos:yfiles.algorithms.IList):yfiles.router.polyline.SegmentGroup;
      };
      /**
      * Adds polyline segment to the orthogonal edge paths of a graph.
      * The current implementation only adds octilinear segments to all orthogonal edges (non-orthogonal edges are completely ignored).
      * Between two succeeding vertical and
      * horizontal segments, an octilinear segment is added whose length can be influenced by the
      * {@link yfiles.router.polyline.PolylineLayoutStage#maximumNonOrthogonalSegmentRatio  maximum non orthogonal segment ratio} and the
      * {@link yfiles.router.polyline.PolylineLayoutStage#preferredPolylineSegmentLength  preferred polyline segment length}. The new octilinear segments
      * keep a {@link yfiles.router.polyline.PolylineLayoutStage#minimalNodeToEdgeDistance  minimum distance} between the edges and all nodes in the graph if possible.
      */
      export interface PolylineLayoutStage extends yfiles.layout.AbstractLayoutStage{
        /**
        * The data provider key used to look up the selected state of the nodes of the graph to be laid out.
        * By default, {@link yfiles.layout.LayouterKeys#SELECTED_NODES_DP_KEY} is used.
        * <p>
        * If the sphere of action is set to {@link yfiles.router.SphereOfAction#ROUTE_EDGES_AT_SELECTED_NODES}, only edges of selected nodes are routed
        * while all other edges are considered to have fixed routes.
        * </p>
        * @see {@link yfiles.router.polyline.PolylineLayoutStage#sphereOfAction}
        * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
        * @see {@link yfiles.router.polyline.PolylineLayoutStage#sphereOfAction}
        */
        selectedNodesDpKey:Object;
        /**
        * The data provider key used to look up the selected state of the edges of the graph to be laid out.
        * By default, {@link yfiles.layout.LayouterKeys#SELECTED_EDGES_DP_KEY} is used.
        * <p>
        * If the sphere of action is set to {@link yfiles.router.SphereOfAction#ROUTE_SELECTED_EDGES}, only the selected keys are routed while all
        * other edges are considered to have fixed routes.
        * </p>
        * @see {@link yfiles.router.polyline.PolylineLayoutStage#sphereOfAction}
        * @throws {yfiles.system.ArgumentException} if the specified key is <code>null</code>.
        * @see {@link yfiles.router.polyline.PolylineLayoutStage#sphereOfAction}
        */
        selectedEdgesDpKey:Object;
        /**
        * Determines the (sub-)set of edges to be routed polylinear.
        * Default setting is {@link yfiles.router.SphereOfAction#ROUTE_ALL_EDGES}.
        * @throws {yfiles.system.ArgumentException} if the given argument is not one of the above constants.
        * @see {@link yfiles.router.polyline.PolylineLayoutStage#selectedEdgesDpKey}
        * @see {@link yfiles.router.polyline.PolylineLayoutStage#selectedNodesDpKey}
        * @see {@link yfiles.router.polyline.PolylineLayoutStage#selectedEdgesDpKey}
        * @see {@link yfiles.router.polyline.PolylineLayoutStage#selectedNodesDpKey}
        */
        sphereOfAction:yfiles.router.SphereOfAction;
        /**
        * Specifies the minimal distance between edges and node bounds.
        * Default is 10.
        * @throws {yfiles.system.ArgumentException} If distance is less than 0.
        */
        minimalNodeToEdgeDistance:number;
        /**
        * The maximum segment length ratio at each end of an orthogonal segment that may get converted into a (non-orthogonal)
        * polyline segment.
        * Default is 0.5.
        * @throws {yfiles.system.ArgumentException} If the ratio is out of bounds.
        */
        maximumNonOrthogonalSegmentRatio:number;
        /**
        * The preferred segment length for (non-orthogonal) polyline segments.
        * Default is 50.
        * @throws {yfiles.system.ArgumentException} If length is less than 0.
        */
        preferredPolylineSegmentLength:number;
        /**
        * Returns <code>true</code> iff the given graph can be laid
        * out by this algorithm.
        * Calling <code>doLayout</code> with
        * the given graph as its argument will only success if
        * this method returns <code>true</code>.
        * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
        */
        canLayout(graph:yfiles.layout.LayoutGraph):boolean;
        /**
        * Main layout routine that assigns new layout information to the given graph.
        * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
        */
        doLayout(graph:yfiles.layout.LayoutGraph):void;
      }
      var PolylineLayoutStage:{
        $class:yfiles.lang.Class;
        /**
        * Initializes this layout stage with the given core layouter.
        * @param {yfiles.layout.ILayouter} coreLayouter The core layouter to wrap with this layout stage.
        */
        WithCoreLayouter:{
          new (coreLayouter:yfiles.layout.ILayouter):yfiles.router.polyline.PolylineLayoutStage;
        };
        new ():yfiles.router.polyline.PolylineLayoutStage;
      };
      /**
      * Stores information about the possible location of an orthogonal edge segment.
      * Most notable, SegmentInfo holds the segment's direction and the interval that restricts the segment's location.
      */
      export interface SegmentInfo extends yfiles.router.polyline.AbstractSegmentInfo{
        /**
        * Returns the number of {@link yfiles.router.polyline.CellSegmentInfo} of this segment info.
        * @return {number} 
        * the number of {@link yfiles.router.polyline.CellSegmentInfo} of this segment info
        */
        cellSegmentInfoCount():number;
        /**
        * Returns the {@link yfiles.router.polyline.CellSegmentInfo} at the given index of this segment info.
        * @param {number} index 
        * index of the {@link yfiles.router.polyline.CellSegmentInfo} to return
        * @return {yfiles.router.polyline.CellSegmentInfo} 
        * the {@link yfiles.router.polyline.CellSegmentInfo} at the given index of this segment info
        */
        getCellSegmentInfo(index:number):yfiles.router.polyline.CellSegmentInfo;
        /**
        * The segment group for this segment info and its cell segment infos and adjusts their{@link yfiles.router.polyline.AbstractSegmentInfo#locationRange}s to use the {@link yfiles.router.polyline.SegmentGroup#commonLocationRange}.
        * @see {@link yfiles.router.polyline.SegmentGroup}
        * @see Overrides {@link yfiles.router.polyline.AbstractSegmentInfo#segmentGroup}
        */
        segmentGroup:yfiles.router.polyline.SegmentGroup;
        /**
        * Determines whether or not this edge segment has the restriction of a strong port constraint.
        */
        atStrongPortConstraint:boolean;
      }
      var SegmentInfo:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance for the segment.
        * @param {yfiles.algorithms.Edge} edge The edge the segment of this info belongs to.
        * @param {number} segmentIndex The index of the segment this info belongs to.
        * @param {yfiles.layout.Direction} direction The direction the segment points to.
        * @param {yfiles.router.polyline.Interval} locationRange The range the common location of this segment has to be inside.
        * @param {yfiles.router.polyline.Interval} minExtension The minimal interval in extension direction this segment is known to intersect.
        * @param {yfiles.router.polyline.Interval} maxExtension The maximum interval in extension direction this segment will span.
        * @param {yfiles.algorithms.IList} cellSegmentInfos A list of cell segment infos this segment info is build upon.
        */
        WithCompleteSpecification:{
          new (edge:yfiles.algorithms.Edge,segmentIndex:number,direction:yfiles.layout.Direction,locationRange:yfiles.router.polyline.Interval,minExtension:yfiles.router.polyline.Interval,maxExtension:yfiles.router.polyline.Interval,cellSegmentInfos:yfiles.algorithms.IList):yfiles.router.polyline.SegmentInfo;
        };
        /**
        * Creates a new instance using a line segment to describe the edge segment.
        * <p>
        * This constructor is meant to be used for fixed orthogonal edge segments already knowing their extension and location.
        * </p>
        * @param {yfiles.algorithms.Edge} edge The edge this segment info belongs to.
        * @param {number} segmentIndex The index of the segment this info belongs to.
        * @param {yfiles.algorithms.LineSegment} segment A line segment describing the edge segment.
        */
        new (edge:yfiles.algorithms.Edge,segmentIndex:number,segment:yfiles.algorithms.LineSegment):yfiles.router.polyline.SegmentInfo;
      };
      /**
      * Extensions are added to a {@link yfiles.router.polyline.PathSearch} to influence the search process.
      * <p>
      * It contains several callback methods that are used by the {@link yfiles.router.polyline.PathSearch} to e.g. calculate the costs for
      * the next possible steps (i.e. entering the next partition cell) and to decide when the target is reached.
      * </p>
      * <p>
      * The {@link yfiles.router.polyline.PathSearch} uses the callbacks in the following order:
      * <ul>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#initialize  initialize}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#initializeEdges  initializeEdges}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#initializeCurrentEdge  initializeCurrentEdge}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#appendStartEntrances  appendStartEntrances}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#calculateStartEntranceCost  calculateStartEntranceCost}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#calculateCosts  calculateCosts}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#calculateHeuristicCosts  calculateHeuristicCosts}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#isValidTargetEntrance  isValidTargetEntrance}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#finalizePath  finalizePath}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#finalizeCurrentEdge  finalizeCurrentEdge} or {@link yfiles.router.polyline.PathSearchExtension#cancelCurrentEdge  cancelCurrentEdge}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#finalizeEdges  finalizeEdges}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#finalizePathSearchResult  finalizePathSearchResult}</li>
      * <li>{@link yfiles.router.polyline.PathSearchExtension#cleanup  cleanup}</li>
      * </ul>
      * </p>
      * @see {@link yfiles.router.polyline.PathSearch#addPathSearchExtension}
      * @see {@link yfiles.router.polyline.PathSearchContext#currentEdge}
      */
      export interface PathSearchExtension extends Object{
        /**
        * The configuration used for the path search.
        * This property is initialized in the {@link yfiles.router.polyline.PathSearchExtension#initialize  init} method.
        */
        configuration:yfiles.router.polyline.PathSearchConfiguration;
        /**
        * The current context of the path search.
        * This property is initialized in the {@link yfiles.router.polyline.PathSearchExtension#initializeEdges  initEdges} method.
        */
        context:yfiles.router.polyline.PathSearchContext;
        /**
        * Initializes this extension for path searches using the given configuration.
        * <p>
        * This method is the first one to be called by the {@link yfiles.router.polyline.PathSearch}.
        * </p>
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration to use for the following path searches.
        */
        initialize(configuration:yfiles.router.polyline.PathSearchConfiguration):void;
        /**
        * Initializes this extension with the context that contains the list of edges for which paths are calculated.
        * May be
        * called several times during a path search. Each call will be balanced by calls to {@link yfiles.router.polyline.PathSearchExtension#finalizeEdges} and {@link yfiles.router.polyline.PathSearchExtension#finalizePathSearchResult}.
        * @param {yfiles.router.polyline.PathSearchContext} context The context containing the list of edges, paths shall be found for.
        * @see {@link yfiles.router.polyline.PathSearchContext#edges}
        */
        initializeEdges(context:yfiles.router.polyline.PathSearchContext):void;
        /**
        * Initializes this extension with the current edge set in the given context.
        * Called for each of the {@link yfiles.router.polyline.PathSearchExtension#context  context's edges}. Each call will be balanced by a call to either finalizeCurrentEdge(PathSearchContext)
        * or cancelCurrentEdge(PathSearchContext).
        * @param {yfiles.router.polyline.PathSearchContext} context The context containing the current edge.
        * @see {@link yfiles.router.polyline.PathSearchContext#currentEdge}
        */
        initializeCurrentEdge(context:yfiles.router.polyline.PathSearchContext):void;
        /**
        * Appends additional start entrances for the path search of the current edge to the given list of all previously
        * generated entrances.
        * @param {yfiles.algorithms.IList} allStartEntrances a list of all previously generated entrances
        */
        appendStartEntrances(allStartEntrances:yfiles.algorithms.IList):void;
        /**
        * Returns the cost for starting the path in the given entrance.
        * This method is called called for each start entrance of the current edge.
        * @param {yfiles.router.polyline.CellEntrance} startEntrance The start entrance to calculate the cost for.
        * @return {number} The cost for starting the path in the given entrance.
        */
        calculateStartEntranceCost(startEntrance:yfiles.router.polyline.CellEntrance):number;
        /**
        * Calculate the costs for entering the <code>enteredCell</code> via the <code>enterInterval</code>.
        * <p>
        * The given {@link yfiles.router.polyline.EdgeCellInfo} describes how the partition cell, that has been entered by the current entrance,
        * would be traversed if this enter interval to the neighbor cell would be chosen.
        * </p>
        * <p>
        * The <code>maxAllowedCosts</code> describe the maximum costs the entering of the neighbor cell via this
        * enter intervals may induce. If the maximum cost is exceeded, calculations that may further increase its cost
        * may be skipped because this interval won't be chosen anyway.
        * </p>
        * @param {yfiles.router.polyline.CellEntrance} currentEntrance The entrance that was used to enter the current cell.
        * @param {yfiles.router.polyline.PartitionCell} enteredCell The neighbor cell that shall be entered.
        * @param {yfiles.router.polyline.OrthogonalInterval} enterInterval The interval that shall be used to enter the neighbor cell.
        * @param {yfiles.router.polyline.EdgeCellInfo} edgeCellInfo 
        * Information about how the current cell would be traversed if the neighbor cell would be
        * entered by this enter interval.
        * @param {number} maxAllowedCosts The maximum allowed costs for this enter intervals.
        * @return {number} The costs for entering the neighbor cell via the enter interval.
        */
        calculateCosts(currentEntrance:yfiles.router.polyline.CellEntrance,enteredCell:yfiles.router.polyline.PartitionCell,enterInterval:yfiles.router.polyline.OrthogonalInterval,edgeCellInfo:yfiles.router.polyline.EdgeCellInfo,maxAllowedCosts:number):number;
        /**
        * Calculates the heuristic costs for the given entrance that describe the minimal costs that will arise to finish
        * the path if the given cell entrance is used as next step.
        * <p>
        * After evaluating the costs for each enter interval to a neighbor cell, this method is called for each of the
        * resulting {@link yfiles.router.polyline.CellEntrance}s.
        * </p>
        * @param {yfiles.router.polyline.CellEntrance} entrance The entrance to calculate the heuristic costs for the rest of the path.
        * @return {number} The minimal costs that will arise to finish the path if the given cell entrance is used as next step.
        */
        calculateHeuristicCosts(entrance:yfiles.router.polyline.CellEntrance):number;
        /**
        * Determines whether this extension considers the given <code>entrance</code> a valid target entrance, i.e.
        * the path may
        * end with this entrance.
        * <p>
        * Each time a {@link yfiles.router.polyline.CellEntrance} is chosen as next step, all registered extension are asked if this entrance
        * is a valid target entrance. Only if none of the extensions returns <code>false</code>, a {@link yfiles.router.polyline.Path} is created.
        * </p>
        * @param {yfiles.router.polyline.CellEntrance} entrance The entrance to decide if it is a valid target entrance.
        * @return {boolean} <code>true</code>, if the path may end with this entrance; <code>false</code> otherwise.
        */
        isValidTargetEntrance(entrance:yfiles.router.polyline.CellEntrance):boolean;
        /**
        * After finding a valid target entrance and creating a {@link yfiles.router.polyline.Path}, the extension is notified about the found path.
        * <p>
        * If the path search is configured to calculate several possible paths for an edge, the path search proceeds
        * with choosing another unhandled CellEntrance.
        * </p>
        * @param {yfiles.router.polyline.Path} path The path found for the current edge in the context.
        * @see {@link yfiles.router.polyline.PathSearchContext#currentEdge}
        */
        finalizePath(path:yfiles.router.polyline.Path):void;
        /**
        * This callback notifies the extension when the path search for the current edge is cancelled.
        * <p>
        * After that, the path search will proceed with altering the penalties of the current edge and reinitializing it again.
        * </p>
        * @param {yfiles.router.polyline.PathSearchContext} context The context containing the current edge the path search has been finished for.
        * @see {@link yfiles.router.polyline.PathSearchExtension#initializeCurrentEdge}
        * @see {@link yfiles.router.polyline.PathSearchExtension#finalizeEdges}
        */
        cancelCurrentEdge(context:yfiles.router.polyline.PathSearchContext):void;
        /**
        * This callback notifies the extension when enough paths are found for the current edge.
        * <p>
        * After that, the path search either proceed with initializing the next current edge in the context's edge list or
        * calls {@link yfiles.router.polyline.PathSearchExtension#finalizeEdges} if all edges in this list have been handled.
        * </p>
        * @param {yfiles.router.polyline.PathSearchContext} context The context containing the current edge the path search has been finished for.
        * @see {@link yfiles.router.polyline.PathSearchExtension#initializeCurrentEdge}
        * @see {@link yfiles.router.polyline.PathSearchExtension#finalizeEdges}
        */
        finalizeCurrentEdge(context:yfiles.router.polyline.PathSearchContext):void;
        /**
        * This callback notifies the extension if enough paths have been found for all edges in the context's edge list.
        * @param {yfiles.router.polyline.PathSearchContext} context The context containing the list of edges, paths have been found for.
        * @see {@link yfiles.router.polyline.PathSearchContext#edges}
        */
        finalizeEdges(context:yfiles.router.polyline.PathSearchContext):void;
        /**
        * Callback notifying the extension about the paths chosen for the edges in the current context.
        * <p>
        * After calling {@link yfiles.router.polyline.PathSearchExtension#finalizeEdges  finalizeEdges}, the PathSearch decides, which of the found
        * paths to use for each edge and adds them to the {@link yfiles.router.polyline.PathSearchResult}.
        * </p>
        * <p>
        * With this callback the registered extensions are notified about this result before the path search either
        * initializes the next list of edges to route or ends the path search by calling {@link yfiles.router.polyline.PathSearchExtension#cleanup}.
        * </p>
        * @param {yfiles.router.polyline.PathSearchResult} pathSearchResult The path search result for the edge in the current context's edge list.
        * @see {@link yfiles.router.polyline.PathSearchExtension#initializeEdges}
        * @see {@link yfiles.router.polyline.PathSearchExtension#cleanup}
        */
        finalizePathSearchResult(pathSearchResult:yfiles.router.polyline.PathSearchResult):void;
        /**
        * Cleans the extension up from the path searches with the current configuration.
        */
        cleanup():void;
      }
      var PathSearchExtension:{
        $class:yfiles.lang.Class;
      };
      /**
      * Manages the best {@link yfiles.router.polyline.Path}s found for each edge and provides according {@link yfiles.router.polyline.EdgeInfo}s.
      * These are used by the {@link yfiles.router.polyline.ChannelBasedPathRouting} algorithm to calculate the final segment locations for the
      * segments of an edge path.
      */
      export interface PathSearchResult extends Object{
        /**
        * Returns an {@link yfiles.router.polyline.EdgeInfo} for the given path.
        * <p>
        * If no {@link yfiles.router.polyline.EdgeInfo} has been created for this path by this context before, a new one is instantiated,
        * otherwise the stored one is returned.
        * </p>
        * @param {yfiles.router.polyline.Path} path 
        * The path to return the {@link yfiles.router.polyline.EdgeInfo} for.
        * @return {yfiles.router.polyline.EdgeInfo} 
        * An {@link yfiles.router.polyline.EdgeInfo} describing this path.
        */
        getEdgeInfoWithPath(path:yfiles.router.polyline.Path):yfiles.router.polyline.EdgeInfo;
        /**
        * Returns an {@link yfiles.router.polyline.EdgeInfo} for the given edge.
        * <p>
        * If the given edge shall be routed but no path has been set for, yet, <code>null</code> is returned.
        * If no {@link yfiles.router.polyline.EdgeInfo} has been created for the path by this context before, a new one is instantiated,
        * otherwise the stored one is returned.
        * </p>
        * @param {yfiles.algorithms.Edge} edge 
        * The edge to return the {@link yfiles.router.polyline.EdgeInfo}.
        * @return {yfiles.router.polyline.EdgeInfo} 
        * An {@link yfiles.router.polyline.EdgeInfo} describing this the path of the edge.
        * @see {@link yfiles.router.polyline.PathSearchResult#setPath}
        */
        getEdgeInfo(edge:yfiles.algorithms.Edge):yfiles.router.polyline.EdgeInfo;
        /**
        * Sets a found path for an edge.
        * @param {yfiles.algorithms.Edge} edge The edge to set the path for.
        * @param {yfiles.router.polyline.Path} path The found path.
        */
        setPath(edge:yfiles.algorithms.Edge,path:yfiles.router.polyline.Path):void;
        /**
        * Returns the earlier registered found path for the edge.
        * @param {yfiles.algorithms.Edge} edge The edge to provide the found path for.
        * @return {yfiles.router.polyline.Path} The earlier registered found path for the edge or <code>null</code>, if no path has been registered, yet.
        */
        getPath(edge:yfiles.algorithms.Edge):yfiles.router.polyline.Path;
      }
      var PathSearchResult:{
        $class:yfiles.lang.Class;
        /**
        * Creates a new instance.
        * @param {yfiles.router.polyline.PathSearchConfiguration} configuration The configuration used for the path search.
        */
        new (configuration:yfiles.router.polyline.PathSearchConfiguration):yfiles.router.polyline.PathSearchResult;
      };
    }
  }
  export module seriesparallel{
    /**
    * This interface is used by {@link yfiles.seriesparallel.SeriesParallelLayouter}.
    * Classes implementing
    * this interface are responsible for the assignment of the edges' ports.
    */
    export interface IPortAssignment extends Object{
      /**
      * Called by {@link yfiles.seriesparallel.SeriesParallelLayouter} before the actual layout of the graph takes place.
      * This method assigns both the incoming edges target ports as well as all source ports for the outgoing edges.
      * At this point outgoing edges are ordered according the specified out-edge comparator from left to right and
      * incoming edges are in the order of the subgraphs their coming from.
      * @param {yfiles.layout.LayoutGraph} graph the graph instance the node is part of
      * @param {yfiles.algorithms.Node} node the node whose adjacent edges' ports should be set
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#SUBGRAPH_COMPARATOR_DP_KEY}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#defaultOutEdgeComparator}
      * @see Specified by {@link yfiles.seriesparallel.IPortAssignment#assignPorts}.
      */
      assignPorts(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):void;
    }
    var IPortAssignment:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This class implements a layout algorithm for drawing series-parallel graphs.
    * <p>
    * Series parallel graphs are directed graphs with a single source (node without incoming edges) and a single sink
    * (node without outgoing edges) that are build using only the following two rules:
    * <ul>
    * <li><b>Series composition:</b> The source of a subgraph is merged with the sink of a second subgraph.</li>
    * <li><b>Parallel composition:</b> The sources and sinks of two subgraphs are merged.</li>
    * </ul>
    * </p>
    * <p>
    * <center><img src="doc-files/y.layout.seriesparallel.SeriesParallelLayouter.gif"/></center>
    * </p>
    * <p>
    * Features:
    * <ul>
    * <li>node labels consideration in spacing and edge routing</li>
    * <li>integrated edge labeling according to the {@link yfiles.layout.PreferredPlacementDescriptor  preferred placement}</li>
    * <li>different {@link yfiles.seriesparallel.SeriesParallelLayouter#defaultPortAssignment  port assignment}s</li>
    * <li>different {@link yfiles.seriesparallel.SeriesParallelLayouter#verticalAlignment  vertical alignments} for parallel subgraphs</li>
    * <li>several {@link yfiles.seriesparallel.SeriesParallelLayouter#routingStyle  edge routing styles}</li>
    * <li>customizable {@link yfiles.seriesparallel.SeriesParallelLayouter#defaultOutEdgeComparator  order} of parallel subgraphs</li>
    * <li>support of grouped graphs that remain series-parallel if the groups are seen as normal nodes and the inner
    * graphs are series-parallel, too; edges which are connected to non-empty group nodes are not allowed</li>
    * <li>{@link yfiles.seriesparallel.SeriesParallelLayouter#fromSketchMode  from-sketch mode} which considers the original node positions</li>
    * <li>support of non-series-parallel input graphs</li>
    * <li>{@link yfiles.layout.PortConstraint}s are considered when assigning the ports and strong
    * <code>PortConstraint</code>s will fix the end point. However, the direction of the
    * <code>PortConstraint</code> will be the graph's flow direction</li>
    * </ul>
    * </p>
    */
    export interface SeriesParallelLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * Checks whether or not the given graph is series-parallel and can be layouted by
      * {@link yfiles.seriesparallel.SeriesParallelLayouter}.
      * @param {yfiles.layout.LayoutGraph} graph the graph to be checked.
      * @return {boolean} <code>true</code> if the given graph is series-parallel, <code>false</code> otherwise.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Calculates a series-parallel layout for the given graph.
      * @param {yfiles.layout.LayoutGraph} graph the graph to be layouted.
      * @throws {yfiles.algorithms.InvalidGraphStructureException} if the graph is not series-parallel.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Specifies whether or not node labels are considered.
      * If enabled, the layouter will reserve space for the node labels to avoid overlaps.
      * <p>
      * By default, node labels are not considered.
      * </p>
      */
      considerNodeLabels:boolean;
      /**
      * Specifies whether or not integrated edge labeling is enabled.
      * If enabled, the layouter will place edge labels and reserve space for them.
      * <p>
      * By default, integrated edge labeling is disabled.
      * </p>
      */
      integratedEdgeLabeling:boolean;
      /**
      * The vertical alignment of parallel subgraphs.
      * A value of <code>0</code> means nodes are top aligned;
      * a value of <code>1</code> means nodes are bottom aligned;
      * a value of <code>0.5</code> means nodes are center aligned.
      * Values outside the interval <code>[0,1]</code> will be matched with the nearest interval end.
      * <p>
      * In grouped graphs, the vertical alignment only applies to parallel subgraphs that belong to the same group.
      * </p>
      * <p>
      * By default the subgraphs are center aligned.
      * </p>
      */
      verticalAlignment:number;
      /**
      * Specifies whether or not general graphs are handled by this layouter.
      * <p>
      * If general graphs are handled, they will be transformed before layout to fit the criteria of series-parallel
      * graphs. After layout, they will be restored and the edges which weren't series-parallel are routed by an
      * {@link yfiles.seriesparallel.SeriesParallelLayouter#nonSeriesParallelEdgeRouter}  edge router}.
      * </p>
      * <p>
      * By default only series-parallel graphs are handled.
      * </p>
      */
      generalGraphHandling:boolean;
      /**
      * The edge router used for edges of a general graph that are not part of the series-parallel subgraph whose layout
      * is calculated.
      * It is required that a suitable {@link yfiles.seriesparallel.SeriesParallelLayouter#nonSeriesParallelEdgesDpKey  selection key} is
      * used.
      * <p>
      * By default  is used.
      * </p>
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#generalGraphHandling}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#nonSeriesParallelEdgesDpKey}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#generalGraphHandling}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#nonSeriesParallelEdgesDpKey}
      */
      nonSeriesParallelEdgeRouter:yfiles.layout.ILayouter;
      /**
      * The key that is used to mark non-series-parallel edges.
      * Note that this layouter automatically marks these edges and registers the DataProvider using the specified key.
      * This key is used to determine the edges that are
      * not part of the series-parallel structure in a general graph, so the specified non-series parallel
      * edge router should only route marked edges.
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#generalGraphHandling}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#nonSeriesParallelEdgeRouter}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#generalGraphHandling}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#nonSeriesParallelEdgeRouter}
      */
      nonSeriesParallelEdgesDpKey:Object;
      /**
      * The default{@link yfiles.seriesparallel.IPortAssignment} that will be used for those nodes, that don't
      * have their own specific instance set via the appropriate DataProvider.
      * <p>
      * By default, all ports are placed in the center of the node.
      * </p>
      */
      defaultPortAssignment:yfiles.seriesparallel.IPortAssignment;
      /**
      * The default{@link yfiles.objectcollections.IComparer} that will be used for those nodes, that don't
      * have their own specific instance set via
      * {@link yfiles.seriesparallel.SeriesParallelLayouter#PORT_ASSIGNMENT_DP_KEY  appropriate DataProvider}.
      * <p>
      * By default, {@link yfiles.seriesparallel.DefaultOutEdgeComparator} is used which uses the edge order of the
      * graph along with a special {@link yfiles.layout.PortConstraint} and edge group handling.
      * </p>
      * <p>
      * If you simply want to use the graph's current edge order you can set the default comparator to <code>null</code>.
      * </p>
      */
      defaultOutEdgeComparator:yfiles.objectcollections.IComparer;
      /**
      * The currently used routing style for edges.
      * Note that the routing style has no effect on
      * {@link yfiles.seriesparallel.SeriesParallelLayouter#generalGraphHandling   non-series-parallel} edges.
      * <p>
      * By default, edges are routed orthogonally.
      * </p>
      * @see {@link yfiles.seriesparallel.RoutingStyle#ORTHOGONAL}
      * @see {@link yfiles.seriesparallel.RoutingStyle#OCTILINEAR}
      * @see {@link yfiles.seriesparallel.RoutingStyle#POLYLINE}
      * @see {@link yfiles.seriesparallel.RoutingStyle#ORTHOGONAL}
      * @see {@link yfiles.seriesparallel.RoutingStyle#OCTILINEAR}
      * @see {@link yfiles.seriesparallel.RoutingStyle#POLYLINE}
      */
      routingStyle:yfiles.seriesparallel.RoutingStyle;
      /**
      * Specifies the minimum segment length for a polyline edge segment.
      * This distance will only be considered when the
      * routing style property is set to polyline edge routes.
      * <p>
      * By default, this distance is 30.
      * </p>
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#minimumSlope}
      * @see {@link yfiles.seriesparallel.RoutingStyle#POLYLINE}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#minimumSlope}
      * @see {@link yfiles.seriesparallel.RoutingStyle#POLYLINE}
      */
      minimumPolylineSegmentLength:number;
      /**
      * The minimum slope which a polyline edge segment should have.
      * A higher minimum slope prevents polyline
      * segments in very wide graphs to get nearly horizontal. This distance will only be considered when the routing style
      * property is set to polyline edge routes.
      * <p>
      * By default, the minimum slope is 0.25.
      * </p>
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#minimumPolylineSegmentLength}
      * @see {@link yfiles.seriesparallel.RoutingStyle#POLYLINE}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#minimumPolylineSegmentLength}
      * @see {@link yfiles.seriesparallel.RoutingStyle#POLYLINE}
      */
      minimumSlope:number;
      /**
      * The preferred length for non-orthogonal segments in octilinear edge routes.
      * This segment length will only
      * be considered when the routing style property is set to octilinear edge routes.
      * <p>
      * By default, the preferred length is 10.
      * </p>
      * @see {@link yfiles.seriesparallel.RoutingStyle#OCTILINEAR}
      * @see {@link yfiles.seriesparallel.RoutingStyle#OCTILINEAR}
      */
      preferredOctilinearSegmentLength:number;
      /**
      * The default{@link yfiles.seriesparallel.EdgeLayoutDescriptor}.
      * This instance is used for all those edges, that do not have a specific layout descriptor assigned.
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
      */
      defaultEdgeLayoutDescriptor:yfiles.seriesparallel.EdgeLayoutDescriptor;
      /**
      * The minimum distance between nodes.
      * <p>
      * By default the distance between nodes is <code>10</code>.
      * </p>
      */
      minimumNodeToNodeDistance:number;
      /**
      * The minimum distance between nodes and edges.
      * <p>
      * By default the distance between nodes and edges is <code>10</code>.
      * </p>
      */
      minimumNodeToEdgeDistance:number;
      /**
      * The minimum distance between edges.
      * <p>
      * By default the distance between edges is <code>5</code>.
      * </p>
      */
      minimumEdgeToEdgeDistance:number;
      /**
      * Specifies whether or not to take the coordinates of the input diagram into account when arranging the nodes.
      * The order of edges with the same source node will stay the same an in the original layout.
      * <p>
      * Note that previously specified {@link yfiles.seriesparallel.SeriesParallelLayouter#SUBGRAPH_COMPARATOR_DP_KEY  comparators} will be ignored if from-sketch-mode
      * is activated.
      * </p>
      * <p>
      * By default this feature is disabled.
      * </p>
      */
      fromSketchMode:boolean;
    }
    var SeriesParallelLayouter:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to store the {@link yfiles.seriesparallel.EdgeLayoutDescriptor} for each edge.
      * If there is no descriptor mapped for an edge, the default descriptor is used.
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#defaultEdgeLayoutDescriptor}
      */
      EDGE_LAYOUT_DESCRIPTOR_DP_KEY:Object;
      /**
      * DataProvider key that can be registered with the graph to provide each node with its own
      * {@link yfiles.objectcollections.IComparer} instance that will be used to sort the outgoing edges.
      * If the <code>Comparator</code>
      * associated with a node is <code>null</code>, the outgoing edges are not sorted.
      * <p>
      * Note that the order cannot be kept in all cases because the target nodes may not be completely independent.
      * </p>
      * <p>
      * For general graphs the comparators are only used for the series-parallel part of the graph. Non-series-parallel
      * edges are not included and will be routed by the
      * {@link yfiles.seriesparallel.SeriesParallelLayouter#nonSeriesParallelEdgeRouter  edge router for non-series-parallel edges}.
      * </p>
      * @see {@link yfiles.algorithms.DataProviders#createConstantDataProvider}
      */
      SUBGRAPH_COMPARATOR_DP_KEY:Object;
      /**
      * DataProvider key that can be registered with the graph to provide each node with its own
      * {@link yfiles.seriesparallel.IPortAssignment} instance.
      */
      PORT_ASSIGNMENT_DP_KEY:Object;
      /**
      * Creates a new SeriesParallelLayouter with default settings.
      */
      new ():yfiles.seriesparallel.SeriesParallelLayouter;
      /**
      * Determines whether or not the given graph has a series-parallel structure.
      * <p>
      * The current implementation detects the series-parallel graph structure in linear runtime.
      * </p>
      * @param {yfiles.algorithms.Graph} graph the graph to be checked.
      * @return {boolean} <code>true</code> if the given graph is series-parallel, <code>false</code> otherwise.
      */
      isSeriesParallelGraph(graph:yfiles.algorithms.Graph):boolean;
    };
    /**
    * This class implements the default port assignment strategy.
    * Ports are either placed at the {@link yfiles.seriesparallel.PortAssignmentMode#CENTER  center} or get {@link yfiles.seriesparallel.PortAssignmentMode#DISTRIBUTED  distributed} at the sides of the node.
    * <p>
    * If {@link yfiles.layout.PortConstraint}s are specified the strong <code>PortConstraints</code> are handled separately
    * and keep their initial location relative to the node while weak <code>PortConstraints</code> just influence on which
    * side the port is placed.
    * </p>
    * <p>
    * If there are edge groups specified the edges which belong to the same group get the same port locations.
    * </p>
    */
    export interface DefaultPortAssignment extends Object,yfiles.seriesparallel.IPortAssignment{
      /**
      * Called by {@link yfiles.seriesparallel.SeriesParallelLayouter} before the actual layout of the graph takes place.
      * This method assigns both the incoming edges target ports as well as all source ports for the outgoing edges.
      * At this point outgoing edges are ordered according the specified out-edge comparator from left to right and
      * incoming edges are in the order of the subgraphs their coming from.
      * @param {yfiles.layout.LayoutGraph} graph the graph instance the node is part of
      * @param {yfiles.algorithms.Node} node the node whose adjacent edges' ports should be set
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#SUBGRAPH_COMPARATOR_DP_KEY}
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#defaultOutEdgeComparator}
      * @see Specified by {@link yfiles.seriesparallel.IPortAssignment#assignPorts}.
      */
      assignPorts(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):void;
      /**
      * Callback method used to determine the port border gap for each node and
      * side.
      * @param {number} sideLength the width/height of the side
      * @param {number} edgeCount the number of edges/port that connect to this side
      * @return {number} the absolute gap to be used on both sides of the ports
      */
      getPortBorderGap(sideLength:number,edgeCount:number):number;
      /**
      * Callback method used to determine the distance between two adjacent ports.
      * @param {number} sideLength the width/height of the side
      * @param {number} edgeCount the number of edges/port that connect to this side
      * @param {number} portBorderGap the previously calculated port border gap
      * @return {number} the absolute distance to be used between two adjacent ports
      */
      getPortDistanceDelta(sideLength:number,edgeCount:number,portBorderGap:number):number;
      /**
      * The port assignment mode.
      * Possible values are
      * <ul>
      * <li>{@link yfiles.seriesparallel.PortAssignmentMode#CENTER}: all ports lie on the same point.</li>
      * <li>{@link yfiles.seriesparallel.PortAssignmentMode#DISTRIBUTED}: ports are distributed among the northern and southern side of the node.</li>
      * </ul>
      */
      mode:yfiles.seriesparallel.PortAssignmentMode;
      /**
      * The ratio of the gap between the border of the node and the next port and the gap between the ports.
      * For example, <code>0.5</code> sets the border gap as wide as half the gap between the ports. Thus,
      * the lower the value is, the wider "spread" the ports at the side of the node.
      * <p>
      * Note: This setting is only useful for distributed port assignment.
      * </p>
      */
      borderGapToPortGapRatio:number;
      /**
      * The fork style which influences the port assignment.
      * <p>
      * If the fork style is set to {@link yfiles.seriesparallel.ForkStyle#OUTSIDE_NODE}, edges without port constraints will be
      * assigned in flow direction.
      * </p>
      * <p>
      * If the fork style is set to {@link yfiles.seriesparallel.ForkStyle#AT_NODE} the ports of edges in flow direction also get
      * distributed to the sides unless they are without bends. Note that edges may overlap due to large
      * minimum first/last segment lengths.
      * </p>
      * @see {@link yfiles.seriesparallel.ForkStyle#AT_NODE}
      * @see {@link yfiles.seriesparallel.ForkStyle#OUTSIDE_NODE}
      * @see {@link yfiles.seriesparallel.ForkStyle#AT_NODE}
      * @see {@link yfiles.seriesparallel.ForkStyle#OUTSIDE_NODE}
      */
      forkStyle:yfiles.seriesparallel.ForkStyle;
    }
    var DefaultPortAssignment:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new DefaultPortAssignment instance using mode {@link yfiles.seriesparallel.PortAssignmentMode#CENTER}.
      */
      new ():yfiles.seriesparallel.DefaultPortAssignment;
      /**
      * Creates a new DefaultPortAssignment instance using the given mode and the default value for
      * the ratio of the gap between the border and the ports and the gap between the ports themselves.
      * The default value is 0.5. 
      * Possible values for <code>mode</code> are:
      * <ul>
      * <li>{@link yfiles.seriesparallel.PortAssignmentMode#CENTER}: all ports lie on the same point.</li>
      * <li>{@link yfiles.seriesparallel.PortAssignmentMode#DISTRIBUTED}: ports are distributed among the sides of the node.</li>
      * </ul>
      */
      WithMode:{
        new (mode:yfiles.seriesparallel.PortAssignmentMode):yfiles.seriesparallel.DefaultPortAssignment;
      };
      /**
      * Creates a new DefaultPortAssignment instance using the given mode and a given value for
      * the ratio of the {@link yfiles.seriesparallel.DefaultPortAssignment#borderGapToPortGapRatio  gap between the border and the ports} and the gap
      * between the ports themselves.
      * <p>
      * Possible values for <code>mode</code> are:
      * <ul>
      * <li>{@link yfiles.seriesparallel.PortAssignmentMode#CENTER}: all ports lie on the same point.</li>
      * <li>{@link yfiles.seriesparallel.PortAssignmentMode#DISTRIBUTED}: ports are distributed among the sides of the node.</li>
      * </ul>
      * </p>
      */
      WithModeAndRatio:{
        new (mode:yfiles.seriesparallel.PortAssignmentMode,ratio:number):yfiles.seriesparallel.DefaultPortAssignment;
      };
    };
    /**
    * Default implementation for the out-edge comparator used in {@link yfiles.seriesparallel.SeriesParallelLayouter}.
    * <p>
    * It keeps the order of the edges in the graph for edges without {@link yfiles.layout.PortConstraint}s and considers the
    * <code>PortConstraints</code> so the order of the target nodes of the out-edges is similar to the port location at
    * the source node. Note that this won't work for all cases because the target nodes may not be completely
    * independent.
    * </p>
    * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#defaultOutEdgeComparator}
    */
    export interface DefaultOutEdgeComparator extends Object,yfiles.objectcollections.IComparer{
      /**
      * Compares two objects.
      * @param {Object} x The first object.
      * @param {Object} y The second object.
      * @return {number} <ul>
      * <li>-1: <code>x</code> is less than <code>y</code></li>
      * <li>0: <code>x</code> is equal to <code>y</code></li>
      * <li>1: <code>x</code> is greater than <code>y</code></li>
      * </ul>
      * @see Specified by {@link yfiles.objectcollections.IComparer#compare}.
      */
      compare(o1:Object,o2:Object):number;
    }
    var DefaultOutEdgeComparator:{
      $class:yfiles.lang.Class;
    };
    export enum RoutingStyle{
      /**
      * Style constant describing an orthogonal edge style. If this style is used, edges will have only horizontal or
      * vertical segments.
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#routingStyle}
      */
      ORTHOGONAL,
      /**
      * Style constant describing an octilinear edge style. If this style is used, edges will have horizontal, vertical
      * and 45-degree sloped segments.
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#routingStyle}
      */
      OCTILINEAR,
      /**
      * Style constant describing an polyline edge style. If this style is used, edges will have vertical
      * and sloped segments.
      * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#routingStyle}
      */
      POLYLINE
    }
    export enum ForkStyle{
      /**
      * Constant that describes a fork style outside a node. Edges leave/enter the nodes south/north
      * and bend between their source and target.
      */
      OUTSIDE_NODE,
      /**
      * Constant that describes fork style on a node. Edges leave/enter the nodes south/north if
      * they are straight (no bends) or east and west of the node.
      */
      AT_NODE
    }
    /**
    * This class is used by {@link yfiles.seriesparallel.SeriesParallelLayouter} to determine the routing details of a
    * graph's edges.
    * @see {@link yfiles.seriesparallel.SeriesParallelLayouter#EDGE_LAYOUT_DESCRIPTOR_DP_KEY}
    */
    export interface EdgeLayoutDescriptor extends Object{
      /**
      * The minimum length for the associated edge.
      */
      minimumLength:number;
      /**
      * The minimum length for the first segment of the associated edge.
      */
      minimumFirstSegmentLength:number;
      /**
      * The minimum length for the last segment of the associated edge.
      */
      minimumLastSegmentLength:number;
      /**
      * Creates a copy of this {@link yfiles.seriesparallel.EdgeLayoutDescriptor} instance.
      * @return {yfiles.seriesparallel.EdgeLayoutDescriptor} 
      * a copy of this {@link yfiles.seriesparallel.EdgeLayoutDescriptor} instance
      */
      createCopy():yfiles.seriesparallel.EdgeLayoutDescriptor;
    }
    var EdgeLayoutDescriptor:{
      $class:yfiles.lang.Class;
    };
    export enum PortAssignmentMode{
      /**
      * Mode constant describing the strategy where ports are reset to the center of their nodes unless their are strong
      * {@link yfiles.layout.PortConstraint}s registered which will be kept.
      */
      CENTER,
      /**
      * Mode constant describing the strategy where the ports of incoming and outgoing edges are distributed evenly at the
      * side of their nodes.
      * <p>
      * The source ports of edges without {@link yfiles.layout.PortConstraint}s will be distributed at the sides of
      * their source and target nodes.
      * Edges with weak <code>PortConstraint</code>s are distributed at the side of the nodes that is specified in the
      * <code>PortConstraint</code>. Strong <code>PortConstraint</code>s are excluded from the even distribution to keep
      * their port locations.
      * </p>
      * <p>
      * Grouped edges will get the same port location.
      * </p>
      */
      DISTRIBUTED
    }
  }
  export module support{
    export interface XmlName extends Object{
      /**
      * Gets or sets the local name.
      * Value: 
      * The local name.
      */
      localName:string;
      /**
      * Gets the namespace.
      */
      xmlNamespace:yfiles.support.XmlNamespace;
      /**
      * Gets the URI of the namespace.
      * Value: 
      * The URI of the namespace.
      */
      namespaceName:string;
      equals(obj:Object):boolean;
      hashCode():number;
    }
    var XmlName:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new instance of the {@link yfiles.support.XmlName} class.
      * @param {string} localName The local name of the element.
      * @param {string} ns The namespace it belongs to.
      */
      new (localName:string,ns:string):yfiles.support.XmlName;
      /**
      * Creates a new name from the given local name and the given namespace URI.
      * @param {string} localName The local name.
      * @param {string} ns The namespace.
      * @return {yfiles.support.XmlName} 
      */
      get(localName:string,ns:string):yfiles.support.XmlName;
      convertFrom(expandedName:string):yfiles.support.XmlName;
      /**
      * Compares two names for equality.
      * @param {yfiles.support.XmlName} left The first name.
      * @param {yfiles.support.XmlName} right The second name.
      * @return {boolean} 
      * <code>true</code> if the names are equal; <code>false</code>, otherwise.
      */
      equals(left:yfiles.support.XmlName,right:yfiles.support.XmlName):boolean;
      /**
      * Compares two names for inequality.
      * @param {yfiles.support.XmlName} left The first name.
      * @param {yfiles.support.XmlName} right The second name.
      * @return {boolean} 
      * <code>false</code> if the names are equal; <code>true</code>, otherwise.
      */
      notEquals(left:yfiles.support.XmlName,right:yfiles.support.XmlName):boolean;
    };
    export interface XmlNamespace extends Object{
      /**
      * Gets the URI of the namespace.
      * Value: 
      * The name of the namespace.
      */
      namespaceName:string;
    }
    var XmlNamespace:{
      $class:yfiles.lang.Class;
      /**
      * Gets the XML namespace.
      */
      xmlns:yfiles.support.XmlNamespace;
      /**
      * Initializes a new instance of the {@link yfiles.support.XmlNamespace} class.
      * @param {string} ns The namespace URI.
      */
      new (ns:string):yfiles.support.XmlNamespace;
      convertFrom(namespaceName:string):yfiles.support.XmlNamespace;
      /**
      * Combines a namespace with a local name, creating a fully-qualified {@link yfiles.support.XmlName}.
      * @param {yfiles.support.XmlNamespace} ns The namespace.
      * @param {string} localName The local name of the element.
      * @return {yfiles.support.XmlName} 
      * The result of the combination.
      */
      add(ns:yfiles.support.XmlNamespace,localName:string):yfiles.support.XmlName;
      /**
      * Compares a namespace to another.
      * @param {yfiles.support.XmlNamespace} ns1 The first namespace.
      * @param {yfiles.support.XmlNamespace} ns2 The second namespace.
      * @return {boolean} 
      * <code>true</code> if the namespaces are equal; <code>false</code>, otherwise.
      */
      equals(ns1:yfiles.support.XmlNamespace,ns2:yfiles.support.XmlNamespace):boolean;
      /**
      * Compares a namespace to another.
      * @param {yfiles.support.XmlNamespace} ns1 The first namespace.
      * @param {yfiles.support.XmlNamespace} ns2 The second namespace.
      * @return {boolean} 
      * <code>false</code> if the namespaces are equal; <code>true</code>, otherwise.
      */
      notEquals(ns1:yfiles.support.XmlNamespace,ns2:yfiles.support.XmlNamespace):boolean;
      /**
      * Creates a new namespace from the given namespace URI.
      * @param {string} namespaceName URI of the namespace.
      * @return {yfiles.support.XmlNamespace} A new namespace object.
      */
      get(namespaceName:string):yfiles.support.XmlNamespace;
    };
    /**
    * A copy of the implementation of the same {@link yfiles.lang.Attribute} found in WPF and .net
    * Indicates that an enumeration can be treated as a bit field; that is, a set of flags.
    */
    export interface FlagsAttribute extends yfiles.lang.Attribute{
    }
    var FlagsAttribute:{
      $class:yfiles.lang.Class;
      new ():yfiles.support.FlagsAttribute;
    };
    /**
    * An {@link yfiles.collections.IEnumerable} implementation that
    * applies a {@link system.Predicate} to determine which elements 
    * to yield in the enumeration.
    */
    export interface FilteredEnumerable<T> extends Object,yfiles.collections.IEnumerable<T>{
      /**
      * Gets an {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance.
      * @return {yfiles.collections.IEnumerator.<T>} The {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance
      * @see Specified by {@link yfiles.collections.IEnumerable#getEnumerator}.
      */
      getEnumerator():yfiles.collections.IEnumerator<T>;
      /**
      * Gets an {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
      * This method exists for internal purposes mainly, if available the {@link yfiles.collections.IEnumerable#getEnumerator} should be used instead.
      * @return {yfiles.objectcollections.IEnumerator} The {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
      * @see Specified by {@link yfiles.objectcollections.IEnumerable#getObjectEnumerator}.
      */
      getObjectEnumerator():yfiles.objectcollections.IEnumerator;
    }
    var FilteredEnumerable:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new instance of the {@link yfiles.support.FilteredEnumerable} class.
      * @param {yfiles.collections.IEnumerable.<T>} backing The backing enumerable to filter.
      * @param {function(T):boolean} predicate The predicate that determines which items should be yielded.
      */
      new <T>(backing:yfiles.collections.IEnumerable<T>,predicate:(obj:T)=>boolean):yfiles.support.FilteredEnumerable<T>;
    };
    /**
    * An {@link yfiles.collections.IEnumerable} that casts items.
    */
    export interface CastingEnumerable<R,T> extends Object,yfiles.collections.IEnumerable<T>{
      /**
      * Gets an {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance.
      * @return {yfiles.collections.IEnumerator.<T>} The {@link yfiles.collections.IEnumerator} which can be used to iterate over the items in this instance
      * @see Specified by {@link yfiles.collections.IEnumerable#getEnumerator}.
      */
      getEnumerator():yfiles.collections.IEnumerator<T>;
      /**
      * Gets an {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
      * This method exists for internal purposes mainly, if available the {@link yfiles.collections.IEnumerable#getEnumerator} should be used instead.
      * @return {yfiles.objectcollections.IEnumerator} The {@link yfiles.objectcollections.IEnumerator} which can be used to iterate over the items in this instance.
      * @see Specified by {@link yfiles.objectcollections.IEnumerable#getObjectEnumerator}.
      */
      getObjectEnumerator():yfiles.objectcollections.IEnumerator;
    }
    var CastingEnumerable:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance wrapping the provided one.
      * @param {yfiles.collections.IEnumerable.<R>} wrapped The instance to wrap.
      */
      new <R,T>(wrapped:yfiles.collections.IEnumerable<R>):yfiles.support.CastingEnumerable<R,T>;
    };
    /**
    * An {@link yfiles.collections.IEnumerator} implementation that
    * applies a {@link system.Predicate} to filter a backing enumerator.
    */
    export interface FilteredEnumerator<T> extends Object,yfiles.collections.IEnumerator<T>{
      /**
      * Causes the implementor to free all resources.
      * @see Specified by {@link yfiles.system.IDisposable#dispose}.
      */
      dispose():void;
      /**
      * Moves this enumerator to the next element.
      * A newly created enumerator's {@link yfiles.objectcollections.IEnumerator#currentObject current position} is before the first element. Thus, this method
      * must be called before first access to the {@link yfiles.objectcollections.IEnumerator#currentObject} property. The same applies to the state after 
      * calling {@link yfiles.objectcollections.IEnumerator#reset}.
      * @return {boolean} <code>true</code> if the enumerator was moved to a valid position
      * @see Specified by {@link yfiles.objectcollections.IEnumerator#moveNext}.
      */
      moveNext():boolean;
      /**
      * Resets the enumerator to its starting state.
      * In other words: sets the current position before the first element.
      * @see Specified by {@link yfiles.objectcollections.IEnumerator#reset}.
      */
      reset():void;
      /**
      * Gets the element at the enumerator's current position.
      * This value is undefined if the enumerator is in initial state (after creation or {@link yfiles.collections.IEnumerator#reset}) or has been moved past the
      * end of the represented collection.
      * @see Specified by {@link yfiles.collections.IEnumerator#current}.
      */
      current:T;
    }
    var FilteredEnumerator:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new instance of the {@link yfiles.support.FilteredEnumerator} class.
      * @param {yfiles.collections.IEnumerator.<T>} backing The backing enumerator.
      * @param {function(T):boolean} predicate The predicate to use.
      */
      new <T>(backing:yfiles.collections.IEnumerator<T>,predicate:(obj:T)=>boolean):yfiles.support.FilteredEnumerator<T>;
    };
    /**
    * A wrapping implementation of an {@link yfiles.collections.IEnumerator}
    * that upcasts elements from a given enumerator to
    * another one.
    */
    export interface CastingEnumerator2<R,T> extends Object,yfiles.collections.IEnumerator<T>{
      /**
      * Gets the element at the enumerator's current position.
      * This value is undefined if the enumerator is in initial state (after creation or {@link yfiles.collections.IEnumerator#reset}) or has been moved past the
      * end of the represented collection.
      * @see Specified by {@link yfiles.collections.IEnumerator#current}.
      */
      current:T;
      /**
      * Causes the implementor to free all resources.
      * @see Specified by {@link yfiles.system.IDisposable#dispose}.
      */
      dispose():void;
      /**
      * Moves this enumerator to the next element.
      * A newly created enumerator's {@link yfiles.objectcollections.IEnumerator#currentObject current position} is before the first element. Thus, this method
      * must be called before first access to the {@link yfiles.objectcollections.IEnumerator#currentObject} property. The same applies to the state after 
      * calling {@link yfiles.objectcollections.IEnumerator#reset}.
      * @return {boolean} <code>true</code> if the enumerator was moved to a valid position
      * @see Specified by {@link yfiles.objectcollections.IEnumerator#moveNext}.
      */
      moveNext():boolean;
      /**
      * Resets the enumerator to its starting state.
      * In other words: sets the current position before the first element.
      * @see Specified by {@link yfiles.objectcollections.IEnumerator#reset}.
      */
      reset():void;
    }
    var CastingEnumerator2:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance wrapping the provided one.
      * @param {yfiles.collections.IEnumerator.<R>} enumerator The enumerator to wrap.
      */
      new <R,T>(enumerator:yfiles.collections.IEnumerator<R>):yfiles.support.CastingEnumerator2<R,T>;
    };
    /**
    * A wrapping implementation of an {@link yfiles.collections.IEnumerator}
    * that casts elements from a given non-generic enumerator to
    * another one.
    */
    export interface CastingEnumerator<T> extends Object,yfiles.collections.IEnumerator<T>{
      /**
      * Gets the element at the enumerator's current position.
      * This value is undefined if the enumerator is in initial state (after creation or {@link yfiles.collections.IEnumerator#reset}) or has been moved past the
      * end of the represented collection.
      * @see Specified by {@link yfiles.collections.IEnumerator#current}.
      */
      current:T;
      /**
      * Causes the implementor to free all resources.
      * @see Specified by {@link yfiles.system.IDisposable#dispose}.
      */
      dispose():void;
      /**
      * Moves this enumerator to the next element.
      * A newly created enumerator's {@link yfiles.objectcollections.IEnumerator#currentObject current position} is before the first element. Thus, this method
      * must be called before first access to the {@link yfiles.objectcollections.IEnumerator#currentObject} property. The same applies to the state after 
      * calling {@link yfiles.objectcollections.IEnumerator#reset}.
      * @return {boolean} <code>true</code> if the enumerator was moved to a valid position
      * @see Specified by {@link yfiles.objectcollections.IEnumerator#moveNext}.
      */
      moveNext():boolean;
      /**
      * Resets the enumerator to its starting state.
      * In other words: sets the current position before the first element.
      * @see Specified by {@link yfiles.objectcollections.IEnumerator#reset}.
      */
      reset():void;
    }
    var CastingEnumerator:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance wrapping the provided one.
      * @param {yfiles.objectcollections.IEnumerator} enumerator The enumerator to wrap.
      */
      new <T>(enumerator:yfiles.objectcollections.IEnumerator):yfiles.support.CastingEnumerator<T>;
    };
  }
  export module system{
    /**
    * Contains information about a property.
    */
    export interface PropertyInfo extends yfiles.system.MemberInfo{
      /**
      * Gets a value indicating whether the property can be read.
      * Value: 
      *   <code>true</code> if the property can be read; otherwise, <code>false</code>.
      */
      canRead:boolean;
      /**
      * Gets a value indicating whether the property can be written.
      * Value: 
      *   <code>true</code> if the property can be written; otherwise, <code>false</code>.
      */
      canWrite:boolean;
      /**
      * Gets the type of the property.
      * Value: 
      * The type of the property.
      */
      propertyType:yfiles.lang.Class;
      /**
      * Provides access to a method that can be used to read the value of the property.
      * @return {yfiles.system.MethodInfo} The "getter" for this property.
      */
      getGetMethod():yfiles.system.MethodInfo;
      /**
      * Provides access to a method that can be used to write the value of the property.
      * @return {yfiles.system.MethodInfo} The "setter" for this property.
      */
      getSetMethod():yfiles.system.MethodInfo;
      /**
      * Gets the index parameters.
      * @return {yfiles.system.ParameterInfo[]} 
      */
      getIndexParameters():yfiles.system.ParameterInfo[];
      /**
      * Gets the value of the property from the given object.
      * @param {Object} obj The object which has the property.
      * @param {Object[]} index The indices. This parameter can be safely ignored.
      * @return {Object} The value of the property from the given object.
      * @throws {yfiles.system.ArgumentException} If the property is not readable.
      * @throws {yfiles.system.TargetException} 
      * If the given object is null (and the property is not static)
      * - or -
      * if the given object is not of the type that this property belongs to.
      */
      getValue(obj:Object,index:Object[]):Object;
      /**
      * Sets the value of the property on the given object.
      * @param {Object} obj The object whose property should be written.
      * @param {Object[]} index The indices. This parameter can be safely ignored.
      * @throws {yfiles.system.ArgumentException} If the property is not writable.
      * @throws {yfiles.system.TargetException} 
      * If the given object is null (and the property is not static)
      * - or -
      * if the given object is not of the type that this property belongs to.
      */
      setValue(obj:Object,value:Object,index:Object[]):void;
      /**
      * Gets the type of the member.
      * Value: 
      * The type of the member.
      */
      memberType:yfiles.system.MemberTypes;
    }
    var PropertyInfo:{
      $class:yfiles.lang.Class;
      new (name:string,reflectedType:yfiles.lang.Class,declaringType:yfiles.lang.Class,attributes:yfiles.lang.Attribute[],getMethod:yfiles.system.MethodInfo,setMethod:yfiles.system.MethodInfo):yfiles.system.PropertyInfo;
    };
    /**
    * Provides information about a field.
    */
    export interface FieldInfo extends yfiles.system.MemberInfo{
      /**
      * Gets a value indicating whether this field is static.
      * Value: 
      *   <code>true</code> if this field is static; otherwise, <code>false</code>.
      */
      isStatic:boolean;
      /**
      * Gets the type of the field.
      * Value: 
      * The type of the field.
      */
      fieldType:yfiles.lang.Class;
      /**
      * Gets the value stored in the field on the specified object.
      * @param {Object} obj The object. This parameter is ignored if the field is static.
      * @return {Object} 
      */
      getValue(obj:Object):Object;
      /**
      * Sets the field on the specified object to the given value.
      * @param {Object} obj The object. This parameter is ignored if the field is static.
      * @param {Object} value The new value of the field.
      */
      setValue(obj:Object,value:Object):void;
      /**
      * Gets the type of the member.
      * Value: 
      * The type of the member.
      */
      memberType:yfiles.system.MemberTypes;
    }
    var FieldInfo:{
      $class:yfiles.lang.Class;
      new (name:string,reflectedType:yfiles.lang.Class,declaringType:yfiles.lang.Class,attributes:yfiles.lang.Attribute[],isStatic:boolean):yfiles.system.FieldInfo;
    };
    /**
    * An abstract base class for information about methods.
    * There are different types of methods that a Type can have: Constructors and actual methods.
    * This class is the base for both and contains all information available for both types of methods.
    */
    export interface MethodBase extends yfiles.system.MemberInfo{
      /**
      * Gets a value indicating whether the method is static.
      * Value: 
      *   <code>true</code> if the method is static; otherwise, <code>false</code>.
      */
      isStatic:boolean;
      /**
      * Gets a value indicating whether the method is a constructor.
      * Value: 
      * 	<code>true</code> if the method is a constructor; otherwise, <code>false</code>.
      */
      isConstructor:boolean;
      fn:Function;
      noPolymorphicCall:boolean;
      /**
      * Gets the parameters of the method.
      * This method requires the {@link yfiles.system.ParameterAttribute} on the method to collect the required
      * information. Therefore it is important that every parameter of the method has an associated
      * {@link yfiles.system.ParameterAttribute}. The order of the {@link yfiles.system.ParameterAttribute} must be the same as
      * the order of the parameters.
      * @return {yfiles.system.ParameterInfo[]} An array of {@link yfiles.system.ParameterInfo}s for the parameters of the method.
      */
      getParameters():yfiles.system.ParameterInfo[];
      /**
      * Invokes the method bound to the <code>thisArg</code> and the given <code>parameters</code>.
      * @param {Object} thisArg The context for the invocation. This argument is ignored when the method is static or a constructor.
      * @param {Object[]} parameters The parameters of the invocation.
      * @return {Object} The return value of the method invocation.
      */
      invoke(thisArg:Object,parameters:Object[]):Object;
      /**
      * Gets the method attributes of this method.
      */
      attributes:yfiles.system.MethodAttributes;
    }
    var MethodBase:{
      $class:yfiles.lang.Class;
      new (name:string,reflectedType:yfiles.lang.Class,declaringType:yfiles.lang.Class,attributes:yfiles.lang.Attribute[],fn:Function,isStatic:boolean,noPolymorphicCall:boolean):yfiles.system.MethodBase;
    };
    /**
    * Contains information about a constructor.
    */
    export interface ConstructorInfo extends yfiles.system.MethodBase{
      /**
      * Gets a value indicating whether the method is a constructor.
      * Value: 
      * 	Always <code>true</code>.
      * @see Overrides {@link yfiles.system.MethodBase#isConstructor}
      */
      isConstructor:boolean;
      /**
      * Invokes the constructor with the given <code>parameters</code>.
      * The <code>thisArg</code> is ignored since constructors can't be bound to a context.
      * @param {Object} thisArg This argument is ignored.
      * @param {Object[]} parameters The parameters of the invocation.
      * @return {Object} 
      * A new instance of the type the constructor belongs to.
      * @see Overrides {@link yfiles.system.MethodBase#invoke}
      */
      invoke(thisArg:Object,parameters:Object[]):Object;
      /**
      * Invokes the constructor with the given <code>parameters</code>..
      * @param {Object[]} parameters The parameters.
      * @return {Object} 
      * A new instance of the type the constructor belongs to.
      */
      invokeConstructor(parameters:Object[]):Object;
      /**
      * Gets the type of the member.
      * Value: 
      * The type of the member.
      */
      memberType:yfiles.system.MemberTypes;
    }
    var ConstructorInfo:{
      $class:yfiles.lang.Class;
      new (name:string,reflectedType:yfiles.lang.Class,declaringType:yfiles.lang.Class,attributes:yfiles.lang.Attribute[],fn:Function,isStatic:boolean):yfiles.system.ConstructorInfo;
    };
    export enum BindingFlags{
      /**
      * The default bindings.
      */
      DEFAULT,
      /**
      * The case should be ignored, i.e. it doesn't matter if a method is named "toString" or "ToStRiNg".
      */
      IGNORE_CASE,
      /**
      * The member must be declared explicitly and not inherited from a parent type.
      */
      DECLARED_ONLY,
      /**
      * The member should be the member of an instance of the type.
      */
      INSTANCE,
      /**
      * The member should be the member of the type and not an instance of it.
      */
      STATIC,
      /**
      * The member must have {@link yfiles.system.Visibility#PUBLIC public visibility}.
      */
      PUBLIC,
      /**
      * The member must not have {@link yfiles.system.Visibility#PUBLIC public visibility}.
      */
      NON_PUBLIC,
      /**
      * Traverse the parent types to find the member.
      */
      FLATTEN_HIERARCHY
    }
    /**
    * An abstract base class for more specific member information classes.
    * Instances of this class provide information about a member of a type, i.e. a method, field or property.
    */
    export interface MemberInfo extends Object{
      /**
      * Contains the attributes associated with this member.
      */
      _attributes:yfiles.lang.Attribute[];
      /**
      * Gets the declaring type, i.e. the type where the member was declared.
      * Value: 
      * The declaring type.
      */
      declaringType:yfiles.lang.Class;
      /**
      * Gets the reflected type, i.e. the type that was asked about its member.
      * Value: 
      * The reflected type.
      */
      reflectedType:yfiles.lang.Class;
      /**
      * Gets the name of the member.
      */
      name:string;
      /**
      * Gets the type of the member.
      * Value: 
      * The type of the member.
      */
      memberType:yfiles.system.MemberTypes;
      /**
      * Gets a value indicating whether the member is private.
      * Value: 
      * 	<code>true</code> if the member is private; otherwise, <code>false</code>.
      */
      isPrivate:boolean;
      /**
      * Gets a value indicating whether the member is public.
      * Value: 
      *   <code>true</code> if the member is public; otherwise, <code>false</code>.
      */
      isPublic:boolean;
      /**
      * Gets the custom attributes of this member and (optionally) the inherited ones if the member was declared
      * by a parent type.
      * @param {boolean} inherit if set to <code>true</code> then inherited attributes will be considered as well.
      * @return {yfiles.lang.Attribute[]} The attributes associated with the member.
      */
      getCustomAttributes(inherit:boolean):yfiles.lang.Attribute[];
      /**
      * Gets the type of the custom attributes of the specified type.
      * @param {yfiles.lang.Class} attributeType The type of attributes that are interesting.
      * @param {boolean} inherit if set to <code>true</code> then inherited attributes will be considered as well.
      * @return {yfiles.lang.Attribute[]} An array of all attributes that are instances of the given type.
      */
      getCustomAttributesOfType(attributeType:yfiles.lang.Class,inherit:boolean):yfiles.lang.Attribute[];
      /**
      * Determines whether the specified attribute type is defined.
      * @param {yfiles.lang.Class} attributeType Type of the attribute.
      * @param {boolean} inherit if set to <code>true</code> then inherited attributes will be considered as well.
      * @return {boolean} 
      *   <code>true</code> if the specified attribute type is defined; otherwise, <code>false</code>.
      */
      isDefined(attributeType:yfiles.lang.Class,inherit:boolean):boolean;
    }
    var MemberInfo:{
      $class:yfiles.lang.Class;
      new (name:string,reflectedType:yfiles.lang.Class,declaringType:yfiles.lang.Class,attributes:yfiles.lang.Attribute[]):yfiles.system.MemberInfo;
    };
    /**
    * Contains information about a parameter of a method.
    */
    export interface ParameterInfo extends Object{
      /**
      * Gets the name of the parameter.
      */
      name:string;
      /**
      * Gets the type of the parameter.
      * Value: 
      * The type of the parameter.
      */
      parameterType:yfiles.lang.Class;
      /**
      * Gets the position of the parameter.
      * The first parameter has the position <code>0</code>.
      */
      position:number;
      /**
      * Gets a value indicating whether the parameter is optional.
      * Value: 
      * 	<code>true</code> if the parameter is optional; otherwise, <code>false</code>.
      */
      isOptional:boolean;
      /**
      * Gets the {@link yfiles.system.MemberInfo} that the parameter belongs to.
      */
      member:yfiles.system.MemberInfo;
    }
    var ParameterInfo:{
      $class:yfiles.lang.Class;
      new (name:string,parameterType:yfiles.lang.Class,position:number,isOptional:boolean,member:yfiles.system.MemberInfo):yfiles.system.ParameterInfo;
    };
    export interface XmlExtensions extends Object{
    }
    var XmlExtensions:{
      $class:yfiles.lang.Class;
      escapeUriString(s:string):string;
      getNamespaceOfPrefix(element:Element,prefix:string):yfiles.support.XmlNamespace;
      getPrefixOfNamespace(element:Element,ns:yfiles.support.XmlNamespace):string;
      getDefaultNamespace(element:Element):yfiles.support.XmlNamespace;
      documentElement(doc:Document):Element;
      getXmlName(element:Node):yfiles.support.XmlName;
      namedElements(xContainer:Node,xName:yfiles.support.XmlName):yfiles.collections.IEnumerable<Element>;
      elements(xContainer:Node):yfiles.collections.IEnumerable<Element>;
      createElement(dox:Document,name:string,namespaceUri:string):Element;
      appendChildToDocument(dox:Document,child:Element):void;
    };
    /**
    * Contains information about a method.
    */
    export interface MethodInfo extends yfiles.system.MethodBase{
      /**
      * Gets the return type of the method.
      * Value: 
      * The type of the return value.
      */
      returnType:yfiles.lang.Class;
      /**
      * Gets a value indicating whether the method is a constructor.
      * Value: 
      * 	Always <code>false</code>.
      * @see Overrides {@link yfiles.system.MethodBase#isConstructor}
      */
      isConstructor:boolean;
      /**
      * Gets the type of the member.
      * Value: 
      * The type of the member.
      */
      memberType:yfiles.system.MemberTypes;
      /**
      * Makes the method generic.
      * @param {yfiles.lang.Class[]} typeArguments The type arguments.
      * @return {yfiles.system.MethodInfo} A generic variant of the method
      */
      makeGenericMethod(typeArguments:yfiles.lang.Class[]):yfiles.system.MethodInfo;
    }
    var MethodInfo:{
      $class:yfiles.lang.Class;
      new (name:string,reflectedType:yfiles.lang.Class,declaringType:yfiles.lang.Class,attributes:yfiles.lang.Attribute[],fn:Function,isStatic:boolean,noPolymorphicCall:boolean):yfiles.system.MethodInfo;
    };
    /**
    * Contains information about a generic method.
    */
    export interface GenericMethodInfo extends yfiles.system.MethodInfo{
      /**
      * Gets the type arguments.
      */
      typeArguments:yfiles.lang.Class[];
      /**
      * Invokes the method bound to the <code>thisArg</code> and with the given <code>parameters</code>. The
      * type parameters of this method are passed before the <code>parameters</code>.
      * @param {Object} thisArg The context for the invocation. This argument is ignored when the method is static or a constructor.
      * @param {Object[]} parameters The parameters of the invocation.
      * @return {Object} 
      * The return value of the method invocation.
      * @see Overrides {@link yfiles.system.MethodBase#invoke}
      */
      invoke(thisArg:Object,parameters:Object[]):Object;
    }
    var GenericMethodInfo:{
      $class:yfiles.lang.Class;
      new (name:string,reflectedType:yfiles.lang.Class,declaringType:yfiles.lang.Class,attributes:yfiles.lang.Attribute[],fn:Function,isStatic:boolean,noPolymorphicCall:boolean,typeArguments:yfiles.lang.Class[]):yfiles.system.GenericMethodInfo;
    };
    export interface WeakReference extends Object{
      target:Object;
      isAlive:boolean;
    }
    var WeakReference:{
      $class:yfiles.lang.Class;
      WithTargetAndTrackResurrection:{
        new (target:Object,trackResurrection:boolean):yfiles.system.WeakReference;
      };
      WithObject:{
        new (target:Object):yfiles.system.WeakReference;
      };
    };
    /**
    * A structure which represents a time span.
    */
    export interface TimeSpan extends yfiles.lang.Struct,yfiles.lang.IComparable<yfiles.system.TimeSpan>,yfiles.system.IEquatable<yfiles.system.TimeSpan>{
      /**
      * Compares this object to the given object of the same type.
      * @param {T} obj The object to compare this to.
      * @return {number} <ul>
      * <li>-1: this is less than <code>obj</code></li>
      * <li>0: this is equal to <code>obj</code></li>
      * <li>1: this is greater than <code>obj</code></li>
      * </ul>
      * @see Specified by {@link yfiles.lang.IComparable#compareTo}.
      */
      compareTo(obj:yfiles.system.TimeSpan):number;
      /**
      * The days part of the time span.
      */
      days:number;
      /**
      * The total milliseconds (i.e. ticks) of this time span.
      */
      totalMilliseconds:number;
      /**
      * The milliseconds part of this time span.
      */
      milliseconds:number;
      /**
      * The total seconds of this time span.
      */
      totalSeconds:number;
      /**
      * Determines whether <code>this</code> is equal to <code>other</code>.
      * @param {T} other The object to compare <code>this</code> to. Must be of the same type.
      * @return {boolean} <code>true</code> if <code>this</code> is equal to the other object.
      * @see Specified by {@link yfiles.system.IEquatable#equalsTyped}.
      */
      equalsTyped(other:yfiles.system.TimeSpan):boolean;
      clone():yfiles.system.TimeSpan;
    }
    var TimeSpan:{
      $class:yfiles.lang.Class;
      /**
      * Empty time span.
      */
      ZERO:yfiles.system.TimeSpan;
      /**
      * Creates a new time span which is <code>ticks</code> milliseconds long.
      * @param {number} ticks The length of the time span in milliseconds.
      */
      FromTotalMillis:{
        new (ticks:number):yfiles.system.TimeSpan;
      };
      /**
      * Creates a new time span with a given length.
      * @param {number} days The days part of the time span.
      * @param {number} hours The hour part of the time span.
      * @param {number} minutes The minute part of the time span.
      * @param {number} seconds The seconds part of the time span.
      * @param {number} millis The milliseconds part of the time span.
      */
      FromDaysHoursMinutesSecondsAndMillis:{
        new (days:number,hours:number,minutes:number,seconds:number,millis:number):yfiles.system.TimeSpan;
      };
      /**
      * Creates a new time span with the given length in days.
      * @param {number} days The length of the time span in days.
      * @return {yfiles.system.TimeSpan} A newly created time span.
      */
      fromDays(days:number):yfiles.system.TimeSpan;
      /**
      * Creates a new time span with the given length in milliseconds.
      * @param {number} milliseconds The length of the time span in milliseconds.
      * @return {yfiles.system.TimeSpan} A newly created time span.
      */
      fromMilliseconds(milliseconds:number):yfiles.system.TimeSpan;
      /**
      * Creates a new time span with the given length in seconds.
      * @param {number} seconds The length of the time span in seconds.
      * @return {yfiles.system.TimeSpan} A newly created time span.
      */
      fromSeconds(seconds:number):yfiles.system.TimeSpan;
      /**
      * Whether time span <code>t1</code> is greater or equal than time span <code>t2</code>.
      * @param {yfiles.system.TimeSpan} t1 The first time span.
      * @param {yfiles.system.TimeSpan} t2 The second time span.
      * @return {boolean} <code>true</code> if the first time span is greater or equal than the second one.
      */
      greaterThanOrEqual(t1:yfiles.system.TimeSpan,t2:yfiles.system.TimeSpan):boolean;
      /**
      * Whether time span <code>t1</code> is less or equal than time span <code>t2</code>.
      * @param {yfiles.system.TimeSpan} t1 The first time span.
      * @param {yfiles.system.TimeSpan} t2 The second time span.
      * @return {boolean} <code>true</code> if the first time span is less or equal than the second one.
      */
      lessThanOrEqual(t1:yfiles.system.TimeSpan,t2:yfiles.system.TimeSpan):boolean;
      /**
      * Whether time span <code>t1</code> is less than time span <code>t2</code>.
      * @param {yfiles.system.TimeSpan} t1 The first time span.
      * @param {yfiles.system.TimeSpan} t2 The second time span.
      * @return {boolean} <code>true</code> if the first time span is less than the second one.
      */
      lessThan(t1:yfiles.system.TimeSpan,t2:yfiles.system.TimeSpan):boolean;
      /**
      * Whether time span <code>t1</code> is greater than time span <code>t2</code>.
      * @param {yfiles.system.TimeSpan} t1 The first time span.
      * @param {yfiles.system.TimeSpan} t2 The second time span.
      * @return {boolean} <code>true</code> if the first time span is greater than the second one.
      */
      greaterThan(t1:yfiles.system.TimeSpan,t2:yfiles.system.TimeSpan):boolean;
      /**
      * Whether the given time spans are not equal.
      * @param {yfiles.system.TimeSpan} t1 The first time span.
      * @param {yfiles.system.TimeSpan} t2 The second time span.
      * @return {boolean} <code>true</code> if the time spans are not equal.
      */
      notEquals(t1:yfiles.system.TimeSpan,t2:yfiles.system.TimeSpan):boolean;
      /**
      * Whether the given time spans are equal.
      * @param {yfiles.system.TimeSpan} t1 The first time span.
      * @param {yfiles.system.TimeSpan} t2 The second time span.
      * @return {boolean} <code>true</code> if the time spans are equal.
      */
      equals(t1:yfiles.system.TimeSpan,t2:yfiles.system.TimeSpan):boolean;
    };
    /**
    * Provides helper classes to manipulate Strings.
    */
    export interface StringExtensions extends Object{
    }
    var StringExtensions:{
      $class:yfiles.lang.Class;
      /**
      * Formats the given String using the string representation of the given objects to replace format items (like <code>{0}</code>).
      * @param {string} s1 The string to format.
      * @param {Object[]} obj The objects to replace the format item with.
      * @return {string} The formatted String.
      */
      format(s1:string,obj:Object[]):string;
    };
    /**
    * A writer which writes an internal builder.
    */
    export interface StringWriter extends Object{
      /**
      * Writes the given String.
      * The String is appended to the internal builder.
      * @param {string} s The String to write.
      */
      write(s:string):void;
      /**
      * Writes the given String and starts a new line.
      * The String is appended to the internal builder.
      * @param {string} s The String to write.
      */
      writeLine(s:string):void;
      /**
      * Writes the given Object's string representation.
      * The String is appended to the internal builder.
      * @param {Object} o The Object to write.
      */
      writeObject(o:Object):void;
      /**
      * Writes the given Object's string representation and starts a new line.
      * The String is appended to the internal builder.
      * @param {Object} o The Object to write.
      */
      writeLineObject(o:Object):void;
      /**
      * Writes a new line.
      */
      writeNewLine():void;
      /**
      * Gets a String representation of all which was written to this instance until now.
      * @return {string} The String.
      */
      toString():string;
      /**
      * Not used here.
      */
      flush():void;
    }
    var StringWriter:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance.
      */
      new ():yfiles.system.StringWriter;
    };
    export interface MissingManifestResourceException extends yfiles.lang.Exception{
    }
    var MissingManifestResourceException:{
      $class:yfiles.lang.Class;
      new (message:string):yfiles.system.MissingManifestResourceException;
    };
    /**
    * The ResourceManager handles the retrieval of string and object resources like keyboard shortcuts and I18N names.
    */
    export interface ResourceManager extends Object{
      /**
      * Gets or sets a value indicating whether the case of the keys should be ignored.
      * Value: 
      *   <code>true</code> if the case should be ignored; otherwise, <code>false</code>.
      */
      ignoreCase:boolean;
      /**
      * Gets the string stored under the specified <code>s</code>.
      * @param {string} s The key.
      * @return {string} The string stored under the key or <code>null</code>, if there is no such key.
      */
      getString(s:string):string;
      /**
      * Gets the string stored under the specified <code>s</code> and {@link yfiles.system.CultureInfo}.
      * @param {string} s The key.
      * @param {yfiles.system.CultureInfo} info The culture info.
      * @return {string} The string stored under the key or <code>null</code>, if there is no such key.
      */
      getStringForCulture(s:string,info:yfiles.system.CultureInfo):string;
      /**
      * Gets the object stored under the specified <code>s</code>.
      * @param {string} s The key.
      * @return {Object} The object stored under the key or <code>null</code>, if there is no such key.
      */
      getObject(s:string):Object;
      /**
      * Gets the object stored under the specified <code>s</code> and {@link yfiles.system.CultureInfo}.
      * @param {string} s The key.
      * @param {yfiles.system.CultureInfo} info The culture info.
      * @return {Object} The object stored under the key or <code>null</code>, if there is no such key.
      */
      getObjectForCulture(s:string,info:yfiles.system.CultureInfo):Object;
    }
    var ResourceManager:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new instance of the {@link yfiles.system.ResourceManager} class with no resources.
      */
      new ():yfiles.system.ResourceManager;
      /**
      * Looks for a resource object under the specified global name.
      * The global object will be queried for the JS object under the given name.
      * Queries will be made to the {@link yfiles.system.CultureInfo#name} of the culture first and
      * if they are not satisfied, the {@link yfiles.system.CultureInfo#parent} chain will be traversed
      * until the {@link yfiles.system.CultureInfo#INVARIANT_CULTURE1} is reached.
      * So in a "en-US" culture the following objects will be queried:
      * <pre><code>
      * window.globalName["en-US"][key]
      * window.globalName["en"][key]
      * window.globalName["invariant"][key]
      * </code></pre>
      * @param {string} globalName The global name to look for a resource object.
      */
      FromGlobalName:{
        new (globalName:string):yfiles.system.ResourceManager;
      };
      /**
      * Uses the given object as the resource backing store.
      * Queries will be made to the {@link yfiles.system.CultureInfo#name} of the culture first and
      * if they are not satisfied, the {@link yfiles.system.CultureInfo#parent} chain will be traversed
      * until the {@link yfiles.system.CultureInfo#INVARIANT_CULTURE1} is reached.
      * So in a "en-US" culture the following objects will be queried:
      * <pre><code>
      * store["en-US"][key]
      * store["en"][key]
      * store["invariant"][key]
      * </code></pre>
      * @param {Object} store The object to query the resources for.
      */
      FromStore:{
        new (store:Object):yfiles.system.ResourceManager;
      };
    };
    /**
    * Contains information about the culture that should be used, i.e. "en-US", "de-de", etc.
    */
    export interface CultureInfo extends Object{
      /**
      * Gets the name of the culture, e.g. "en-US".
      */
      name:string;
      /**
      * Gets the parent culture.
      * If the current culture is "en-US", this property would point to the "en" culture. The parent
      * of the "en" culture is the {@link yfiles.system.CultureInfo#INVARIANT_CULTURE}. The parent of the {@link yfiles.system.CultureInfo#INVARIANT_CULTURE}
      * is the {@link yfiles.system.CultureInfo#INVARIANT_CULTURE} itself.
      */
      parent:yfiles.system.CultureInfo;
    }
    var CultureInfo:{
      $class:yfiles.lang.Class;
      /**
      * Gets the invariant culture.
      */
      INVARIANT_CULTURE:yfiles.system.CultureInfo;
      /**
      * Gets or sets the current UI culture.
      * Value: 
      * The current UI culture.
      */
      currentUICulture:yfiles.system.CultureInfo;
      /**
      * Initializes a new instance of the {@link yfiles.system.CultureInfo} class to the invariant culture.
      */
      new ():yfiles.system.CultureInfo;
      /**
      * Initializes a new instance of the {@link yfiles.system.CultureInfo} class to the given name.
      * @param {string} name The name.
      */
      FromCultureId:{
        new (name:string):yfiles.system.CultureInfo;
      };
    };
    /**
    * Provides a method for type-safe equality checks.
    */
    export interface IEquatable<T> extends Object{
      /**
      * Determines whether <code>this</code> is equal to <code>other</code>.
      * @param {T} other The object to compare <code>this</code> to. Must be of the same type.
      * @return {boolean} <code>true</code> if <code>this</code> is equal to the other object.
      * @see Specified by {@link yfiles.system.IEquatable#equalsTyped}.
      */
      equalsTyped(other:T):boolean;
    }
    var IEquatable:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Implemented by objects which can create a clone of themselves.
    */
    export interface ICloneable extends Object{
      /**
      * Create a clone of this object.
      * @return {Object} A clone of this object.
      * @see Specified by {@link yfiles.system.ICloneable#clone}.
      */
      clone():Object;
    }
    var ICloneable:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * Provides a method which can be used to free resources used by the implementor.
    */
    export interface IDisposable extends Object{
      /**
      * Causes the implementor to free all resources.
      * @see Specified by {@link yfiles.system.IDisposable#dispose}.
      */
      dispose():void;
    }
    var IDisposable:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that one or more parameters passed to the current method are out of the legal range.
    */
    export interface IndexOutOfRangeException extends yfiles.lang.Exception{
    }
    var IndexOutOfRangeException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.IndexOutOfRangeException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      WithMessage:{
        new (message:string):yfiles.system.IndexOutOfRangeException;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate an error in an arithmetic operation.
    */
    export interface ArithmeticException extends yfiles.lang.Exception{
    }
    var ArithmeticException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.ArithmeticException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      WithMessage:{
        new (message:string):yfiles.system.ArithmeticException;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that an argument has not the expected format.
    */
    export interface FormatException extends yfiles.lang.Exception{
    }
    var FormatException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.FormatException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      WithMessage:{
        new (message:string):yfiles.system.FormatException;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that one or more parameters passed to the current method are
    * <code>null</code> where a non-<code>null</code> parameter was expected.
    */
    export interface ArgumentNullException extends yfiles.lang.Exception{
    }
    var ArgumentNullException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.ArgumentNullException;
      /**
      * Creates a new instance with the given message.
      * @param {string} parameter The parameter name.
      */
      FromMessage:{
        new (parameter:string):yfiles.system.ArgumentNullException;
      };
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      * @param {string} parameter The parameter name.
      */
      FromMessageAndParameter:{
        new (parameter:string,message:string):yfiles.system.ArgumentNullException;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that one or more parameters passed to the current method are out of the legal range.
    */
    export interface ArgumentOutOfRangeException extends yfiles.lang.Exception{
    }
    var ArgumentOutOfRangeException:{
      $class:yfiles.lang.Class;
      new ():yfiles.system.ArgumentOutOfRangeException;
      /**
      * Creates a new instance with the given parameter.
      * @param {string} param The parameter name that was out of range.
      */
      FromMessage:{
        new (param:string):yfiles.system.ArgumentOutOfRangeException;
      };
      /**
      * Creates a new instance with the given message.
      * @param {string} param The error message.
      * @param {string} message The message.
      */
      FromMessageAndParameter:{
        new (param:string,message:string):yfiles.system.ArgumentOutOfRangeException;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that the current operation is not valid in the object's current state.
    */
    export interface InvalidOperationException extends yfiles.lang.Exception{
    }
    var InvalidOperationException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.InvalidOperationException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      WithMessage:{
        new (message:string):yfiles.system.InvalidOperationException;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate an error in an IO operation.
    */
    export interface IOException extends yfiles.lang.Exception{
    }
    var IOException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.IOException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      FromMessage:{
        new (message:string):yfiles.system.IOException;
      };
      /**
      * Creates a new instance based on the given Exception.
      * @param {string} message The error message.
      * @param {yfiles.lang.Exception} ex The exception which should be forwarded by the new instance. The exception's message is concatenated to the given message.
      */
      FromMessageAndException:{
        new (message:string,ex:yfiles.lang.Exception):yfiles.system.IOException;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that a value is <code>null</code> where it shouldn't.
    */
    export interface NullReferenceException extends yfiles.lang.Exception{
    }
    var NullReferenceException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.NullReferenceException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      WithMessage:{
        new (message:string):yfiles.system.NullReferenceException;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that a class cannot be found.
    */
    export interface ClassNotFoundException extends yfiles.lang.Exception{
    }
    var ClassNotFoundException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      new (message:string):yfiles.system.ClassNotFoundException;
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that the called method is not implemented.
    */
    export interface NotImplementedException extends yfiles.lang.Exception{
    }
    var NotImplementedException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.NotImplementedException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      WithMessage:{
        new (message:string):yfiles.system.NotImplementedException;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that the operation is not supported.
    */
    export interface NotSupportedException extends yfiles.lang.Exception{
    }
    var NotSupportedException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.NotSupportedException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      WithMessage:{
        new (message:string):yfiles.system.NotSupportedException;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that the {@link yfiles.collections.IDictionary} does not contain the given key.
    */
    export interface KeyNotFoundException extends yfiles.lang.Exception{
    }
    var KeyNotFoundException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.KeyNotFoundException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      WithMessage:{
        new (message:string):yfiles.system.KeyNotFoundException;
      };
    };
    /**
    * A copy of the implementation of the same {@link yfiles.lang.Attribute} found in WPF and .net
    * Specifies the type of persistence to use when serializing a property on a component at design time.
    */
    export interface DesignerSerializationVisibilityAttribute extends yfiles.lang.Attribute{
      visibility:yfiles.system.DesignerSerializationVisibility;
    }
    var DesignerSerializationVisibilityAttribute:{
      $class:yfiles.lang.Class;
      CONTENT:yfiles.system.DesignerSerializationVisibilityAttribute;
      VISIBLE:yfiles.system.DesignerSerializationVisibilityAttribute;
      HIDDEN:yfiles.system.DesignerSerializationVisibilityAttribute;
      DEFAULT:yfiles.system.DesignerSerializationVisibilityAttribute;
    };
    export enum DesignerSerializationVisibility{
      /**
      * The code generator does not produce code for the object.
      */
      HIDDEN,
      /**
      * The code generator produces code for the object.
      */
      VISIBLE,
      /**
      * The code generator produces code for the contents of the object, rather than for the object itself.
      */
      CONTENT
    }
    /**
    * A copy of the implementation of the same {@link yfiles.lang.Attribute} found in WPF and .net
    * Specifies what type to use as a converter for the object this attribute is bound to. This class cannot be inherited.
    */
    export interface TypeConverterAttribute extends yfiles.lang.Attribute{
      converterTypeName:string;
    }
    var TypeConverterAttribute:{
      $class:yfiles.lang.Class;
      new ():yfiles.system.TypeConverterAttribute;
      WithType:{
        new (type:yfiles.lang.Class):yfiles.system.TypeConverterAttribute;
      };
      WithTypeName:{
        new (typeName:string):yfiles.system.TypeConverterAttribute;
      };
    };
    /**
    * A copy of the implementation of the same {@link yfiles.lang.Attribute} found in WPF and .net
    * Specifies the default value for a property.
    */
    export interface DefaultValueAttribute extends yfiles.lang.Attribute{
      /**
      * Gets the default value of the property this attribute is bound to.
      */
      value:Object;
      /**
      * Sets the default value of the property this attribute is bound to.
      * @param {Object} value 
      */
      setValue(value:Object):void;
    }
    var DefaultValueAttribute:{
      $class:yfiles.lang.Class;
      With:{
        new (value:Object):yfiles.system.DefaultValueAttribute;
      };
      ConvertedFrom:{
        new (type:yfiles.lang.Class,value:string):yfiles.system.DefaultValueAttribute;
      };
    };
    /**
    * Provides helper methods to manipulate arrays.
    */
    export interface ArrayExtensions extends Object{
    }
    var ArrayExtensions:{
      $class:yfiles.lang.Class;
      /**
      * Not implemented. Always throws an exception.
      * @param {Object} arrayCreationExpression The array creation expression.
      */
      consumeSideEffects(arrayCreationExpression:Object):void;
      /**
      * Creates a class object of an array with the given <code>type</code> and the given <code>dimension</code>.
      * @param {yfiles.lang.Class} type The type of an array element.
      * @param {number} dimension The dimension of the array.
      * @return {yfiles.lang.Class} 
      */
      arrayTypeOf(type:yfiles.lang.Class,dimension:number):yfiles.lang.Class;
      /**
      * Creates an array of <code>number</code>s with the given length,
      * initialized with <code>0</code>.
      * @param {number} length The length of the array to create.
      * @return {Array} An array of <code>number</code>s with the given length.
      */
      createnumberArray(length:number):Array<any>;
      /**
      * Creates an array of <code>number</code>s with the given length,
      * initialized with <code>0</code>.
      * @param {number} length The length of the array to create.
      * @return {Array} An array of <code>number</code>s with the given length.
      */
      createbyteArray(length:number):Array<any>;
      /**
      * Creates an array of <code>number</code>s with the given length,
      * initialized with <code>0</code>.
      * @param {number} length The length of the array to create.
      * @return {Array} An array of <code>number</code>s with the given length.
      */
      createintArray(length:number):Array<any>;
      /**
      * Creates an array of <code>number</code>s with the given length,
      * initialized with <code>0</code>.
      * @param {number} length The length of the array to create.
      * @return {Array} An array of <code>number</code>s with the given length.
      */
      createlongArray(length:number):Array<any>;
      /**
      * Creates an array of <code>boolean</code>s with the given length,
      * initialized with <code>false</code>.
      * @param {number} length The length of the array to create.
      * @return {Array} An array of <code>boolean</code>s with the given length.
      */
      createbooleanArray(length:number):Array<any>;
      /**
      * Creates an array of objects with the given length.
      * @param {number} length The length of the array to create.
      * @return {Array} A object array with the given length.
      */
      createObjectArray(length:number):Array<any>;
      /**
      * Creates an array of <code>string</code>s with the given length,
      * initialized with the empty string.
      * @param {number} length The length of the array to create.
      * @return {Array} An array of <code>string</code>s with the given length.
      */
      createstringArray(length:number):Array<any>;
      /**
      * Creates an array of <code>string</code>s with the given length,
      * initialized with the empty string.
      * @param {number} length The length of the array to create.
      * @return {Array} An array of <code>string</code>s with the given length.
      */
      createcharArray(length:number):Array<any>;
      /**
      * Creates an array of <code>number</code>s with the given length,
      * initialized with <code>0</code>.
      * @param {number} length The length of the array to create.
      * @return {Array} An array of <code>number</code>s with the given length.
      */
      createfloatArray(length:number):Array<any>;
      /**
      * Creates an array of <code>number</code>s with the given length,
      * initialized with <code>0</code>.
      * @param {number} length The length of the array to create.
      * @return {Array} An array of <code>number</code>s with the given length.
      */
      createdoubleArray(length:number):Array<any>;
      /**
      * Creates a multi dimensional array with the given lengths.
      * @param {number[]} lengths An array with the length of the dimensions of the array to create.
      * @return {Array} A multi dimensional array.
      */
      createMultiArray(lengths:number[]):Array<any>;
      /**
      * Whether the given object is an array.
      * @param {Object} obj The object to test.
      * @param {number} dimensions The number of the dimensions of the array. Not used here.
      * @return {boolean} <code>true</code> if the given object is an array.
      */
      instanceOfArray(obj:Object,dimensions:number):boolean;
      /**
      * Copies a given array into another one.
      * @param {Object[]} src The array to copy from.
      * @param {Object[]} target The array to copy to.
      * @param {number} index The index to start at the target.
      */
      copyTo(src:Object[],target:Object[],index:number):void;
      /**
      * Copies a part of a given array into another one.
      * @param {Object[]} src The array to copy from.
      * @param {Object[]} target The array to copy to.
      * @param {number} length The number of elements to copy.
      */
      copy(src:Object[],target:Object[],length:number):void;
      /**
      * Copies a part of a given array into another one.
      * @param {Object[]} src The array to copy from.
      * @param {number} srcIndex The index to start copying at the source array.
      * @param {Object[]} target The array to copy to.
      * @param {number} targetIndex The index to start copying to at the target array.
      * @param {number} count The number of elements to copy.
      */
      arrayCopy(src:Object[],srcIndex:number,target:Object[],targetIndex:number,count:number):void;
      /**
      * Reverses the order of elements in the given array.
      * @param {Object} array The array to revert.
      */
      reverse(array:Object):void;
      /**
      * Sorts a given array in ascending order.
      * This method determines the sort order:
      * <ul>
      * <li>Numbers are sorted according to their numerical value.</li>
      * <li>Implementors of {@link yfiles.lang.IObjectComparable} and {@link yfiles.lang.IComparable} are sorted according to their {@link yfiles.lang.IComparable#compareTo} method.</li>
      * <li>All other items are sorted alphabetically.</li>
      * </ul>
      * @param {Object} array The array to sort.
      */
      sort(array:Object):void;
      /**
      * Sorts an array in ascending order using the given {@link yfiles.collections.IComparer}.
      * @param {Object} a The array ti sort.
      * @param {yfiles.collections.IComparer.<Object>} comparer The comparer to use to compare the array elements.
      */
      sortComparer(a:Object,comparer:yfiles.collections.IComparer<Object>):void;
      /**
      * Sorts an array in ascending order using the given {@link yfiles.objectcollections.IComparer}.
      * @param {Object} a The array ti sort.
      * @param {yfiles.objectcollections.IComparer} comparer The comparer to use to compare the array elements.
      */
      sortObjectComparer(a:Object,comparer:yfiles.objectcollections.IComparer):void;
      /**
      * Sorts an array in ascending order using the given <code>comparer</code>.
      * The comparison function takes two arguments, o1 and o2, and returns
      * <ul>
      * <li><b>-1</b> if <code>>o1 &lt; o2</code></li>
      * <li><b>0</b> if <code>>o1 == o2</code></li>
      * <li><b>1</b> if <code>>o1 &gt; o2</code></li>
      * </ul>
      * @param {Object} a The array to sort.
      * @param {function(Object, Object):number} comparer The comparison function.
      */
      sortComparison(a:Object,comparer:(arg1:Object,arg2:Object)=>number):void;
      /**
      * Sorts the range of an array in ascending order.
      * @param {yfiles.lang.Class} type The type of the array elements.
      * @param {Array} a The array to sort.
      * @param {number} index The index to start from.
      * @param {number} length The length of the range to sort.
      */
      sortRange<T>(type:yfiles.lang.Class,a:Array<any>,index:number,length:number):void;
      /**
      * Sorts an array with the given type in ascending order.
      * @param {yfiles.lang.Class} type The type of the array elements.
      * @param {Array} a The array to sort.
      */
      sortTyped<T>(type:yfiles.lang.Class,a:Array<any>):void;
      /**
      * Creates an {@link yfiles.collections.IEnumerator} which iterates over the given array.
      * @param {Object[]} array The array to create the enumerator for.
      * @return {yfiles.collections.IEnumerator.<Object>} An {@link yfiles.collections.IEnumerator} which iterates over the given array.
      */
      getEnumerator(array:Object[]):yfiles.collections.IEnumerator<Object>;
      /**
      * Returns the highest possible index for the given dimension of the given array.
      * The highest possible index is the array's length - 1.
      * @param {Array} a The array to get the bound for.
      * @param {number} dimension The dimension of the array to get the bound for. 0 for a one-dimensional array.
      * @return {number} The upper bound of the given array.
      */
      getUpperBound(a:Array<any>,dimension:number):number;
      /**
      * Returns the length of the given dimension of the given array.
      * @param {Array} a The array to get the length for.
      * @param {number} dimension The dimension of the array to get the length for. 0 for a one-dimensional array.
      * @return {number} The length of the given array.
      */
      getLength(a:Array<any>,dimension:number):number;
    };
    /**
    * Subclasses of {@link yfiles.system.EventArgs} are passed to event handlers to provide the
    * information they need to handle an event.
    */
    export interface EventArgs extends Object{
    }
    var EventArgs:{
      $class:yfiles.lang.Class;
      /**
      * An empty {@link yfiles.system.EventArgs} object that can be used when no information needs to be passed
      * to the event handler.
      */
      EMPTY:yfiles.system.EventArgs;
    };
    /**
    * An event that sends this argument can be canceled.
    * If, after the event handlers have been processed, the {@link yfiles.system.CancelEventArgs#cancel} property
    * is set to <code>true</code>, then the expected behaviour of the event source is to cancel the action it was
    * about to do.
    */
    export interface CancelEventArgs extends yfiles.system.EventArgs{
      /**
      * Gets or sets a value indicating whether the action should be canceled.
      * Value: 
      *   <code>true</code> if the action should be canceled; otherwise, <code>false</code>.
      */
      cancel:boolean;
    }
    var CancelEventArgs:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new instance of the {@link yfiles.system.CancelEventArgs} class.
      * The default value for the {@link yfiles.system.CancelEventArgs#cancel} property will be <code>false</code>.
      */
      new ():yfiles.system.CancelEventArgs;
      /**
      * Initializes a new instance of the {@link yfiles.system.CancelEventArgs} class with the given value for the
      * {@link yfiles.system.CancelEventArgs#cancel} field.
      * This constructor can be useful if the event is fired in a "opt-in" style, i.e. if the action should not be
      * performed unless at least one of the event handlers requested it by setting the value of {@link yfiles.system.CancelEventArgs#cancel} to
      * <code>false</code>-
      * @param {boolean} cancel The starting value of the {@link yfiles.system.CancelEventArgs#cancel} property.
      */
      WithCancel:{
        new (cancel:boolean):yfiles.system.CancelEventArgs;
      };
    };
    /**
    * An {@link yfiles.lang.Exception} to indicate that one or more parameters passed to the current method are illegal.
    */
    export interface ArgumentException extends yfiles.lang.Exception{
    }
    var ArgumentException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.ArgumentException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      FromMessage:{
        new (message:string):yfiles.system.ArgumentException;
      };
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      * @param {string} parameterName The parameter name that caused the problem.
      */
      FromMessageAndParameter:{
        new (message:string,parameterName:string):yfiles.system.ArgumentException;
      };
      /**
      * Creates a new instance based on the given Exception.
      * @param {string} message The error message.
      * @param {yfiles.lang.Exception} exception The exception which should be forwarded by the new instance. The exception's message is concatenated to the given message.
      */
      FromMessageAndException:{
        new (message:string,exception:yfiles.lang.Exception):yfiles.system.ArgumentException;
      };
    };
    export interface Convert extends Object{
    }
    var Convert:{
      $class:yfiles.lang.Class;
      /**
      * Converts a string into a Number type. Simply forwards to the standard <code>parseFloat</code> method on <code>window</code>.
      * @param {string} s The string which represents the number.
      * @return {number} The Number represented by the string
      */
      stringToDouble(s:string):number;
      /**
      * Converts a Double object to a Number.
      * @param {number} d The double.
      * @return {number} The Number represented by the input.
      */
      toDouble(d:number):number;
      /**
      * Converts an object into a Number using the native <code>parseFloat</code> method.
      * The object is first converted to a string before it is converted to a Number.
      * @param {Object} o The object.
      * @return {number} The Number represented by the object.
      */
      objectToDouble(o:Object):number;
      /**
      * Converts a string into a boolean.
      * Only the value <code>true</code> is converted to the boolean value <code>true</code>, all other values are converted to <code>false</code>.
      * @param {string} s The string.
      * @return {boolean} <code>true</code>, if the string value equals <code>true</code>; <code>false</code> otherwise.
      */
      stringToBoolean(s:string):boolean;
      /**
      * Casts an object to a boolean.
      * This method follows the standard Javascript rules to determine whether an object is "truthy" or "falsy".
      * @param {Object} o The object.
      * @return {boolean} <code>true</code>, unless the object has a "falsy" value, i.e. is <code>undefined</code> or <code>null</code>.
      */
      objectToBoolean(o:Object):boolean;
      /**
      * Returns the string representation of the given number.
      * @param {number} value The number
      * @return {string} A string representation of the given number.
      */
      doubleToString(value:number):string;
      /**
      * Returns the string representation of the given number with respect to the specified base.
      * @param {number} value The number
      * @param {number} toBase The base
      * @return {string} A string representation of the given number with respect to the specified base.
      */
      intToStringWithBase(value:number,toBase:number):string;
      /**
      * Converts an integer value into a byte value by keeping only the last 8 bits.
      * @param {number} value The value.
      * @return {number} 
      */
      toByte(value:number):number;
      /**
      * Converts the integer value into a 16-bit long integer by keeping only the last 16 bits.
      * @param {number} value The value.
      * @return {number} 
      */
      toInt16(value:number):number;
      /**
      * Converts a string into an integer with a base of 10 (decimal system).
      * @param {string} value The value.
      * @return {number} The integer value as parsed from the string.
      */
      stringToInt32(value:string):number;
      /**
      * Converts a string into an integer with the given radix as the base.
      * @param {string} value The value.
      * @param {number} radix The radix.
      * @return {number} The integer value as parsed from the string.
      */
      stringToInt32WithRadix(value:string,radix:number):number;
      /**
      * Converts an object into an integer with a base of 10 (decimal system).
      * @param {Object} value The value.
      * @return {number} The integer value as parsed from the string.
      */
      objectToInt32(value:Object):number;
      stringToInt64(value:string):number;
      toUInt16(value:number):Number;
      toUInt32(value:number):number;
      toUInt64(value:number):number;
    };
    /**
    * Provides error handling functionality for the yFiles library.
    * If {@link yfiles.system.ErrorHandling#catchErrors} is enabled, most entry points (e.g. event listeners)
    * use try/catch blocks to catch possible errors that could be thrown in the event handlers.
    * The errors are handled by the {@link yfiles.system.ErrorHandling#handleError} function, which calls the {@link yfiles.system.ErrorHandling#errorHandler} 
    * function, if it has been set. 
    * Note that for some browsers/plugins, try/catch blocks prevent error debugging functionality. Hence, {@link yfiles.system.ErrorHandling#catchErrors}
    * should be turned off while debugging.
    */
    export interface ErrorHandling extends Object{
    }
    var ErrorHandling:{
      $class:yfiles.lang.Class;
      /**
      * Whether to use try/catch blocks when invoking event handlers.
      * If this property is enabled, try/catch blocks are used when invoking event handlers. 
      * As most browsers provide a stack trace with Error objects, this property can be used to provide 
      * more detailed error information.
      */
      catchErrors:boolean;
      /**
      * If {@link yfiles.system.ErrorHandling#catchErrors} is enabled, any caught errors are passed to this function.
      */
      errorHandler:(obj:Object)=> void;
      /**
      * This function is called in catch blocks if {@link yfiles.system.ErrorHandling#catchErrors} is enabled. 
      * If an {@link yfiles.system.ErrorHandling#errorHandler} is registered, the error is passed to the error handler.
      * @param {Object} error The error that has been caught
      */
      handleError(error:Object):void;
    };
    export interface TargetException extends yfiles.lang.Exception{
    }
    var TargetException:{
      $class:yfiles.lang.Class;
      new (message:string):yfiles.system.TargetException;
    };
    /**
    * Defines an event which is dispatched when a property changes.
    */
    export interface INotifyPropertyChanged extends Object{
      /**
      * Event which is dispatched when a property changes.
      */
      addPropertyChangedListener(value:(sender:Object,e:yfiles.system.PropertyChangedEventArgs)=> void):void;
      /**
      * Event which is dispatched when a property changes.
      */
      removePropertyChangedListener(value:(sender:Object,e:yfiles.system.PropertyChangedEventArgs)=> void):void;
    }
    var INotifyPropertyChanged:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * A copy of the implementation of the Monitor class found in WPF and .net
    * Provides a mechanism that synchronizes access to objects.
    * This implementation is rather useless in a single-threaded environment.
    */
    export interface Monitor extends Object{
    }
    var Monitor:{
      $class:yfiles.lang.Class;
      /**
      * Notifies a thread in the waiting queue of a change in the locked object's state.
      * @param {Object} obj The object a thread is waiting for.
      */
      pulse(obj:Object):void;
      /**
      * Does nothing.
      */
      pulseAll(obj:Object):void;
      /**
      * Does nothing.
      */
      wait(obj:Object):boolean;
      /**
      * Does nothing.
      */
      waitWithTimeout(obj:Object,millisecondsTimeout:number):boolean;
    };
    /**
    * Event arguments which contain information for a {@link yfiles.system.INotifyPropertyChanged#addPropertyChangedListener PropertyChanged} event.
    */
    export interface PropertyChangedEventArgs extends yfiles.system.EventArgs{
      /**
      * The name of the changed property.
      */
      propertyName:string;
    }
    var PropertyChangedEventArgs:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance.
      * @param {string} propertyName The name of the changed property.
      */
      new (propertyName:string):yfiles.system.PropertyChangedEventArgs;
    };
    export enum MethodAttributes{
      /**
      * There is no information available.
      */
      NONE,
      /**
      * Signals that the method is public.
      */
      PUBLIC,
      /**
      * Signals that the method is static, i.e. it can be invoked without creating an instance of the type first.
      */
      STATIC
    }
    export enum MemberTypes{
      /**
      * The member is a constructor.
      */
      CONSTRUCTOR,
      /**
      * The member is an event.
      */
      EVENT,
      /**
      * The member is a field.
      */
      FIELD,
      /**
      * The member is a method.
      */
      METHOD,
      /**
      * The member is a property.
      */
      PROPERTY,
      /**
      * The member is a type info.
      */
      TYPE_INFO,
      /**
      * The member is of a custom, unknown, type.
      */
      CUSTOM,
      /**
      * The member is a nested type, i.e. a nested inner class or interface.
      */
      NESTED_TYPE,
      /**
      * The member is of any type.
      */
      ALL
    }
    /**
    * An attribute that can be used to specify the type of a field or property or the return type of a method.
    */
    export interface TypeAttribute extends yfiles.lang.Attribute{
      /**
      * Gets or sets the type.
      * Value: 
      * The type.
      */
      type:yfiles.lang.Class;
    }
    var TypeAttribute:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new instance of the {@link yfiles.system.TypeAttribute} class.
      * @param {yfiles.lang.Class} type The type.
      */
      new (type:yfiles.lang.Class):yfiles.system.TypeAttribute;
    };
    /**
    * An attribute which contains information about the parameters of a method.
    */
    export interface ParameterAttribute extends yfiles.lang.Attribute{
      /**
      * Gets the name of the parameter.
      */
      name:string;
      /**
      * Gets the type of the parameter.
      */
      type:yfiles.lang.Class;
      /**
      * Gets a value indicating whether the parameter is optional.
      * Value: 
      * 	<code>true</code> if the parameter is optional; otherwise, <code>false</code>.
      */
      isOptional:boolean;
      /**
      * Converts this {@link yfiles.system.ParameterAttribute} into a {@link yfiles.system.ParameterInfo} object.
      * @param {yfiles.system.MemberInfo} owner The owner.
      * @param {number} position The position.
      * @return {yfiles.system.ParameterInfo} 
      */
      toParameterInfo(owner:yfiles.system.MemberInfo,position:number):yfiles.system.ParameterInfo;
    }
    var ParameterAttribute:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new instance of the {@link yfiles.system.ParameterAttribute} class.
      * @param {string} name The name.
      * @param {yfiles.lang.Class} type The type.
      * @param {boolean} isOptional if set to <code>true</code> [is optional].
      */
      new (name:string,type:yfiles.lang.Class,isOptional:boolean):yfiles.system.ParameterAttribute;
    };
    /**
    * Provides static arithmetic methods which are missing in JavaScript's <code>Math</code> class.
    */
    export interface Math extends Object{
    }
    var Math:{
      $class:yfiles.lang.Class;
      /**
      * Rounds the given <code>value</code> to the given <code>digits</code>.
      * @param {number} value The value to round.
      * @param {number} digits The number of digits to round to.
      * @return {number} The rounded value.
      */
      round(value:number,digits:number):number;
      /**
      * Rounds the given <code>value</code> to the given <code>digits</code>
      * following the given <code>midpoint</code> for rounding 0.5.
      * @param {number} value The value to round.
      * @param {number} digits The number of digits to round to.
      * @param {yfiles.system.MidpointRounding} midpoint The rule for rounding midpoint values.
      * @return {number} The rounded value.
      */
      roundMidpoint(value:number,digits:number,midpoint:yfiles.system.MidpointRounding):number;
      /**
      * Determines the sign of a given value.
      * @param {number} value The value to determine the sign for.
      * @return {number} -1 for negative values, 1 for positive values, 0 for 0.
      */
      sign(value:number):number;
      /**
      * The negative maximum value (i.e. the minimum value) for <code>Number</code>.
      */
      NEGATIVE_MAX_VALUE:number;
      /**
      * The maximum value for signed 32 bit integers.
      */
      INT32_MAX_VALUE:number;
      /**
      * The minimum value for signed 32 bit integers.
      */
      INT32_MIN_VALUE:number;
      /**
      * The maximum value for signed 16 bit integers.
      */
      INT16_MAX_VALUE:number;
      /**
      * The minimum value for signed 16 bit integers.
      */
      INT16_MIN_VALUE:number;
      /**
      * The maximum value for signed 8 bit integers.
      */
      BYTE_MAX_VALUE:number;
      /**
      * The minimum value for signed 8 bit integers.
      */
      BYTE_MIN_VALUE:number;
    };
    /**
    * A pseudo-random number generator.
    */
    export interface Random extends Object{
      /**
      * Sets the random seed.
      */
      seed:Number;
      /**
      * Gets a random boolean value.
      * @return {boolean} A random boolean value.
      */
      nextBoolean():boolean;
      /**
      * Gets a random positive integer value between 0 (included) and {@link yfiles.system.Math#INT32_MAX_VALUE} (excluded).
      * @return {number} A random integer value (0 &lt;= value &lt; {@link yfiles.system.Math#INT32_MAX_VALUE}).
      */
      next():number;
      /**
      * Gets a random positive integer value between 0 (included) and <code>max</code> (excluded).
      * @param {number} max The maximum value of the returned integer values. Must be greater than 0.
      * @return {number} A random integer value (0 &lt;= value &lt; <code>max</code>).
      */
      nextInt(max:number):number;
      /**
      * Gets a random integer value between <code>min</code> (included) and <code>max</code> (excluded).
      * @param {number} min The lower bound of the range of possible values.
      * @param {number} max The upper bound of the range of possible values.
      * @return {number} A random integer value (<code>min</code> &lt;= value &lt; <code>max</code>).
      */
      nextIntInRange(min:number,max:number):number;
      /**
      * Returns a byte array with random values.
      * @param {number[]} buffer The byte array to fill with random values.
      */
      nextBytes(buffer:number[]):void;
      /**
      * Returns a random Number between 0 (included) and 1 (excluded).
      * @return {number} A random Number (0 &lt;= value &lt; 1).
      */
      nextDouble():number;
      /**
      * Returns a random Number between 0 (included) and 1 (excluded).
      * @return {number} A random Number (0 &lt;= value &lt; 1).
      */
      sample():number;
    }
    var Random:{
      $class:yfiles.lang.Class;
      /**
      * Create a new instance which uses the current system time as seed.
      */
      new ():yfiles.system.Random;
      /**
      * Create a new instance with the given seed.
      * @param {Number} seed A number to use as seed.
      */
      WithSeed:{
        new (seed:Number):yfiles.system.Random;
      };
    };
    export interface ApplicationException extends yfiles.lang.Exception{
    }
    var ApplicationException:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with an empty message.
      */
      new ():yfiles.system.ApplicationException;
      /**
      * Creates a new instance with the given message.
      * @param {string} message The error message.
      */
      WithMessage:{
        new (message:string):yfiles.system.ApplicationException;
      };
    };
    export enum MidpointRounding{
      /**
      * Round to the next even value.
      */
      TO_EVEN,
      /**
      * Round to the value which is away from 0.
      */
      AWAY_FROM_ZERO
    }
  }
  export module tree{
    export enum ConnectorDirection{
      /**
      * Direction constant used by .
      */
      NORTH,
      /**
      * Direction constant used by .
      */
      EAST,
      /**
      * Direction constant used by .
      */
      SOUTH,
      /**
      * Direction constant used by .
      */
      WEST
    }
    export enum BorderlineSide{
      /**
      * Side constant used by .
      */
      NORTH,
      /**
      * Side constant used by .
      */
      EAST,
      /**
      * Side constant used by .
      */
      SOUTH,
      /**
      * Side constant used by .
      */
      WEST
    }
    export enum LayeredRoutingStyle{
      /**
      * Layout style constant. Draw edges as straight lines.
      * <p>
      * Note that it is possible that edges overlap with nodes depending on their size and vertical alignment. When
      * , there
      * might also be edge overlaps with node labels that are placed above the according node.
      * </p>
      */
      PLAIN,
      /**
      * Layout style constant. Draw edges orthogonally in a bus-like fashion.
      */
      ORTHOGONAL
    }
    export enum RoutingStyle{
      /**
      * Routing style byte constant used for the <code>routingStyle</code> property.
      * Using this value will result in orthogonally routed child node
      * connectors where the bends are placed in the channel between the
      * root node and the child nodes.
      */
      FORK,
      /**
      * Routing style byte constant used for the <code>routingStyle</code> property.
      * Using this value will result in orthogonally routed child node
      * connectors with one bend each placed next to the root node.
      */
      FORK_AT_ROOT,
      /**
      * Routing style byte constant used for the <code>routingStyle</code> property.
      * Using this value will result in straight connections to the child nodes.
      * Edges may overlap nodes in this case.
      */
      STRAIGHT,
      /**
      * Routing style byte constant used for the <code>routingStyle</code> property.
      * Using this value will result in straight connections to the connector of the subtree.
      */
      POLY_LINE
    }
    export enum RootAlignment{
      /**
      * Alignment byte constant used for the <code>rootAlignment</code> property.
      * This constant places the root ahead of all the child subtrees.
      */
      LEADING_OFFSET,
      /**
      * Alignment byte constant used for the <code>rootAlignment</code> property.
      * This constant aligns the root with the first of its subtrees.
      */
      LEADING,
      /**
      * Alignment byte constant used for the <code>rootAlignment</code> property.
      * This constant aligns the root at the center of its subtrees.
      */
      CENTER,
      /**
      * Alignment byte constant used for the <code>rootAlignment</code> property.
      * This constant aligns the root at the median of the connection points to its subtrees.
      */
      MEDIAN,
      /**
      * Alignment byte constant used for the <code>rootAlignment</code> property.
      * This constant aligns the root at with the last of its subtrees.
      */
      TRAILING,
      /**
      * Alignment byte constant used for the <code>rootAlignment</code> property.
      * This constant places the root after all of its subtrees.
      */
      TRAILING_OFFSET,
      /**
      * Alignment byte constant used for the <code>rootAlignment</code> property.
      * This constant places the root after all of its subtrees and centered on the bus.
      * <p>
      * Note: The vertical/horizontal distance between the root node and the subtree shapes depend on the value
      * of parameters verticalDistance/horizontalDistance passed to the Constructor.
      * </p>
      */
      TRAILING_ON_BUS,
      /**
      * Alignment byte constant used for the <code>rootAlignment</code> property.
      * This constant places the root ahead of all the child subtrees and centered on the bus.
      * <p>
      * Note: The vertical/horizontal distance between the root node and the subtree shapes depend on the value
      * of parameters verticalDistance/horizontalDistance passed to the Constructor.
      * </p>
      */
      LEADING_ON_BUS
    }
    export enum Orientation{
      /**
      * Orientation specifier. Node shapes will be aligned on the x-axis.
      */
      HORIZONTAL,
      /**
      * Orientation specifier. Node shapes will be aligned on the y-axis.
      */
      VERTICAL
    }
    export enum PortAssignmentMode{
      /**
      * Mode constant describing the strategy where edges having 
      * <ul>
      * <li>
      * a weak port constraint, i.e., effectively a side constraint, will be anchored 
      * at the center of that side 
      * </li>
      * <li>
      * no port constraint set will be anchored at the center of the node 
      * </li>
      * </ul>
      * Edges having a strong port constraint are anchored at that coordinates.
      * <p>
      * If edges with port constraints are grouped, all edges in the same group will use the port coordinates of the
      * first edge in the group.
      * </p>
      * @see {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY}
      * @see {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}
      */
      PORT_CONSTRAINT,
      /**
      * Mode constant describing the strategy where edges are distributed evenly at the
      * northern side of their nodes.
      * <p>
      * Grouped edges will use the same port coordinate and will be considered as a single edge when calculating the 
      * distribution.
      * </p>
      * @see {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY}
      * @see {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}
      */
      DISTRIBUTED_NORTH,
      /**
      * Mode constant describing the strategy where edges are distributed evenly at the
      * southern side of their nodes.
      * <p>
      * Grouped edges will use the same port coordinate and will be considered as a single edge when calculating the 
      * distribution.
      * </p>
      * @see {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY}
      * @see {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}
      */
      DISTRIBUTED_SOUTH,
      /**
      * Mode constant describing the strategy where edges are distributed evenly at the
      * eastern side of their nodes.
      * <p>
      * Grouped edges will use the same port coordinate and will be considered as a single edge when calculating the 
      * distribution.
      * </p>
      * @see {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY}
      * @see {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}
      */
      DISTRIBUTED_EAST,
      /**
      * Mode constant describing the strategy where edges are distributed evenly at the
      * western side of their nodes.
      * <p>
      * Grouped edges will use the same port coordinate and will be considered as a single edge when calculating the 
      * distribution.
      * </p>
      * @see {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY}
      * @see {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}
      */
      DISTRIBUTED_WEST,
      /**
      * Mode constant describing the strategy where all ports are reset to the center 
      * of their nodes.
      */
      NONE
    }
    export enum EdgeLayoutStyle{
      /**
      * Layout style constant. Draw edges as straight lines.
      */
      PLAIN,
      /**
      * Layout style constant. Draw edges orthogonally in a bus-like fashion.
      */
      ORTHOGONAL
    }
    export enum ChildPlacementPolicy{
      /**
      * Symbolic child placement policy specifier.
      * This setting configures the algorithm for a stacked style of leaf nodes.
      * In this context, <em>stacked</em> means that leaf nodes that connect to
      * the same root node are placed one upon the other.
      * This results in horizontally compact layouts.
      * Additionally, this policy tries to balance stack heights. I.e. for each
      * subtree that consists of leaf nodes only,
      * {@link yfiles.tree.ChildPlacementPolicy#LEAVES_STACKED_RIGHT} or
      * {@link yfiles.tree.ChildPlacementPolicy#LEAVES_STACKED_LEFT_AND_RIGHT} will be used
      * depending on the number of leaves in the subtree.
      */
      LEAVES_STACKED,
      /**
      * Symbolic child placement policy specifier.
      * This setting configures the algorithm for a stacked style of leaf nodes.
      * In this context, <em>stacked</em> means that leaf nodes that connect to
      * the same root node are placed one upon the other.
      * This results in horizontally compact layouts.
      * Moreover, the stack of leaf nodes is on the left.
      */
      LEAVES_STACKED_LEFT,
      /**
      * Symbolic child placement policy specifier.
      * This setting configures the algorithm for a stacked style of leaf nodes.
      * In this context, <em>stacked</em> means that leaf nodes that connect to
      * the same root node are placed one upon the other.
      * This results in horizontally compact layouts.
      * Moreover, the stack of leaf nodes is on the right.
      */
      LEAVES_STACKED_RIGHT,
      /**
      * Symbolic child placement policy specifier.
      * This setting configures the algorithm for a stacked style of leaf nodes.
      * In this context, <em>stacked</em> means that leaf nodes that connect to
      * the same root node are placed one upon the other.
      * This results in horizontally compact layouts.
      * Moreover, leaf nodes are distributed among two stacks, one on the left
      * and one on the right.
      */
      LEAVES_STACKED_LEFT_AND_RIGHT,
      /**
      * Symbolic child placement policy specifier.
      * This results in a Dendrogram-style layout with all leaf nodes being
      * placed in one layer (i.e. all leaves are being placed on one horizontal
      * line in a top to bottom or bottom to top layout).
      * A Dendrogram layout is often applied in computational biology in order to
      * show clustering of genes.
      */
      ALL_LEAVES_ON_SAME_LAYER,
      /**
      * Symbolic child placement policy specifier.
      * This setting configures the algorithm to place siblings (leaf nodes with
      * the same parent node) in the same layer (i.e. siblings are being placed
      * on one horizontal line in a top to bottom or bottom to top layout).
      */
      SIBLINGS_ON_SAME_LAYER
    }
    export enum ParentConnectorDirection{
      /**
      * Byte constant that is as argument to the main method, indicating that no connector
      * should be calculated.
      */
      NONE,
      /**
      * Byte constant that is an argument to the main method, indicating that any connector
      * direction can be used for the connection to the parent node.
      */
      ANY,
      /**
      * Byte constant that is an argument to the main method, indicating that the connector
      * direction to the parent node should end in a segment that can be extended by a segment
      * that goes into north direction.
      */
      NORTH,
      /**
      * Byte constant that is an argument to the main method, indicating that the connector
      * direction to the parent node should end in a segment that can be extended by a segment
      * that goes into east direction.
      */
      EAST,
      /**
      * Byte constant that is an argument to the main method, indicating that the connector
      * direction to the parent node should end in a segment that can be extended by a segment
      * that goes into south direction.
      */
      SOUTH,
      /**
      * Byte constant that is an argument to the main method, indicating that the connector
      * direction to the parent node should end in a segment that can be extended by a segment
      * that goes into west direction.
      */
      WEST
    }
    export enum MultiParentRoutingStyle{
      /**
      * Routing style for edges that are connected to nodes that constitute a multi-parent structure.
      * Using this style will route the part of the edges that doesn't share the same path in a polyline fashion.
      * @see {@link yfiles.tree.MultiParentRoutingStyle#ORTHOGONAL}
      * @see {@link yfiles.tree.MultiParentRoutingStyle#STRAIGHT}
      */
      POLYLINE,
      /**
      * Routing style for edges that are connected to nodes that constitute a multi-parent structure.
      * Using this style will route the part of the edges that doesn't share the same path orthogonally.
      * @see {@link yfiles.tree.MultiParentRoutingStyle#POLYLINE}
      * @see {@link yfiles.tree.MultiParentRoutingStyle#STRAIGHT}
      */
      ORTHOGONAL,
      /**
      * Routing style for edges that are connected to nodes that constitute a multi-parent structure.
      * Using this style will route the part of the edges that doesn't share the same path directly from the center of the
      * multi-parent to the common point of the edges in the multi-parent structure.
      * @see {@link yfiles.tree.MultiParentRoutingStyle#POLYLINE}
      * @see {@link yfiles.tree.MultiParentRoutingStyle#ORTHOGONAL}
      */
      STRAIGHT
    }
    export enum PortStyle{
      /**
      * Port style constant. Uses (0,0) as port offset.
      */
      NODE_CENTER,
      /**
      * Port style constant. Ports will lie at the center of a node border.
      */
      BORDER_CENTER,
      /**
      * Port style constant. Ports will be distributed evenly on the side of a node.
      */
      BORDER_DISTRIBUTED,
      /**
      * Port style constant. The specified port constraints will be considered.
      */
      PORT_CONSTRAINTS_AWARE
    }
    export interface HierarchicTreePlacer extends yfiles.tree.AbstractNodePlacer{
      /**
      * This method must be implemented by subclasses.
      * It assigns a connector shape
      * direction to each child.
      * @param {yfiles.algorithms.Node} child the child node
      * @return {number} 
      * a byte constant as defined in the {@link yfiles.tree.INodePlacer} interface
      */
      determineChildConnector(child:yfiles.algorithms.Node):number;
      /**
      * The main placeSubtree method that must be implemented by subclasses.
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction of the connector shape
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} a SubtreeShape instance that describes the shape of the whole subtree
      */
      placeSubtreeImpl(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
    }
    var HierarchicTreePlacer:{
      $class:yfiles.lang.Class;
      /**
      * creates a new HierarchicTreePlacer.
      * @param {number} minimalNodeDistance the minimal allowed distance between two nodes in the same layer
      */
      new (minimalNodeDistance:number):yfiles.tree.HierarchicTreePlacer;
    };
    export enum ChildPlacement{
      /**
      * Placement byte constant used for the <code>childPlacement</code> property.
      * This placement strategy arranges child subtrees vertically beneath each other
      * to the left of the root node.
      */
      VERTICAL_TO_LEFT,
      /**
      * Placement byte constant used for the <code>childPlacement</code> property.
      * This placement strategy arranges child subtrees vertically beneath each other
      * to the right of the root node.
      */
      VERTICAL_TO_RIGHT,
      /**
      * Placement byte constant used for the <code>childPlacement</code> property.
      * This placement strategy arranges child subtrees horizontally next to each other
      * above the root node.
      */
      HORIZONTAL_UPWARD,
      /**
      * Placement byte constant used for the <code>childPlacement</code> property.
      * This placement strategy arranges child subtrees horizontally next to each other
      * below the root node.
      */
      HORIZONTAL_DOWNWARD
    }
    /**
    * Placer that can be used as simple "pseudo"-placer.
    * May be useful if the localRoot does not have any children
    * or you want to place them manually.
    */
    export interface FreePlacer extends yfiles.tree.AbstractRotatableNodePlacer{
      /**
      * This method must be implemented by subclasses.
      * It is used to assigns a connector shape direction to each child.
      * @param {yfiles.algorithms.Node} child the child node
      * @return {yfiles.tree.ParentConnectorDirection} 
      * a byte constant as defined in the {@link yfiles.tree.INodePlacer} interface
      */
      determineChildConnector(child:yfiles.algorithms.Node):yfiles.tree.ParentConnectorDirection;
      /**
      * Creates the subtree shape.
      * @param {yfiles.algorithms.Node} localRoot 
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection 
      * @return {yfiles.tree.SubtreeShapeRotated} the created subtree shape
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtreeWithDirection}
      */
      placeSubtreeWithDirection(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.SubtreeShapeRotated;
      /**
      * Creates a processor suitable to the FreePlacer.
      * This processor will change all descendants node placers to FreePlacer.
      * @param {yfiles.tree.GenericTreeLayouter} layouter 
      * @param {yfiles.layout.LayoutGraph} graph 
      * @param {yfiles.algorithms.Node} currentRoot 
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#createProcessor}
      * @see Specified by {@link yfiles.tree.INodePlacer#createProcessor}.
      */
      createProcessor(layouter:yfiles.tree.GenericTreeLayouter,graph:yfiles.layout.LayoutGraph,currentRoot:yfiles.algorithms.Node):yfiles.tree.IProcessor;
    }
    var FreePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance with the default matrix.
      */
      new ():yfiles.tree.FreePlacer;
    };
    /**
    * The DoubleLinePlacer is a special node placer that places its children in
    * two lines.
    * This node placer is especially useful for leaves with great width.
    */
    export interface DoubleLinePlacer extends yfiles.tree.AbstractRotatableNodePlacer{
      /**
      * Returns {@link yfiles.tree.ParentConnectorDirection#NORTH}.
      * @return {yfiles.tree.ParentConnectorDirection} <code>NodePlacer#DIRECTION_NORTH</code>
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#determineChildConnector}
      */
      determineChildConnector(child:yfiles.algorithms.Node):yfiles.tree.ParentConnectorDirection;
      /**
      * Places the subtree in two lines.
      * @return {yfiles.tree.SubtreeShapeRotated} the subtree
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtreeWithDirection}
      */
      placeSubtreeWithDirection(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.SubtreeShapeRotated;
      /**
      * The horizontal alignment that is used for the root node.
      */
      rootAlignment:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
      /**
      * The ratio of the{@link yfiles.tree.AbstractRotatableNodePlacer#spacing  spacing} between the root and the children in the upper line
      * and the spacing between the two lines of subtrees.
      * <p>
      * By default, the ratio is 0.33 due to backwards compatibility.
      * </p>
      */
      doubleLineSpacingRatio:number;
    }
    var DoubleLinePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new DoubleLinePlacer with the default modification matrix.
      */
      new ():yfiles.tree.DoubleLinePlacer;
      /**
      * Creates a new DoubleLinePlacer with the given modification matrix.
      * @param {yfiles.tree.AbstractRotatableNodePlacer.Matrix} modificationMatrix the current modification matrix
      */
      WithMatrix:{
        new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix):yfiles.tree.DoubleLinePlacer;
      };
    };
    /**
    * This is an implementation of the {@link yfiles.tree.INodePlacer} interface that
    * can be used to create dendrogram-like tree layouts.
    * This placer arranges nodes from top to bottom.
    * It arranges subtrees in such a way that all subtrees of a single local root align at their bottom border.
    * This implementation does not support {@link yfiles.layout.PortConstraint}s.
    */
    export interface DendrogramPlacer extends Object,yfiles.tree.IFromSketchNodePlacer{
      /**
      * The distance between the root shape and the bus connecting all of its subtrees.
      * The default is <code>30</code>.
      */
      minimumRootDistance:number;
      /**
      * The distance between two adjacent subtree shapes.
      * The default is <code>30</code>.
      */
      minimumSubtreeDistance:number;
      /**
      * This method is called by GenericTreeLayouter before the subtree shapes of
      * this local root node's children are calculated.
      * This method must provide for each child node a byte constant indicating
      * the preferred direction of the connector to the subtree shape.
      * @param {yfiles.algorithms.Node} localRoot 
      * the local root node whose child nodes will be provided with
      * a byte constant indicating the direction of the connector
      * @param {yfiles.algorithms.IDataMap} connectorMap 
      * the map that should be used for storing the byte constant
      * with the child nodes.
      * @see Specified by {@link yfiles.tree.INodePlacer#determineChildConnectors}.
      */
      determineChildConnectors(localRoot:yfiles.algorithms.Node,connectorMap:yfiles.algorithms.IDataMap):void;
      /**
      * Creates a comparator that can be used to do a from sketch layout.
      * If this instance is used for the root node's {@link yfiles.tree.GenericTreeLayouter#CHILD_COMPARATOR_DP_KEY}
      * this implementation will do a from sketch layout.
      * @return {yfiles.objectcollections.IComparer} the comparator implementation to use to simulate from sketch layout
      */
      createComparator():yfiles.objectcollections.IComparer;
      /**
      * The main method of the tree layout algorithm.
      * This method arranges the
      * SubtreeShapes and the shape of the local root, routes the edges to the
      * SubtreeShapes, calculates the resulting SubtreeShape and returns it.
      * @param {yfiles.algorithms.IDataProvider} nodeShapeProvider 
      * this instance can be used to obtain an initial shape
      * of the root node. This shape can then be merged with all the subtrees' shapes
      * and finally be returned by this method.
      * @param {yfiles.algorithms.IDataProvider} subtreeShapeProvider 
      * provides access to the pre-calculated shapes of
      * the subtrees. It is guaranteed that at the time of the invocation of this
      * method for every child node the subtree shape has already been calculated
      * @param {yfiles.layout.LayoutGraph} graph the graph which is to be laid out
      * @param {yfiles.algorithms.Node} localRoot the root of the subtree that should be laid out by this method
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection 
      * the direction byte constant as it is defined
      * in this interface, that must be used for initializing the connector of the
      * localRoot node to the parent node of the localRoot node
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} the shape of the whole subtree
      * @see Specified by {@link yfiles.tree.INodePlacer#placeSubtree}.
      */
      placeSubtree(nodeShapeProvider:yfiles.algorithms.IDataProvider,subtreeShapeProvider:yfiles.algorithms.IDataProvider,graph:yfiles.layout.LayoutGraph,localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * Creates an optional Processor for pre- and post-processing.
      * @param {yfiles.tree.GenericTreeLayouter} layouter 
      * @param {yfiles.layout.LayoutGraph} graph the actual graph
      * @param {yfiles.algorithms.Node} currentRoot the actual root node for this node placer
      * @return {yfiles.tree.IProcessor} a Processor or null
      * @see Specified by {@link yfiles.tree.INodePlacer#createProcessor}.
      */
      createProcessor(layouter:yfiles.tree.GenericTreeLayouter,graph:yfiles.layout.LayoutGraph,currentRoot:yfiles.algorithms.Node):yfiles.tree.IProcessor;
      /**
      * Creates a comparator for edges.
      * This comparator is used to sort the outgoing edges of a node before the
      * placement of the node's subtree is calculated.
      * @return {yfiles.objectcollections.IComparer} a comparator for edges.
      * @see Specified by {@link yfiles.tree.IFromSketchNodePlacer#createFromSketchComparator}.
      */
      createFromSketchComparator():yfiles.objectcollections.IComparer;
    }
    var DendrogramPlacer:{
      $class:yfiles.lang.Class;
    };
    /**
    * A tree layouter that lays out the subtrees of the tree in a balloon-like
    * fashion.
    * Here is a sample layout output
    * <center><img src="doc-files/y.layout.tree.BalloonLayouter.gif" border="1"/></center>
    */
    export interface BalloonLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * The layout graph being acted upon.
      */
      graph:yfiles.layout.LayoutGraph;
      /**
      * The{@link yfiles.objectcollections.IComparer} that will be used
      * to sort the {@link yfiles.algorithms.Node#sortOutEdges  outgoing edges}
      * of each local root in the tree before they are being arranged.
      * The default value is <code>null</code> which indicates that the algorithm should
      * use its built-in logic.
      */
      comparator:yfiles.objectcollections.IComparer;
      /**
      * The current policy for sorting the children around the local roots.
      * Possible values are {@link yfiles.tree.ChildOrderingPolicy#COMPACT} and {@link yfiles.tree.ChildOrderingPolicy#SYMMETRIC}.
      * Note: the policy is only considered if sketch mode is disabled (see method {@link yfiles.tree.BalloonLayouter#fromSketchMode})
      * and no comparator is set (see method {@link yfiles.tree.BalloonLayouter#comparator}).
      * Furthermore, the policy is ignored for nodes whose children are placed in an
      * {@link yfiles.tree.BalloonLayouter#interleavedMode  interleaved} fashion.
      */
      childOrderingPolicy:yfiles.tree.ChildOrderingPolicy;
      /**
      * The distance to keep between the nodes in the tree.
      * Note that this distance is not always considered if {@link yfiles.tree.BalloonLayouter#allowOverlaps} is set to true.
      * The default distance is 0.0.
      * @see {@link yfiles.tree.BalloonLayouter#allowOverlaps}
      */
      minimalNodeDistance:number;
      /**
      * Specifies whether or not to take the coordinates of the input diagram
      * into account when arranging the nodes of the elements of the tree.
      * If this features is enabled, the original circular order of child nodes around
      * each parent node will be maintained.
      * By default this feature is disabled.
      */
      fromSketchMode:boolean;
      /**
      * The root node policy that determines which node
      * is chosen as (virtual) tree root for the layout process.
      * By default {@link yfiles.tree.RootNodePolicy#DIRECTED_ROOT} is set.
      */
      rootNodePolicy:yfiles.tree.RootNodePolicy;
      /**
      * The preferred child wedge angle.
      * This value controls the degree
      * to which the child nodes may radiate away from the center of layout.
      * By default the wedge is <code>340</code> degrees which means that
      * the child nodes may radiate in almost any direction from a
      * parent node.
      * Allowed values lie within <code>0</code> and <code>360</code>
      * degrees.
      * By default a child wedge of <code>340</code> degrees is used.
      */
      preferredChildWedge:number;
      /**
      * The preferred radial amount in degrees that stay unoccupied
      * around the root node of the graph.
      * By default a root wedge of <code>360</code> degrees is used.
      */
      preferredRootWedge:number;
      /**
      * Specifies whether or not to allow partially overlapping nodes.
      * Activating this feature results in a more compact layout. The price for
      * this feature is that some nodes may partially overlap.
      * By default this feature is set to <code>false</code>.
      */
      allowOverlaps:boolean;
      /**
      * The compactness factor for this layouter.
      * This factor has to be a
      * double value between 0 and 1.
      * The smaller the factor the more compact will the layout potentially be.
      * The price for a more compact layout is a potentially higher running time.
      */
      compactnessFactor:number;
      /**
      * The minimal edge length that this layouter assigns
      * to laid out edges.
      * By default a minimal edge length of 40 is set.
      */
      minimalEdgeLength:number;
      /**
      * Specifies whether or not the layouter considers node labels for the next layout run.
      * Note: this setting does only have an effect if the integrated labeling mechanism is not enabled, that is if
      * {@link yfiles.tree.BalloonLayouter#integratedNodeLabeling} returns true.
      * <p>
      * Note that this option only works correctly if the {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation}
      * is set to {@link yfiles.layout.LayoutOrientation#TOP_TO_BOTTOM} (which is the default).
      * Changing the layout orientation for an undirected layout algorithm like the
      * {@link yfiles.tree.BalloonLayouter} doesn't make sense.
      * </p>
      */
      considerNodeLabels:boolean;
      /**
      * The mode for interleaving child node arrangement.
      * Possible values are {@link yfiles.tree.InterleavedMode#ALL_NODES}, {@link yfiles.tree.InterleavedMode#OFF} (default)
      * and {@link yfiles.tree.InterleavedMode#SELECTED_NODES}.
      * Note that if placing children of a node in an interleaved fashion, then the
      * {@link yfiles.tree.BalloonLayouter#childOrderingPolicy  ordering policy} will not be considered for these children.
      */
      interleavedMode:yfiles.tree.InterleavedMode;
      /**
      * The child alignment policy used by the layouter.
      * This policy influences the distance of a child node to its parent node.
      * Possible values are {@link yfiles.tree.ChildAlignmentPolicy#COMPACT} (default), {@link yfiles.tree.ChildAlignmentPolicy#PLAIN},
      * {@link yfiles.tree.ChildAlignmentPolicy#SAME_CENTER} and {@link yfiles.tree.ChildAlignmentPolicy#SMART}.
      */
      childAlignmentPolicy:yfiles.tree.ChildAlignmentPolicy;
      /**
      * Specifies whether or not the integrated node labeling mechanism is enabled.
      * The integrated labeling does automatically place node labels. Different strategies may be selected using
      * {@link yfiles.tree.BalloonLayouter#nodeLabelingPolicy}.
      * The default value is <code>false</code>.
      * Note: if the integrated labeling mechanism is enabled, then the labels will always be placed by this algorithm,
      * independent of the setting of {@link yfiles.tree.BalloonLayouter#considerNodeLabels}.
      * @see {@link yfiles.tree.BalloonLayouter#nodeLabelingPolicy}
      * @see {@link yfiles.tree.BalloonLayouter#nodeLabelingPolicy}
      */
      integratedNodeLabeling:boolean;
      /**
      * Specifies whether or not the integrated edge labeling mechanism is enabled.
      * With enabled integrated labeling the layouter does automatically place edge labels.
      * The default value is <code>false</code>.
      * Note: when enabling integrated edge labeling it is recommended to also activate the chain straightening mode, as
      * edge labels (especially large ones) may lead to significantly non-straight chains.
      * @see {@link yfiles.tree.BalloonLayouter#chainStraighteningMode}
      */
      integratedEdgeLabeling:boolean;
      /**
      * The policy for the integrated node labeling mechanism.
      * Possible values are {@link yfiles.tree.NodeLabelingPolicy#HORIZONTAL}, {@link yfiles.tree.NodeLabelingPolicy#RAYLIKE} (default) and
      * {@link yfiles.tree.NodeLabelingPolicy#MIXED}.
      * Note: the policy is only considered if {@link yfiles.tree.BalloonLayouter#integratedNodeLabeling} is set to <code>true</code>.
      * @see {@link yfiles.tree.BalloonLayouter#integratedNodeLabeling}
      * @see {@link yfiles.tree.BalloonLayouter#integratedNodeLabeling}
      */
      nodeLabelingPolicy:yfiles.tree.NodeLabelingPolicy;
      /**
      * The node label spacing value.
      * It affects the distance between two node labels of the same node as well as the
      * distance of the labels and the node itself in case of a placement outside the node.
      * The default value is <code>4.0d</code>.
      * Note, that the node label spacing has an effect only if the integrated node labeling is enabled.
      * @see {@link yfiles.tree.BalloonLayouter#integratedNodeLabeling}
      * @see {@link yfiles.tree.BalloonLayouter#integratedNodeLabeling}
      */
      nodeLabelSpacing:number;
      /**
      * The edge label spacing value.
      * It affects the distance between two edge labels belonging to the same edge as well
      * as the distance of the edge labels to the target node.
      * The default value is <code>4.0d</code>.
      * Note, that the edge label spacing has an effect only if the integrated edge labeling is enabled.
      * @see {@link yfiles.tree.BalloonLayouter#integratedEdgeLabeling}
      * @see {@link yfiles.tree.BalloonLayouter#integratedEdgeLabeling}
      */
      edgeLabelSpacing:number;
      /**
      * Specifies whether chains within the graph shall be drawn straight or not.
      * Straightening all chains may lead
      * to smoother, more symmetric results. A chain is defined as a tree node with exactly one child.
      * The default value is <code>false</code>.
      */
      chainStraighteningMode:boolean;
      /**
      * Core layout routine.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Returns true if the core layouter can layout the given graph structure.
      * This is the case if the graph is a tree.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Returns the NodeInfo object that is associated with the given node
      * while the layouter is active.
      * Subclasses may want to use this information
      * to refine the behavior of this algorithm.
      */
      getInfo(v:yfiles.algorithms.Node):yfiles.tree.BalloonLayouter.NodeInfo;
      /**
      * Determines the root node of {@link yfiles.tree.BalloonLayouter#graph} according to the chosen root
      * node policy.
      * @return {yfiles.algorithms.Node} 
      * the root node of {@link yfiles.tree.BalloonLayouter#graph}.
      * @see {@link yfiles.tree.BalloonLayouter#rootNodePolicy}
      * @see {@link yfiles.tree.BalloonLayouter#rootNodePolicy}
      */
      determineRoot():yfiles.algorithms.Node;
      /**
      * Calculates the child nodes arrangement for a given root node of the
      * tree.
      * Subclasses may overwrite this method to perform a
      * custom child node arrangement.
      */
      calcChildArrangement(root:yfiles.algorithms.Node):void;
      /**
      * Sorts the child nodes of the given node.
      * This method uses
      * the original node coordinates if <code>fromSketchMode</code> is enabled.
      * Otherwise, it sorts the child nodes according to their wedge angle sizes, or, if present
      * uses {@link yfiles.tree.BalloonLayouter#comparator  the specified comparator} to sort the outgoing edges of
      * the local root node.
      * The biggest one receives median position in the sorting order.
      * The smaller the wedges the further away a node will be placed from the
      * median position.
      * This method gets called within method
      * {@link yfiles.tree.BalloonLayouter#calcChildArrangement} before coordinates are assigned and
      * just after the wedges sizes for all subgraphs rooted at root were determined.
      * <p>
      * Note: This method will not be called for nodes whose children are placed in an
      * {@link yfiles.tree.BalloonLayouter#interleavedMode  interleaved} fashion.
      * </p>
      */
      sortChildNodes(root:yfiles.algorithms.Node):void;
      /**
      * Returns the preferred child wedge angle in degrees that is
      * used for the children of the given root node.
      * Subclasses may overwrite this method to provide
      * a custom child wedge function.
      */
      getPreferredChildWedge(root:yfiles.algorithms.Node):number;
      /**
      * Calculates the angle wedge that has to be reserved for the subtree rooted
      * at the given node.
      * Subclasses may overwrite this method to perform a
      * custom angle wedge assignment scheme.
      */
      calcAngles(root:yfiles.algorithms.Node):number;
      /**
      * Calculates the angle wedge that has to be reserved for the subtree rooted
      * at the given node.
      * The distance of the successor nodes is additionally scaled by <code>scaleFactor</code>
      * (use <code>scaleFactor = 1.0</code> for no scaling).
      * Subclasses may overwrite this method to perform a
      * custom angle wedge assignment scheme.
      */
      calcAnglesWithRootAndScaleFactor(root:yfiles.algorithms.Node,scaleFactor:number):number;
    }
    export module BalloonLayouter{
      /**
      * Encapsulates information bound to a node during the algorithm calculates a layout.
      */
      export interface NodeInfo extends Object{
        /**
        * The upper angle of the subtree wedge rooted at the node.
        */
        upperAngle:number;
        /**
        * The lower angle of the subtree wedge rooted at the node.
        */
        lowerAngle:number;
        /**
        * The angle that of the gap that to the wedge of the previous child node.
        */
        gapAngle:number;
        /**
        * The distance of the node to its root node.
        */
        dist:number;
        /**
        * The sum of all wedge angles.
        */
        angleSum:number;
      }
    }
    var BalloonLayouter:{
      $class:yfiles.lang.Class;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to store if the children of a node should be arranged in an
      * interleaved fashion or not (boolean values, <code>true</code> encodes interleaved).
      * It allows to individually
      * configure the interleaving feature for each node in the graph. Note that the data provider will only be considered
      * if mode is set to {@link yfiles.tree.InterleavedMode#SELECTED_NODES}.
      * @see {@link yfiles.tree.BalloonLayouter#interleavedMode}
      */
      INTERLEAVED_NODES_DP_KEY:Object;
      new ():yfiles.tree.BalloonLayouter;
    };
    /**
    * This class implements the basis of a generic tree layout algorithm.
    * It can be customized easily to control the
    * placement and order of child nodes, the edge routing and port assignment on a per node basis.
    *  Using {@link yfiles.algorithms.IDataProvider}s, one can specify objects that implement the {@link yfiles.tree.INodePlacer} interface. Those instances are
    * responsible for the arrangement of the subtrees of the node's they are registered with and the routing of the
    * connecting edges. 
    *  Likewise instances of {@link yfiles.tree.IPortAssignment} are responsible for the assignment of the ports
    * and {@link yfiles.objectcollections.IComparer} instances can be used to sort the outgoing edges of each node. 
    *  Customization of this
    * class should be done via own implementations of the {@link yfiles.tree.INodePlacer}, possibly {@link yfiles.tree.IPortAssignment}, and {@link yfiles.objectcollections.IComparer} instances.
    * Here is an example output that shows multiple different configurations in one layout using {@link yfiles.tree.DefaultNodePlacer}
    * instances:
    * <center><img src="doc-files/y.layout.tree.GenericTreeLayouter.generic.gif" border="1"/></center>
    * @see {@link yfiles.tree.INodePlacer}
    * @see {@link yfiles.tree.DefaultNodePlacer}
    * @see {@link yfiles.tree.IPortAssignment}
    * @see {@link yfiles.tree.DefaultPortAssignment}
    */
    export interface GenericTreeLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * the graph this layout is running on.
      */
      graph:yfiles.layout.LayoutGraph;
      /**
      * True if grouping support is enabled.
      * Note that the grouping only works correctly, if each group represents a complete subtree.
      * This means that for each group there is a node v such that the group contains exactly v and all its descendants.
      */
      groupingSupported:boolean;
      /**
      * Subclasses have to provide information whether or not they
      * can layout the given graph.
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Subclasses have to provide core layout code in this method.
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Provides access to the SubTreeShape instances for each node.
      * Those instances should be modified only during the
      * layout of the parent node.
      * @param {yfiles.algorithms.Node} localRoot the node for which the subtree should be returned
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} the SubTreeShape instance if it has been calculated already or <code>null</code> otherwise
      */
      getSubtreeShape(localRoot:yfiles.algorithms.Node):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * This is the core method of the algorithm.
      * This method is invoked for each node in the tree exactly once in such an
      * order that all of the child nodes of each node have already been calculated by the time of the method invocation.
      *  This method uses the {@link yfiles.tree.GenericTreeLayouter#getSubtreeShape} callback to retrieve the shapes of the subtrees of all
      * of the children of <code>localRoot</code>.
      * @param {yfiles.algorithms.Node} localRoot The root to be laid out together with its SubtreeShapes
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} the combined SubtreeShape of the local root node and all of its children and connecting edges
      */
      layoutRoot(localRoot:yfiles.algorithms.Node):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * This method returns a {@link yfiles.tree.IPortAssignment} instance that will be used for the port assignments at the given Node.
      * This method is allowed to return a shared instance for multiple different nodes, the instances are not used after
      * subsequent calls to this method.
      * @param {yfiles.algorithms.Node} localRoot the root of the local subtree
      * @return {yfiles.tree.IPortAssignment} 
      * a readily configured instance of {@link yfiles.tree.IPortAssignment} that can be used to assign the ports of the edges
      * at the given local root node.
      */
      getPortAssignment(localRoot:yfiles.algorithms.Node):yfiles.tree.IPortAssignment;
      /**
      * This method returns a {@link yfiles.objectcollections.IComparer} instance or <code>null</code> that will be used for the sorting of the
      * outgoing edges at the given Node.
      * This method is allowed to return a shared instance for multiple different nodes,
      * the instances are not used after subsequent calls to this method.
      * @param {yfiles.algorithms.Node} localRoot the root of the local subtree
      * @return {yfiles.objectcollections.IComparer} 
      * a readily configured instance of {@link yfiles.objectcollections.IComparer} or <code>null</code> that can be used sort the outgoing
      * edges of the given node
      */
      getChildNodeInEdgeComparator(localRoot:yfiles.algorithms.Node):yfiles.objectcollections.IComparer;
      /**
      * This method returns a {@link yfiles.tree.INodePlacer} instance that will be used for the placement of the root node and the
      * subtree shapes.
      * This method is allowed to return a shared instance for multiple different nodes, the instances are
      * not used after subsequent calls to this method.
      * @param {yfiles.algorithms.Node} localRoot the root of the local subtree
      * @return {yfiles.tree.INodePlacer} 
      * a readily configured instance of {@link yfiles.tree.INodePlacer} that can be used to layout the subtree under the given
      * local root node.
      */
      getNodePlacer(localRoot:yfiles.algorithms.Node):yfiles.tree.INodePlacer;
      /**
      * Factory method that creates a SubtreeShape for a given node, that consists of the bounds of the node only.
      * @param {yfiles.algorithms.Node} node the node that will be represented by a SubTreeShape instance
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} a newly created SubtreeShape describing the bounds of the given node
      */
      getNodeShape(node:yfiles.algorithms.Node):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * Returns the array of the nodes to be laid out.
      * The order of the elements is chosen so that no parent is laid out
      * before one of its successors.
      * @param {yfiles.algorithms.Node} root the node that should be used as the root of the tree
      * @return {yfiles.algorithms.Node[]} all nodes in the graph that should be laid out in order
      */
      getRootsArray(root:yfiles.algorithms.Node):yfiles.algorithms.Node[];
      /**
      * This method is called initially with the graph to calculate a rooted tree.
      * It returns a list of edges that have to
      * be reversed in order for the graph to become a valid rooted and directed tree.
      * @return {yfiles.algorithms.EdgeList} an EdgeList containing all the edges that need to be reversed
      */
      directTree():yfiles.algorithms.EdgeList;
      /**
      * A{@link yfiles.algorithms.IDataAcceptor} implementation
      * that can be used to overwrite the source port constraint ({@link yfiles.layout.PortConstraint}
      * temporarily for use during the layout.
      */
      sourcePortConstraintDataAcceptor:yfiles.algorithms.IDataAcceptor;
      /**
      * A{@link yfiles.algorithms.IDataAcceptor} implementation
      * that can be used to overwrite the target port constraint ({@link yfiles.layout.PortConstraint}
      * temporarily for use during the layout.
      */
      targetPortConstraintDataAcceptor:yfiles.algorithms.IDataAcceptor;
      /**
      * A{@link yfiles.algorithms.IDataAcceptor} implementation that can be used to overwrite edge grouping at source temporarily
      * for use during the layout.
      * @see {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY}
      */
      sourceGroupDataAcceptor:yfiles.algorithms.IDataAcceptor;
      /**
      * A{@link yfiles.algorithms.IDataAcceptor} implementation that can be used to overwrite edge grouping at target temporarily
      * for use during the layout.
      * @see {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}
      */
      targetGroupDataAcceptor:yfiles.algorithms.IDataAcceptor;
      /**
      * This method is used for the actual reversal of edges.
      * It will be called initially after the {@link yfiles.tree.GenericTreeLayouter#directTree} method and finally
      * after the layout has been calculated.
      * @param {yfiles.algorithms.EdgeList} reversedEdges the edges that will be reversed by this method
      */
      reverseEdges(reversedEdges:yfiles.algorithms.EdgeList):void;
      /**
      * The default{@link yfiles.tree.INodePlacer} instance that will be used for those subtrees, that don't have their own
      * specific instance set via the appropriate DataProvider.
      * This should be non-<code>null</code>, unless it is
      * guaranteed that for any node in the graph there is a specific instance provided by the registered DataProvider
      * instance.
      */
      defaultNodePlacer:yfiles.tree.INodePlacer;
      /**
      * The default{@link yfiles.tree.INodePlacer} instance that will be used for the leaf nodes of the tree.
      */
      defaultLeafPlacer:yfiles.tree.INodePlacer;
      /**
      * The default{@link yfiles.tree.IPortAssignment} instance that will be used for those subtrees, that don't have their
      * own specific instance set via the appropriate DataProvider.
      * This should be non-<code>null</code>, unless it is
      * guaranteed that for any node in the graph there is a specific instance provided by the registered DataProvider
      * instance.
      */
      defaultPortAssignment:yfiles.tree.IPortAssignment;
      /**
      * The default{@link yfiles.objectcollections.IComparer} instance or <code>null</code> that will be used for those subtrees, that
      * don't have their own specific instance set via the appropriate DataProvider.
      * This can be set to <code>null</code> which implies no
      * sorting by default.
      */
      defaultChildComparator:yfiles.objectcollections.IComparer;
      /**
      * Specifies whether integrated node labeling is enabled (extension of the
      * shapes of the nodes with its labels).
      * If set to <code>true</code>, the shape of the nodes will be extended with
      * the shapes of its labels.
      */
      integratedNodeLabeling:boolean;
      /**
      * Specifies whether integrated edge labeling is enabled (extension of the
      * shapes of subtrees with the labels of the edges).
      */
      integratedEdgeLabeling:boolean;
      /**
      * Determines whether or not multi-parent structures are allowed for this tree layout.
      * <p>
      * If multi-parent structures are allowed, the directed input graph may contain structures of multiple
      * nodes that share the same predecessors
      * as well as the same successors. All nodes belonging to such a structure are placed side by side and the incident
      * edges are routed in a bus-style.
      * </p>
      * <p>
      * Note that if the input graph contains groups, all nodes belonging to the same multi-parent structure must
      * be associated with the same group node, i.e., it is not possible to assign these nodes to different group nodes.
      * </p>
      * <p>
      * By default multi-parent structures are not allowed.
      * </p>
      * <p>
      * As for the different ways in which the {@link yfiles.tree.INodePlacer}s route their edges, multi-parent structures only work
      * for some <code>NodePlacer</code>s:
      * <ul>
      * <li>
      * {@link yfiles.tree.DefaultNodePlacer} delivers the best results for multi-parents. However, routing style
      * {@link yfiles.tree.RoutingStyle#FORK_AT_ROOT} as well as root alignments
      * {@link yfiles.tree.RootAlignment#LEADING_ON_BUS} and
      * {@link yfiles.tree.RootAlignment#TRAILING_ON_BUS} are not supported.
      * </li>
      * <li>
      * {@link yfiles.tree.DendrogramPlacer} fully supports multi-parents.
      * </li>
      * <li>
      * {@link yfiles.tree.BusPlacer} supports multi-parents.
      * </li>
      * <li>
      * {@link yfiles.tree.LeftRightPlacer} supports multi-parents.
      * </li>
      * </ul>
      * </p>
      */
      multiParentAllowed:boolean;
    }
    export module GenericTreeLayouter{
      /**
      * Instances of this class are used to represent the shape of subtrees during the layout.
      */
      export interface SubtreeShape extends Object{
        /**
        * Yields the bounds of the {@link yfiles.layout.INodeLayout} of the root node.
        */
        coreBounds:yfiles.algorithms.Rectangle2D.Double;
        /**
        * The current bounds of this SubtreeShape.
        */
        bounds:yfiles.algorithms.Rectangle2D;
        /**
        * The current x coordinate of the connection point where the layout algorithm should connect the ingoing
        * edge to.
        */
        connectorX:number;
        /**
        * The current y coordinate of the connection point where the layout algorithm should connect the ingoing
        * edge to.
        */
        connectorY:number;
        /**
        * Adds the line segments of the connector shape to the bounds and borderlines of this SubTreeShape.
        */
        updateConnectorShape():void;
        /**
        * Adds another point to the connecting edge (away from the target node).
        * @param {number} x the current x coordinate of the point
        * @param {number} y the current x coordinate of the point
        */
        addTargetPoint(x:number,y:number):void;
        /**
        * Helper method that takes all edge segments of the given Edge instance and updates the shape bounds with that
        * information.
        * @param {yfiles.layout.LayoutGraph} lg the LayoutGraph that contains the edge
        * @param {yfiles.algorithms.Edge} e the edge whose path will be used to update the shape
        */
        addEdgeSegments(lg:yfiles.layout.LayoutGraph,e:yfiles.algorithms.Edge):void;
        /**
        * Appends all target points that have previously been added to this shape to the given EdgeLayout instance.
        * Used by
        * NodePlacer instances for the final edge connections.
        * @param {yfiles.layout.IEdgeLayout} el the EdgeLayout that will be modified
        */
        appendTargetPoints(el:yfiles.layout.IEdgeLayout):void;
        /**
        * The direction byte constant as defined in this class, that indicates the direction of the last connecting
        * edge segment.
        */
        connectorDirection:yfiles.tree.ConnectorDirection;
        /**
        * Convenience method that updates the shape to respect the given line segment.
        */
        addLineSegment(x1:number,y1:number,x2:number,y2:number):void;
        /**
        * Adds a rectangular shape to the current shape.
        */
        addBoundsToShape(x:number,y:number,width:number,height:number):void;
        /**
        * Merges the given SubtreeShape with this shape's bounds.
        * @param {yfiles.tree.GenericTreeLayouter.SubtreeShape} other the shape to be merged with this shape
        */
        mergeWith(other:yfiles.tree.GenericTreeLayouter.SubtreeShape):void;
        /**
        * The current minimal x coordinate of this shape.
        */
        minX:number;
        /**
        * The current minimal y coordinate of this shape.
        */
        minY:number;
        /**
        * The current maximum x coordinate of this shape.
        */
        maxX:number;
        /**
        * The current maximum y coordinate of this shape.
        */
        maxY:number;
        /**
        * Returns the BorderLine instance for the given direction.
        * @param {number} index 
        * the direction index where
        * {@link yfiles.tree.BorderlineSide#NORTH} is north,
        * {@link yfiles.tree.BorderlineSide#EAST} is east,
        * {@link yfiles.tree.BorderlineSide#SOUTH} is south, and
        * {@link yfiles.tree.BorderlineSide#WEST} is west.
        * @return {yfiles.algorithms.BorderLine} 
        * the current {@link yfiles.algorithms.BorderLine} instance
        */
        getBorderLine(index:number):yfiles.algorithms.BorderLine;
        /**
        * Moves this shape and its connector by the given offsets.
        * This is a cheap operation and does not depend on the
        * size or complexity of the shape or connector.
        * @param {number} dx the delta x offset this shape will be moved by
        * @param {number} dy the delta y offset this shape will be moved by
        */
        move(dx:number,dy:number):void;
        /**
        * The current x coordinate of the origin of this shape.
        * The origin is defined as the upper left corner of
        * the NodeLayout of the local root of this shape.
        */
        originX:number;
        /**
        * The current y coordinate of the origin of this shape.
        * The origin is defined as the upper left corner of
        * the NodeLayout of the local root of this shape.
        */
        originY:number;
        /**
        * Creates a clone of this instance, modifying it using the provided matrix.
        */
        createCopy(matrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix):yfiles.tree.GenericTreeLayouter.SubtreeShape;
        /**
        * Copies this instance to another shape, applying a modification matrix.
        */
        assignValuesTo(toShape:yfiles.tree.GenericTreeLayouter.SubtreeShape,modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix):void;
        toString():string;
      }
    }
    var GenericTreeLayouter:{
      $class:yfiles.lang.Class;
      /**
      * DataProvider key that can be registered with the graph to provide each node with its own {@link yfiles.tree.INodePlacer}
      * instance.
      */
      NODE_PLACER_DP_KEY:Object;
      /**
      * DataProvider key that can be registered with the graph to provide each node with its own {@link yfiles.tree.IPortAssignment}
      * instance.
      */
      PORT_ASSIGNMENT_DP_KEY:Object;
      /**
      * DataProvider key that can be registered with the graph to provide each node with its own {@link yfiles.objectcollections.IComparer}
      * instance that will be used to sort its outgoing edges.
      */
      CHILD_COMPARATOR_DP_KEY:Object;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to store the priority (integer values) for "critical" edges.
      * The layouter tries to align each node pair that is connected by a critical edge (integer value > 0).
      * This feature can for example be utilized to highlight different edge paths that are relevant for a user. Conflicts
      * between different critical edges are always resolved in favor of the higher priority.
      * <p>
      * Critical edges will always align the centers of source and target node, thus replace the current root alignment
      * of the {@link yfiles.tree.INodePlacer}.
      * </p>
      * <p>
      * Note that the critical edge may not be straight if subtrees are rotated or port constraints are assigned.
      * </p>
      * <p>
      * This feature is only supported by the following <code>NodePlacer</code>s:
      * <ul>
      * <li>{@link yfiles.tree.DefaultNodePlacer}</li>
      * <li>{@link yfiles.tree.SimpleNodePlacer}</li>
      * <li>{@link yfiles.tree.LayeredNodePlacer}</li>
      * <li>{@link yfiles.tree.DoubleLinePlacer}</li>
      * <li>{@link yfiles.tree.DendrogramPlacer}</li>
      * </ul>
      * </p>
      */
      CRITICAL_EDGE_DP_KEY:Object;
      /**
      * {@link yfiles.algorithms.IDataProvider} key used to retrieve {@link yfiles.tree.MultiParentDescriptor}
      * instances for each node that belongs to a multi-parent structure.
      * The returned descriptor affects the layout of the multi-parent structure.
      * <p>
      * Note that this key is only considered if multi-parent structures are allowed,
      * see {@link yfiles.tree.GenericTreeLayouter#multiParentAllowed}. Furthermore, all nodes belonging to the same multi-parent
      * structure should return the same descriptor.
      * </p>
      * @see {@link yfiles.tree.GenericTreeLayouter#multiParentAllowed}
      */
      MULTI_PARENT_DESCRIPTOR_DP_KEY:Object;
      /**
      * Creates a new GenericTreeLayouter with a default {@link yfiles.tree.INodePlacer}, a default {@link yfiles.tree.IPortAssignment} instance and
      * no default edge comparator.
      */
      new ():yfiles.tree.GenericTreeLayouter;
    };
    /**
    * This NodePlacer arranges nodes into a grid.
    * The grid consists of a number of columns. Rows are filled automatically by the placer.
    * Each row is filled from left to right. When all columns in a row are filled, the next row is created.
    */
    export interface GridNodePlacer extends yfiles.tree.AbstractRotatableNodePlacer{
      /**
      * Returns  {@link yfiles.tree.ParentConnectorDirection#NORTH}.
      * @return {yfiles.tree.ParentConnectorDirection} 
      * {@link yfiles.tree.ParentConnectorDirection#NORTH}.
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#determineChildConnector}
      */
      determineChildConnector(child:yfiles.algorithms.Node):yfiles.tree.ParentConnectorDirection;
      /**
      * Places the children in a grid.
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtreeWithDirection}
      */
      placeSubtreeWithDirection(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.SubtreeShapeRotated;
      /**
      * Creates a comparator that uses the positions of the target nodes to
      * order edges.
      * For two edges <code>e1=(s,t1)</code> and <code>e2=(s,t2)</code>,
      * <code>e1</code> is considered to be less than <code>e2</code>, if
      * <code>t1</code>'s row is less than <code>t2</code>'s row. If both
      * <code>t1</code> and <code>t2</code> lie in the same row, then the nodes'
      * <code>x</code>-coordinates are compared.
      * @return {yfiles.objectcollections.IComparer} 
      * a comparator that orders edges lexicographically by row and
      * <code>x</code>-coordinate of their target nodes.
      * @see {@link yfiles.tree.GridNodePlacer#GRID_DP_KEY}
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#createFromSketchComparator}
      * @see Specified by {@link yfiles.tree.IFromSketchNodePlacer#createFromSketchComparator}.
      */
      createFromSketchComparator():yfiles.objectcollections.IComparer;
      /**
      * The horizontal alignment of the root node.
      */
      rootAlignment:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
    }
    var GridNodePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Key which can be used to register a data provider that tells the placer in which row
      * a given node should be put into.
      * For each node, the row is determined using
      * the data provider's {@link yfiles.algorithms.IDataProvider#getInt  getInt} method.
      * If no provider is specified, all nodes will be placed in one row.
      */
      GRID_DP_KEY:Object;
      /**
      * Creates a grid placer with the modification matrix {@link yfiles.tree.AbstractRotatableNodePlacer.Matrix#DEFAULT}.
      */
      new ():yfiles.tree.GridNodePlacer;
      /**
      * Creates grid placer with a given modification matrix.
      */
      WithMatrix:{
        new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix):yfiles.tree.GridNodePlacer;
      };
      /**
      * Creates grid placer with a given modification matrix and the horizontal alignment of the root.
      */
      WithMatrixAndAlignment:{
        new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix,rootAlignment:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment):yfiles.tree.GridNodePlacer;
      };
    };
    /**
    * A {@link yfiles.tree.INodePlacer} that places the children of a local root in groups.
    * <p>
    * The placement of the groups is specified by a {@link yfiles.tree.INodePlacer} which will consider grouped children
    * as one child. The children within a group are placed by another <code>NodePlacer</code>.
    * </p>
    * <p>
    * The groups are determined by the grouping of the edges that connect the children to its root.
    * </p>
    * @see {@link yfiles.layout.PortConstraintKeys#SOURCE_GROUP_ID_DP_KEY}
    * @see {@link yfiles.layout.PortConstraintKeys#TARGET_GROUP_ID_DP_KEY}
    */
    export interface GroupedNodePlacer extends Object,yfiles.tree.INodePlacer{
      /**
      * This method is called by GenericTreeLayouter before the subtree shapes of
      * this local root node's children are calculated.
      * This method must provide for each child node a byte constant indicating
      * the preferred direction of the connector to the subtree shape.
      * @param {yfiles.algorithms.Node} localRoot 
      * the local root node whose child nodes will be provided with
      * a byte constant indicating the direction of the connector
      * @param {yfiles.algorithms.IDataMap} connectorMap 
      * the map that should be used for storing the byte constant
      * with the child nodes.
      * @see Specified by {@link yfiles.tree.INodePlacer#determineChildConnectors}.
      */
      determineChildConnectors(localRoot:yfiles.algorithms.Node,connectorMap:yfiles.algorithms.IDataMap):void;
      /**
      * The main method of the tree layout algorithm.
      * This method arranges the
      * SubtreeShapes and the shape of the local root, routes the edges to the
      * SubtreeShapes, calculates the resulting SubtreeShape and returns it.
      * @param {yfiles.algorithms.IDataProvider} nodeShapeProvider 
      * this instance can be used to obtain an initial shape
      * of the root node. This shape can then be merged with all the subtrees' shapes
      * and finally be returned by this method.
      * @param {yfiles.algorithms.IDataProvider} subtreeShapeProvider 
      * provides access to the pre-calculated shapes of
      * the subtrees. It is guaranteed that at the time of the invocation of this
      * method for every child node the subtree shape has already been calculated
      * @param {yfiles.layout.LayoutGraph} graph the graph which is to be laid out
      * @param {yfiles.algorithms.Node} localRoot the root of the subtree that should be laid out by this method
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection 
      * the direction byte constant as it is defined
      * in this interface, that must be used for initializing the connector of the
      * localRoot node to the parent node of the localRoot node
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} the shape of the whole subtree
      * @see Specified by {@link yfiles.tree.INodePlacer#placeSubtree}.
      */
      placeSubtree(nodeShapeProvider:yfiles.algorithms.IDataProvider,subtreeShapeProvider:yfiles.algorithms.IDataProvider,graph:yfiles.layout.LayoutGraph,localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * Creates an optional Processor for pre- and post-processing.
      * @param {yfiles.tree.GenericTreeLayouter} layouter 
      * @param {yfiles.layout.LayoutGraph} graph the actual graph
      * @param {yfiles.algorithms.Node} currentRoot the actual root node for this node placer
      * @return {yfiles.tree.IProcessor} a Processor or null
      * @see Specified by {@link yfiles.tree.INodePlacer#createProcessor}.
      */
      createProcessor(layouter:yfiles.tree.GenericTreeLayouter,graph:yfiles.layout.LayoutGraph,currentRoot:yfiles.algorithms.Node):yfiles.tree.IProcessor;
    }
    var GroupedNodePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of <code>GroupedNodePlacer</code> that uses a <code>groupPlacer</code> to place the grouped
      * nodes combined and a <code>childPlacer</code> to place the children within their group.
      * @param {yfiles.tree.INodePlacer} groupPlacer the <code>NodePlacer</code> which places the child groups.
      * @param {yfiles.tree.INodePlacer} childPlacer the <code>NodePlacer</code> which places the children within their group.
      */
      new (groupPlacer:yfiles.tree.INodePlacer,childPlacer:yfiles.tree.INodePlacer):yfiles.tree.GroupedNodePlacer;
    };
    /**
    * The DelegatingNodePlacer may be used to layout the children of the actual
    * node with two different <code>NodePlacer</code>s.
    */
    export interface DelegatingNodePlacer extends yfiles.tree.AbstractRotatableNodePlacer{
      /**
      * Creates a processor that partitions child nodes of the specified root node
      * into two subsets, one to be arranged by the "upper left"
      * <code>NodePlacer</code> and one to be arranged by the "lower right"
      * <code>NodePlacer</code>.
      * @see {@link yfiles.tree.DelegatingNodePlacer#placerLowerRight}
      * @see {@link yfiles.tree.DelegatingNodePlacer#placerUpperLeft}
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#createProcessor}
      * @see Specified by {@link yfiles.tree.INodePlacer#createProcessor}.
      */
      createProcessor(layouter:yfiles.tree.GenericTreeLayouter,graph:yfiles.layout.LayoutGraph,currentRoot:yfiles.algorithms.Node):yfiles.tree.IProcessor;
      /**
      * This method is called by GenericTreeLayouter before the subtree shapes of
      * this local root node's children are calculated.
      * This method must provide for each child node a byte constant indicating
      * the preferred direction of the connector to the subtree shape.
      * @param {yfiles.algorithms.Node} localRoot 
      * the local root node whose child nodes will be provided with
      * a byte constant indicating the direction of the connector
      * @param {yfiles.algorithms.IDataMap} connectorMap 
      * the map that should be used for storing the byte constant
      * with the child nodes.
      * @see Specified by {@link yfiles.tree.INodePlacer#determineChildConnectors}.
      */
      determineChildConnectors(localRoot:yfiles.algorithms.Node,connectorMap:yfiles.algorithms.IDataMap):void;
      /**
      * Places the shapes of the children using the two node placers {@link yfiles.tree.DelegatingNodePlacer#getUpperLeftChildren} and
      * {@link yfiles.tree.DelegatingNodePlacer#getLowerRightChildren}.
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} the subtree shape for the given local root.
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtree}
      * @see Specified by {@link yfiles.tree.INodePlacer#placeSubtree}.
      */
      placeSubtree(nodeShapeProvider:yfiles.algorithms.IDataProvider,subtreeShapeProvider:yfiles.algorithms.IDataProvider,graph:yfiles.layout.LayoutGraph,localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * Determines the lower right children of the specified root node.
      * Data provider <code>LEFT_RIGHT_DPKEY</code> is used to determine
      * on which side a node is placed.
      * If no provider is specified, the first half of the nodes get placed on the
      * left, the others on the right side
      * These nodes are placed using the <code>NodePlacer</code> returned by
      * {@link yfiles.tree.DelegatingNodePlacer#placerLowerRight}.
      * @return {yfiles.algorithms.NodeList} a NodeList containing the lower right nodes.
      * @see {@link yfiles.tree.DelegatingNodePlacer#LEFT_RIGHT_DP_KEY}
      */
      getLowerRightChildren(localRoot:yfiles.algorithms.Node,graph:yfiles.layout.LayoutGraph):yfiles.algorithms.NodeList;
      /**
      * Determines the upper left children of the specified root node.
      * Data provider <code>LEFT_RIGHT_DPKEY</code> is used to determine
      * on which side a node is placed.
      * If no provider is specified, the first half of the nodes get placed on the
      * left, the others on the right side
      * These nodes are placed using the <code>NodePlacer</code> returned by
      * {@link yfiles.tree.DelegatingNodePlacer#placerUpperLeft}.
      * @return {yfiles.algorithms.NodeList} a NodeList containing the upper left nodes.
      * @see {@link yfiles.tree.DelegatingNodePlacer#LEFT_RIGHT_DP_KEY}
      */
      getUpperLeftChildren(localRoot:yfiles.algorithms.Node,graph:yfiles.layout.LayoutGraph):yfiles.algorithms.NodeList;
      /**
      * This method must be implemented by subclasses.
      * It is used to assigns a connector shape direction to each child.
      * @param {yfiles.algorithms.Node} child the child node
      * @return {yfiles.tree.ParentConnectorDirection} 
      * a byte constant as defined in the {@link yfiles.tree.INodePlacer} interface
      */
      determineChildConnector(child:yfiles.algorithms.Node):yfiles.tree.ParentConnectorDirection;
      /**
      * This method must be implemented by subclasses.
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction of the connector shape
      * @return {yfiles.tree.SubtreeShapeRotated} a SubtreeShape instance that describes the shape of the whole subtree
      */
      placeSubtreeWithDirection(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.SubtreeShapeRotated;
      /**
      * The orientation according to which node shapes are aligned by
      * this placer.
      * Depending on the orientation the shapes are aligned on the x- or y-axis.
      */
      orientation:yfiles.tree.Orientation;
      /**
      * The <code>NodePlacer</code> that is used to layout the nodes on
      * the "lower right".
      */
      placerLowerRight:yfiles.tree.INodePlacer;
      /**
      * The <code>NodePlacer</code> that is used to layout the nodes on
      * the "upper left".
      */
      placerUpperLeft:yfiles.tree.INodePlacer;
    }
    var DelegatingNodePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Key which can be used to register a data provider that tells the node
      * placer whether the node shall be placed on the left or right side.
      * If no provider is specified, the first half of the nodes placed on the
      * left, the others on the right side
      * The provider should return true if the node shall be placed on the left
      * side.
      */
      LEFT_RIGHT_DP_KEY:Object;
      /**
      * Creates a new instance using the given modification matrix an the node placers "this" delegates to.
      */
      new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix,placerUpperLeft:yfiles.tree.INodePlacer,placerLowerRight:yfiles.tree.INodePlacer):yfiles.tree.DelegatingNodePlacer;
    };
    export enum ChildAlignmentPolicy{
      /**
      * Child alignment policy specifier constant.
      * Child nodes rooted at the same node are aligned such that the border of the nodes convex hull has the same
      * distance from the root for all of the children.
      * Note: two different distances will be realized, if the interleaved mode is active {@link yfiles.tree.BalloonLayouter#interleavedMode}.
      * @see {@link yfiles.tree.BalloonLayouter#childAlignmentPolicy}
      */
      PLAIN,
      /**
      * Child alignment policy specifier constant.
      * Child nodes rooted at the same node are aligned such that each node has the same center-to-center distance
      * to the root. Therefore all nodes will be placed on one common radius around their root.
      * Note: does realize two different radii if in interleaved mode {@link yfiles.tree.BalloonLayouter#interleavedMode}.
      * @see {@link yfiles.tree.BalloonLayouter#childAlignmentPolicy}
      */
      SAME_CENTER,
      /**
      * Child alignment policy specifier constant.
      * Child nodes rooted at the same node are aligned such that the resulting drawing will be as compact as possible,
      * not considering any symmetric constraints or similar.
      * @see {@link yfiles.tree.BalloonLayouter#childAlignmentPolicy}
      */
      COMPACT,
      /**
      * Child alignment policy specifier constant.
      * Child nodes rooted at the same node are aligned using a smart strategy, which - if possible - tries
      * to estimate an alignment such that the resulting drawing is well-balanced and symmetric.
      * Note: if in interleaved mode {@link yfiles.tree.BalloonLayouter#interleavedMode}, then currently a plain alignment
      * will be chosen {@link yfiles.tree.ChildAlignmentPolicy#PLAIN}.
      * @see {@link yfiles.tree.BalloonLayouter#childAlignmentPolicy}
      */
      SMART
    }
    export enum ChildOrderingPolicy{
      /**
      * Child ordering policy specifier constant.
      * This policy sorts the child nodes according to the size of the subtree rooted by them in an interleaved fashion.
      * Using this policy the produced results are often more compact.
      * @see {@link yfiles.tree.BalloonLayouter#childOrderingPolicy}
      */
      COMPACT,
      /**
      * Child ordering policy specifier constant.
      * This policy sorts the child nodes according to their wedge angle sizes.
      * The node with the biggest angle receives median position in the sorting order.
      * The smaller the wedges the further away a node will be placed from the
      * median position. Using this policy the produced results are often more symmetric.
      * @see {@link yfiles.tree.BalloonLayouter#childOrderingPolicy}
      */
      SYMMETRIC
    }
    export enum RootNodePolicy{
      /**
      * Root node policy specifier constant. A node with indegree 0
      * is chosen as root node of the tree. If no node with that property
      * is present the an arbitrary node is chosen.
      */
      DIRECTED_ROOT,
      /**
      * Root node policy specifier constant. A center node 
      * will be chosen as root node of the tree.
      * @see {@link yfiles.algorithms.Trees#getCenterRoot}
      */
      CENTER_ROOT,
      /**
      * Root node policy specifier constant. A weighted center node 
      * will be chosen as root node of the tree.
      * @see {@link yfiles.algorithms.Trees#getCenterRoot}
      */
      WEIGHTED_CENTER_ROOT
    }
    export enum NodeLabelingPolicy{
      /**
      * Node labeling policy specifier constant.
      * Leaf nodes and nodes having exactly one successor (thus forming a sort of chain) will not be oriented horizontal
      * but ray-like: that means they get the same orientation as their nodes' incoming edge.
      * The labels of the nodes having more than 1 successor will be oriented horizontally and placed at the center
      * of the corresponding node.
      * @see {@link yfiles.tree.BalloonLayouter#nodeLabelingPolicy}
      */
      RAYLIKE,
      /**
      * Node labeling policy specifier constant.
      * Only labels corresponding to leaf nodes won't be oriented horizontally. They get the same orientation
      * as their nodes' incoming edge. These labels will be placed outside the node (without overlaps).
      * The labels of all the other nodes will be oriented horizontally and placed at the center of the corresponding node.
      * @see {@link yfiles.tree.BalloonLayouter#nodeLabelingPolicy}
      */
      MIXED,
      /**
      * Node labeling policy specifier constant.
      * The labels of all nodes will be oriented horizontally and placed at the center of the corresponding node.
      * @see {@link yfiles.tree.BalloonLayouter#nodeLabelingPolicy}
      */
      HORIZONTAL
    }
    /**
    * This class provides simple default port assignment strategies.
    */
    export interface DefaultPortAssignment extends Object,yfiles.tree.IPortAssignment{
      /**
      * Called by {@link yfiles.tree.GenericTreeLayouter} before the actual layout
      * of the graph takes place.
      * This method assigns both the single
      * incoming edge's target port as well as all source ports for all
      * outgoing child edges. Note that at the time this method gets invoked,
      * GenericTreeLayouter may have reversed some edges in order to normalize the
      * tree structure.
      * @param {yfiles.layout.LayoutGraph} graph the graph instance the node is part of
      * @param {yfiles.algorithms.Node} node the node whose adjacent edges' ports should be set
      * @see Specified by {@link yfiles.tree.IPortAssignment#assignPorts}.
      */
      assignPorts(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):void;
      /**
      * This method assigns the target port of the edge that goes to the parent node.
      * @param {yfiles.layout.LayoutGraph} graph the graph which contains the node
      * @param {yfiles.algorithms.Node} node the node
      * @param {yfiles.algorithms.Edge} edge the edge to the parent node
      */
      assignParentEdgeTargetPort(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node,edge:yfiles.algorithms.Edge):void;
      /**
      * This method assigns the source port of an edge that goes to a child node.
      * @param {yfiles.layout.LayoutGraph} graph the graph which contains the node
      * @param {yfiles.algorithms.Node} node the parent node
      * @param {yfiles.algorithms.Edge} edge the edge to the child node
      * @param {number} index the zero-based index of the child edge
      */
      assignChildEdgeSourcePort(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node,edge:yfiles.algorithms.Edge,index:number):void;
      /**
      * Callback method used to determine the port border gap for each node and
      * side.
      * @param {number} sideLength the width/height of the side
      * @param {number} edgeCount the number of edges/port that connect to this side
      * @return {number} the absolute gap to be used on both sides of the ports
      */
      getPortBorderGap(sideLength:number,edgeCount:number):number;
      /**
      * Callback method used to determine the distance between two adjacent ports.
      * @param {number} sideLength the width/height of the side
      * @param {number} edgeCount the number of edges/port that connect to this side
      * @param {number} portBorderGap the previously calculated port border gap
      * @return {number} the absolute distance to be used between two adjacent ports
      */
      getPortDistanceDelta(sideLength:number,edgeCount:number,portBorderGap:number):number;
      /**
      * Returns the PortConstraint for the given edge or <code>null</code> if no
      * PortConstraint is set.
      * This implementation uses the PortConstraint data provider
      * that is bound to the graph, if available.
      * @param {yfiles.layout.LayoutGraph} graph the graph the edge is part of
      * @param {yfiles.algorithms.Edge} edge the edge whose PortConstraint is to be determined
      * @param {number} index the child's index
      * @return {yfiles.layout.PortConstraint} a PortConstraint or <code>null</code>
      */
      getSourcePortConstraint(graph:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge,index:number):yfiles.layout.PortConstraint;
      /**
      * Returns the PortConstraint for the given edge or <code>null</code> if no
      * PortConstraint is set.
      * This implementation uses the PortConstraint data provider
      * that is bound to the graph, if available.
      * @param {yfiles.layout.LayoutGraph} graph the graph the edge is part of
      * @param {yfiles.algorithms.Edge} edge the edge whose PortConstraint is to be determined
      * @return {yfiles.layout.PortConstraint} a PortConstraint or <code>null</code>
      */
      getTargetPortConstraint(graph:yfiles.layout.LayoutGraph,edge:yfiles.algorithms.Edge):yfiles.layout.PortConstraint;
      /**
      * The port assignment mode.
      * Possible values are
      * <ul>
      * <li>{@link yfiles.tree.PortAssignmentMode#NONE}: all ports lie on the same point.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_NORTH}: ports are distributed among the northern side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_SOUTH}: ports are distributed among the southern side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_EAST}: ports are distributed among the eastern side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_WEST}: ports are distributed among the western side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#PORT_CONSTRAINT}: ports are distributed as specified.</li>
      * </ul>
      */
      mode:yfiles.tree.PortAssignmentMode;
      /**
      * The ratio of the gap between the border of the node and the next port and the gap between the ports.
      * <b>Getter:</b>For example, the default value, <code>0.5</code>, indicates that the border gap is as wide as half the gap between the ports.
      * <b>Setter:</b>For example, <code>0.5</code> sets the border gap as wide as half the gap between the ports. Thus,
      * the lower the value is, the wider "spread" the ports at the side of the node.     
      * <b>Note:</b> This setting is only useful for distributed port assignment.
      */
      borderGapToPortGapRatio:number;
      /**
      * Indicates if the port assignment is set to reversed order.
      * <b>Getter:</b>The default order is from
      * left to right and from top to bottom. Thus, the default value is false.
      * <b>Setter:</b>If set to true, the order is from right to left and from bottom to top.
      * <b>Note:</b> This setting is only useful for distributed port assignment.
      */
      reversedPortOrder:boolean;
    }
    var DefaultPortAssignment:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new DefaultPortAssignment instance using mode {@link yfiles.tree.PortAssignmentMode#NONE}.
      */
      new ():yfiles.tree.DefaultPortAssignment;
      /**
      * Creates a new DefaultPortAssignment instance using the given mode and the default value for
      * the ratio of the gap between the border and the ports and the gap between the ports themselves.
      * The default value is 0.5. 
      * Possible values for <code>mode</code> are:
      * <ul>
      * <li>{@link yfiles.tree.PortAssignmentMode#NONE}: all ports lie on the same point.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_NORTH}: ports are distributed among the northern side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_SOUTH}: ports are distributed among the southern side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_EAST}: ports are distributed among the eastern side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_WEST}: ports are distributed among the western side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#PORT_CONSTRAINT}: ports are distributed as specified.</li>
      * </ul>
      */
      WithMode:{
        new (mode:yfiles.tree.PortAssignmentMode):yfiles.tree.DefaultPortAssignment;
      };
      /**
      * Creates a new DefaultPortAssignment instance using the given mode and a given value for
      * the ratio of the gap between the border and the ports and the gap between the ports themselves.
      * Possible values for <code>mode</code> are:
      * <ul>
      * <li>{@link yfiles.tree.PortAssignmentMode#NONE}: all ports lie on the same point.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_NORTH}: ports are distributed among the northern side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_SOUTH}: ports are distributed among the southern side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_EAST}: ports are distributed among the eastern side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#DISTRIBUTED_WEST}: ports are distributed among the western side of the node.</li>
      * <li>{@link yfiles.tree.PortAssignmentMode#PORT_CONSTRAINT}: ports are distributed as specified.</li>
      * </ul>
      */
      WithModeAndRatio:{
        new (mode:yfiles.tree.PortAssignmentMode,ratio:number):yfiles.tree.DefaultPortAssignment;
      };
    };
    export enum FillStyle{
      /**
      * Byte constant that can be used for the <code>fillStyle</code> property.
      * Elements in one lane will be aligned with the leading edge.
      */
      LEADING,
      /**
      * Byte constant that can be used for the <code>fillStyle</code> property.
      * Elements in one lane will be centered with the bounds.
      */
      CENTERED,
      /**
      * Byte constant that can be used for the <code>fillStyle</code> property.
      * Elements in one lane will be justified with the bounds.
      */
      JUSTIFY,
      /**
      * Byte constant that can be used for the <code>fillStyle</code> property.
      * Elements in one lane will be aligned with the trailing edge.
      */
      TRAILING
    }
    export enum InterleavedMode{
      /**
      * Interleaved mode specifier constant.
      * This mode does turn off the interleaved child arrangement for all nodes in the tree.
      * This is the default mode.
      * @see {@link yfiles.tree.BalloonLayouter#interleavedMode}
      */
      OFF,
      /**
      * Interleaved mode specifier constant.
      * Using this mode, the children (successors) of all nodes in the tree will possibly be placed in an interleaved
      * fashion. Interleaved arrangement means, that the successors of node <code>root</code> are placed at different
      * distances in an alternating way.
      * Note: If there is enough space within the desired child wedge of some node to place all children without using
      * different distances, then the children will simply be placed without interleaving.
      * @see {@link yfiles.tree.BalloonLayouter#interleavedMode}
      */
      ALL_NODES,
      /**
      * Interleaved mode specifier constant.
      * Using this mode, it is possible to specify individually for each node if the nodes children should be arranged
      * in an interleaved way or not. For this purpose a {@link yfiles.algorithms.IDataProvider} with key {@link yfiles.tree.BalloonLayouter#INTERLEAVED_NODES_DP_KEY}
      * can be attached to the graph to be laid out. The data provider may then provide a boolean value which determines,
      * if the children of a specific node will be placed interleaved or not.
      * <p>If there is no {@link yfiles.algorithms.IDataProvider} with key {@link yfiles.tree.BalloonLayouter#INTERLEAVED_NODES_DP_KEY} registered, then
      * the selection of nodes where children shall arranged interleaved will be made based on a very simple heuristic.</p>
      * Note: If there is enough space within the desired child wedge of a selected node to place all children without using
      * different distances, then the children will simply be placed without interleaving.
      * @see {@link yfiles.tree.BalloonLayouter#interleavedMode}
      */
      SELECTED_NODES
    }
    /**
    * Versatile default implementation of {@link yfiles.tree.INodePlacer} used by
    * {@link yfiles.tree.GenericTreeLayouter}.
    * This implementation provides
    * a couple of related styles for laying out subtrees in a tree layout.
    * The styles can be customized easily using a wealth of different options.
    * This implementation is capable of dealing with PortConstraints correctly.
    */
    export interface DefaultNodePlacer extends yfiles.tree.AbstractNodePlacer,yfiles.tree.IFromSketchNodePlacer,yfiles.algorithms.ICloneable{
      /**
      * The main placeSubtree method that must be implemented by subclasses.
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction of the connector shape
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} a SubtreeShape instance that describes the shape of the whole subtree
      */
      placeSubtreeImpl(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * Calculates the connector the the parent node.
      * Subclasses may override this method.
      * @param {yfiles.layout.LayoutGraph} graph the graph
      * @param {yfiles.algorithms.Node} localRoot 
      * the root whose connector must be calculated and stored in the
      * subtreeShape
      * @param {yfiles.layout.INodeLayout} rootLayout the NodeLayout of the root node
      * @param {yfiles.tree.GenericTreeLayouter.SubtreeShape} subtreeShape the shape to be used for the connector information
      * @param {yfiles.algorithms.Edge} parentEdge 
      * the edge that will later be routed according to the
      * information in the subtreeShape
      * @param {yfiles.layout.IEdgeLayout} parentEdgeLayout the current EdgeLayout of the edge
      * @param {number} direction 
      * the direction byte constant as defined in the
      * {@link yfiles.tree.INodePlacer} interface which should be used for
      * the connector
      */
      calcParentConnector(graph:yfiles.layout.LayoutGraph,localRoot:yfiles.algorithms.Node,rootLayout:yfiles.layout.INodeLayout,subtreeShape:yfiles.tree.GenericTreeLayouter.SubtreeShape,parentEdge:yfiles.algorithms.Edge,parentEdgeLayout:yfiles.layout.IEdgeLayout,direction:number):void;
      /**
      * Performs the routing of the target side of the edge to
      * the given child node.
      * This method does nothing but resets the current
      * EdgeLayout.
      * @param {yfiles.layout.INodeLayout} rootLayout the NodeLayout of the local root node
      * @param {yfiles.tree.GenericTreeLayouter.SubtreeShape} childShape 
      * the SubtreeShape instance of the corresponding child's
      * subtree
      * @param {yfiles.algorithms.Edge} edge the edge
      */
      calcTargetEdgeLayout(rootLayout:yfiles.layout.INodeLayout,childShape:yfiles.tree.GenericTreeLayouter.SubtreeShape,edge:yfiles.algorithms.Edge):void;
      /**
      * Performs the routing of the source side of the edge to
      * the given child node.
      * This method delegates to {@link yfiles.tree.DefaultNodePlacer#calcSourceEdgeLayout}
      * if <code>routingStyle</code> is not <code>ROUTING_FORK</code>
      * This method calculates the source bends according to
      * the current <code>routingStyle</code>, and connects the bends of the child
      * SubtreeShape connector to the EdgeLayout.
      * @param {yfiles.layout.INodeLayout} rootLayout the NodeLayout of the local root node
      * @param {yfiles.tree.GenericTreeLayouter.SubtreeShape} childShape the SubtreeShape instance of the corresponding child's subtree
      * @param {yfiles.algorithms.Edge} edge the edge
      * @param {number} rootForkCoordinate the y-coordinate of the first bend of the edge if the placement is horizontal and the x-coordinate otherwise.
      * @param {number} childForkCoordinate the y-coordinate of the second (= last) bend of the edge if the placement is horizontal and the x-coordinate otherwise.
      */
      calcSlopedSourceEdgeLayout(rootLayout:yfiles.layout.INodeLayout,childShape:yfiles.tree.GenericTreeLayouter.SubtreeShape,edge:yfiles.algorithms.Edge,childForkCoordinate:number,rootForkCoordinate:number):void;
      /**
      * Performs the routing of the source side of the edge to
      * the given child node.
      * This method calculates the source bends according to
      * the current <code>routingStyle</code>, and connects the bends of the child
      * SubtreeShape connector to the EdgeLayout.
      * @param {yfiles.layout.INodeLayout} rootLayout the NodeLayout of the local root node
      * @param {yfiles.tree.GenericTreeLayouter.SubtreeShape} childShape 
      * the SubtreeShape instance of the corresponding child's
      * subtree
      * @param {yfiles.algorithms.Edge} edge the edge
      */
      calcSourceEdgeLayout(rootLayout:yfiles.layout.INodeLayout,childShape:yfiles.tree.GenericTreeLayouter.SubtreeShape,edge:yfiles.algorithms.Edge):void;
      /**
      * The child node placement policy.
      */
      childPlacement:yfiles.tree.ChildPlacement;
      /**
      * The root node alignment policy.
      */
      rootAlignment:yfiles.tree.RootAlignment;
      /**
      * The relative vertical alignment of nodes with the same parent.
      * A value of <code>0</code> means nodes are top aligned;
      * a value of <code>1</code> means nodes are bottom aligned;
      * a value of <code>0.5</code> means nodes are center aligned.
      * Values outside the interval <code>[0,1]</code> will result in a compact node placement with unaligned nodes.
      * <p>
      * By default the compact placement with unaligned nodes is used.
      * </p>
      */
      verticalAlignment:number;
      /**
      * This method must be implemented by subclasses.
      * It assigns a connector shape
      * direction to each child.
      * @param {yfiles.algorithms.Node} child the child node
      * @return {number} 
      * a byte constant as defined in the {@link yfiles.tree.INodePlacer} interface
      */
      determineChildConnector(child:yfiles.algorithms.Node):number;
      /**
      * The current routing style byte constant.
      */
      routingStyle:yfiles.tree.RoutingStyle;
      /**
      * The vertical distance this NodePlacer should use for the
      * arrangement of the elements.
      */
      verticalDistance:number;
      /**
      * The minimum length of the segment between the parent node port and the first bend of the edge.
      */
      minFirstSegmentLength:number;
      /**
      * The minimum length of the segment between the last bend of the slope and the port of the child node..
      */
      minLastSegmentLength:number;
      /**
      * The minimum slope of edges.
      */
      minSlope:number;
      /**
      * The minimum height for slopes of edges.
      */
      minSlopeHeight:number;
      /**
      * The horizontal distance this <code>NodePlacer</code> should use for the
      * arrangement of the elements.
      */
      horizontalDistance:number;
      /**
      * Returns a Comparator instance that can be used to register with the
      * GenericTreeLayouter.
      * The returned instance can be used to sort the child
      * nodes in such a way that the layout will look like the current arrangement
      * of the nodes. This is especially useful for interactive or incremental layouts.
      * @return {yfiles.objectcollections.IComparer} 
      * a Comparator instance that can be used for the current configuration of
      * this instance.
      */
      createComparator():yfiles.objectcollections.IComparer;
      /**
      * Creates a comparator for edges.
      * This comparator is used to sort the outgoing edges of a node before the
      * placement of the node's subtree is calculated.
      * @return {yfiles.objectcollections.IComparer} a comparator for edges.
      * @see Specified by {@link yfiles.tree.IFromSketchNodePlacer#createFromSketchComparator}.
      */
      createFromSketchComparator():yfiles.objectcollections.IComparer;
    }
    var DefaultNodePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new DefaultNodePlacer with default alignment ({@link yfiles.tree.RootAlignment#CENTER}),
      * default child placement ({@link yfiles.tree.ChildPlacement#HORIZONTAL_DOWNWARD}),
      * and default edge routing ({@link yfiles.tree.RoutingStyle#FORK}) and a horizontal and vertical distance
      * of <code>40.0d</code>.
      */
      new ():yfiles.tree.DefaultNodePlacer;
      /**
      * Creates a new DefaultNodePlacer with default alignment ({@link yfiles.tree.RootAlignment#CENTER})
      * and default edge routing ({@link yfiles.tree.RoutingStyle#FORK}).
      * @param {yfiles.tree.ChildPlacement} childPlacement placement constant describing the style of the arrangement
      * @param {number} verticalDistance 
      * the vertical distance between the root node and the subtree shapes or between
      * subtree shapes in case of vertical child placement
      * @param {number} horizontalDistance 
      * the horizontal distance between the root node and the subtree shapes or between
      * subtree shapes in case of horizontal child placement
      */
      WithDistance:{
        new (childPlacement:yfiles.tree.ChildPlacement,verticalDistance:number,horizontalDistance:number):yfiles.tree.DefaultNodePlacer;
      };
      /**
      * Creates a new DefaultNodePlacer with default edge routing ({@link yfiles.tree.RoutingStyle#FORK}).
      * @param {yfiles.tree.ChildPlacement} childPlacement placement constant describing the style of the arrangement
      * @param {yfiles.tree.RootAlignment} rootAlignment 
      * alignment constant describing the position of the root nod
      * with respect to the subtrees
      * @param {number} verticalDistance 
      * the vertical distance between the root node and the subtree shapes or between
      * subtree shapes in case of vertical child placement
      * @param {number} horizontalDistance 
      * the horizontal distance between the root node and the subtree shapes or between
      * subtree shapes in case of horizontal child placement
      */
      WithAlignmentAndDistance:{
        new (childPlacement:yfiles.tree.ChildPlacement,rootAlignment:yfiles.tree.RootAlignment,verticalDistance:number,horizontalDistance:number):yfiles.tree.DefaultNodePlacer;
      };
      /**
      * Creates a new DefaultNodePlacer.
      * @param {yfiles.tree.RoutingStyle} routingStyle routing style constant
      * @param {yfiles.tree.ChildPlacement} childPlacement placement constant describing the style of the arrangement
      * @param {yfiles.tree.RootAlignment} rootAlignment 
      * alignment constant describing the position of the root nod
      * with respect to the subtrees
      * @param {number} verticalDistance 
      * the vertical distance between the root node and the subtree shapes or between
      * subtree shapes in case of vertical child placement
      * @param {number} horizontalDistance 
      * the horizontal distance between the root node and the subtree shapes or between
      * subtree shapes in case of horizontal child placement
      */
      WithAlignmentStyleAndDistance:{
        new (childPlacement:yfiles.tree.ChildPlacement,rootAlignment:yfiles.tree.RootAlignment,routingStyle:yfiles.tree.RoutingStyle,verticalDistance:number,horizontalDistance:number):yfiles.tree.DefaultNodePlacer;
      };
      /**
      * Creates a new DefaultNodePlacer.
      * @param {yfiles.tree.RoutingStyle} routingStyle routing style constant
      * @param {yfiles.tree.ChildPlacement} childPlacement placement constant describing the style of the arrangement
      * @param {yfiles.tree.RootAlignment} rootAlignment 
      * alignment constant describing the position of the root nod
      * with respect to the subtrees
      * @param {number} verticalDistance 
      * the vertical distance between the root node and the subtree shapes or between
      * subtree shapes in case of vertical child placement
      * @param {number} horizontalDistance 
      * the horizontal distance between the root node and the subtree shapes or between
      * subtree shapes in case of horizontal child placement
      * @param {number} minFirstSegmentLength the minimum length of the segment from the parent node port to the bend of the slope
      * @param {number} minLastSegmentLength the minimum length of the segment from the last bend of the slope to the port of the child node
      * @param {number} minSlope the minimum slope between the root node and the subtree shapes
      * @param {number} minSlopeHeight the minimum height of slopes between the root node and the subtree shapes
      */
      WithAlignmentStyleDistanceLengthAndSlope:{
        new (childPlacement:yfiles.tree.ChildPlacement,rootAlignment:yfiles.tree.RootAlignment,routingStyle:yfiles.tree.RoutingStyle,verticalDistance:number,horizontalDistance:number,minFirstSegmentLength:number,minLastSegmentLength:number,minSlope:number,minSlopeHeight:number):yfiles.tree.DefaultNodePlacer;
      };
    };
    /**
    * This comparator compares edges by examining the x-coordinates of the centers
    * of their target nodes.
    */
    export interface XCoordComparator extends Object,yfiles.objectcollections.IComparer,yfiles.algorithms.Comparators.IPartialOrder{
      /**
      * Object is actually expected to be {@link yfiles.algorithms.Edge}.
      * Compares the x-coordinates of the centers of the target nodes.
      * @see Specified by {@link yfiles.objectcollections.IComparer#compare}.
      */
      compare(a:Object,b:Object):number;
    }
    var XCoordComparator:{
      $class:yfiles.lang.Class;
    };
    /**
    * This stage can be used to do mix layouts for tree-like subgraph structures and
    * the non-tree like rest of a graph.
    */
    export interface TreeComponentLayouter extends Object,yfiles.layout.ILayoutStage{
      /**
      * Returns <code>true</code> iff the given graph can be laid
      * out by this algorithm.
      * Calling <code>doLayout</code> with
      * the given graph as its argument will only success if
      * this method returns <code>true</code>.
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Assigns a new graph layout to the given layout graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Called by {@link yfiles.tree.TreeComponentLayouter#doLayout} to delegate to the
      * {@link yfiles.tree.TreeComponentLayouter#coreLayouter}, adding the dummy provider to the graph instance.
      */
      doLayoutUsingDummies(graph:yfiles.layout.LayoutGraph,dummyDp:yfiles.algorithms.IDataProvider):void;
      /**
      * The core layouter.
      * @see Specified by {@link yfiles.layout.ILayoutStage#coreLayouter}.
      */
      coreLayouter:yfiles.layout.ILayouter;
      /**
      * The core layouter used for tree components.
      */
      treeComponentCoreLayouter:yfiles.layout.ILayouter;
      /**
      * <code>true</code> if this layouter tries to improve tree component
      * placement by changing the components orientation and <code>false</code>
      * otherwise.
      */
      orientationOptimizationActive:boolean;
    }
    var TreeComponentLayouter:{
      $class:yfiles.lang.Class;
      /**
      * During the main run of the layout dummy nodes can be identified by looking
      * at the value of the registered DataProvider which can be obtained from
      * the graph using this key.
      */
      DUMMY_NODE_DP_KEY:Object;
      /**
      * Creates a new instance of TreeComponentLayouter using the specified
      * layouter for laying out the subtrees.
      */
      new (treeCoreLayouter:yfiles.layout.ILayouter):yfiles.tree.TreeComponentLayouter;
    };
    /**
    * Implementation of a layout algorithm for trees.
    * Here is an sample output of the layouter using left to right orientation and {@link yfiles.tree.EdgeLayoutStyle#ORTHOGONAL} layout style.
    * <center><img src="doc-files/y.layout.tree.TreeLayouter.gif" border="1"/></center>
    */
    export interface TreeLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * Returns true if the core layouter can layout the given graph structure.
      * This is the case if the graph is a tree.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Specifies whether or not global layering is enforced.
      * If this feature is enabled, the algorithm ensures that nodes never span
      * more than one layer. Otherwise, a large node might span two, three, etc
      * layers of smaller nodes to produce a more compact layout.
      * <p>
      * Disabling this feature to generate more compact layouts will usually
      * result in the algorithm ignoring the specified relative vertical alignment
      * for nodes.
      * </p><p>
      * By default, this feature is enabled.
      * </p>
      * @see {@link yfiles.tree.TreeLayouter#verticalAlignment}
      * @see {@link yfiles.tree.TreeLayouter#verticalAlignment}
      */
      enforceGlobalLayering:boolean;
      /**
      * The layout policy for leaf nodes.
      * <p>
      * Defaults to {@link yfiles.tree.ChildPlacementPolicy#SIBLINGS_ON_SAME_LAYER}.
      * </p>
      * @throws {yfiles.system.ArgumentException} if the specified policy does not match one of the leaf layout policy constants.
      */
      childPlacementPolicy:yfiles.tree.ChildPlacementPolicy;
      /**
      * True if grouping support is enabled.
      * Note that the grouping only works correctly, if each group represents
      * a complete subtree. This means that for each group there is a node v such that the group contains exactly v and all
      * its descendants.
      */
      groupingSupported:boolean;
      /**
      * Starts the tree layout process.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The comparator for outgoing edges at a node This comparator defines the relative order of the child nodes
      * in the layout to be calculated.
      * By default {@link yfiles.tree.XCoordComparator} is set.
      */
      comparator:yfiles.objectcollections.IComparer;
      /**
      * The port assignment style.
      */
      portStyle:yfiles.tree.PortStyle;
      /**
      * The layout style of this layouter.
      * @see {@link yfiles.tree.EdgeLayoutStyle#PLAIN}
      * @see {@link yfiles.tree.EdgeLayoutStyle#ORTHOGONAL}
      */
      layoutStyle:yfiles.tree.EdgeLayoutStyle;
      /**
      * The minimum horizontal distance between adjacent nodes for this layouter.
      * Default value is 20.0.
      */
      minimalNodeDistance:number;
      /**
      * The minimal distance between adjacent layers for the layout.
      * Default value is 40.0.
      */
      minimalLayerDistance:number;
      /**
      * Specifies whether integrated node labeling is enabled.
      */
      integratedNodeLabeling:boolean;
      /**
      * Specifies whether integrated edge labeling is enabled.
      */
      integratedEdgeLabeling:boolean;
      /**
      * The vertical bus alignment for orthogonally routed edge buses.
      * The bus alignment determines the relative position of an edge bus in
      * between two subsequent layers of nodes.
      * A value of <code>0</code> places the bus at the top right below the parent node;
      * a value of <code>0.5</code> places the bus in the middle between parent and child nodes; and
      * a value of <code>1</code> places the bus at the bottom right above the child nodes.
      * <p>
      * Bus alignment is taken into account only for
      * <ul>
      * <li>
      * layout style {@link yfiles.tree.EdgeLayoutStyle#ORTHOGONAL} with global layering enforced and
      * </li>
      * <li>
      * layout style {@link yfiles.tree.EdgeLayoutStyle#ORTHOGONAL} with child placement policy
      * {@link yfiles.tree.ChildPlacementPolicy#ALL_LEAVES_ON_SAME_LAYER}.
      * </li>
      * </ul>
      * </p><p>
      * Defaults to <code>0.3</code>.
      * </p>
      * @see {@link yfiles.tree.TreeLayouter#layoutStyle}
      * @see {@link yfiles.tree.TreeLayouter#enforceGlobalLayering}
      * @see {@link yfiles.tree.TreeLayouter#childPlacementPolicy}
      * @see {@link yfiles.tree.TreeLayouter#layoutStyle}
      * @see {@link yfiles.tree.TreeLayouter#enforceGlobalLayering}
      * @see {@link yfiles.tree.TreeLayouter#childPlacementPolicy}
      */
      busAlignment:number;
      /**
      * The relative vertical alignment of nodes within their respective
      * layers.
      * A value of <code>0</code> means nodes are top aligned;
      * a value of <code>1</code> means nodes are bottom aligned.
      * <p>
      * If global layering is not enforced, the value of this property is usually
      * ignored.
      * </p><p>
      * Defaults to <code>0.5</code>, i.e. nodes are center aligned.
      * </p>
      * @see {@link yfiles.tree.TreeLayouter#enforceGlobalLayering}
      * @see {@link yfiles.tree.TreeLayouter#enforceGlobalLayering}
      * @see {@link yfiles.tree.TreeLayouter#enforceGlobalLayering}
      * @see {@link yfiles.tree.TreeLayouter#enforceGlobalLayering}
      */
      verticalAlignment:number;
      /**
      * The modification matrix that is used to rotate / mirror the tree layout.
      */
      modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
    }
    var TreeLayouter:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of TreeLayouter.
      */
      new ():yfiles.tree.TreeLayouter;
    };
    /**
    * This stage can be used to layout non-tree structures with a
    * tree layout algorithm.
    * First this stage transforms a graph into a tree or forest by removing some
    * edges.
    * Then it invokes the core layout algorithm on the reduced graph.
    * Finally, it reinserts the hidden non-tree edges to the graph
    * again and optionally routes these edges.
    * <p>
    * Typical usage:
    * </p>
    * <pre><code>
    * var tl = new yfiles.tree.TreeLayouter();
    * var trs = new yfiles.tree.TreeReductionStage();
    * trs.nonTreeEdgeRouter = new yfiles.router.OrganicEdgeRouter();
    * trs.nonTreeEdgeSelectionKey = yfiles.router.OrganicEdgeRouter.ROUTE_EDGE_DP_KEY;
    * tl.appendStage(trs);
    * graph.applyLayout(tl);
    * tl.RemoveStage(trs);
    * </code></pre>
    * <p>
    * Note that if there are edges between group nodes, the {@link yfiles.tree.TreeLayouter} may throw a
    * {@link yfiles.algorithms.InvalidGraphStructureException} exception. Such exceptions can be prevented by temporarily removing
    * those edges.
    * </p>
    * <p>
    * Note that this layout stage is also able to handle multi-parent structures, i.e., structures of multiple nodes
    * that share the same predecessors as well as the same successors. More precisely, if the specified core layout
    * can handle multi-parent structures (see {@link yfiles.tree.GenericTreeLayouter#multiParentAllowed})
    * and option {@link yfiles.tree.TreeReductionStage#multiParentAllowed} is enabled, this stage does not hide such structures
    * (i.e., the multi-parents are passed to the core layouter).
    * </p>
    * @see {@link yfiles.router.OrganicEdgeRouter}
    * @see {@link yfiles.router.polyline.EdgeRouter}
    * @see {@link yfiles.router.OrthogonalEdgeRouter}
    */
    export interface TreeReductionStage extends yfiles.layout.AbstractLayoutStage{
      /**
      * Returns <code>true</code>.
      * @see Overrides {@link yfiles.layout.AbstractLayoutStage#canLayout}
      * @see Specified by {@link yfiles.layout.ILayouter#canLayout}.
      */
      canLayout(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Main layout routine that assigns new layout information to the given graph.
      * @see Specified by {@link yfiles.layout.ILayouter#doLayout}.
      */
      doLayout(graph:yfiles.layout.LayoutGraph):void;
      /**
      * Routes the non-tree edges.
      * @param {yfiles.layout.LayoutGraph} graph graph that can contain tree and non-tree edges.
      * @param {yfiles.algorithms.IEdgeMap} nonTreeEdgeMap 
      * an edge map that marks all non-tree edges
      * in the graph with boolean value <code>true</code>.
      */
      routeNonTreeEdges(graph:yfiles.layout.LayoutGraph,nonTreeEdgeMap:yfiles.algorithms.IEdgeMap):void;
      /**
      * Specifies whether or not multi-parent structures (structures of multiple nodes that share the same predecessors as
      * well as the same successors) are allowed.
      * <p>
      * More precisely, if this option is enabled and the specified core layout can handle multi-parent
      * structures (see {@link yfiles.tree.GenericTreeLayouter#multiParentAllowed}),
      * this stage does not hide such structures (i.e., the multi-parent structures are passed to the core layouter).
      * </p>
      */
      multiParentAllowed:boolean;
      /**
      * The currently set edge router for non-tree edges.
      * Very often, this method should
      * be used in conjunction with {@link yfiles.tree.TreeReductionStage#nonTreeEdgeSelectionKey} to
      * control the set of edges that should be handled by the edge router.
      */
      nonTreeEdgeRouter:yfiles.layout.ILayouter;
      /**
      * The currently set non-tree edge selection key.
      * @see {@link yfiles.algorithms.Graph#addDataProvider}
      * @see {@link yfiles.tree.TreeReductionStage#nonTreeEdgeRouter}
      */
      nonTreeEdgeSelectionKey:Object;
      /**
      * Creates a layouter that can be used to route all non-tree edges
      * as a single straight-line segment.
      * @see {@link yfiles.tree.TreeReductionStage#nonTreeEdgeRouter}
      */
      createStraightlineRouter():yfiles.layout.ILayouter;
    }
    var TreeReductionStage:{
      $class:yfiles.lang.Class;
      new ():yfiles.tree.TreeReductionStage;
      /**
      * DataProvider key that can be used to explicitly mark (some) edges
      * that should not be considered to belong to a tree.
      */
      NON_TREE_EDGES_DP_KEY:Object;
    };
    /**
    * Utility class that serves as a basis for implementations of the
    * {@link yfiles.tree.INodePlacer} interface.
    * It provides convenience methods for
    * often used sub tasks during a layout.
    * Subclasses need to override the two abstract methods only.
    */
    export interface AbstractNodePlacer extends Object,yfiles.tree.INodePlacer,yfiles.algorithms.ICloneable{
      /**
      * The graph instance this class is working on.
      */
      graph:yfiles.layout.LayoutGraph;
      /**
      * Creates an optional Processor for pre- and post-processing.
      * @param {yfiles.tree.GenericTreeLayouter} layouter 
      * @param {yfiles.layout.LayoutGraph} graph the actual graph
      * @param {yfiles.algorithms.Node} currentRoot the actual root node for this node placer
      * @return {yfiles.tree.IProcessor} a Processor or null
      * @see Specified by {@link yfiles.tree.INodePlacer#createProcessor}.
      */
      createProcessor(layouter:yfiles.tree.GenericTreeLayouter,graph:yfiles.layout.LayoutGraph,currentRoot:yfiles.algorithms.Node):yfiles.tree.IProcessor;
      /**
      * Convenience method that queries the DataProvider for a SubtreeShape.
      * This method can be called during the execution of {@link yfiles.tree.AbstractNodePlacer#placeSubtreeImpl}
      * @param {yfiles.algorithms.Node} node the root node whose subtree shape will be returned in the form of a SubtreeShape instance
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} an instance that can be modified
      */
      getSubtreeShape(node:yfiles.algorithms.Node):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * Convenience method that queries the DataProvider for the shape of a single
      * node as a SubtreeShape instance.
      * This instance can be used to modify it and
      * return it in the main placeSubtree method. 
      * This method can be called during the execution of {@link yfiles.tree.AbstractNodePlacer#placeSubtreeImpl}
      * @param {yfiles.algorithms.Node} node the node whose shape will be returned in the form of a SubtreeShape instance
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} an instance that can be modified
      */
      getNodeShape(node:yfiles.algorithms.Node):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * This method initializes internal data structures and then uses the
      * abstract method to determine the child node connector directions.
      * @see {@link yfiles.tree.AbstractNodePlacer#determineChildConnector}
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.algorithms.IDataMap} connectorMap the map that will be used to store the values
      * @see Specified by {@link yfiles.tree.INodePlacer#determineChildConnectors}.
      */
      determineChildConnectors(localRoot:yfiles.algorithms.Node,connectorMap:yfiles.algorithms.IDataMap):void;
      /**
      * This method must be implemented by subclasses.
      * It assigns a connector shape
      * direction to each child.
      * @param {yfiles.algorithms.Node} child the child node
      * @return {number} 
      * a byte constant as defined in the {@link yfiles.tree.INodePlacer} interface
      */
      determineChildConnector(child:yfiles.algorithms.Node):number;
      /**
      * The main placeSubtree method that must be implemented by subclasses.
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction of the connector shape
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} a SubtreeShape instance that describes the shape of the whole subtree
      */
      placeSubtreeImpl(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * This method initializes the local data structures and then delegates the work
      * to the abstract variant.
      * @see {@link yfiles.tree.AbstractNodePlacer#placeSubtreeImpl}
      * @see Specified by {@link yfiles.tree.INodePlacer#placeSubtree}.
      */
      placeSubtree(nodeShapeProvider:yfiles.algorithms.IDataProvider,subtreeShapeProvider:yfiles.algorithms.IDataProvider,graph:yfiles.layout.LayoutGraph,localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * Overwritten to support cloning.
      * @return {Object} an exact copy of this instance
      * @see Specified by {@link yfiles.algorithms.ICloneable#clone}.
      */
      clone():Object;
    }
    var AbstractNodePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of AbstractNodePlacer.
      */
      new ():yfiles.tree.AbstractNodePlacer;
    };
    /**
    * The assistant placer is a NodePlacer that delegates the node placement to two different node placers depending
    * on the type of the children.
    * The type of a child is recognized using a DataProvider providing boolean values.
    * The data provider is registered
    * using the key {@link yfiles.tree.AssistantPlacer#ASSISTANT_DP_KEY}.
    * Assistant placer uses a {@link yfiles.tree.LeftRightPlacer} for those nodes the DataProvider returns true (they are
    * understood as "assistants").
    * Below the assistants the other children are arranged using the childNodePlacer (settable
    * using {@link yfiles.tree.AssistantPlacer#childNodePlacer}).
    * <p>
    * Assistant placer provides the best results when using a port assignment that starts all edges at the same node.
    * If the ports are distributed at the border, edge crossings may occur.
    * </p>
    */
    export interface AssistantPlacer extends yfiles.tree.AbstractRotatableNodePlacer{
      /**
      * This method must be implemented by subclasses.
      * It is used to assigns a connector shape direction to each child.
      * @param {yfiles.algorithms.Node} child the child node
      * @return {yfiles.tree.ParentConnectorDirection} 
      * a byte constant as defined in the {@link yfiles.tree.INodePlacer} interface
      */
      determineChildConnector(child:yfiles.algorithms.Node):yfiles.tree.ParentConnectorDirection;
      /**
      * Delegates to the the left right placer.
      * @param {yfiles.algorithms.Node} localRoot 
      * @param {yfiles.algorithms.IDataMap} connectorMap 
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#determineChildConnectors}
      * @see Specified by {@link yfiles.tree.INodePlacer#determineChildConnectors}.
      */
      determineChildConnectors(localRoot:yfiles.algorithms.Node,connectorMap:yfiles.algorithms.IDataMap):void;
      /**
      * Returns the subtree shape for the given child node.
      * @param {yfiles.algorithms.Node} node the child node the subtree shape is returned for.
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} the subtree shape for the given child node.
      */
      getNodeShape(node:yfiles.algorithms.Node):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * Creates a processor that creates a dummy node and changes the edges for the non-assistant children.
      * @param {yfiles.tree.GenericTreeLayouter} layouter 
      * @param {yfiles.layout.LayoutGraph} graph 
      * @param {yfiles.algorithms.Node} currentRoot 
      * @return {yfiles.tree.IProcessor} the processor that changes the graph structure suitable for the AssistantPlacer
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#createProcessor}
      * @see Specified by {@link yfiles.tree.INodePlacer#createProcessor}.
      */
      createProcessor(layouter:yfiles.tree.GenericTreeLayouter,graph:yfiles.layout.LayoutGraph,currentRoot:yfiles.algorithms.Node):yfiles.tree.IProcessor;
      /**
      * The spacing between subtrees this <code>NodePlacer</code> is
      * arranging.
      */
      spacing:number;
      /**
      * Places the shapes.
      * @param {yfiles.algorithms.IDataProvider} nodeShapeProvider 
      * @param {yfiles.algorithms.IDataProvider} subtreeShapeProvider 
      * @param {yfiles.layout.LayoutGraph} graph 
      * @param {yfiles.algorithms.Node} localRoot 
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection 
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtree}
      * @see Specified by {@link yfiles.tree.INodePlacer#placeSubtree}.
      */
      placeSubtree(nodeShapeProvider:yfiles.algorithms.IDataProvider,subtreeShapeProvider:yfiles.algorithms.IDataProvider,graph:yfiles.layout.LayoutGraph,localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * This method must be implemented by subclasses.
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction of the connector shape
      * @return {yfiles.tree.SubtreeShapeRotated} a SubtreeShape instance that describes the shape of the whole subtree
      */
      placeSubtreeWithDirection(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.SubtreeShapeRotated;
      /**
      * The child node placer for the non-assistant children.
      * The child node placer is used to arrange the nodes that are not assistants.
      * {@link yfiles.tree.AssistantPlacer#ASSISTANT_DP_KEY}
      */
      childNodePlacer:yfiles.tree.INodePlacer;
      /**
      * Creates a comparator that compares edges of two assistant nodes with the
      * comparator created by {@link yfiles.tree.LeftRightPlacer} and all other edges with
      * the sketch comparator created by this placer's <code>childNodePlacer</code>.
      * @return {yfiles.objectcollections.IComparer} a comparator to compare two edges.
      * @see {@link yfiles.tree.AssistantPlacer#childNodePlacer}
      * @see {@link yfiles.tree.IFromSketchNodePlacer#createFromSketchComparator}
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#createComparator}
      */
      createComparator():yfiles.objectcollections.IComparer;
    }
    var AssistantPlacer:{
      $class:yfiles.lang.Class;
      /**
      * Contains a boolean for each node whether it is an assistant or not.
      * True: Is assistant
      * False: Is not an assistant
      */
      ASSISTANT_DP_KEY:Object;
      /**
      * Creates a default instance with horizontal orientation.
      * Call to this(Matrix.DEFAULT)
      */
      new ():yfiles.tree.AssistantPlacer;
      /**
      * Creates an AssistantPlacer for the given modification matrix.
      * @param {yfiles.tree.AbstractRotatableNodePlacer.Matrix} modificationMatrix the modification matrix that is used as translation matrix.
      */
      WithMatrix:{
        new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix):yfiles.tree.AssistantPlacer;
      };
      /**
      * Creates a comparator that compares edges connecting to assistant nodes
      * with the given <code>assistantComparator</code> and all other edges with
      * the given <code>childComparator</code>.
      * @param {yfiles.objectcollections.IComparer} assistantComparator the comparator for assistant edges
      * @param {yfiles.objectcollections.IComparer} childComparator the comparator for non-assistants edges
      * @return {yfiles.objectcollections.IComparer} 
      * a comparator that compares edges connecting to assistant nodes
      * with the given <code>assistantComparator</code> and all other edges
      * with the given <code>childComparator</code>.
      */
      createCompoundComparator(assistantComparator:yfiles.objectcollections.IComparer,childComparator:yfiles.objectcollections.IComparer):yfiles.objectcollections.IComparer;
    };
    /**
    * The BusPlacer is a special NodePlacer that creates a bus where all child nodes and the root node
    * are connected to.
    * The BusPlacer is rotatable using the constructor .
    */
    export interface BusPlacer extends yfiles.tree.AbstractRotatableNodePlacer{
      /**
      * This method must be implemented by subclasses.
      * It is used to assigns a connector shape direction to each child.
      * @param {yfiles.algorithms.Node} child the child node
      * @return {yfiles.tree.ParentConnectorDirection} 
      * a byte constant as defined in the {@link yfiles.tree.INodePlacer} interface
      */
      determineChildConnector(child:yfiles.algorithms.Node):yfiles.tree.ParentConnectorDirection;
      /**
      * This method initializes internal data structures, then uses the abstract method {@link yfiles.tree.BusPlacer#determineChildConnector}
      * to determine the child node connector directions.
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.algorithms.IDataMap} connectorMap the map that will be used to store the values
      * @see {@link yfiles.tree.BusPlacer#determineChildConnector}
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#determineChildConnectors}
      * @see Specified by {@link yfiles.tree.INodePlacer#determineChildConnectors}.
      */
      determineChildConnectors(localRoot:yfiles.algorithms.Node,connectorMap:yfiles.algorithms.IDataMap):void;
      /**
      * Places the root node and its children.
      * @param {yfiles.algorithms.Node} localRoot 
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection 
      * @return {yfiles.tree.SubtreeShapeRotated} the created subtree shape
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtreeWithDirection}
      */
      placeSubtreeWithDirection(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.SubtreeShapeRotated;
      createComparator():yfiles.objectcollections.IComparer;
    }
    var BusPlacer:{
      $class:yfiles.lang.Class;
      /**
      * Initializes a new instance with the Default matrix.
      */
      new ():yfiles.tree.BusPlacer;
      /**
      * Initializes a new BusPlacer with the given modification matrix.
      * @param {yfiles.tree.AbstractRotatableNodePlacer.Matrix} modificationMatrix 
      */
      WithMatrix:{
        new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix):yfiles.tree.BusPlacer;
      };
    };
    /**
    * This tree layouter tries to generate compact tree layouts with a certain aspect
    * ratio.
    * The ratio can be specified for each subtree.
    * Here is a sample layout output (using an aspect ratio of 1 by 2)
    * <center><img src="doc-files/y.layout.tree.ARTreeLayouter.gif" border="1"/></center>
    */
    export interface ARTreeLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      graph:yfiles.layout.LayoutGraph;
      /**
      * The horizontal distance between adjacent nodes.
      * By default a value of <code>10</code> is set.
      */
      horizontalSpace:number;
      /**
      * The vertical distance between adjacent nodes.
      * By default a value of <code>10</code> is set.
      */
      verticalSpace:number;
      /**
      * Core layout routine.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The core layouter can layout trees.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Returns the aspectRatio that should be used for the subtree starting
      * at the given node.
      */
      getAspectRatio(v:yfiles.algorithms.Node):number;
      getSuccessors(localRoot:yfiles.algorithms.Node):yfiles.algorithms.INodeCursor;
      /**
      * The{@link yfiles.objectcollections.IComparer} that will be used
      * to sort the {@link yfiles.algorithms.Node#sortOutEdges  outgoing edges}
      * of each local root in the tree before they are being arranged.
      * Note that the algorithm will only use the order induced by the comparator,
      * if the nodes (or better their whole subtrees) have equal size.
      * The default value is <code>null</code> which indicates that the algorithm should
      * use its built-in logic, only.
      */
      comparator:yfiles.objectcollections.IComparer;
      createBends(el:yfiles.layout.IEdgeLayout,root:yfiles.algorithms.Node,child:yfiles.algorithms.Node,rootPlacement:Object,routingPolicy:Object):void;
      /**
      * Returns the routing policy used by this <code>ARTreeLayouter</code> for
      * the given subtree root.
      * Should be one of
      * <ul>
      * <li>{@link yfiles.tree.ARTreeLayouter#ROUTING_HORIZONTAL}</li>
      * <li>{@link yfiles.tree.ARTreeLayouter#ROUTING_VERTICAL}</li>
      * </ul>
      * @param {Object} root the subtree root.
      * @return {Object} the routing policy used for the given subtree root.
      */
      getRoutingPolicy(root:Object):Object;
      /**
      * Returns the desired placement for the given subtree root.
      * Should be one of
      * <ul>
      * <li>{@link yfiles.tree.ARTreeLayouter#PLACEMENT_TOP}</li>
      * <li>{@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER}</li>
      * <li>{@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER_SIDE}</li>
      * <li>{@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER_TOP}</li>
      * </ul>
      * @param {Object} root the subtree root.
      * @return {Object} 
      * a symbolic constant representing the desired placement for the
      * given subtree root.
      */
      getRootPlacement(root:Object):Object;
      /**
      * The preferred aspect ratio for this <code>ARTreeLayouter</code>.
      */
      aspectRatio:number;
      /**
      * The desired placement of the tree's root node.
      * Should be one of
      * <ul>
      * <li>{@link yfiles.tree.ARTreeLayouter#PLACEMENT_TOP}</li>
      * <li>{@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER}</li>
      * <li>{@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER_SIDE}</li>
      * <li>{@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER_TOP}</li>
      * </ul>
      * By default, <code>PLACEMENT_CORNER</code> is used.
      */
      rootPlacement:Object;
      /**
      * The routing policy used by this <code>ARTreeLayouter</code>.
      * Should be one of
      * <ul>
      * <li>{@link yfiles.tree.ARTreeLayouter#ROUTING_HORIZONTAL}</li>
      * <li>{@link yfiles.tree.ARTreeLayouter#ROUTING_VERTICAL}</li>
      * </ul>
      */
      routingPolicy:Object;
      /**
      * The preferred distance between any two bends of an edge.
      * Additionally, the preferred bend distance governs the distance between the
      * first and last edges and the corresponding ports.
      */
      bendDistance:number;
    }
    var ARTreeLayouter:{
      $class:yfiles.lang.Class;
      /**
      * The data provider key used to specify a target aspect ratio for each subtree individually.
      * <p>
      * The aspect ratio needs to be greater than 0:
      * <ul>
      * <li>aspect ratio 1: width and height of the layout should be the same.</li>
      * <li>aspect ratio between 0 and 1: layouts are higher than wide.</li>
      * <li>aspect ratio larger than 1: layouts are wider than high.</li>
      * </ul>
      * </p>
      * <p>
      * If no specific ratio is defined for a subtree, the layouter uses the default
      * {@link yfiles.tree.ARTreeLayouter#aspectRatio  aspect ratio}.
      * </p>
      */
      RATIO_DP_KEY:Object;
      /**
      * The data provider key used to specify the placement of each subtree root individually.
      * If no root placement is specified for one of the subtree roots, the layouter uses the default
      * {@link yfiles.tree.ARTreeLayouter#rootPlacement  route placement}.
      * @see {@link yfiles.tree.ARTreeLayouter#PLACEMENT_TOP}
      * @see {@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER}
      * @see {@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER_SIDE}
      * @see {@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER_TOP}
      */
      ROOT_PLACEMENT_DP_KEY:Object;
      /**
      * A constant value to describe the placement of the root of a subtree.
      * When this placement is used, a subtree's root
      * is placed above its children in relation to the {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation}.
      * @see {@link yfiles.tree.ARTreeLayouter#ROOT_PLACEMENT_DP_KEY}
      */
      PLACEMENT_TOP:Object;
      /**
      * A constant value to describe the placement of the root of a subtree.
      * When this placement is used, a subtree's root
      * is placed in the upper left corner of the subtree bounds regarding the
      * {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation}.
      * <p>
      * If the root is placed entirely beside the subtree with no horizontal overlaps or entirely above the node
      * without vertical overlaps will be determined by the layout of the subtree. The layouter tries minimize the bounds
      * of the subtree.
      * </p>
      * @see {@link yfiles.tree.ARTreeLayouter#ROOT_PLACEMENT_DP_KEY}
      * @see {@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER_TOP}
      * @see {@link yfiles.tree.ARTreeLayouter#PLACEMENT_CORNER_SIDE}
      */
      PLACEMENT_CORNER:Object;
      /**
      * A constant value to describe the placement of the root of a subtree.
      * When this placement is used, a subtree's root
      * is placed in the upper left corner of the subtree bounds regarding the
      * {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation}.
      * <p>
      * The root is placed entirely beside the subtree with no horizontal overlaps. This might by important if
      * the root's height is very large while its width is small.
      * </p>
      * @see {@link yfiles.tree.ARTreeLayouter#ROOT_PLACEMENT_DP_KEY}
      */
      PLACEMENT_CORNER_SIDE:Object;
      /**
      * A constant value to describe the placement of the root of a subtree.
      * When this placement is used, a subtree's root
      * is placed in the upper left corner of the subtree bounds regarding the
      * {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation}.
      * <p>
      * The root is placed entirely above the subtree with no vertical overlaps. This might by important if the root's
      * width is very large while its height is small.
      * </p>
      * @see {@link yfiles.tree.ARTreeLayouter#ROOT_PLACEMENT_DP_KEY}
      */
      PLACEMENT_CORNER_TOP:Object;
      /**
      * The data provider key used to specify the routing policy of each subtree root individually.
      * The children in a subtree are arranged either horizontal or vertical. The edges are routed to the top of the child
      * nodes or at the side, respectively. Directions depend on the
      * {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation} and refer to {@link yfiles.layout.LayoutOrientation#TOP_TO_BOTTOM} in this
      * case.
      * <p>
      * If no specific routing policy is specified for a subtree root, the default
      * {@link yfiles.tree.ARTreeLayouter#routingPolicy  routing policy} is used.
      * </p>
      * @see {@link yfiles.tree.ARTreeLayouter#ROUTING_HORIZONTAL}
      * @see {@link yfiles.tree.ARTreeLayouter#ROUTING_VERTICAL}
      */
      ROUTING_POLICY_DP_KEY:Object;
      /**
      * A constant value to describe the routing for each subtree root.
      * When this routing is applied to a
      * subtree, the children will be placed next to each other in direction of the
      * {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation} with the edges connecting to in flow direction.
      * @see {@link yfiles.tree.ARTreeLayouter#ROUTING_POLICY_DP_KEY}
      */
      ROUTING_HORIZONTAL:Object;
      /**
      * A constant value to describe the routing for each subtree root.
      * When this routing is applied to a
      * subtree, the children will be placed above each other in direction of the
      * {@link yfiles.layout.CanonicMultiStageLayouter#layoutOrientation  layout orientation} with the edges connecting orthogonal to the flow
      * direction.
      * @see {@link yfiles.tree.ARTreeLayouter#ROUTING_POLICY_DP_KEY}
      */
      ROUTING_VERTICAL:Object;
      /**
      * Initializes a new instance of the ARTreeLayouter class.
      */
      new ():yfiles.tree.ARTreeLayouter;
    };
    /**
    * This is an abstract base class for NodePlacers that supports rotations.
    * "Supporting rotation" means that the NodePlacers only implement the default direction (e.g.
    * bottom-down).
    * The other directions are calculated using the modification matrix within the constructor.
    * But take care! Using rotatable NodePlacers contains some pitfalls. Especially calculations must be aware of
    * that. Especially operations on {@link yfiles.algorithms.BorderLine}s should not be called directly (e.g. mergeWithMin, mergeWithMax).
    * Use the corresponding methods on AbstractRotatableNodePlacer instead.
    */
    export interface AbstractRotatableNodePlacer extends Object,yfiles.tree.IFromSketchNodePlacer{
      /**
      * The graph instance this class is working on.
      */
      graphF:yfiles.layout.LayoutGraph;
      /**
      * The active modification matrix.
      */
      modificationMatrixF:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
      /**
      * The actual subtree shape provider.
      */
      subtreeShapeProviderF:yfiles.algorithms.IDataProvider;
      /**
      * The actual node shape provider.
      */
      nodeShapeProviderF:yfiles.algorithms.IDataProvider;
      /**
      * List containing the created children.
      */
      createdChildrenF:yfiles.algorithms.IList;
      /**
      * Creates an optional Processor for pre- and post-processing.
      * @param {yfiles.tree.GenericTreeLayouter} layouter 
      * @param {yfiles.layout.LayoutGraph} graph the actual graph
      * @param {yfiles.algorithms.Node} currentRoot the actual root node for this node placer
      * @return {yfiles.tree.IProcessor} a Processor or null
      * @see Specified by {@link yfiles.tree.INodePlacer#createProcessor}.
      */
      createProcessor(layouter:yfiles.tree.GenericTreeLayouter,graph:yfiles.layout.LayoutGraph,currentRoot:yfiles.algorithms.Node):yfiles.tree.IProcessor;
      /**
      * Translates the absolute source point of the given edge to the "view coordinates" (translated by
      * the modification matrix).
      * @param {yfiles.algorithms.Edge} edge the source point for is returned
      * @return {yfiles.algorithms.YPoint} the translated absolute source point for the given edge and the actual modification matrix
      */
      getSourcePointAbs(edge:yfiles.algorithms.Edge):yfiles.algorithms.YPoint;
      /**
      * This method must be implemented by subclasses.
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction of the connector shape
      * @return {yfiles.tree.SubtreeShapeRotated} a SubtreeShape instance that describes the shape of the whole subtree
      */
      placeSubtreeWithDirection(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.SubtreeShapeRotated;
      /**
      * Convenience method that queries the DataProvider for the shape of a single node as a SubtreeShape instance.
      * This
      * instance can be used to modify and return it in the main placeSubtree method. 
      * This method can only be called during the execution of {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtreeWithDirection}
      * @param {yfiles.algorithms.Node} node the node whose shape will be returned in the form of a SubtreeShape instance
      * @return {yfiles.tree.SubtreeShapeRotated} an instance that can be modified
      */
      createRootNodeShape(node:yfiles.algorithms.Node):yfiles.tree.SubtreeShapeRotated;
      /**
      * Convenience method that queries the DataProvider for a SubtreeShape.
      * This method can only be called during the execution of {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtreeWithDirection}
      * @param {yfiles.algorithms.Node} node the root node whose subtree shape will be returned in the form of a SubtreeShape instance
      * @return {yfiles.tree.SubtreeShapeRotated} an instance that can be modified
      */
      createSubtreeShape(node:yfiles.algorithms.Node):yfiles.tree.SubtreeShapeRotated;
      /**
      * This method initializes internal data structures, then uses the abstract method {@link yfiles.tree.AbstractRotatableNodePlacer#determineChildConnector}
      * to determine the child node connector directions.
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.algorithms.IDataMap} connectorMap the map that will be used to store the values
      * @see {@link yfiles.tree.AbstractRotatableNodePlacer#determineChildConnector}
      * @see Specified by {@link yfiles.tree.INodePlacer#determineChildConnectors}.
      */
      determineChildConnectors(localRoot:yfiles.algorithms.Node,connectorMap:yfiles.algorithms.IDataMap):void;
      /**
      * Lookup method to get the PortConstraint for the local root translated.
      * @param {yfiles.algorithms.Node} localRoot the local root
      * @return {yfiles.layout.PortConstraint} 
      * the PortConstraint for the local root. The PortConstraint is translated based on the
      * actual modification matrix.
      */
      getPortConstraint(localRoot:yfiles.algorithms.Node):yfiles.layout.PortConstraint;
      /**
      * Translates a modelDirectionModel into the "real" directionModel.
      * @param {yfiles.tree.ParentConnectorDirection} modelDirection the model direction
      * @return {number} the translated model direction
      */
      translateDirectionToReal(modelDirection:yfiles.tree.ParentConnectorDirection):number;
      /**
      * Translates a "real" direction into a directionModel direction.
      * @param {yfiles.tree.ParentConnectorDirection} realDirection the "real" direction
      * @return {number} the translated direction
      */
      translateDirectionToModel(realDirection:yfiles.tree.ParentConnectorDirection):number;
      /**
      * This method must be implemented by subclasses.
      * It is used to assigns a connector shape direction to each child.
      * @param {yfiles.algorithms.Node} child the child node
      * @return {yfiles.tree.ParentConnectorDirection} 
      * a byte constant as defined in the {@link yfiles.tree.INodePlacer} interface
      */
      determineChildConnector(child:yfiles.algorithms.Node):yfiles.tree.ParentConnectorDirection;
      /**
      * This method initializes the local data structures and then delegates the work to the abstract variant.
      * @see {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtreeWithDirection}
      * @see Specified by {@link yfiles.tree.INodePlacer#placeSubtree}.
      */
      placeSubtree(nodeShapeProvider:yfiles.algorithms.IDataProvider,subtreeShapeProvider:yfiles.algorithms.IDataProvider,graph:yfiles.layout.LayoutGraph,localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * The actual modification matrix.
      */
      modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
      createComparator():yfiles.objectcollections.IComparer;
      /**
      * The spacing between subtrees this <code>NodePlacer</code> is
      * arranging.
      */
      spacing:number;
      /**
      * Creates a comparator for edges.
      * This comparator is used to sort the outgoing edges of a node before the
      * placement of the node's subtree is calculated.
      * @return {yfiles.objectcollections.IComparer} a comparator for edges.
      * @see Specified by {@link yfiles.tree.IFromSketchNodePlacer#createFromSketchComparator}.
      */
      createFromSketchComparator():yfiles.objectcollections.IComparer;
    }
    export module AbstractRotatableNodePlacer{
      /**
      * This class represents the horizontal alignment of the root node.
      * There are several implementation that may be used:
      * <ul>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.RootAlignment#CENTER}: Placement in the center</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.RootAlignment#CENTER_OVER_CHILDREN}: Placement in the center of the direct children</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.RootAlignment#LEADING}: Placement on the left of the children.</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.RootAlignment#TRAILING}: Placement on the right of the children</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.RootAlignment#LEFT}: Left alignment of root and children</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.RootAlignment#RIGHT}: Right alignment of root and children</li>
      * </ul>
      */
      export interface RootAlignment extends Object{
        /**
        * This method moves the rootShape to the right position relative to the children's shapes.
        * The movement should
        * only be done on the X-axis (horizontally).
        * @param {yfiles.tree.SubtreeShapeRotated} rootShape the shape of the root node that is moved
        * @param {yfiles.algorithms.IList} shapes list of shapes of the children nodes
        * @param {yfiles.algorithms.Rectangle2D} shapeBounds accumulated shapes of all children's shapes
        * @param {number} spacing the spacing that should be used.
        */
        placeParentHorizontal(rootShape:yfiles.tree.SubtreeShapeRotated,shapes:yfiles.algorithms.IList,shapeBounds:yfiles.algorithms.Rectangle2D,spacing:number):void;
      }
      /**
      * Instances of this class may be used to configure the {@link yfiles.tree.AbstractRotatableNodePlacer}.
      * The possible transformations are:
      * <ul>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.Matrix#DEFAULT}</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.Matrix#ROT90}</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.Matrix#ROT180}</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.Matrix#ROT270}</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.Matrix#MIR_HOR}</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.Matrix#MIR_VERT}</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.Matrix#MIR_HOR_ROT90}</li>
      * <li>{@link yfiles.tree.AbstractRotatableNodePlacer.Matrix#MIR_VERT_ROT90}</li>
      * </ul>
      */
      export interface Matrix extends Object{
        /**
        * Multiplies this matrix with another matrix.
        * @param {yfiles.tree.AbstractRotatableNodePlacer.Matrix} other the other matrix
        * @return {yfiles.tree.AbstractRotatableNodePlacer.Matrix} the product of this and the other matrix
        */
        multiply(other:yfiles.tree.AbstractRotatableNodePlacer.Matrix):yfiles.tree.AbstractRotatableNodePlacer.Matrix;
        /**
        * Returns a String representation of this matrix.
        * @return {string} a String representing this matrix
        */
        toString():string;
        /**
        * Compares the values of the actual matrix with the values of the given matrix.
        * @param {yfiles.tree.AbstractRotatableNodePlacer.Matrix} result the given matrix
        * @return {boolean} true if all values are the same, false otherwise
        */
        equalValues(result:yfiles.tree.AbstractRotatableNodePlacer.Matrix):boolean;
      }
    }
    var AbstractRotatableNodePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Default constructor.
      * Instantiates a new instance with the
      * given modification matrix.
      * @param {yfiles.tree.AbstractRotatableNodePlacer.Matrix} modificationMatrix the translation for the NodePlacer
      */
      new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix):yfiles.tree.AbstractRotatableNodePlacer;
      /**
      * Translates a "real world point" to a "model point".
      * @param {yfiles.tree.AbstractRotatableNodePlacer.Matrix} modificationMatrix the matrix to apply
      * @param {yfiles.algorithms.YPoint} realWorldPoint the point with the coordinates from the real world
      * @return {yfiles.algorithms.YPoint} the model point
      */
      translatePoint(modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix,realWorldPoint:yfiles.algorithms.YPoint):yfiles.algorithms.YPoint;
      RootAlignment:{
        $class:yfiles.lang.Class;
        /**
        * Horizontal alignment at the center.
        * The root node is horizontally placed at the center of its whole subgraph.
        * To determine the alignment, only node layouts are considered instead of including node labels which
        * are also contained in subtree shapes.
        */
        CENTER:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
        /**
        * Horizontal alignment at the median.
        * The root node is placed above the median of its children.
        * To determine the alignment, only node layouts are considered instead of including node labels which
        * are also contained in subtree shapes.
        */
        MEDIAN:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
        /**
        * Horizontal alignment at the left side of the children.
        * The root node leaves a distance specified by the current
        * spacing to the leftmost child.
        * To determine the alignment, only node layouts are considered instead of including node labels which
        * are also contained in subtree shapes.
        */
        LEADING:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
        /**
        * Horizontal alignment at the right side of the children.
        * The root node leaves a distance specified by the current
        * spacing to the rightmost child.
        * To determine the alignment, only node layouts are considered instead of including node labels which
        * are also contained in subtree shapes.
        */
        TRAILING:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
        /**
        * Horizontal alignment at the left.
        * The root node is placed left aligned with its leftmost child.
        * To determine the alignment, only node layouts are considered instead of including node labels which
        * are also contained in subtree shapes.
        */
        LEFT:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
        /**
        * Horizontal alignment at the right.
        * The root node is placed right aligned with its rightmost child.
        * To determine the alignment, only node layouts are considered instead of including node labels which
        * are also contained in subtree shapes.
        */
        RIGHT:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
        /**
        * Horizontal alignment at the center.
        * The root node is placed centered over its direct children.
        * To determine the alignment, only node layouts are considered instead of including node labels which
        * are also contained in subtree shapes.
        */
        CENTER_OVER_CHILDREN:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
        ALL:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment[];
        /**
        * Calculates the bounds of a list of shapes.
        * @param {yfiles.algorithms.IList} shapes the list of shapes the bounds shall be calculated of.
        * @return {yfiles.algorithms.Rectangle2D} the bounds around all shapes in the list.
        */
        getBounds(shapes:yfiles.algorithms.IList):yfiles.algorithms.Rectangle2D;
      };
      Matrix:{
        $class:yfiles.lang.Class;
        /**
        * no transformation.
        */
        DEFAULT:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
        /**
        * rotation by 90 degrees counter-clockwise.
        */
        ROT90:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
        /**
        * rotation by 180 degrees.
        */
        ROT180:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
        /**
        * rotation by 270 degrees counter-clockwise.
        */
        ROT270:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
        /**
        * mirror horizontally.
        */
        MIR_HOR:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
        /**
        * mirror vertically.
        */
        MIR_VERT:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
        /**
        * mirror horizontally and rotate by 90 degrees counter-clockwise.
        */
        MIR_HOR_ROT90:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
        /**
        * mirror vertically and rotate by 90 degrees counter-clockwise.
        */
        MIR_VERT_ROT90:yfiles.tree.AbstractRotatableNodePlacer.Matrix;
        AVAILABLE:yfiles.algorithms.IList;
      };
    };
    /**
    * This class is used by {@link yfiles.tree.GenericTreeLayouter} and implements a
    * sophisticated {@link yfiles.tree.INodePlacer}.
    * Subtrees are placed so that the overall
    * subtree layout's aspect ratio will be close to a given aspect ratio.
    */
    export interface ARNodePlacer extends yfiles.tree.AbstractNodePlacer,yfiles.tree.IFromSketchNodePlacer{
      /**
      * This method must be implemented by subclasses.
      * It assigns a connector shape
      * direction to each child.
      * @param {yfiles.algorithms.Node} child the child node
      * @return {number} 
      * a byte constant as defined in the {@link yfiles.tree.INodePlacer} interface
      */
      determineChildConnector(child:yfiles.algorithms.Node):number;
      /**
      * The main placeSubtree method that must be implemented by subclasses.
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction of the connector shape
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} a SubtreeShape instance that describes the shape of the whole subtree
      */
      placeSubtreeImpl(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * Specifies whether this instance is configured to create horizontal
      * rows of child nodes.
      */
      horizontal:boolean;
      /**
      * The vertical distance this NodePlacer should use for the
      * arrangement of the elements.
      */
      verticalDistance:number;
      /**
      * The horizontal distance this NodePlacer should use for the
      * arrangement of the elements.
      */
      horizontalDistance:number;
      /**
      * The preferred aspect ratio.
      */
      aspectRatio:number;
      /**
      * The fill style.
      * The byte constant defines how nodes should
      * be distributed within their lanes.
      */
      fillStyle:yfiles.tree.FillStyle;
      /**
      * Creates a comparator for edges.
      * This comparator is used to sort the outgoing edges of a node before the
      * placement of the node's subtree is calculated.
      * @return {yfiles.objectcollections.IComparer} a comparator for edges.
      * @see Specified by {@link yfiles.tree.IFromSketchNodePlacer#createFromSketchComparator}.
      */
      createFromSketchComparator():yfiles.objectcollections.IComparer;
    }
    var ARNodePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Creates a new instance of ARNodePlacer with default orientation (vertical),
      * aspect ratio (1.0d), fill style ({@link yfiles.tree.FillStyle#LEADING}),
      * and default distances (<code>40.0d</code>).
      */
      new ():yfiles.tree.ARNodePlacer;
      /**
      * Creates a new instance of ARNodePlacer with given orientation
      * and distances.
      * @param {boolean} horizontal <code>true</code> for horizontal row mode
      * @param {number} horizontalDistance horizontal distance between adjacent elements
      * @param {number} verticalDistance vertical distance between adjacent elements
      * @param {number} aspectRatio the aspectRatio, this instance should try to obey
      * @param {yfiles.tree.FillStyle} fillStyle a fill style constant describing the node distribution
      */
      WithOrientationAndAspectRatio:{
        new (horizontal:boolean,aspectRatio:number,fillStyle:yfiles.tree.FillStyle,horizontalDistance:number,verticalDistance:number):yfiles.tree.ARNodePlacer;
      };
    };
    /**
    * A processor is the possibility for each NodePlacer to prepare (and clean up) the graph for its children.
    * It is created within {@link yfiles.tree.INodePlacer#createProcessor} and called by the
    * GenericTreeLayouter at specific positions of the life-cycle.
    * The processor may change the values within the DataMaps for its children.
    */
    export interface IProcessor extends Object{
      /**
      * This method is called before the NodePlacers are called recursively.
      * A NodePlacer may change different
      * settings within this method. This can be used to specify values for its children, manipulate the graph structure
      * or do anything else that needs to be done.
      * But only changes for the descendants of current root are allowed.
      * @param {yfiles.algorithms.IDataMap} nodePlacerDataProvider 
      * @param {yfiles.algorithms.IDataMap} portAssignmentDataProvider 
      * @param {yfiles.algorithms.IDataMap} childComparatorProvider 
      * @see Specified by {@link yfiles.tree.IProcessor#preProcess}.
      */
      preProcess(nodePlacerDataProvider:yfiles.algorithms.IDataMap,portAssignmentDataProvider:yfiles.algorithms.IDataMap,childComparatorProvider:yfiles.algorithms.IDataMap):void;
      /**
      * This method is called from the GenericTreeLayouter after the layout has finished.
      * It can be used for
      * cleanup tasks.
      * E.g. changes on the graph structure that have been made in {@link yfiles.tree.IProcessor#preProcess}
      * can be undone here.
      * @see Specified by {@link yfiles.tree.IProcessor#postProcess}.
      */
      postProcess():void;
    }
    var IProcessor:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This NodePlacer calculates and respects layers.
    * <p>
    * <b>Warning:</b> Changing the orientation within the LayeredNodePlacers will
    * result in dubious problems.
    * </p>
    */
    export interface LayeredNodePlacer extends yfiles.tree.AbstractRotatableNodePlacer{
      dendrogramStyle:boolean;
      /**
      * This method must be implemented by subclasses.
      * It is used to assigns a connector shape direction to each child.
      * @param {yfiles.algorithms.Node} child the child node
      * @return {yfiles.tree.ParentConnectorDirection} 
      * a byte constant as defined in the {@link yfiles.tree.INodePlacer} interface
      */
      determineChildConnector(child:yfiles.algorithms.Node):yfiles.tree.ParentConnectorDirection;
      /**
      * This method must be implemented by subclasses.
      * @param {yfiles.algorithms.Node} localRoot the local root node
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection the direction of the connector shape
      * @return {yfiles.tree.SubtreeShapeRotated} a SubtreeShape instance that describes the shape of the whole subtree
      */
      placeSubtreeWithDirection(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.SubtreeShapeRotated;
      /**
      * Creates an processor that distributes the LayerRoot.
      * @param {yfiles.layout.LayoutGraph} graph the actual graph
      * @param {yfiles.algorithms.Node} currentRoot the actual root node for this node placer
      * @return {yfiles.tree.IProcessor} a Processor or null
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#createProcessor}
      * @see Specified by {@link yfiles.tree.INodePlacer#createProcessor}.
      */
      createProcessor(layouter:yfiles.tree.GenericTreeLayouter,graph:yfiles.layout.LayoutGraph,currentRoot:yfiles.algorithms.Node):yfiles.tree.IProcessor;
      /**
      * The alignment strategy for the tree's root node.
      */
      rootAlignment:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
      /**
      * The relative vertical alignment of nodes within their respective
      * layers.
      * A value of <code>0</code> means nodes are top aligned;
      * a value of <code>1</code> means nodes are bottom aligned.
      * <p>
      * Defaults to <code>0.5</code>, i.e. nodes are center aligned.
      * </p>
      */
      verticalAlignment:number;
      /**
      * The ID.
      * The ID is used to identify LayeredNodePlacers that share information about their height. Using
      * different IDs offers aligned layouts within different subtrees.
      */
      id:Object;
      /**
      * The spacing between two layers.
      */
      layerSpacing:number;
      /**
      * The routing style.
      * The possible values are: <ul> <li>{@link yfiles.tree.LayeredRoutingStyle#ORTHOGONAL}</li> <li>{@link yfiles.tree.LayeredRoutingStyle#PLAIN}</li> </ul>
      */
      routingStyle:yfiles.tree.LayeredRoutingStyle;
      /**
      * The vertical bus alignment for orthogonally routed edge buses.
      * The bus alignment determines the relative position of an edge bus in
      * between two subsequent layers of nodes.
      * A value of <code>0</code> places the bus at the top right below the parent node;
      * a value of <code>0.5</code> places the bus in the middle between parent and child nodes; and
      * a value of <code>1</code> places the bus at the bottom right above the child nodes.
      * <p>
      * Defaults to <code>0.3</code>.
      * </p>
      */
      busAlignment:number;
      /**
      * Specifies whether polyline labeling is used.
      * <p> If set to <code>true</code>, the poly line connectors between the
      * parent and its children are added to the shape. Labels (of nodes and edges) will not cut them. </p>
      */
      polylineLabelingEnabled:boolean;
    }
    var LayeredNodePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Default constructor.
      * Instantiates a new instance with the given modification matrix.
      * @param {yfiles.tree.AbstractRotatableNodePlacer.Matrix} modificationMatrix the translation for the NodePlacer
      */
      WithMatrixAndId:{
        new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix,id:Object):yfiles.tree.LayeredNodePlacer;
      };
      new ():yfiles.tree.LayeredNodePlacer;
    };
    /**
    * This implementation can be used to "place" leafs.
    * It only routes the first incoming edge.
    */
    export interface LeafPlacer extends Object,yfiles.tree.INodePlacer{
      /**
      * Creates an optional Processor for pre- and post-processing.
      * @param {yfiles.tree.GenericTreeLayouter} layouter 
      * @param {yfiles.layout.LayoutGraph} graph the actual graph
      * @param {yfiles.algorithms.Node} currentRoot the actual root node for this node placer
      * @return {yfiles.tree.IProcessor} a Processor or null
      * @see Specified by {@link yfiles.tree.INodePlacer#createProcessor}.
      */
      createProcessor(layouter:yfiles.tree.GenericTreeLayouter,graph:yfiles.layout.LayoutGraph,currentRoot:yfiles.algorithms.Node):yfiles.tree.IProcessor;
      /**
      * This method is called by GenericTreeLayouter before the subtree shapes of
      * this local root node's children are calculated.
      * This method must provide for each child node a byte constant indicating
      * the preferred direction of the connector to the subtree shape.
      * @param {yfiles.algorithms.Node} localRoot 
      * the local root node whose child nodes will be provided with
      * a byte constant indicating the direction of the connector
      * @param {yfiles.algorithms.IDataMap} connectorMap 
      * the map that should be used for storing the byte constant
      * with the child nodes.
      * @see Specified by {@link yfiles.tree.INodePlacer#determineChildConnectors}.
      */
      determineChildConnectors(localRoot:yfiles.algorithms.Node,connectorMap:yfiles.algorithms.IDataMap):void;
      /**
      * The main method of the tree layout algorithm.
      * This method arranges the
      * SubtreeShapes and the shape of the local root, routes the edges to the
      * SubtreeShapes, calculates the resulting SubtreeShape and returns it.
      * @param {yfiles.algorithms.IDataProvider} nodeShapeProvider 
      * this instance can be used to obtain an initial shape
      * of the root node. This shape can then be merged with all the subtrees' shapes
      * and finally be returned by this method.
      * @param {yfiles.algorithms.IDataProvider} subtreeShapeProvider 
      * provides access to the pre-calculated shapes of
      * the subtrees. It is guaranteed that at the time of the invocation of this
      * method for every child node the subtree shape has already been calculated
      * @param {yfiles.layout.LayoutGraph} graph the graph which is to be laid out
      * @param {yfiles.algorithms.Node} localRoot the root of the subtree that should be laid out by this method
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection 
      * the direction byte constant as it is defined
      * in this interface, that must be used for initializing the connector of the
      * localRoot node to the parent node of the localRoot node
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} the shape of the whole subtree
      * @see Specified by {@link yfiles.tree.INodePlacer#placeSubtree}.
      */
      placeSubtree(nodeShapeProvider:yfiles.algorithms.IDataProvider,subtreeShapeProvider:yfiles.algorithms.IDataProvider,graph:yfiles.layout.LayoutGraph,localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
    }
    var LeafPlacer:{
      $class:yfiles.lang.Class;
    };
    /**
    * This interface is used by {@link yfiles.tree.GenericTreeLayouter}.
    * Classes implementing
    * this interface are responsible for the assignment of the edges' ports.
    * {@link yfiles.tree.INodePlacer} instances will have to obey the currently set ports.
    */
    export interface IPortAssignment extends Object{
      /**
      * Called by {@link yfiles.tree.GenericTreeLayouter} before the actual layout
      * of the graph takes place.
      * This method assigns both the single
      * incoming edge's target port as well as all source ports for all
      * outgoing child edges. Note that at the time this method gets invoked,
      * GenericTreeLayouter may have reversed some edges in order to normalize the
      * tree structure.
      * @param {yfiles.layout.LayoutGraph} graph the graph instance the node is part of
      * @param {yfiles.algorithms.Node} node the node whose adjacent edges' ports should be set
      * @see Specified by {@link yfiles.tree.IPortAssignment#assignPorts}.
      */
      assignPorts(graph:yfiles.layout.LayoutGraph,node:yfiles.algorithms.Node):void;
    }
    var IPortAssignment:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This tree layouter allows to layout a tree such that
    * each subgraph rooted at a node can either have a horizontal or
    * vertical layout.
    * Here is an sample output of the layouter
    * <center><img src="doc-files/y.layout.tree.HVTreeLayouter.gif" border="1"/></center>
    */
    export interface HVTreeLayouter extends yfiles.layout.CanonicMultiStageLayouter{
      /**
      * The layout graph being acted upon.
      */
      graph:yfiles.layout.LayoutGraph;
      /**
      * The horizontal distance between adjacent nodes.
      * By default a value of <code>10</code> is set.
      */
      horizontalSpace:number;
      /**
      * The vertical distance between adjacent nodes.
      * By default a value of <code>10</code> is set.
      */
      verticalSpace:number;
      /**
      * Core layout routine.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#doLayoutCore}
      */
      doLayoutCore(graph:yfiles.layout.LayoutGraph):void;
      /**
      * The core layouter can layout trees.
      * @see Overrides {@link yfiles.layout.CanonicMultiStageLayouter#canLayoutCore}
      */
      canLayoutCore(graph:yfiles.layout.LayoutGraph):boolean;
      /**
      * Returns whether or not the subtree rooted at the given node should
      * be laid out vertically.
      */
      isVerticalRoot(v:yfiles.algorithms.Node):boolean;
      /**
      * Returns whether or not the subtree rooted at the given node should
      * be laid out horizontally.
      */
      isHorizontalRoot(v:yfiles.algorithms.Node):boolean;
      getSuccessors(localParent:yfiles.algorithms.Node):yfiles.algorithms.INodeCursor;
      /**
      * The{@link yfiles.objectcollections.IComparer} that will be used
      * to sort the {@link yfiles.algorithms.Node#sortOutEdges  outgoing edges}
      * of each local root in the tree before they are being arranged.
      * The default value is <code>null</code> which indicates that the algorithm should
      * use its built-in logic.
      */
      comparator:yfiles.objectcollections.IComparer;
    }
    var HVTreeLayouter:{
      $class:yfiles.lang.Class;
      /**
      * The data provider key used to specify the subtree orientation
      * of each node in the tree.
      * This layout algorithm will try to retrieve a
      * data provider from the tree to be laid out with this key.
      * The looked up data provider should provide either
      * {@link yfiles.tree.HVTreeLayouter#HORIZONTAL_SUBTREE}, {@link yfiles.tree.HVTreeLayouter#VERTICAL_SUBTREE}
      */
      SUBTREE_ORIENTATION_DP_KEY:Object;
      /**
      * Subtree orientation specifier.
      * This specifier indicated
      * that the subtree rooted at the associated node should be laid
      * out horizontally.
      */
      HORIZONTAL_SUBTREE:Object;
      /**
      * Subtree orientation specifier.
      * This specifier indicated
      * that the subtree rooted at the associated node should be laid
      * out vertically.
      */
      VERTICAL_SUBTREE:Object;
      new ():yfiles.tree.HVTreeLayouter;
    };
    /**
    * A FromSketchNodePlacer is responsible for arranging its nodes using a comparator, which sorts
    * the outgoing edges of a node according to the position of their target nodes in the graph before the actual placement
    * happens.
    * @see {@link yfiles.tree.INodePlacer}
    */
    export interface IFromSketchNodePlacer extends Object,yfiles.tree.INodePlacer{
      /**
      * Creates a comparator for edges.
      * This comparator is used to sort the outgoing edges of a node before the
      * placement of the node's subtree is calculated.
      * @return {yfiles.objectcollections.IComparer} a comparator for edges.
      * @see Specified by {@link yfiles.tree.IFromSketchNodePlacer#createFromSketchComparator}.
      */
      createFromSketchComparator():yfiles.objectcollections.IComparer;
    }
    var IFromSketchNodePlacer:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * This interface is used by {@link yfiles.tree.GenericTreeLayouter}.
    * Classes implementing this
    * interface are responsible for the arrangement of a root node and all of its subtrees.
    * Subtrees are represented as shapes with a connecting edge to the root of the subtree.
    * Instances have to:
    * <ul>
    * <li>arrange the subtree shapes and the root node
    * (only the relative position matters, shapes can be placed at any absolute location,
    * GenericTreeLayouter will perform the final alignment).
    * </li>
    * <li>perform the edge routing from the root node to all child nodes with respect
    * to the connector provided by the subtree shapes</li>
    * <li>
    * calculate the union of the subtree shapes and the shape of the root node as well as
    * any edges added in this run
    * </li>
    * <li>
    * initialize the connector of the root node with respect to the preferred connection
    * direction
    * </li>
    * <li>
    * return the subtree shape
    * </li>
    * </ul>
    * Instances may modify the subtree shape instances of the subtrees of the current
    * root node and use the subtree shape obtained by the DataProvider as the return value.
    */
    export interface INodePlacer extends Object{
      /**
      * This method is called by GenericTreeLayouter before the subtree shapes of
      * this local root node's children are calculated.
      * This method must provide for each child node a byte constant indicating
      * the preferred direction of the connector to the subtree shape.
      * @param {yfiles.algorithms.Node} localRoot 
      * the local root node whose child nodes will be provided with
      * a byte constant indicating the direction of the connector
      * @param {yfiles.algorithms.IDataMap} connectorMap 
      * the map that should be used for storing the byte constant
      * with the child nodes.
      * @see Specified by {@link yfiles.tree.INodePlacer#determineChildConnectors}.
      */
      determineChildConnectors(localRoot:yfiles.algorithms.Node,connectorMap:yfiles.algorithms.IDataMap):void;
      /**
      * The main method of the tree layout algorithm.
      * This method arranges the
      * SubtreeShapes and the shape of the local root, routes the edges to the
      * SubtreeShapes, calculates the resulting SubtreeShape and returns it.
      * @param {yfiles.algorithms.IDataProvider} nodeShapeProvider 
      * this instance can be used to obtain an initial shape
      * of the root node. This shape can then be merged with all the subtrees' shapes
      * and finally be returned by this method.
      * @param {yfiles.algorithms.IDataProvider} subtreeShapeProvider 
      * provides access to the pre-calculated shapes of
      * the subtrees. It is guaranteed that at the time of the invocation of this
      * method for every child node the subtree shape has already been calculated
      * @param {yfiles.layout.LayoutGraph} graph the graph which is to be laid out
      * @param {yfiles.algorithms.Node} localRoot the root of the subtree that should be laid out by this method
      * @param {yfiles.tree.ParentConnectorDirection} parentConnectorDirection 
      * the direction byte constant as it is defined
      * in this interface, that must be used for initializing the connector of the
      * localRoot node to the parent node of the localRoot node
      * @return {yfiles.tree.GenericTreeLayouter.SubtreeShape} the shape of the whole subtree
      * @see Specified by {@link yfiles.tree.INodePlacer#placeSubtree}.
      */
      placeSubtree(nodeShapeProvider:yfiles.algorithms.IDataProvider,subtreeShapeProvider:yfiles.algorithms.IDataProvider,graph:yfiles.layout.LayoutGraph,localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.GenericTreeLayouter.SubtreeShape;
      /**
      * Creates an optional Processor for pre- and post-processing.
      * @param {yfiles.tree.GenericTreeLayouter} layouter 
      * @param {yfiles.layout.LayoutGraph} graph the actual graph
      * @param {yfiles.algorithms.Node} currentRoot the actual root node for this node placer
      * @return {yfiles.tree.IProcessor} a Processor or null
      * @see Specified by {@link yfiles.tree.INodePlacer#createProcessor}.
      */
      createProcessor(layouter:yfiles.tree.GenericTreeLayouter,graph:yfiles.layout.LayoutGraph,currentRoot:yfiles.algorithms.Node):yfiles.tree.IProcessor;
    }
    var INodePlacer:{
      $class:yfiles.lang.Class;
      isInstance(o:Object):boolean;
    };
    /**
    * The LeftRightPlacer is a NodePlacer that arranges the Nodes on the left and
    * right side of a vertical bus.
    */
    export interface LeftRightPlacer extends yfiles.tree.AbstractRotatableNodePlacer{
      /**
      * The horizontal distance/spacing between subtree shapes.
      * <p>
      * By default, a value of <code>20</code> is used.
      * </p>
      * @see {@link yfiles.tree.LeftRightPlacer#verticalDistance}
      * @see {@link yfiles.tree.LeftRightPlacer#verticalDistance}
      * @see {@link yfiles.tree.LeftRightPlacer#verticalDistance}
      * @see {@link yfiles.tree.LeftRightPlacer#verticalDistance}
      */
      horizontalDistance:number;
      /**
      * The vertical distance/spacing between subtree shapes.
      * <p>
      * By default, a value of <code>20</code> is used.
      * </p>
      * @see {@link yfiles.tree.LeftRightPlacer#horizontalDistance}
      * @see {@link yfiles.tree.LeftRightPlacer#horizontalDistance}
      * @see {@link yfiles.tree.LeftRightPlacer#horizontalDistance}
      * @see {@link yfiles.tree.LeftRightPlacer#horizontalDistance}
      */
      verticalDistance:number;
      /**
      * Specifies the spacing between subtrees this <code>NodePlacer</code> is
      * arranging.
      * Calls
      * <blockquote>
      * <c>setHorizontalDistance(spacing);</c><br/>
      * <c>setVerticalDistance(spacing);</c>
      * </blockquote>
      * @see {@link yfiles.tree.LeftRightPlacer#horizontalDistance}
      * @see {@link yfiles.tree.LeftRightPlacer#verticalDistance}
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#spacing}
      */
      spacing:number;
      /**
      * Determines the direction the children should place their connectors.
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#determineChildConnectors}
      * @see Specified by {@link yfiles.tree.INodePlacer#determineChildConnectors}.
      */
      determineChildConnectors(localRoot:yfiles.algorithms.Node,connectorMap:yfiles.algorithms.IDataMap):void;
      /**
      * Throws IllegalStateException, should not be reached.
      * @throws {yfiles.system.InvalidOperationException} always.
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#determineChildConnector}
      */
      determineChildConnector(child:yfiles.algorithms.Node):yfiles.tree.ParentConnectorDirection;
      /**
      * Places the shapes of the children on the left and right side of a vertical bus.
      * @return {yfiles.tree.SubtreeShapeRotated} the new subtree shape
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtreeWithDirection}
      */
      placeSubtreeWithDirection(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.SubtreeShapeRotated;
      /**
      * Specifies whether or not the last child is placed at the bottom of the other.
      * <p>
      * By default, this feature is enabled.
      * </p>
      */
      placeLastOnBottom:boolean;
      /**
      * Returns a comparator for edges.
      * The comparator applies the modification matrix of the {@link yfiles.tree.LeftRightPlacer}
      * and returns
      * <ul>
      * <li>1 if the target node of the first edge is above the target node of the second edge.</li>
      * <li>0 if the edges to compare point to nodes which lie in the same horizontal plane.</li>
      * <li>-1 if the target node of the first edge is below the target node of the second edge.</li>
      * </ul>
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#createComparator}
      */
      createComparator():yfiles.objectcollections.IComparer;
    }
    export module LeftRightPlacer{
      /**
      * Utility class providing a method to determine if a given node
      * is aligned left (true) or right (false) to the parent node.
      */
      export interface LeftRightDataProvider extends yfiles.algorithms.DataProviderAdapter{
        /**
        * Determines if the given node is "left" of its parent node.
        * Left is considered as
        * a lower x coordinate when the alignment of the nodes is vertical (north or south) and
        * a lower y coordinate when the alignment of the nodes is horizontal (east or west).
        * @param {Object} dataHolder a node to check the placement to its parent node.
        * @return {boolean} <code>true</code> if the given node is left of its parent node.
        * @see Overrides {@link yfiles.algorithms.DataProviderAdapter#getBool}
        * @see Specified by {@link yfiles.algorithms.IDataProvider#getBool}.
        */
        getBool(dataHolder:Object):boolean;
      }
    }
    var LeftRightPlacer:{
      $class:yfiles.lang.Class;
      /**
      * Key which can be used to register a data provider that tells the node
      * placer whether the node shall be placed on the left or right side.
      * If no provider is specified, the nodes will be placed alternating from
      * left to right.
      * The provider should return true if the node shall be placed on the left
      * side.
      */
      LEFT_RIGHT_DP_KEY:Object;
      /**
      * Creates a LeftRightPlacer with the default modificationMatrix.
      */
      new ():yfiles.tree.LeftRightPlacer;
      /**
      * Creates a LeftRightPlacer with the given modificationMatrix.
      */
      WithMatrix:{
        new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix):yfiles.tree.LeftRightPlacer;
      };
      LeftRightDataProvider:{
        $class:yfiles.lang.Class;
        /**
        * Constructs a new data provider for the LeftRightPlacer.
        * The nodePlacerMap is a reference to the map where the node placer for each node in the graph is stored.
        * The node placer of a node holds its modification matrix which can be used to determine
        * the alignment of the node to its parent (if its "left").
        */
        new (nodePlacerMap:yfiles.algorithms.IDataProvider):yfiles.tree.LeftRightPlacer;
      };
    };
    /**
    * This is a "default" NodePlacer.
    * It arranges its children simply in one row.
    */
    export interface SimpleNodePlacer extends yfiles.tree.AbstractRotatableNodePlacer{
      /**
      * The horizontal alignment of the root node.
      */
      rootAlignment:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment;
      /**
      * The relative vertical alignment of nodes with the same parent.
      * A value of <code>0</code> means nodes are top aligned;
      * a value of <code>1</code> means nodes are bottom aligned;
      * a value of <code>0.5</code> means nodes are center aligned.
      * Values outside the interval <code>[0,1]</code> will result in a compact node placement with unaligned nodes.
      * <p>
      * By default the compact placement with unaligned nodes is used.
      * </p>
      */
      verticalAlignment:number;
      /**
      * Returns  {@link yfiles.tree.ParentConnectorDirection#NORTH}.
      * @return {yfiles.tree.ParentConnectorDirection} 
      * {@link yfiles.tree.ParentConnectorDirection#NORTH}.
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#determineChildConnector}
      */
      determineChildConnector(child:yfiles.algorithms.Node):yfiles.tree.ParentConnectorDirection;
      /**
      * Specifies whether a bus should be created between the parent and its children.
      */
      createBus:boolean;
      /**
      * Places the children in a single row.
      * @see Overrides {@link yfiles.tree.AbstractRotatableNodePlacer#placeSubtreeWithDirection}
      */
      placeSubtreeWithDirection(localRoot:yfiles.algorithms.Node,parentConnectorDirection:yfiles.tree.ParentConnectorDirection):yfiles.tree.SubtreeShapeRotated;
    }
    var SimpleNodePlacer:{
      $class:yfiles.lang.Class;
      /**
      * Default constructor that creates an instance with the modification matrix {@link yfiles.tree.AbstractRotatableNodePlacer.Matrix#DEFAULT}.
      */
      new ():yfiles.tree.SimpleNodePlacer;
      /**
      * Constructor that creates an instance with the given modification matrix.
      */
      WithMatrix:{
        new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix):yfiles.tree.SimpleNodePlacer;
      };
      /**
      * Constructor that creates an instance with the given modification matrix and the horizontal root alignment.
      */
      WithMatrixAndRootAlignment:{
        new (modificationMatrix:yfiles.tree.AbstractRotatableNodePlacer.Matrix,rootAlignment:yfiles.tree.AbstractRotatableNodePlacer.RootAlignment):yfiles.tree.SimpleNodePlacer;
      };
    };
    /**
    * Decorates a SubtreeShape and provides rotated access on it.
    */
    export interface SubtreeShapeRotated extends Object{
    }
    var SubtreeShapeRotated:{
      $class:yfiles.lang.Class;
      /**
      * For testing purposes only.
      */
      new ():yfiles.tree.SubtreeShapeRotated;
    };
    /**
    * This comparator compares edges by examining the {@link yfiles.lang.IObjectComparable}
    * that is obtained by passing the {@link yfiles.algorithms.Edge#target  target nodes} to
    * the {@link yfiles.algorithms.IDataProvider#get  get method}
    * of the {@link yfiles.algorithms.IDataProvider} bound to the graph via the
    * {@link yfiles.tree.NodeOrderComparator#NODE_ORDER_DP_KEY} key.
    * @see {@link yfiles.tree.TreeLayouter#comparator}
    * @see {@link yfiles.tree.GenericTreeLayouter#defaultChildComparator}
    * @see {@link yfiles.tree.GenericTreeLayouter#CHILD_COMPARATOR_DP_KEY}
    * @see {@link yfiles.tree.BalloonLayouter#comparator}
    * @see {@link yfiles.tree.ARTreeLayouter#comparator}
    * @see {@link yfiles.tree.HVTreeLayouter#comparator}
    * @see {@link yfiles.tree.NodeOrderComparator#NODE_ORDER_DP_KEY}
    */
    export interface NodeOrderComparator extends Object,yfiles.objectcollections.IComparer,yfiles.algorithms.Comparators.IPartialOrder{
      /**
      * Object is actually expected to be {@link yfiles.algorithms.Edge}.
      * Compares values returned by {@link yfiles.algorithms.IDataProvider#get} for
      * the {@link yfiles.algorithms.Edge#target  target nodes} of the edges.
      * <code>null</code> values or instances that do not implement the {@link yfiles.lang.IObjectComparable}
      * interface will be treated as (equal) smaller values.
      * @see Specified by {@link yfiles.objectcollections.IComparer#compare}.
      */
      compare(a:Object,b:Object):number;
    }
    var NodeOrderComparator:{
      $class:yfiles.lang.Class;
      /**
      * A data provider key that can be used to register a
      * {@link yfiles.algorithms.IDataProvider} for each {@link yfiles.algorithms.Node} in the graph that yields a {@link yfiles.lang.IObjectComparable} object
      * via the {@link yfiles.algorithms.IDataProvider#get} method.
      * The values can be used by the various tree layouter implementations to sort the children
      * of each node in the tree and use the order to influence the layout.
      * To achieve this use this comparator and assign it to the layouter implementations
      * comparator property.
      */
      NODE_ORDER_DP_KEY:Object;
    };
    /**
    * This class is used by {@link yfiles.tree.GenericTreeLayouter} to determine the desired
    * layout of nodes that constitute a multi-parent structure.
    * All nodes of such a structure are placed side by side and the incident
    * edges are routed over common points for incoming edges and for outgoing edges.
    * @see {@link yfiles.tree.GenericTreeLayouter#MULTI_PARENT_DESCRIPTOR_DP_KEY}
    */
    export interface MultiParentDescriptor extends Object{
      /**
      * The minimum distance between two nodes belonging to the same multi-parent structure.
      */
      minimumNodeDistance:number;
      /**
      * The minimum distance between the nodes of a multi-parent structure and the bus connecting these nodes.
      * In case the edges style is not orthogonal the bus only consists of a common point.
      */
      minimumBusDistance:number;
      /**
      * The relative vertical alignment of nodes belonging to the same multi-parent structure.
      * A value of <code>0</code>
      * means nodes are top aligned; a value of <code>1</code> means nodes are bottom aligned; a value of <code>0.5</code>
      * means nodes are center aligned. Values outside the interval <code>[0,1]</code> will result in a compact node
      * placement with unaligned nodes.
      * <p>By default the compact placement with unaligned nodes is used.</p>
      */
      verticalAlignment:number;
      /**
      * The routing style for edges that connect to nodes that constitute a multi-parent structure.
      * The routing style is applied only to the part of the edge route that is not shared.
      */
      edgeStyle:yfiles.tree.MultiParentRoutingStyle;
    }
    var MultiParentDescriptor:{
      $class:yfiles.lang.Class;
      new ():yfiles.tree.MultiParentDescriptor;
    };
  }
}