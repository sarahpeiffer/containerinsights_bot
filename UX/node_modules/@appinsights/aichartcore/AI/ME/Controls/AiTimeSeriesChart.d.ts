import * as Constants from "../Constants";
import { TimeRange } from "../MELiteShared";
import * as Interfaces from "../SharedInterfaces";
import { IAiControl } from "./IAiControl";
export declare class AiTimeSeriesChart implements IAiControl {
    telemetryContext: Interfaces.InsightsTelemetryContext;
    keyset: any[];
    chartRangeInDays: number;
    private _aiChart;
    private _uniqueId;
    private _interactions;
    private _backendData;
    private _userDataStatusWithError;
    private _hasLiveMetrics;
    private _transformedData;
    private _visualOptions;
    private _stackedDataset;
    private _selectedDataPoint;
    private _isSegmented;
    private _groupColors;
    private _hasMissingValues;
    private _tooltip;
    private _viewPortTimeRange;
    private _clipPathUniqueId;
    private _watermark;
    private _watermarkText;
    private _isFocused;
    private _keyboardSelectedSeriesIndex;
    private _keyboardSelectedDataPointIndex;
    private _chartWidth;
    private _chartHeight;
    constructor(chart: Interfaces.IChart, context?: Interfaces.InsightsTelemetryContext, data?: Interfaces.ControlData, visualization?: Interfaces.IChartVisualization, interactions?: Interfaces.IAiChartInteractions);
    private _createMouseClosingInteractiveData;
    private _onMouseOverHandler;
    private _onMouseOutHandler;
    private _onZoomHandler;
    getYAxisScale(): any;
    getXAxisScale(): any;
    getUniqueId(): string;
    getVisualization(): Interfaces.IChartVisualization;
    setVisualization(newVisual: Interfaces.IChartVisualization): void;
    clearData(dataStatus?: Constants.UserDataStatus): void;
    updateData(data: Interfaces.ControlData, cause?: Constants.RefreshReason): void;
    changeToolTipBody(body: string): void;
    private _showWatermark;
    hideWatermark(): void;
    private _refresh;
    private _removeSvgElement;
    private _shouldShowErrorMessage;
    private _clearDataSets;
    private _prepareSkeletalChart;
    private _createClickCaptureRectangle;
    private _createTimeBrush;
    filterDataset(begin: Date, end: Date): Array<Interfaces.ChartSeriesData>;
    /**
     * Filter and return points that are between begin and end.
     */
    protected filterDatapoints(points: Interfaces.MetricDataPoint[], begin: Date, end: Date): Interfaces.MetricDataPoint[];
    private _drawTempTicksAndGuideline;
    hoverOn(timeTick: Date, selection?: boolean): void;
    getTimeRange(): TimeRange;
    private _getBisectionDate;
    /**
     * This function used d3 bisectors to find the closest data element near to the mouse and then uses selectTheBar to select it.
     */
    private _selectClosestItemOnChart;
    private _getStackedDataByIndex;
    hoverOut(): void;
    private _selectItemOnChart;
    /**
     * Selects an item on the bar chart, including making all others translucent.
     */
    private _selectItemOnBarChart;
    /**
     * Selects an item on the chart, including making all others translucent.
     */
    private _selectItemOnLineChart;
    private _getFillColorForHoverDot;
    private _fadeTicksNearPosition;
    protected updateLegendsOnHover(data: any): void;
    protected parseData(allSeriesData: Interfaces.ChartSeriesData[]): void;
    fixSeriesVisual(seriesData: Interfaces.ChartSeriesData): Interfaces.ISeriesVisualization;
    private _getSeriesColor;
    /**
     * Returns the appropriate legend display value.
     * For a segmented chart it is the segment name, for multi-metric chart it is the metric display name,
     */
    protected getLegendMetricDisplayName(index: number): string;
    /**
     * Returns the appropriate legend metric value.
     * For a segmented chart it is the segment name, for multi-metric chart it is the metric display name.
     */
    private _getLegendMetricTitleValue;
    /**
     * Returns the appropriate legend resource display value.
     */
    protected getLegendResourceDisplayName(index: number): string;
    /**
     * Returns the appropriate legend resource value.
     */
    private _getLegendResourceTitleValue;
    /**
     * Returns the appropriate legend unit.
     * For a single metric (and segmented chart), the units will all be the same and taken from the first metric.
     * For a multi-metric chart, use the index to index into the seriesVisualization array and get the unit.
     */
    private _getLegendUnits;
    private _getLegendSummaryValue;
    protected createLegends(): void;
    /**
     * Method to calculate the units the legend value.
     */
    _configureLegend(originalValue: number, index: number): Interfaces.ILegendSummaryData;
    private _createAxes;
    private _xScale;
    private _yScale;
    private _getOrCreateClipPathContainer;
    /**
     *  Create the container element containing the chart data points and guidelines for hover
     */
    private _getOrCreateChartContainerArtifacts;
    private _drawBars;
    private _drawPoints;
    private _drawLines;
    private _drawHoverMarker;
    private _calculateYForChartType;
    private _adjustFillForAreaStroke;
    private _drawSVGPoints;
    private _drawSVGPath;
    private _updateChartLines;
    private _addNewChartLinesForDottedLineForMissingValue;
    private _addNewChartLines;
    private _updateClipPath;
    /**
     * Transforms the display name shown on the legend.
     */
    private _transformLegendDisplayName;
    private _processUnit;
    focusFirstSeries(): void;
    focusLastSeries(): void;
    focusNextSeries(): void;
    focusPrevSeries(): void;
    focusNextDataPoint(): void;
    focusPrevDataPoint(): void;
    unfocusSeries(): void;
    _removeSeriesVirtualFocus(isFocused?: boolean): void;
    deselect(): void;
    focusDataPoint(index?: number): void;
    focusSeries(index?: number): void;
    private _getD3LegendYValueDef;
    private _getXValueDefForBottomLegend;
}
