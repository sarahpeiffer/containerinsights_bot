"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var d3 = require("d3");
var Strings = require("../../../Scripts/Strings/src/MELiteStrings");
var LocaleFormatter = require("../../../Utils/LocaleFormatter");
var MapppedUtils_1 = require("../../../Utils/MapppedUtils");
var Constants = require("../Constants");
var FeatureFlagService_1 = require("../FeatureFlagService");
var Telemetry = require("../Telemetry");
var ChartUtils_1 = require("../Utilities/ChartUtils");
var DateUtil = require("../Utilities/DateUtils");
var ResourceTypes_1 = require("../Utilities/ResourceTypes");
var TimeUnits = require("../Utilities/TimeUnits");
var Util = require("../Utilities/Util");
var AiTooltip_1 = require("./AiTooltip");
/**
 * This function takes the data and index of a segment summary, and formats it appropriately for d3.
 * This is needed in order to pass the data properly from legendArea through LegendContainer to its constituents.
 * The format does the following:
 * 1- It preserves the original index of the segment. Otherwise, it will be 0 for each summary.
 * 2- Returns the data as a single element array that is passed to its corresponding container (d3.data expects an array, not an object).
 *
 * @param {*} d: The data for a specific segment.
 * @param {number} i: The index of that segment.
 * @returns {[D3FormatedSummaryData]} the data/index in a d3 suitable format.
 */
function d3FormatSummaryData(d, i) {
    return [{
            data: d,
            index: i,
        }];
}
/**
 * Calculates the width of the bars using a padding:bar ratio of 0.6.
 *
 * @export
 * @param {number} totalWidth The total available width to subdivide.
 * @returns The width of bars
 *
 * @memberOf AiBarChart
 */
function calculateBarWidth(totalWidth, dataLength) {
    return (totalWidth / dataLength) * .6;
}
function calculateStrokeOpacity(targetOpacity, pathType) {
    if (pathType === 3 /* Area */) {
        return 0;
    }
    return targetOpacity;
}
function calculateFillOpacity(targetOpacity, pathType) {
    if (pathType === 3 /* Area */) {
        return 0.5;
    }
    return targetOpacity;
}
/**
 * Returns the margins for the plottable area within the svg.
 */
function getPlottableAreaMargin() {
    return {
        // y-axis is on the left hand side, we need to have cushion on the left to plot data.
        left: 25 /* PaddingLeft */ + 25 /* PlottableLeftAreaMargin */,
        // If we have y-axis on the right-hand side, we will need to adjust the right field accordingly
        right: 5 /* PaddingRight */,
    };
}
/* Create dataset for metrics with no data or error, to create a legend */
function dataSetForNoData(seriesVisual) {
    var transformedMetric = {
        seriesPoints: [],
        summary: undefined,
        seriesMetadata: seriesVisual,
    };
    return transformedMetric;
}
function getUniqueDatasetId(uniqueId, datapoint) {
    return uniqueId + "-" + Util.hashCode((datapoint.metric || "") +
        (datapoint.segment || ""));
}
function getUniqueTransformedDataId(uniqueId, transformedData) {
    return uniqueId + "-" + Util.hashCode((transformedData && transformedData.seriesMetadata ?
        ((transformedData.seriesMetadata.resourceDisplayName ? transformedData.seriesMetadata.resourceDisplayName : "") +
            (transformedData.seriesMetadata.displayName ? transformedData.seriesMetadata.displayName : "")) :
        ""));
}
function createLegendColorBar(legendArea, hideSubtitle, uniqueId) {
    // Create legend rectangle markers. Creates as many rectangles as there are data entries.
    var legendRect = legendArea.selectAll("rect.fxc-monitorchart-legend-bar").data(function (d, i) {
        return d3FormatSummaryData(getUniqueTransformedDataId(uniqueId, d), i);
    });
    legendRect
        .classed("fxc-monitorchart-legend-bar", true)
        .attr("height", !hideSubtitle ? 45 : 25);
    legendRect.enter()
        .append("rect")
        .classed("fxc-monitorchart-legend-bar", true)
        .attr({
        "id": function (d) { return "legend-rect-" + d.data; },
        "height": !hideSubtitle ? 45 : 25,
        "aria-hidden": true,
        "width": 5,
    });
    legendRect.exit().remove();
    return legendRect;
}
var AiTimeSeriesChart = /** @class */ (function () {
    function AiTimeSeriesChart(chart, context, data, visualization, interactions) {
        this.keyset = new Array();
        this.chartRangeInDays = Constants.DefaultChartDurationInDays;
        this._hasLiveMetrics = false;
        // Represent the transformed data consumed by d3.
        this._transformedData = [];
        this._stackedDataset = new Array();
        this._isSegmented = false;
        this._groupColors = Constants.Colors.palettes.multiColor;
        this._aiChart = chart;
        if (visualization.toolTip) {
            this._tooltip = new AiTooltip_1.AiTooltip(visualization.toolTip);
        }
        this._backendData = data;
        if (data) {
            this._userDataStatusWithError = data.userDataStatusWithError // Error.
                || ((!data.chartSeriesData || data.chartSeriesData.length === 0) && { userDataStatus: 0 /* None */ }) // No data.
                || { userDataStatus: 1 /* HasData */ }; // Default has data.
        }
        else {
            this._userDataStatusWithError = { userDataStatus: 0 /* None */ };
        }
        this._interactions = interactions;
        this._visualOptions = visualization;
        this.telemetryContext = context;
        this._uniqueId = ChartUtils_1.generateUniqueId(this.telemetryContext);
        if (!Util.isNullOrUndefined(visualization) && !Util.isNullOrUndefined(visualization.palette)) {
            this._groupColors = visualization.palette;
        }
        this._clipPathUniqueId = "url(#viewPort-clip-" + this._uniqueId + ")";
        this._keyboardSelectedSeriesIndex = -1;
        this._keyboardSelectedDataPointIndex = -1;
        this._isFocused = false;
        // Call refresh.
        this._refresh();
    }
    AiTimeSeriesChart.prototype._createMouseClosingInteractiveData = function () {
        var interactionsData = {
            id: this._uniqueId,
            chartType: this._visualOptions.chartType,
            isLive: this._hasLiveMetrics,
        };
        return interactionsData;
    };
    AiTimeSeriesChart.prototype._onMouseOverHandler = function (d) {
        if (this._interactions) {
            this._interactions.OnHover(d);
        }
        return true;
    };
    AiTimeSeriesChart.prototype._onMouseOutHandler = function (d) {
        if (this._interactions) {
            this._interactions.OnLeave(d);
        }
    };
    AiTimeSeriesChart.prototype._onZoomHandler = function (begin, end) {
        if (this._interactions) {
            var interactionsData = {
                id: this._uniqueId,
                chartType: this._visualOptions.chartType,
                isLive: this._hasLiveMetrics,
                xRange: {
                    from: begin,
                    to: end,
                },
            };
            this._interactions.OnZoom(interactionsData);
        }
    };
    AiTimeSeriesChart.prototype.getYAxisScale = function () {
        return this._yScaleStored;
    };
    AiTimeSeriesChart.prototype.getXAxisScale = function () {
        return this._xScaleStored;
    };
    AiTimeSeriesChart.prototype.getUniqueId = function () {
        return this._uniqueId;
    };
    AiTimeSeriesChart.prototype.getVisualization = function () {
        return this._visualOptions;
    };
    AiTimeSeriesChart.prototype.setVisualization = function (newVisual) {
        this._visualOptions = newVisual || Util.cloneProperties(ChartUtils_1.DefaultVisualizationOptions);
        this._refresh();
    };
    AiTimeSeriesChart.prototype.clearData = function (dataStatus) {
        if (dataStatus === void 0) { dataStatus = 0 /* None */; }
        var chartData = {
            chartSeriesData: [],
            userDataStatusWithError: { userDataStatus: dataStatus },
        };
        this.updateData(chartData);
    };
    AiTimeSeriesChart.prototype.updateData = function (data, cause) {
        // Update chart data.
        this._backendData = data;
        if (this._hasLiveMetrics) {
            this._viewPortTimeRange = undefined;
        }
        else if (this._backendData.timeContext) {
            this._viewPortTimeRange = this._backendData.timeContext.getTimerange();
        }
        this._userDataStatusWithError = data.userDataStatusWithError;
        this._refresh(cause);
    };
    AiTimeSeriesChart.prototype.changeToolTipBody = function (body) {
        if (this._tooltip) {
            this._tooltip.AddBody(body);
        }
    };
    AiTimeSeriesChart.prototype._showWatermark = function (message) {
        var watermarktextClassName = "fxc-monitorchart-watermark-text";
        var watermarktextId = "fxc-monitorchart-watermark-text-id-" + this._uniqueId;
        if (this._watermark && this._watermarkText) {
            this._watermarkText.textContent = message;
            this._watermarkText.title = message;
            this._watermark.style.display = "flex";
        }
        else {
            var div = document.getElementById(this._aiChart.realm);
            var watermarkTextContainer = MapppedUtils_1.createElement("div", {
                "aria-label": message,
                "class": watermarktextClassName,
                "id": watermarktextId,
                "role": "banner",
                "title": message,
            });
            watermarkTextContainer.textContent = message;
            this._watermark = MapppedUtils_1.createElement("div", {
                "class": "fxc-monitorchart-watermark-container",
            }, MapppedUtils_1.createElement("div", {
                "id": "watermark" + this._uniqueId,
                "class": "fxc-monitorchart-watermark",
            }, watermarkTextContainer));
            if (div) {
                div.appendChild(this._watermark);
            }
            this._watermarkText = this._watermark.getElementsByClassName(watermarktextClassName)[0];
        }
    };
    AiTimeSeriesChart.prototype.hideWatermark = function () {
        if (this._watermark) {
            this._watermark.style.display = "none";
        }
    };
    AiTimeSeriesChart.prototype._refresh = function (cause) {
        this._chartWidth = this._aiChart.getActualWidth();
        this._chartHeight = this._aiChart.getActualHeight();
        if (this._chartWidth <= 0) {
            // don't draw the chart svg if the width is not valid.
            this._chartHeight = 0;
        }
        // Determine whether to the watermark DIV or not.
        var showShowNoDataOrErrorMessage = this._shouldShowErrorMessage(cause);
        if (this._backendData && this._backendData.chartSeriesData) {
            this._prepareSkeletalChart(this._backendData.chartSeriesData, showShowNoDataOrErrorMessage);
        }
        else {
            this._prepareSkeletalChart([], showShowNoDataOrErrorMessage);
        }
        // clip the view port.
        this._updateClipPath();
        this._removeSvgElement();
        if (this._chartHeight > 0 && this._chartWidth > 0) {
            if (this._visualOptions.chartType === 1 /* Bar */) {
                // Create bars.
                this._drawBars();
            }
            else if (this._visualOptions.chartType === 7 /* Scatter */) {
                // Create path element.
                this._drawPoints();
            }
            else {
                // Create path element.
                this._drawLines();
            }
            if (showShowNoDataOrErrorMessage) {
                var message = Util.getErrorMessage(this._userDataStatusWithError, Strings.errorRetrievingDataMessage);
                this._showWatermark(message);
            }
            else {
                this.hideWatermark();
            }
        }
        // Create legends after draw other svg content, otherwise, they maybe not enought space for legend yet.
        this.createLegends();
    };
    AiTimeSeriesChart.prototype._removeSvgElement = function () {
        var barGroup = this._aiChart.svgElement.selectAll("g.fxc-monitorchart-bargroup");
        if (barGroup && !barGroup.empty()) {
            barGroup.remove();
        }
        var scatterGroup = this._aiChart.svgElement.selectAll("g.scatterGroup");
        if (scatterGroup && !scatterGroup.empty()) {
            scatterGroup.remove();
        }
        var linePoints = this._aiChart.svgElement.selectAll(".fxc-monitorchart-timeSeriesPoints.fxc-monitorchart-linePoints");
        if (scatterGroup && !linePoints.empty()) {
            linePoints.remove();
        }
        var linePointsMissing = this._aiChart.svgElement.selectAll(".fxc-monitorchart-timeSeriesPoints.fxc-monitorchart-linePoints-missing");
        if (linePointsMissing && !linePointsMissing.empty()) {
            linePointsMissing.remove();
        }
        var dots = this._aiChart.svgElement.selectAll(".fxc-monitorchart-timeSeriesPoints.fxc-monitorchart-timeSeriesPoints-dot");
        if (dots && !dots.empty()) {
            dots.remove();
        }
        var doubleEndedMissing = this._aiChart.svgElement.selectAll(".fxc-monitorchart-doubleEndedMissing");
        if (doubleEndedMissing && !doubleEndedMissing.empty()) {
            doubleEndedMissing.remove();
        }
    };
    AiTimeSeriesChart.prototype._shouldShowErrorMessage = function (cause) {
        var statesWithoutErrorMessage = [
            1 /* HasData */,
            2 /* NoData */,
            0 /* None */,
            10 /* Invisible */,
            4 /* NoMetrics */,
        ];
        return this._userDataStatusWithError && statesWithoutErrorMessage.indexOf(this._userDataStatusWithError.userDataStatus) < 0
            && cause !== 2 /* Auto */;
    };
    AiTimeSeriesChart.prototype._clearDataSets = function () {
        this._transformedData = [];
        this.keyset = [];
        this._stackedDataset = [];
        // Start parsing the data (assuming the data isn't segmented unless data tells so later).
        this._isSegmented = false;
    };
    AiTimeSeriesChart.prototype._prepareSkeletalChart = function (data, showNoDataOrErrorMessage) {
        // Reset the global data sets.
        this._clearDataSets();
        if (!Util.isNullOrUndefined(data)) {
            // Parse the data in a stacked layer of datapoints.
            this.parseData(data);
        }
        // Create axes.
        this._createAxes(showNoDataOrErrorMessage);
    };
    AiTimeSeriesChart.prototype._createClickCaptureRectangle = function (graphContainer) {
        var _this = this;
        var clickCapture = graphContainer.select("rect.fxc-monitorchart-click-capture");
        if (clickCapture.empty()) {
            graphContainer.append("rect")
                .classed({
                "fxc-monitorchart-graphContainerRect": true,
                "fxc-monitorchart-click-capture": true,
            })
                .style("visibility", "hidden")
                .attr({
                "pointer-events": "all",
                "x": getPlottableAreaMargin().left,
                "y": 15 /* PaddingTop */,
                "width": Math.abs(this._chartWidth - getPlottableAreaMargin().right - getPlottableAreaMargin().left),
                "height": Math.abs(this._chartHeight - 25 /* PaddingBottom */),
            })
                .on("mouseover", function () {
                var d3Event = d3.event;
                var xPosition = (d3Event && d3Event.target) ? d3.mouse(d3Event.target)[0] : 0; // A necessary check for tests.
                _this._drawTempTicksAndGuideline(xPosition, !_this._hasLiveMetrics);
                if (_this._tooltip) {
                    if (_this._interactions && _this._interactions.OnToolTipWillShowPoint) {
                        _this._interactions.OnToolTipWillShowPoint(_this._selectedDataPoint);
                    }
                    // bbax: same note as xPosition; the testing framework hasn't setup the d3Event object for mousemove
                    var x = (d3Event && d3Event.pageX) ? d3Event.pageX : 0;
                    var y = (d3Event && d3Event.pageY) ? d3Event.pageY : 0;
                    _this._tooltip.ChangePosition(x, y, true);
                }
                d3.timer(function () { return _this._onMouseOverHandler(_this._selectedDataPoint); }, 50);
            })
                .on("mouseenter", function () {
                var d3Event = d3.event;
                var xPosition = (d3Event && d3Event.target) ? d3.mouse(d3Event.target)[0] : 0; // A necessary check for tests.
                _this._drawTempTicksAndGuideline(xPosition, !_this._hasLiveMetrics);
                if (_this._tooltip) {
                    if (_this._interactions && _this._interactions.OnToolTipWillShowPoint) {
                        _this._interactions.OnToolTipWillShowPoint(_this._selectedDataPoint);
                    }
                    var x = (d3Event && d3Event.pageX) ? d3Event.pageX : 0;
                    var y = (d3Event && d3Event.pageY) ? d3Event.pageY : 0;
                    _this._tooltip.ChangePosition(x, y, true);
                }
                d3.timer(function () { return _this._onMouseOverHandler(_this._selectedDataPoint); }, 50);
            })
                .on("mousemove", function () {
                var d3Event = d3.event;
                var xPosition = (d3Event && d3Event.target) ? d3.mouse(d3Event.target)[0] : 0; // A necessary check for tests.
                _this._drawTempTicksAndGuideline(xPosition, !_this._hasLiveMetrics);
                if (_this._tooltip) {
                    if (_this._interactions && _this._interactions.OnToolTipWillShowPoint) {
                        _this._interactions.OnToolTipWillShowPoint(_this._selectedDataPoint);
                    }
                    var x = (d3Event && d3Event.pageX) ? d3Event.pageX : 0;
                    var y = (d3Event && d3Event.pageY) ? d3Event.pageY : 0;
                    _this._tooltip.ChangePosition(x, y, false);
                }
                d3.timer(function () { return _this._onMouseOverHandler(_this._selectedDataPoint); }, 50);
            })
                .on("mouseout", function () {
                _this.hoverOut();
                var interactionData = _this._createMouseClosingInteractiveData();
                if (_this._tooltip) {
                    _this._tooltip.Hide();
                }
                d3.timer.flush();
                d3.timer(function () { _this._onMouseOutHandler(interactionData); return true; }, 100);
            })
                .on("mouseleave", function () {
                _this.hoverOut();
                var interactionData = _this._createMouseClosingInteractiveData();
                if (_this._tooltip) {
                    _this._tooltip.Hide();
                }
                d3.timer.flush();
                d3.timer(function () { _this._onMouseOutHandler(interactionData); return true; }, 100);
            })
                .on("mousedown", function () {
                if (_this._visualOptions.timeBrushEnable) {
                    var brush_elm = graphContainer.select(".fxc-monitorchart-brush").node();
                    var options = {
                        clientX: d3.event.clientX,
                        clientY: d3.event.clientY,
                    };
                    var new_click_event = new MouseEvent("mousedown", options);
                    brush_elm.dispatchEvent(new_click_event);
                }
            });
        }
        else {
            clickCapture
                .attr({
                "x": getPlottableAreaMargin().left,
                "y": 15 /* PaddingTop */,
                "width": Math.abs(this._chartWidth - getPlottableAreaMargin().right - getPlottableAreaMargin().left),
                "height": Math.abs(this._chartHeight - 25 /* PaddingBottom */),
            });
        }
    };
    AiTimeSeriesChart.prototype._createTimeBrush = function (graphContainer) {
        var _this = this;
        if (this._visualOptions.timeBrushEnable) {
            // Create the time brush for this chart and associated callbacks
            var x2 = this._xScale();
            this._brush = d3.svg.brush()
                .x(x2)
                .on("brushend", function () {
                if (!_this._brush.empty()) {
                    var begin = _this._brush.extent()[0];
                    var end = _this._brush.extent()[1];
                    _this._backendData.chartSeriesData = _this.filterDataset(begin, end);
                    _this._refresh();
                    // Call the zoom handler specified for this chart
                    _this._onZoomHandler(begin, end);
                }
                d3.select(".fxc-monitorchart-brush").call(function () { return _this._brush.clear(); });
            })
                .extent([0, 0]);
            // Apply the brush on this chart
            var brushcontainer = void 0;
            if (graphContainer.select(".fxc-monitorchart-brush").empty()) {
                brushcontainer = graphContainer.append("g")
                    .attr({
                    "class": "fxc-monitorchart-brush",
                    "pointer-events": "none",
                })
                    .call(this._brush);
            }
            else {
                brushcontainer = graphContainer.select(".fxc-monitorchart-brush");
                brushcontainer.call(this._brush);
            }
            // Style brush background and selection
            brushcontainer.selectAll("rect.fxc-monitorchart-background")
                .attr({
                "height": this._chartHeight - 25 /* PaddingBottom */,
                "width": this._chartWidth - getPlottableAreaMargin().right,
            });
            brushcontainer.selectAll("rect.fxc-monitorchart-extent")
                .attr({
                "height": this._chartHeight - 25 /* PaddingBottom */,
                "width": this._chartWidth - getPlottableAreaMargin().right,
            });
            // Style the brush handle bars
            var arc = d3.svg.arc()
                .outerRadius(20)
                .startAngle(0)
                .endAngle(function (d, i) { return i ? -Math.PI : Math.PI; });
            brushcontainer.selectAll(".fxc-monitorchart-resize")
                .append("rect")
                .classed("fxc-monitorchart-resize-rect", true)
                .attr({
                "y": this._chartHeight - 25 /* PaddingBottom */,
                "fill": "black",
                "width": 100,
                "height": 20,
                "transform": function (d, i) { return "translate(" + i * -100 + ",0)"; },
            });
            brushcontainer.selectAll(".fxc-monitorchart-resize")
                .append("path")
                .classed("fxc-monitorchart-resize-path", true)
                .attr({
                "d": arc,
                "transform": "translate(0," + this._chartHeight / 2 + ")",
            });
            this._brush.clear();
        }
    };
    AiTimeSeriesChart.prototype.filterDataset = function (begin, end) {
        var _this = this;
        // Snap brush times to nearest datasets.
        var bisectDate = d3.bisector(function (d) { return d; }).left;
        var snappedBegin = this.keyset[bisectDate(this.keyset, begin, 1)];
        var snappedEnd = this.keyset[bisectDate(this.keyset, end, 1)];
        return this._backendData.chartSeriesData.map(function (seriesData) {
            if (Array.isArray(seriesData.metricResults.data)) {
                // If there is more than one entry in data, then this will filter each segment as well.
                seriesData.metricResults.data = seriesData.metricResults.data.map(function (metricSeriesAndSummary) {
                    return {
                        dataPoints: _this.filterDatapoints(metricSeriesAndSummary.dataPoints, snappedBegin, snappedEnd),
                        summary: metricSeriesAndSummary.summary,
                        segment: metricSeriesAndSummary.segment,
                    };
                });
            }
            // Change the time in the metric result to have to new snapped time.
            seriesData.metricResults.startTime = snappedBegin;
            seriesData.metricResults.endTime = snappedEnd;
            return seriesData;
        });
    };
    /**
     * Filter and return points that are between begin and end.
     */
    AiTimeSeriesChart.prototype.filterDatapoints = function (points, begin, end) {
        var filtered = points.filter(function (dp) {
            return dp.timestamp.getTime() >= begin.getTime() && dp.timestamp.getTime() <= end.getTime();
        });
        return filtered;
    };
    AiTimeSeriesChart.prototype._drawTempTicksAndGuideline = function (xPosition, selection) {
        var _this = this;
        var xScale = this._xScaleStored;
        var x0 = xScale.invert(xPosition);
        var outOfRange = false;
        if (this._viewPortTimeRange && this._viewPortTimeRange.startTime && this._viewPortTimeRange.endTime) {
            var currentTime = x0.getTime();
            if (currentTime > this._viewPortTimeRange.endTime.getTime() || currentTime < this._viewPortTimeRange.startTime.getTime()) {
                // Don't draw tempTicks and guideline if the xPosition is out of the range of xAxis's start/end.
                outOfRange = true;
            }
        }
        this._aiChart.svgElement.select("line.fxc-monitorchart-guideline." + this._uniqueId)
            .attr({
            "x1": xPosition,
            "x2": xPosition,
            "y1": 0 + 15 /* PaddingTop */,
            "y2": this._chartHeight - 25 /* PaddingBottom */,
        })
            .style("display", outOfRange ? "none" : "flex");
        this._aiChart.svgElement.select("text.fxc-monitorchart-temp-tick." + this._uniqueId)
            .text(function () {
            return LocaleFormatter.formatTickTime(x0, _this.getVisualization().axis.x.axisType === 3 /* DateUTC */);
        })
            .attr({
            "x": xPosition,
            "y": this._chartHeight - 25 /* PaddingBottom */ + 20,
        })
            .style("display", outOfRange ? "none" : "flex");
        d3.timer(function () { _this._fadeTicksNearPosition(xPosition); return true; }, 50);
        this._selectedDataPoint = {
            x: x0,
            metricId: undefined,
            dimensionId: undefined,
            chartType: undefined,
            isLive: this._hasLiveMetrics,
            id: this._uniqueId,
            stackedDataIndex: undefined,
            stackedDataColumn: [],
        };
        var wait = false;
        if (!wait && selection) {
            this._selectClosestItemOnChart(xPosition);
            wait = true;
            setTimeout(function () { wait = false; }, 300);
        }
        if (this._tooltip && this._tooltip.ControlRequiresBody()) {
            var toolTipBody_1 = [];
            this._selectedDataPoint.stackedDataColumn.forEach(function (item) {
                var yNumber = item && item.y ? item.y : 0;
                toolTipBody_1.push(yNumber.toFixed(2).toString());
            });
            if (toolTipBody_1.length < 1) {
                toolTipBody_1.push(Strings.noDataForMetric);
            }
            this._tooltip.AddBody("<span>" + toolTipBody_1.join(", ") + "</span>");
        }
    };
    AiTimeSeriesChart.prototype.hoverOn = function (timeTick, selection) {
        if (ChartUtils_1.isElementInViewport(this._aiChart.realm)) {
            var xScale = this._xScale();
            var xPosition = xScale(timeTick);
            this._drawTempTicksAndGuideline(xPosition, selection);
        }
    };
    AiTimeSeriesChart.prototype.getTimeRange = function () {
        return this._viewPortTimeRange;
    };
    AiTimeSeriesChart.prototype._getBisectionDate = function (xPosition) {
        var xScale = this._xScaleStored;
        var x0 = xScale.invert(xPosition);
        var bisectDate = d3.bisector(function (d) { return d; }).left;
        return { i: bisectDate(this.keyset, x0, 1), x0: x0 };
    };
    /**
     * This function used d3 bisectors to find the closest data element near to the mouse and then uses selectTheBar to select it.
     */
    AiTimeSeriesChart.prototype._selectClosestItemOnChart = function (xPosition) {
        if (this._stackedDataset && this._stackedDataset.length > 0) {
            var result = this._getBisectionDate(xPosition);
            var x0 = result.x0;
            var i_1 = result.i;
            var stackedDatasetWithData = this._stackedDataset.filter(function (s) { return s[i_1 - 1]; })[0];
            if (stackedDatasetWithData && stackedDatasetWithData[i_1 - 1]) {
                var d0 = stackedDatasetWithData[i_1 - 1].x;
                var d1 = i_1 < stackedDatasetWithData.length ? stackedDatasetWithData[i_1].x : new Date(8640000000000000);
                var d = Math.abs(x0.getTime() - d0.getTime()) > Math.abs(d1.getTime() - x0.getTime()) ? stackedDatasetWithData[i_1] : stackedDatasetWithData[i_1 - 1];
                this._selectedDataPoint.stackedDataIndex = d;
                this._getStackedDataByIndex();
                this._selectItemOnChart(d);
            }
        }
    };
    AiTimeSeriesChart.prototype._getStackedDataByIndex = function () {
        var _this = this;
        if (!this._selectedDataPoint || !this._selectedDataPoint.stackedDataIndex) {
            return;
        }
        this._stackedDataset.forEach(function (item) {
            var dataPoint = item.filter(function (d) {
                if (d) {
                    return d.x.getTime() === _this._selectedDataPoint.stackedDataIndex.x.getTime();
                }
                else {
                    return false;
                }
            })[0];
            _this._selectedDataPoint.stackedDataColumn.push(dataPoint);
        });
    };
    AiTimeSeriesChart.prototype.hoverOut = function () {
        var _this = this;
        var svgElement = this._aiChart.svgElement;
        var container = this._aiChart.legendElement.selectAll(".fxc-monitorchart-legend");
        // Make all the bars opaque.
        d3.selectAll("rect.fxc-monitorchart-bars").classed("fxc-monitorchart-translucent", false);
        // Reset legend values to summary values.
        var legendValueText = container.selectAll(".fxc-monitorchart-value").data(function (d, i) {
            return d3FormatSummaryData(getUniqueTransformedDataId(_this._uniqueId, d), i);
        });
        var units = [];
        legendValueText
            .text(function (d) {
            // If the legend summary exists, transform the value & unit.
            var originalValue = _this._getLegendSummaryValue(d.index);
            return _this._processUnit(originalValue, d.index, units);
        });
        legendValueText.enter()
            .append("text")
            .classed("fxc-monitorchart-value", true)
            .attr("id", function (d) { return "legend-value-" + d.data; })
            .text(function (d) {
            // If the legend summary exists, transform the value & unit.
            var originalValue = _this._getLegendSummaryValue(d.index);
            return _this._processUnit(originalValue, d.index, units);
        });
        legendValueText.exit().remove();
        // Create legend units.
        var legendUnits = legendValueText.selectAll(".fxc-monitorchart-units").data(function (d, i) {
            return d3FormatSummaryData(units[i], i);
        });
        legendUnits
            .text(function (d) {
            return d.data;
        });
        legendUnits.enter()
            .append("tspan")
            .classed("fxc-monitorchart-units", true)
            .attr("id", function (d) { return "legend-units-" + getUniqueTransformedDataId(_this._uniqueId, _this._transformedData[d.index]); })
            .text(function (d) {
            return " " + d.data;
        });
        legendUnits.exit().remove();
        svgElement.selectAll(".fxc-monitorchart-guideline")
            .attr({
            "x1": this._chartWidth + getPlottableAreaMargin().right,
            "x2": this._chartWidth + getPlottableAreaMargin().right,
        })
            .style("display", "none");
        svgElement.selectAll(".fxc-monitorchart-temp-tick")
            .attr("x", this._chartWidth + getPlottableAreaMargin().right + 20 /* padding */)
            .style("display", "none");
        // Since the fade out is on a timer, we also need to put this on a timer.
        d3.timer(function () {
            svgElement.selectAll("g.fxc-monitorchart-tick")
                .select("text")
                .attr("opacity", 1);
            return true;
        }, 51);
        svgElement.selectAll("circle.fxc-monitorchart-marker").style("display", "none");
    };
    AiTimeSeriesChart.prototype._selectItemOnChart = function (data) {
        if (data) {
            // Create scale.
            if (this._visualOptions.chartType === 1 /* Bar */) {
                this._selectItemOnBarChart(data);
            }
            else {
                this._selectItemOnLineChart(data);
            }
        }
    };
    /**
     * Selects an item on the bar chart, including making all others translucent.
     */
    AiTimeSeriesChart.prototype._selectItemOnBarChart = function (data) {
        // Create scale.
        var xScale = this._xScale();
        var xPosition = xScale(data.x) + 5;
        // Make all bars translucent
        d3.select("#graphContainer-" + this._uniqueId).selectAll("rect.fxc-monitorchart-bars").classed("fxc-monitorchart-translucent", true);
        // Make the selected bars opaque
        d3.select("#graphContainer-" + this._uniqueId).selectAll("rect.fxc-monitorchart-bars")
            .filter(function (d) { return d.x.getTime() === data.x.getTime(); }).classed("fxc-monitorchart-translucent", false);
        // Update all the legends.
        this.updateLegendsOnHover(data);
        return xPosition;
    };
    /**
     * Selects an item on the chart, including making all others translucent.
     */
    AiTimeSeriesChart.prototype._selectItemOnLineChart = function (data) {
        var _this = this;
        // Create scale.
        var xScale = this._xScaleStored;
        var xPosition = xScale(data.x);
        var yScale = this._yScaleStored;
        var opacity = 1;
        var lineStyle = FeatureFlagService_1.getLineStyleForMissingValue();
        if (lineStyle === 1 /* Transparent */) {
            opacity = 0.5 /* LineStrokeOpacityForMissing */;
        }
        else if (lineStyle === 3 /* Disappearing */) {
            opacity = 0;
        }
        this._aiChart.svgElement.selectAll("circle.fxc-monitorchart-marker." + this._uniqueId)
            .data(this._stackedDataset.map(function (layer) {
            return layer.filter(function (d) {
                if (d) {
                    return d.x.getTime() === data.x.getTime();
                }
                else {
                    return false;
                }
            })[0];
        }))
            .style({
            "display": "inherit",
            "fill": function (d, i) {
                return _this._getFillColorForHoverDot(d, i);
            },
            "stroke-opacity": function (d) {
                return d && d.missingValue ? opacity.toString() : "1";
            },
        })
            .attr({
            "cx": xPosition,
            "cy": function (d) {
                if (d) {
                    return yScale(d.y + d.y0);
                }
                else {
                    return 0;
                }
            },
        });
        this.updateLegendsOnHover(data);
        return xPosition;
    };
    AiTimeSeriesChart.prototype._getFillColorForHoverDot = function (d, i) {
        if (d && d.missingValue) {
            // using background color to fill the the empty circle for missing values.
            return this.getVisualization().backgroundColor || "white";
        }
        else {
            return this._getSeriesColor(i);
        }
    };
    AiTimeSeriesChart.prototype._fadeTicksNearPosition = function (xPosition) {
        var _this = this;
        // Fade the nearby ticks - This follows the behavior of Ibiza charts where the ticks closer to where we
        // are hovering are faded out. The fading amount is dependent on the closeness with mouse position.
        var xScale = this._xScale();
        this._aiChart.svgElement.selectAll("g.fxc-monitorchart-tick")
            .filter(function (d) {
            return Math.abs(xPosition - xScale(d)) < _this._chartWidth / 8;
        })
            .select("text")
            .attr("opacity", function (d) {
            return (0.8 * Math.abs(xPosition - xScale(d))) / (_this._chartWidth / 8);
        });
        this._aiChart.svgElement.selectAll("g.fxc-monitorchart-tick").filter(function (d) { return Math.abs(xPosition - xScale(d)) >= _this._chartWidth / 8; })
            .select("text")
            .attr("opacity", 1);
    };
    AiTimeSeriesChart.prototype.updateLegendsOnHover = function (data) {
        var _this = this;
        // Calculate the shortest val for the legend.
        var legendValues = this._stackedDataset.map(function (layer) {
            return layer.filter(function (d) {
                return d.x.getTime() === data.x.getTime();
            })[0];
        }).map(function (d, i) {
            return {
                data: d,
                index: i,
            };
        });
        var units = [];
        var legendText = this._aiChart.legendElement.selectAll(".fxc-monitorchart-value").data(legendValues);
        legendText.text(function (d) {
            return _this._processUnit(d.data && !d.data.missingValue && d.data.y, d.index, units);
        });
        var legendUnit = legendText.selectAll(".fxc-monitorchart-units").data(function (d, i) {
            return d3FormatSummaryData(units[i], i);
        });
        legendUnit.text(function (d) { return d.data; });
        legendUnit.enter()
            .append("tspan")
            .classed("fxc-monitorchart-units", true)
            .attr({
            "id": function (d) { return "legend-units-" + getUniqueTransformedDataId(_this._uniqueId, _this._transformedData[d.index]); },
            "aria-hidden": true,
        })
            .text(function (d) {
            return " " + d.data;
        });
    };
    AiTimeSeriesChart.prototype.parseData = function (allSeriesData) {
        // Safeguard and return early.
        if (Util.isNullOrUndefined(allSeriesData) || allSeriesData.length < 1) {
            return;
        }
        this._hasLiveMetrics = !!allSeriesData[0] && !!allSeriesData[0].metricResults && ResourceTypes_1.isAILiveMetric(allSeriesData[0].metricResults.metricId);
        var isStackChart = this._visualOptions && (this._visualOptions.chartType === 3 /* Area */ || this._visualOptions.chartType === 1 /* Bar */);
        var tempDataset = [];
        this._stackedDataset = [];
        var interval;
        var _loop_1 = function (index) {
            var eachSeriesData = allSeriesData[index];
            if (eachSeriesData) {
                // Each series should return a series visual.
                var seriesVisual = this_1.fixSeriesVisual(eachSeriesData);
                // Is there data?
                if (eachSeriesData.metricResults && eachSeriesData.metricResults.data
                    && Array.isArray(eachSeriesData.metricResults.data)) {
                    // If there is a result with segmented data in this chart (chart is segmented).
                    interval = DateUtil.convertISODurationToMilliseconds(eachSeriesData.metricResults.timeGrain);
                    // get key set base on starTime, endTime and interval
                    var startTime = eachSeriesData.metricResults.startTime.getTime();
                    var endTime = eachSeriesData.metricResults.endTime.getTime();
                    // D3 range doesn't include the stop value in the range array hence add interval to stop value
                    this_1.keyset = d3.range(startTime + interval / 2, endTime + interval / 2, interval).map(function (t) { return new Date(t); });
                    this_1.chartRangeInDays = Math.round((endTime - startTime) / TimeUnits.milliseconds.scalar);
                    // todo: we are still debating on this.
                    // adjust time range to fit the view.
                    // this.adjustTimeRangeToFitTheView(eachSeriesData);
                    // NOTE: A segmented chart could have only one segment. A segmented chart, however, would have a segment name.
                    var allSegments = eachSeriesData.metricResults.data;
                    // figure out the xValues for d3 data transformation.
                    // If there is buffer time range (metricResults.timeRangeExtended), use that to get the xValues. otherwise, use metricResults.startTime and metricResults.endTime.
                    var xValues_1 = this_1.keyset;
                    if (eachSeriesData.metricResults.timeRangeExtended && eachSeriesData.metricResults.timeRangeExtended.startTime && eachSeriesData.metricResults.timeRangeExtended.endTime) {
                        var startTimeE = eachSeriesData.metricResults.timeRangeExtended.startTime.getTime();
                        var endTimeE = eachSeriesData.metricResults.timeRangeExtended.endTime.getTime();
                        this_1.keyset = d3.range(startTimeE + interval / 2, endTimeE + interval / 2, interval).map(function (t) { return new Date(t); });
                        xValues_1 = this_1.keyset;
                    }
                    // add to stack data set. need to do for each metric, because some metric may require zero-filling, and others may not, depends on the aggregation.
                    var transformedData = Util.transformMetricResultForD3(xValues_1, allSegments, seriesVisual.displayName, seriesVisual.missingDataFillType, this_1._hasLiveMetrics, isStackChart);
                    this_1._stackedDataset = this_1._stackedDataset.concat(transformedData.d3StackDataSet);
                    this_1._hasMissingValues = allSegments.some(function (s) { return xValues_1.length > s.dataPoints.length; });
                    this_1._isSegmented = !!(allSegments && allSegments[0] && allSegments[0].segment && allSegments[0].segment[0]);
                    if (allSegments.length > 0) {
                        for (var segmentIndex = 0; segmentIndex < allSegments.length; segmentIndex++) {
                            var seriesDataPoints = transformedData.transformedMetricResult[segmentIndex];
                            var seriesSummary = allSegments[segmentIndex].summary;
                            // If this is indeed a segmented chart and not just a single metric result, we need to create the visual for the segment.
                            var segmentVisual = null;
                            if (this_1._isSegmented && allSegments[segmentIndex].segment && allSegments[segmentIndex].segment[0]) {
                                var segmentDisplayName = allSegments[segmentIndex].segment[0].value;
                                segmentVisual = {
                                    color: seriesVisual.color,
                                    displayName: segmentDisplayName,
                                    resourceDisplayName: seriesVisual.resourceDisplayName,
                                    unit: seriesVisual.unit,
                                    useSIConversions: seriesVisual.useSIConversions,
                                    displaySIUnit: seriesVisual.displaySIUnit,
                                    missingDataFillType: seriesVisual.missingDataFillType,
                                };
                            }
                            var transformedSeriesData = [];
                            if (seriesDataPoints && seriesDataPoints[0]) {
                                for (var i = 0; i < seriesDataPoints.length; i++) {
                                    // The datapoints comes from metric provider is already at the center of the time bucket they represent.
                                    transformedSeriesData.push([new Date(seriesDataPoints[i].timestamp.getTime()),
                                        seriesDataPoints[i].value,
                                        segmentVisual ? segmentVisual.displayName : eachSeriesData.metricResults.metricId]);
                                }
                            }
                            var transformedMetric = {
                                seriesPoints: transformedSeriesData,
                                summary: seriesSummary,
                                seriesMetadata: segmentVisual || seriesVisual,
                            };
                            this_1._transformedData.push(transformedMetric);
                        }
                    }
                    else {
                        // No data OR error retrieving data for this metric.
                        // We still need to push the series visualization needed to create the legend.
                        tempDataset.push(dataSetForNoData(seriesVisual));
                    }
                }
                else {
                    // we still need to populate this.transformedData so the legend can get created.
                    tempDataset.push(dataSetForNoData(seriesVisual));
                }
            }
        };
        var this_1 = this;
        // For each metric result..
        for (var index = 0; index < allSeriesData.length; index++) {
            _loop_1(index);
        }
        this._transformedData = this._transformedData.concat(tempDataset);
        if (isStackChart) {
            if (this._stackedDataset && this._stackedDataset.length > 0) {
                this._stackedDataset = d3.layout.stack()(this._stackedDataset);
            }
            else {
                this._stackedDataset = [];
            }
        }
    };
    AiTimeSeriesChart.prototype.fixSeriesVisual = function (seriesData) {
        // Check the metric/resource name is specified.
        if (Util.isNullOrUndefined(seriesData) || Util.isNullOrUndefined(seriesData.visualization)) {
            Telemetry.logWarning("AiTimeSeriesChart: series visualization was not specified", this.telemetryContext);
            // Push temp visualization.
            var tempVisual = {
                displayName: seriesData.metricResults && seriesData.metricResults.metricId ? seriesData.metricResults.metricId.name.id : "",
                resourceDisplayName: seriesData.metricResults && seriesData.metricResults.metricId ? seriesData.metricResults.metricId.resourceDefinition.id : "",
                color: Constants.Colors.defaultSeriesColor,
            };
            return tempVisual;
        }
        else {
            var seriesVisualization = seriesData.visualization;
            // If the metric name is not specified.
            if (Util.isNullOrWhiteSpace(seriesData.visualization.displayName)) {
                seriesVisualization.displayName = seriesData.metricResults && seriesData.metricResults.metricId ? seriesData.metricResults.metricId.name.id : "";
            }
            // If the resource name is not specified.
            if (Util.isNullOrWhiteSpace(seriesData.visualization.resourceDisplayName)) {
                seriesVisualization.resourceDisplayName = seriesData.metricResults && seriesData.metricResults.metricId ? seriesData.metricResults.metricId.resourceDefinition.id : "";
            }
            // If color is not specified we default to default series color.
            if (Util.isNullOrUndefined(seriesData.visualization.color)) {
                seriesVisualization.color = Constants.Colors.defaultSeriesColor;
            }
            if (Util.isNullOrUndefined(seriesVisualization.missingDataFillType)) {
                var aggregation = seriesData.metricResults && seriesData.metricResults.aggregation ? seriesData.metricResults.aggregation : 1 /* Sum */;
                seriesVisualization.missingDataFillType = FeatureFlagService_1.getMissingValueFillType(this._visualOptions.chartType, aggregation);
            }
            return seriesVisualization;
        }
    };
    AiTimeSeriesChart.prototype._getSeriesColor = function (index) {
        var colorIndex = index % this._groupColors.length;
        return this._isSegmented || !this._transformedData[index] || !this._transformedData[index].seriesMetadata
            ? this._groupColors[colorIndex]
            : (this._transformedData[index].seriesMetadata ? this._transformedData[index].seriesMetadata.color : Constants.Colors.defaultSeriesColor);
    };
    /**
     * Returns the appropriate legend display value.
     * For a segmented chart it is the segment name, for multi-metric chart it is the metric display name,
     */
    AiTimeSeriesChart.prototype.getLegendMetricDisplayName = function (index) {
        return this._transformedData[index] ? this._transformLegendDisplayName(this._transformedData[index].seriesMetadata.displayName) : "";
    };
    /**
     * Returns the appropriate legend metric value.
     * For a segmented chart it is the segment name, for multi-metric chart it is the metric display name.
     */
    AiTimeSeriesChart.prototype._getLegendMetricTitleValue = function (index) {
        return (this._transformedData[index] && this._transformedData[index].seriesMetadata && this._transformedData[index].seriesMetadata.displayName) || "";
    };
    /**
     * Returns the appropriate legend resource display value.
     */
    AiTimeSeriesChart.prototype.getLegendResourceDisplayName = function (index) {
        // Grab resource name from first item in series visualization.
        if (this._isSegmented) {
            index = 0;
        }
        return this._transformedData[index] && this._transformedData[index].seriesMetadata
            ? this._transformLegendDisplayName(this._transformedData[index].seriesMetadata.resourceDisplayName) : "";
    };
    /**
     * Returns the appropriate legend resource value.
     */
    AiTimeSeriesChart.prototype._getLegendResourceTitleValue = function (index) {
        return this._transformedData[index] && this._transformedData[index].seriesMetadata
            ? this._transformedData[index].seriesMetadata.resourceDisplayName : "";
    };
    /**
     * Returns the appropriate legend unit.
     * For a single metric (and segmented chart), the units will all be the same and taken from the first metric.
     * For a multi-metric chart, use the index to index into the seriesVisualization array and get the unit.
     */
    AiTimeSeriesChart.prototype._getLegendUnits = function (index) {
        try {
            return this._transformedData[index] && this._transformedData[index].seriesMetadata
                ? this._transformedData[index].seriesMetadata.unit : 1 /* Count */;
        }
        catch (e) {
            // If the results for don't specify series visualization details we default to a counter.
            if (e) {
                Telemetry.logError("AiTimeSeriesChart", this.telemetryContext, e, { ErrorMessage: e.message, Error: e.stack });
            }
            return 1 /* Count */;
        }
    };
    AiTimeSeriesChart.prototype._getLegendSummaryValue = function (index) {
        return this._transformedData[index] && this._transformedData[index].summary;
    };
    /* tslint:disable:no-switch-case-fall-through */
    AiTimeSeriesChart.prototype.createLegends = function () {
        var _this = this;
        var legendArea = this._aiChart.legendElement.selectAll(".fxc-monitorchart-legendsContainer");
        var uniqueId = this._uniqueId;
        if (!this._visualOptions.legend.isVisible) {
            // Clean any existing legends on chart.
            legendArea.attr("display", "none");
            return;
        }
        var hideSubtitle = this._visualOptions.legend.hideSubtitle;
        if (legendArea.empty()) {
            this._aiChart.legendElement.append("g").classed("fxc-monitorchart-legendsContainer", true);
        }
        // If legends were previously removed, show them back.
        legendArea.attr("display", "inherit");
        // Create legend container for accessibility
        var legendContainer = legendArea.selectAll(".fxc-monitorchart-legend").data(this._transformedData);
        legendContainer.classed("fxc-monitorchart-legend", true);
        legendContainer.enter()
            .append("g")
            .classed("fxc-monitorchart-legend", true)
            .attr({
            "id": function (d) { return "legend-container-" + getUniqueTransformedDataId(uniqueId, d); },
            "aria-labelledby": function (d) {
                var id = getUniqueTransformedDataId(uniqueId, d);
                return "legend-metric-" + id +
                    " legend-resource-" + id +
                    " legend-value-" + id +
                    " legend-units-" + id;
            },
            "role": "group",
        }).on("mouseover", function (d, i) {
            if (_this._visualOptions.chartType === 1 /* Bar */) {
                _this._aiChart.svgElement.selectAll(".fxc-monitorchart-bargroup").classed("notSelected", function (data, index) {
                    return i !== index;
                });
                _this._aiChart.svgElement.selectAll(".fxc-monitorchart-bargroup").classed("Selected", function (data, index) {
                    return i === index;
                });
            }
            else if (_this._visualOptions.chartType === 7 /* Scatter */) {
                _this._aiChart.svgElement.selectAll(".scatterGroup").classed("notSelected", function (data, index) {
                    return i !== index;
                });
                _this._aiChart.svgElement.selectAll(".scatterGroup").classed("Selected", function (data, index) {
                    return i === index;
                });
                _this._aiChart.svgElement.selectAll("circle.fxc-monitorchart-timeSeriesPoints-dot").attr("r", 3.5);
                _this._aiChart.svgElement.selectAll(".scatterGroup").filter(function (data, index) {
                    return i === index;
                }).selectAll("circle.fxc-monitorchart-timeSeriesPoints-dot").attr("r", 4.5);
            }
            else if (_this._visualOptions.chartType === 3 /* Area */ || _this._visualOptions.chartType === 2 /* Line */) {
                _this._aiChart.svgElement.selectAll(".fxc-monitorchart-lineContainer").classed("notSelected", function (data, index) {
                    return i !== index;
                });
                _this._aiChart.svgElement.selectAll(".fxc-monitorchart-lineContainer").classed("Selected", function (data, index) {
                    return i === index;
                });
            }
            legendArea.selectAll(".fxc-monitorchart-legend").classed("notSelected", function (data, index) {
                return i !== index;
            });
        })
            .on("mouseout", function (d, i) {
            // fallback to keyboard focus, if any.
            if (_this._visualOptions.chartType === 1 /* Bar */) {
                _this._aiChart.svgElement.selectAll(".fxc-monitorchart-bargroup").classed("notSelected", function (data, index) {
                    return _this._isFocused && (index !== _this._keyboardSelectedSeriesIndex);
                });
                _this._aiChart.svgElement.selectAll(".fxc-monitorchart-bargroup").classed("Selected", function (data, index) {
                    return _this._isFocused && (index === _this._keyboardSelectedSeriesIndex);
                });
            }
            else if (_this._visualOptions.chartType === 7 /* Scatter */) {
                _this._aiChart.svgElement.selectAll(".scatterGroup").classed("notSelected", function (data, index) {
                    return _this._isFocused && (index !== _this._keyboardSelectedSeriesIndex);
                });
                _this._aiChart.svgElement.selectAll(".scatterGroup").classed("Selected", function (data, index) {
                    return _this._isFocused && (index === _this._keyboardSelectedSeriesIndex);
                });
                _this._aiChart.svgElement.selectAll("circle.fxc-monitorchart-timeSeriesPoints-dot").attr("r", 3.5);
                _this._aiChart.svgElement.selectAll(".scatterGroup").filter(function (data, index) {
                    return _this._keyboardSelectedSeriesIndex === index;
                }).selectAll("circle.fxc-monitorchart-timeSeriesPoints-dot").attr("r", 4.5);
            }
            else if (_this._visualOptions.chartType === 3 /* Area */ || _this._visualOptions.chartType === 2 /* Line */) {
                _this._aiChart.svgElement.selectAll(".fxc-monitorchart-lineContainer").classed("notSelected", function (data, index) {
                    return _this._isFocused && (index !== _this._keyboardSelectedSeriesIndex);
                });
                _this._aiChart.svgElement.selectAll(".fxc-monitorchart-lineContainer").classed("Selected", function (data, index) {
                    return _this._isFocused && (index === _this._keyboardSelectedSeriesIndex);
                });
            }
            legendArea.selectAll(".fxc-monitorchart-legend").classed("notSelected", function (data, index) {
                return _this._isFocused && (index !== _this._keyboardSelectedSeriesIndex);
            });
        });
        legendContainer.exit().remove();
        // Create legend rectangle markers. Creates as many rectangles as there are data entries.
        var legendRect = createLegendColorBar(legendContainer, hideSubtitle, uniqueId);
        // Create METRIC NAME.
        var legendText = legendContainer.selectAll(".fxc-monitorchart-metric").data(function (d, i) {
            return d3FormatSummaryData(getUniqueTransformedDataId(uniqueId, d), i);
        });
        legendText
            .text(function (d) { return _this.getLegendMetricDisplayName(d.index); })
            .append("svg:title").text(function (d) { return _this._getLegendMetricTitleValue(d.index); });
        legendText.enter()
            .append("text")
            .classed("fxc-monitorchart-metric", true)
            .attr({
            "id": function (d) { return "legend-metric-" + d.data; },
            "aria-hidden": true,
        })
            .text(function (d) { return _this.getLegendMetricDisplayName(d.index); })
            .append("svg:title").text(function (d) { return _this._getLegendMetricTitleValue(d.index); });
        legendText.exit().remove();
        // Create RESOURCE NAME.
        var legendResourceText;
        if (!hideSubtitle) {
            legendResourceText = legendContainer.selectAll(".fxc-monitorchart-resource").data(function (d, i) {
                return d3FormatSummaryData(getUniqueTransformedDataId(uniqueId, d), i);
            });
            legendResourceText
                .text(function (d) { return _this.getLegendResourceDisplayName(d.index); })
                .append("svg:title").text(function (d) { return _this._getLegendResourceTitleValue(d.index); });
            legendResourceText.enter()
                .append("text")
                .classed("fxc-monitorchart-resource", true)
                .attr({
                "id": function (d) { return "legend-resource-" + d.data; },
                "aria-hidden": true,
            })
                .text(function (d) { return _this.getLegendResourceDisplayName(d.index); })
                .append("svg:title").text(function (d) { return _this._getLegendResourceTitleValue(d.index); });
            legendResourceText.exit().remove();
        }
        // Create LEGEND VALUE.
        var legendValueText = legendContainer.selectAll(".fxc-monitorchart-value").data(function (d, i) {
            return d3FormatSummaryData(d, i);
        });
        var units = [];
        legendValueText
            .text(function (d) {
            return _this._processUnit(d.data && d.data.summary, d.index, units);
        });
        legendValueText.enter()
            .append("text")
            .classed("fxc-monitorchart-value", true)
            .attr({
            "id": function (d) { return "legend-value-" + getUniqueTransformedDataId(uniqueId, d.data); },
            "aria-hidden": true,
        })
            .text(function (d) {
            return _this._processUnit(d.data && d.data.summary, d.index, units);
        });
        legendValueText.exit().remove();
        // Create LEGEND UNITS.
        var legendUnits = legendValueText.selectAll(".fxc-monitorchart-units").data(function (d, i) {
            return d3FormatSummaryData(units[i], i);
        });
        legendUnits.text(function (d) {
            return d.data;
        });
        legendUnits.enter()
            .append("tspan")
            .classed("fxc-monitorchart-units", true)
            .attr({
            "id": function (d) { return "legend-units-" + getUniqueTransformedDataId(uniqueId, _this._transformedData[d.index]); },
            "aria-hidden": true,
        })
            .text(function (d) {
            return " " + d.data;
        });
        legendUnits.exit().remove();
        var lineHeight = 11;
        var linePadding = 3; // should match margin in .fxc-monitorchart-metric
        var textOffset = 10; // the offset from the rect box to the text.
        switch (this._visualOptions.legend.position) {
            case 4 /* Right */:
                legendRect
                    .attr({
                    "x": 0,
                    "y": this._getD3LegendYValueDef(0),
                    "fill": function (d) { return _this._getSeriesColor(d.index); },
                });
                legendText
                    .attr({
                    "x": textOffset,
                    "y": this._getD3LegendYValueDef(lineHeight),
                });
                if (!hideSubtitle) {
                    legendResourceText
                        .attr({
                        "x": textOffset,
                        "y": this._getD3LegendYValueDef(lineHeight * 2),
                    });
                }
                legendValueText
                    .attr({
                    "x": textOffset,
                    "y": !!hideSubtitle ? this._getD3LegendYValueDef(lineHeight * 2 + linePadding) : this._getD3LegendYValueDef(lineHeight * 4),
                });
                break;
            case 2 /* Bottom */:
            default:
                legendRect
                    .attr({
                    "x": this._getXValueDefForBottomLegend(0),
                    "y": 0,
                    "fill": function (d) { return _this._getSeriesColor(d.index); },
                });
                legendText
                    .attr({
                    "x": this._getXValueDefForBottomLegend(textOffset),
                    "y": lineHeight,
                });
                if (!hideSubtitle) {
                    legendResourceText
                        .attr({
                        "x": this._getXValueDefForBottomLegend(textOffset),
                        "y": lineHeight * 2,
                    });
                }
                legendValueText
                    .attr({
                    "x": this._getXValueDefForBottomLegend(textOffset),
                    "y": function () {
                        if (!!hideSubtitle) {
                            return lineHeight * 2 + linePadding;
                        }
                        else {
                            return lineHeight * 4;
                        }
                    },
                });
        }
        if (!!hideSubtitle) {
            legendText.style("font-size", "10px");
            legendValueText.style("font-size", "14px");
        }
    };
    /**
     * Method to calculate the units the legend value.
     */
    AiTimeSeriesChart.prototype._configureLegend = function (originalValue, index) {
        var _transformedLegend;
        var originalUnit = this._getLegendUnits(index);
        var displaySIUnit = !!(this._transformedData && this._transformedData[index] && this._transformedData[index].seriesMetadata && this._transformedData[index].seriesMetadata.displaySIUnit);
        var useSIConversions = !!(this._transformedData && this._transformedData[index] && this._transformedData[index].seriesMetadata && this._transformedData[index].seriesMetadata.useSIConversions);
        switch (originalUnit) {
            case 7 /* MilliSeconds */:
                _transformedLegend = LocaleFormatter.formatTime(originalValue, TimeUnits.milliseconds);
                break;
            case 6 /* Seconds */:
                _transformedLegend = LocaleFormatter.formatTime(originalValue, TimeUnits.seconds);
                break;
            case 5 /* Percent */:
                _transformedLegend = LocaleFormatter.formatPercentages(originalValue);
                break;
            case 2 /* Bytes */:
                _transformedLegend = LocaleFormatter.formatBytes(originalValue, useSIConversions, displaySIUnit);
                break;
            case 4 /* BytesPerSecond */:
                var bytesLegend = LocaleFormatter.formatBytes(originalValue, useSIConversions, displaySIUnit);
                _transformedLegend = {
                    value: bytesLegend.value,
                    unit: bytesLegend.unit + Strings.perSecond,
                };
                break;
            case 3 /* CountPerSecond */:
                var countPerSecondLegend = LocaleFormatter.formatCounts(originalValue);
                _transformedLegend = {
                    value: countPerSecondLegend.value,
                    unit: countPerSecondLegend.unit + Strings.perSecond,
                };
                break;
            case 1 /* Count */:
            case 0 /* None */:
            default:
                _transformedLegend = LocaleFormatter.formatCounts(originalValue);
                break;
        }
        return _transformedLegend;
    };
    /* tslint:enable:no-switch-case-fall-through */
    AiTimeSeriesChart.prototype._createAxes = function (showNoDataOrErrorMessage) {
        var _this = this;
        this._xScaleStored = this._xScale();
        this._yScaleStored = this._yScale();
        // Create scale functions.
        var xScale = this._xScale();
        var yScale = this._yScale();
        // Create x-axis.
        if (this._visualOptions.axis.x.isVisible) {
            var xAxis = d3.svg.axis()
                .outerTickSize(0)
                .tickFormat(function (d) { return LocaleFormatter.formatAxisTime(d, _this.getVisualization().axis.x.axisType === 3 /* DateUTC */); })
                .scale(xScale)
                .orient("bottom").ticks(4);
            var oldXAxis = this._aiChart.svgElement.select("g.x.fxc-monitorchart-axis");
            if (!oldXAxis.empty()) {
                oldXAxis
                    .attr("transform", "translate(0," + Math.abs(this._chartHeight - 25 /* PaddingBottom */) + ")")
                    .call(xAxis);
            }
            else {
                this._aiChart.svgElement.append("g")
                    .attr({
                    "class": "x fxc-monitorchart-axis",
                    "pointer-events": "none",
                    "transform": "translate(0," + Math.abs(this._chartHeight - 25 /* PaddingBottom */) + ")",
                })
                    .call(xAxis);
            }
            var gxaxis = this._aiChart.svgElement.select(".x.fxc-monitorchart-axis");
            // Add Classes
            gxaxis.selectAll("g.tick")
                .classed("fxc-monitorchart-tick", true);
            gxaxis.selectAll("g.tick text")
                .classed("fxc-monitorchart-tick-text", true)
                .attr("aria-hidden", true);
            gxaxis.selectAll("g.tick line")
                .classed("fxc-monitorchart-tick-line", true);
            gxaxis.selectAll("path")
                .classed("fxc-monitorchart-tick-path", true);
            // Show axis if hidden previously
            this._aiChart.svgElement.selectAll("g.x.fxc-monitorchart-axis").attr("display", "inherit");
        }
        else {
            // Hide axis if requested
            this._aiChart.svgElement.selectAll("g.x.fxc-monitorchart-axis").attr("display", "none");
        }
        // Create y-axis.
        if (this._visualOptions.axis.y.isVisible) {
            var yAxis = d3.svg.axis()
                .scale(yScale).orient("left")
                .innerTickSize(getPlottableAreaMargin().right - this._chartWidth)
                .outerTickSize(-getPlottableAreaMargin().right);
            var chartHeight = this._chartHeight;
            var tickCount = Math.floor(chartHeight / 30 /* yAxisTickHeightMin */);
            if (tickCount < 10) {
                // to avoid each y tick is too close to each other.
                yAxis.ticks(tickCount);
            }
            // TODO : We only support one y axis currently so we use the first metric unit
            var unit = this._getLegendUnits(0);
            var displaySIUnit_1 = !!(this._transformedData && this._transformedData[0] && this._transformedData[0].seriesMetadata && this._transformedData[0].seriesMetadata.displaySIUnit);
            var useSIConversions_1 = !!(this._transformedData && this._transformedData[0] && this._transformedData[0].seriesMetadata && this._transformedData[0].seriesMetadata.useSIConversions);
            /* tslint:disable:no-switch-case-fall-through */
            switch (unit) {
                case 6 /* Seconds */:
                    yAxis.tickFormat(function (d) {
                        var data = LocaleFormatter.formatTime(d, TimeUnits.seconds, true);
                        return data.value + data.unit;
                    });
                    break;
                case 7 /* MilliSeconds */:
                    yAxis.tickFormat(function (d) {
                        var data = LocaleFormatter.formatTime(d, TimeUnits.milliseconds, true);
                        return data.value + data.unit;
                    });
                    break;
                case 5 /* Percent */:
                    yAxis.tickFormat(function (d) { return d + "%"; });
                    break;
                case 2 /* Bytes */:
                    yAxis.tickFormat(function (d) {
                        var data = LocaleFormatter.formatBytes(d, useSIConversions_1, displaySIUnit_1);
                        return data.value + data.unit;
                    });
                    break;
                case 4 /* BytesPerSecond */:
                    yAxis.tickFormat(function (d) {
                        var data = LocaleFormatter.formatBytes(d, useSIConversions_1, displaySIUnit_1);
                        return data.value + data.unit + Strings.perSecond;
                    });
                    break;
                case 3 /* CountPerSecond */:
                    yAxis.tickFormat(function (d) {
                        var data = LocaleFormatter.formatCounts(d);
                        return data.value + data.unit + Strings.perSecond;
                    });
                    break;
                case 1 /* Count */:
                default:
                    yAxis.tickFormat(function (d) {
                        var data = LocaleFormatter.formatCounts(d);
                        return data.value + data.unit;
                    });
                    break;
            }
            /* tslint:enable:no-switch-case-fall-through */
            var oldYAxis = this._aiChart.svgElement.select("g.y.fxc-monitorchart-axis");
            if (!oldYAxis.empty()) {
                oldYAxis.call(yAxis)
                    .selectAll("g.fxc-monitorchart-tick")
                    .classed("fxc-monitorchart-minor", true)
                    .selectAll("text")
                    .classed("fxc-monitorchart-tick-text", true)
                    .attr("aria-hidden", true)
                    .attr({ "x": 22, "dy": -2 })
                    .selectAll("path")
                    .classed("fxc-monitorchart-tick-path", true)
                    .style("display", "none");
            }
            else {
                this._aiChart.svgElement.append("g")
                    .attr({
                    "class": "y fxc-monitorchart-axis",
                    "pointer-events": "none",
                    "transform": "translate(" + 25 /* PaddingLeft */ + ", 0)",
                })
                    .call(yAxis);
            }
            // Show axis if hidden previously
            var gyaxis = this._aiChart.svgElement.selectAll("g.y.fxc-monitorchart-axis").attr("display", "inherit");
            gyaxis.selectAll("g.tick")
                .classed({ "fxc-monitorchart-minor": true, "fxc-monitorchart-tick": true });
            gyaxis.selectAll("g.tick text")
                .classed("fxc-monitorchart-tick-text", true)
                .attr("aria-hidden", true)
                .attr({ "x": 22, "dy": -2 });
            gyaxis.selectAll("g.tick line")
                .classed({
                "fxc-monitorchart-tick-line-nodata": showNoDataOrErrorMessage,
                "fxc-monitorchart-tick-line": !showNoDataOrErrorMessage,
            });
            gyaxis.selectAll("path")
                .classed("fxc-monitorchart-tick-path", true)
                .style("display", "none");
        }
        else {
            // Hide axis if requested
            this._aiChart.svgElement.selectAll("g.y.fxc-monitorchart-axis").attr("display", "none");
        }
    };
    // Method to return a time based scale for xaxis
    AiTimeSeriesChart.prototype._xScale = function () {
        var scale = (this._visualOptions.axis.x.axisType === 2 /* DateLocal */)
            ? d3.time.scale() : d3.time.scale.utc();
        var domain;
        if (this._transformedData.length !== 0 && this.keyset.length !== 0) {
            // has data.
            if (this._viewPortTimeRange && this._viewPortTimeRange.startTime && this._viewPortTimeRange.endTime) {
                domain = [this._viewPortTimeRange.startTime, this._viewPortTimeRange.endTime];
            }
            else {
                domain = [this.keyset[0], this.keyset[this.keyset.length - 1]];
            }
        }
        else {
            // no data
            var xAxis = this.getVisualization().axis.x;
            if (xAxis.max && xAxis.min) {
                domain = [new Date(xAxis.min), new Date(xAxis.max)];
            }
            else {
                domain = [d3.time.day.offset(new Date(), Constants.DefaultChartDurationInDays), new Date()];
            }
        }
        return scale
            .domain(domain)
            .range([getPlottableAreaMargin().left, this._chartWidth - getPlottableAreaMargin().right]);
    };
    // Method to return a liner scale for y axis
    AiTimeSeriesChart.prototype._yScale = function () {
        var domain;
        if (this._stackedDataset && this._stackedDataset.length !== 0) {
            var minYValue = void 0;
            var yAxis = this.getVisualization().axis.y;
            if (!Util.isNullOrUndefined(yAxis.min)) {
                minYValue = yAxis.min;
            }
            else {
                minYValue = d3.min(this._stackedDataset, function (layer) {
                    return d3.min(layer, function (d) {
                        return d.y0 + d.y;
                    });
                });
                // If the minimum data value is positive value, we force it to start from 0
                minYValue = minYValue < 0 ? minYValue : 0;
            }
            var maxYValue = undefined;
            if (!Util.isNullOrUndefined(yAxis.max)) {
                maxYValue = yAxis.max;
            }
            else {
                maxYValue = d3.max(this._stackedDataset, function (layer) {
                    return d3.max(layer, function (d) {
                        return (d.y0 + d.y) * 1.15; // give 15% buffer for max y value to avoid chart stay at the very top
                    });
                });
                maxYValue = maxYValue || 0;
            }
            domain = [
                minYValue || 0,
                maxYValue === minYValue ? 100 : maxYValue,
            ];
        }
        else {
            domain = [0, 100];
        }
        return d3.scale.linear()
            .domain(domain)
            .range([this._chartHeight - 25 /* PaddingBottom */, 15 /* PaddingTop */]);
    };
    AiTimeSeriesChart.prototype._getOrCreateClipPathContainer = function () {
        var clipPathContainer = this._aiChart.svgElement.select("#clipPathContainer-" + this._uniqueId);
        // Note: Create a container for "clip-path", so we can guarantee that "clip-path" only get applied once for the whole svg element.
        //       Because Edge doesn't handel clip-path get applied multiple times properly.
        if (clipPathContainer.empty()) {
            clipPathContainer = this._aiChart.svgElement.append("g")
                .attr({
                "id": "clipPathContainer-" + this._uniqueId,
                "fill": "transparent",
                "width": "100%",
                "pointer-events": "none",
            })
                .style("clip-path", this._clipPathUniqueId)
                .classed("fxc-monitorchart-clipPathContainer", true);
        }
        return clipPathContainer;
    };
    /**
     *  Create the container element containing the chart data points and guidelines for hover
     */
    AiTimeSeriesChart.prototype._getOrCreateChartContainerArtifacts = function () {
        var clipPathContainer = this._getOrCreateClipPathContainer();
        var graphContainer = clipPathContainer.select("#graphContainer-" + this._uniqueId);
        if (graphContainer.empty()) {
            graphContainer = clipPathContainer.append("g")
                .attr({
                "id": "graphContainer-" + this._uniqueId,
                "fill": "transparent",
                "width": "100%",
                "pointer-events": "none",
            })
                .classed("fxc-monitorchart-graphContainer", true);
        }
        // Create temporary guideline for hover
        var guideline = this._aiChart.svgElement.selectAll("line.fxc-monitorchart-guideline." + this._uniqueId);
        if (guideline.empty()) {
            this._aiChart.svgElement.append("line")
                .attr({
                "class": "fxc-monitorchart-guideline " + this._uniqueId,
                "stroke": "grey",
                "stroke-width": 1,
                "pointer-events": "none",
            })
                .style("display", "none");
        }
        // always set the guideline's x and y to avoid hover lines out of sync
        guideline.attr({
            "x1": this._chartWidth + getPlottableAreaMargin().right + 20,
            "y1": 0 + 15 /* PaddingTop */,
            "x2": this._chartWidth + getPlottableAreaMargin().right + 20,
            "y2": this._chartHeight - 25 /* PaddingBottom */,
        });
        // Create temporary tick text for hover
        var temptick = this._aiChart.svgElement.selectAll("text.fxc-monitorchart-temp-tick." + this._uniqueId);
        if (temptick.empty()) {
            this._aiChart.svgElement.append("text")
                .attr("class", "fxc-monitorchart-temp-tick " + this._uniqueId)
                .text("");
        }
        // always set the temptick's x and y to avoid hover lines out of sync
        temptick.attr({
            "x": this._chartWidth + getPlottableAreaMargin().right + 30,
            "y": this._chartHeight - 25 /* PaddingBottom */ + 20,
        });
        return graphContainer;
    };
    AiTimeSeriesChart.prototype._drawBars = function () {
        var _this = this;
        // Create scale functions.
        var xScale = this._xScale();
        var yScale = this._yScale();
        var graphContainer = this._getOrCreateChartContainerArtifacts();
        this._createTimeBrush(graphContainer);
        this._createClickCaptureRectangle(graphContainer);
        // Create bars.
        var histogramBarsGroup = graphContainer.selectAll("g.fxc-monitorchart-bargroup").data(this._stackedDataset);
        histogramBarsGroup.style("fill", function (d, i) { return _this._getSeriesColor(i); })
            .attr("pointer-events", "none");
        histogramBarsGroup.enter().append("g")
            .attr({
            "class": "fxc-monitorchart-bargroup",
            "pointer-events": "none",
        })
            .style("fill", function (d, i) { return _this._getSeriesColor(i); });
        histogramBarsGroup.exit().remove();
        var histogramBars = histogramBarsGroup.selectAll("rect.fxc-monitorchart-bars").data(function (d) { return d; });
        var datasetSize = !Util.isNullOrUndefined(this._stackedDataset[0]) ? this._stackedDataset[0].length : this._stackedDataset.length;
        // If SVG element is available, calculate width otherwise use default of 10
        var perBarWidth = !this._aiChart.svgElement.empty()
            ? Math.max(calculateBarWidth(this._chartWidth - getPlottableAreaMargin().left - getPlottableAreaMargin().right, datasetSize), 5 /* BarWidthPerPointMin */)
            : 10 /* BarWidthDefault */;
        histogramBars
            .transition()
            .attr({
            "class": "fxc-monitorchart-timeSeriesPoints fxc-monitorchart-bars",
            "id": function (d) {
                return "id-" + getUniqueDatasetId(_this._uniqueId, d) + "-" + d.x.getTime();
            },
            "x": function (d) { return xScale(d.x) - perBarWidth / 2; },
            "y": function (d) { return yScale(d.y + d.y0); },
            "width": perBarWidth,
            "height": function (d) { return yScale(d.y); },
            "pointer-events": "none",
        });
        // Add new bars
        histogramBars.enter()
            .append("rect")
            .classed("fxc-monitorchart-timeSeriesPoints fxc-monitorchart-bars", true)
            .transition()
            .attr({
            "id": function (d) {
                return "id-" + getUniqueDatasetId(_this._uniqueId, d) + "-" + d.x.getTime();
            },
            "x": function (d) { return xScale(d.x) - perBarWidth / 2; },
            "y": function (d) { return yScale(d.y + d.y0); },
            "width": perBarWidth,
            "height": function (d) { return yScale(d.y0) - yScale(d.y + d.y0); },
            "pointer-events": "none",
        });
        // Remove old bars
        histogramBars.exit()
            .remove();
    };
    AiTimeSeriesChart.prototype._drawPoints = function () {
        var _this = this;
        // Create scale functions.
        var xScale = this._xScale();
        var yScale = this._yScale();
        var graphContainer = this._getOrCreateChartContainerArtifacts();
        this._createTimeBrush(graphContainer);
        this._createClickCaptureRectangle(graphContainer);
        // Create group element.
        var scatterGroup = graphContainer.selectAll("g.scatterGroup").data(this._stackedDataset);
        scatterGroup.style("fill", function (d, i) { return _this._getSeriesColor(i); })
            .attr("pointer-events", "none");
        scatterGroup.enter().append("g")
            .attr({
            "class": "scatterGroup",
            "pointer-events": "none",
        })
            .style("fill", function (d, i) { return _this._getSeriesColor(i); });
        scatterGroup.exit().remove();
        var scatterPoints = scatterGroup.selectAll("circle.fxc-monitorchart-timeSeriesPoints-dot").data(function (d) { return d; });
        scatterPoints
            .attr({
            "class": "fxc-monitorchart-timeSeriesPoints fxc-monitorchart-timeSeriesPoints-dot",
            "id": function (d) {
                return "id-" + getUniqueDatasetId(_this._uniqueId, d) + "-" + new Date(d.x).getTime();
            },
            "r": 3.5,
            "cx": function (d) { return xScale(d.x); },
            "cy": function (d) { return yScale(d.y); },
            "pointer-events": "none",
        })
            .style("display", function (d) { return d && d.missingValue ? "none" : "flex"; });
        // Add new scatter points
        scatterPoints.enter()
            .append("circle")
            .classed("fxc-monitorchart-timeSeriesPoints fxc-monitorchart-timeSeriesPoints-dot", true)
            .transition()
            .attr({
            "id": function (d) {
                return "id-" + getUniqueDatasetId(_this._uniqueId, d) + "-" + new Date(d.x).getTime();
            },
            "r": 3.5,
            "cx": function (d) { return xScale(d.x); },
            "cy": function (d) { return yScale(d.y); },
            "pointer-events": "none",
        })
            .style("display", function (d) { return d && d.missingValue ? "none" : "flex"; });
        // Remove old scatter points
        scatterPoints.exit()
            .remove();
        this._drawHoverMarker();
    };
    AiTimeSeriesChart.prototype._drawLines = function () {
        var graphContainer = this._getOrCreateChartContainerArtifacts();
        this._createTimeBrush(graphContainer);
        this._createClickCaptureRectangle(graphContainer);
        var definedDataAll = function (d) { return true; };
        if (this._hasMissingValues) {
            // has missing data on the chart, draw as two paths based on feature flag.
            // data that has real values
            var definedData = function (d) { return !d.missingValue && (!d.nextValueMissing || !d.previousValueMissing); };
            // data that are filled with missing values.
            var definedMissingData = function (d) { return d.missingValue || d.nextValueMissing || d.previousValueMissing; };
            // line style for missing values.
            var lineStyle = FeatureFlagService_1.getLineStyleForMissingValue();
            switch (lineStyle) {
                case 2 /* DottedLine */:
                    // draw two path, for for real data, one for missing values with dotted line.
                    this._drawSVGPath(graphContainer, false, definedData, 2 /* DottedLine */);
                    this._drawSVGPath(graphContainer, true, definedMissingData, 2 /* DottedLine */);
                    break;
                case 1 /* Transparent */:
                    // draw two path, for for real data, one for missing values with semi-transparent lines..
                    this._drawSVGPath(graphContainer, false, definedData, 1 /* Transparent */);
                    this._drawSVGPath(graphContainer, true, definedMissingData, 1 /* Transparent */);
                    break;
                case 3 /* Disappearing */:
                    this._drawSVGPath(graphContainer, false, definedData, 3 /* Disappearing */);
                    this._drawSVGPath(graphContainer, true, definedMissingData, 3 /* Disappearing */);
                    var fullDiscoPoints_1 = [];
                    this._stackedDataset.forEach(function (item, i) {
                        item.forEach(function (rowItem) {
                            if (!rowItem.missingValue) {
                                if (rowItem.nextValueMissing && rowItem.previousValueMissing) {
                                    fullDiscoPoints_1.push({ rowItem: rowItem, series: i });
                                }
                            }
                        });
                    });
                    this._drawSVGPoints(graphContainer, fullDiscoPoints_1);
                    break;
                default:
                    this._drawSVGPath(graphContainer, false, definedDataAll, undefined);
                    break;
            }
        }
        else {
            // no missing data on the chart, draw one path.
            this._drawSVGPath(graphContainer, false, definedDataAll, undefined);
        }
        this._drawHoverMarker();
    };
    AiTimeSeriesChart.prototype._drawHoverMarker = function () {
        var _this = this;
        var clipPathContainer = this._getOrCreateClipPathContainer();
        // Create a separated container (g) for hover marker.
        // Note: Don't put the hover marker (circle) in the same container as path (line),
        //       Otherwise, the circle will get placed before path in DOM and result in path cross over the hollow circle for missing values.
        var hoverContainer = clipPathContainer.select("#hoverContainer-" + this._uniqueId);
        if (hoverContainer.empty()) {
            hoverContainer = clipPathContainer.append("g")
                .attr({
                "id": "hoverContainer-" + this._uniqueId,
                "fill": "transparent",
                "width": "100%",
                "pointer-events": "none",
            })
                .classed("fxc-monitorchart-hoverContainer", true);
        }
        // Create hover marker
        var hoverMarkers = hoverContainer.selectAll("circle.fxc-monitorchart-marker." + this._uniqueId).data(this._transformedData);
        // Update
        hoverMarkers.attr({
            "class": "fxc-monitorchart-marker " + this._uniqueId,
            "r": 4,
            "pointer-events": "none",
        })
            .style({
            "display": "none",
            "fill": function (d, i) { return _this._getSeriesColor(i); },
            "stroke": function (d, i) { return _this._getSeriesColor(i); },
            "stroke-width": "3px",
        });
        // Add
        hoverMarkers.enter().append("circle")
            .attr({
            "class": "fxc-monitorchart-marker " + this._uniqueId,
            "r": 4,
            "pointer-events": "none",
        })
            .style({
            "display": "none",
            "fill": function (d, i) { return _this._getSeriesColor(i); },
            "stroke": function (d, i) { return _this._getSeriesColor(i); },
            "stroke-width": "3px",
        });
        // Remove
        hoverMarkers.exit().remove();
    };
    AiTimeSeriesChart.prototype._calculateYForChartType = function (chartPointRow) {
        var yScale = this._yScale();
        var yPos = chartPointRow.rowItem.y;
        if (this._visualOptions.chartType === 3 /* Area */) {
            yPos += chartPointRow.rowItem.y0;
        }
        return yScale(yPos);
    };
    AiTimeSeriesChart.prototype._adjustFillForAreaStroke = function (chartPoint, index, pathType, lineStyle) {
        if (lineStyle === 3 /* Disappearing */) {
            return "none";
        }
        if (pathType === 3 /* Area */) {
            return this._getSeriesColor(index);
        }
        return "none";
    };
    AiTimeSeriesChart.prototype._drawSVGPoints = function (graphContainer, fullDiscoPoints) {
        var _this = this;
        var fullMissingPoints = graphContainer.selectAll("circle.fxc-monitorchart-doubleEndedMissing").data(fullDiscoPoints);
        var className = "fxc-monitorchart-doubleEndedMissing";
        var xScale = this._xScale();
        fullMissingPoints
            .classed(className, true)
            .attr({
            "r": 2,
            "cx": function (d) { return xScale(d.rowItem.x); },
            "cy": this._calculateYForChartType.bind(this),
            "opacity": function (d) { return d.rowItem.y > 0 ? 1 : 0; },
            "pointer-events": "none",
        })
            .attr({
            "fill": function (d) { return _this._getSeriesColor(d.series); },
            "stroke": function (d) { return _this._getSeriesColor(d.series); },
            "stroke-width": "1px",
        });
        fullMissingPoints.enter().append("circle")
            .classed(className, true)
            .attr({
            "r": 2,
            "cx": function (d) { return xScale(d.rowItem.x); },
            "cy": this._calculateYForChartType.bind(this),
            "opacity": function (d) { return d.rowItem.y > 0 ? 1 : 0; },
            "pointer-events": "none",
        })
            .attr({
            "fill": function (d, i) { return _this._getSeriesColor(d.series); },
            "stroke": function (d, i) { return _this._getSeriesColor(d.series); },
            "stroke-width": "1px",
        });
        fullMissingPoints.exit().remove();
    };
    AiTimeSeriesChart.prototype._drawSVGPath = function (graphContainer, forMissingValue, definedData, lineStyle) {
        var chartLineContainers = graphContainer.selectAll(".fxc-monitorchart-lineContainer").data(this._stackedDataset);
        chartLineContainers.enter().append("g").classed("fxc-monitorchart-lineContainer", true);
        chartLineContainers.exit().remove();
        var chartLines;
        var className;
        if (forMissingValue) {
            chartLines = chartLineContainers.selectAll(".fxc-monitorchart-linePoints-missing").data(function (d, i) {
                return d3FormatSummaryData(d, i);
            });
            className = "fxc-monitorchart-timeSeriesPoints fxc-monitorchart-linePoints-missing";
        }
        else {
            chartLines = chartLineContainers.selectAll(".fxc-monitorchart-linePoints").data(function (d, i) {
                return d3FormatSummaryData(d, i);
            });
            className = "fxc-monitorchart-timeSeriesPoints fxc-monitorchart-linePoints";
        }
        // Create scale functions.
        var xScale = this._xScale();
        var yScale = this._yScale();
        // draw the path for the points that has values.
        var line = d3.svg.line()
            .defined(definedData)
            .x(function (d) { return xScale(new Date(d.x)); })
            .y(function (d) { return yScale(d.y + d.y0); });
        var areaPath;
        if (this._visualOptions.chartType === 3 /* Area */) {
            areaPath = d3.svg.area()
                .defined(definedData)
                .x(function (d) { return xScale(new Date(d.x)); })
                .y1(function (d) { return yScale(d.y + d.y0); })
                .y0(function (d) { return yScale(d.y0); });
        }
        // Update
        if (areaPath) {
            this._updateChartLines(chartLines, line, 2 /* Line */);
            this._updateChartLines(chartLines, areaPath, 3 /* Area */);
        }
        else {
            this._updateChartLines(chartLines, line, this._visualOptions.chartType);
        }
        // Add new chartLines
        if (forMissingValue) {
            if (lineStyle === 2 /* DottedLine */) {
                // do dotted line.
                if (areaPath) {
                    this._addNewChartLinesForDottedLineForMissingValue(chartLines, line, 2 /* Line */, className);
                    this._addNewChartLinesForDottedLineForMissingValue(chartLines, areaPath, 3 /* Area */, className);
                }
                else {
                    this._addNewChartLinesForDottedLineForMissingValue(chartLines, line, this._visualOptions.chartType, className);
                }
            }
            else {
                var targetOpacity = 0.5 /* LineStrokeOpacityForMissing */;
                if (lineStyle === 3 /* Disappearing */) {
                    targetOpacity = 0;
                }
                // do semi-transparent line
                if (areaPath) {
                    this._addNewChartLines(chartLines, line, 2 /* Line */, className, lineStyle, targetOpacity);
                    this._addNewChartLines(chartLines, areaPath, 3 /* Area */, className, lineStyle, targetOpacity);
                }
                else {
                    this._addNewChartLines(chartLines, line, this._visualOptions.chartType, className, lineStyle, targetOpacity);
                }
            }
        }
        else {
            if (areaPath) {
                this._addNewChartLines(chartLines, line, 2 /* Line */, className, 0 /* None */, 1);
                this._addNewChartLines(chartLines, areaPath, 3 /* Area */, className, 0 /* None */, 1);
            }
            else {
                this._addNewChartLines(chartLines, line, this._visualOptions.chartType, className, 0 /* None */, 1);
            }
        }
        chartLines.exit()
            .transition()
            .duration(0)
            .ease("linear")
            .remove();
    };
    AiTimeSeriesChart.prototype._updateChartLines = function (chartLines, path, pathType) {
        var _this = this;
        chartLines.attr("pointer-events", "none")
            .transition()
            .duration(0)
            .ease("linear")
            .attr({
            "d": path,
            "stroke-width": 2 /* LineStrokeWidth */,
            "stroke": function (d) { return _this._getSeriesColor(d.index); },
            "stroke-opacity": function (d) { return calculateStrokeOpacity(1, pathType); },
            "fill": function (d) { return _this._adjustFillForAreaStroke(d.data, d.index, pathType); },
            "fill-opacity": function (d) { return calculateFillOpacity(1, pathType); },
        });
    };
    AiTimeSeriesChart.prototype._addNewChartLinesForDottedLineForMissingValue = function (chartLines, path, pathType, className) {
        this._addNewChartLines(chartLines, path, pathType, className, 2 /* DottedLine */, 1)
            .attr("stroke-dasharray", ("3, 3"));
    };
    AiTimeSeriesChart.prototype._addNewChartLines = function (chartLines, path, pathType, className, lineStyle, targetOpacity) {
        var _this = this;
        return chartLines.enter().append("path")
            .classed(className, true)
            .transition()
            .duration(0)
            .ease("linear")
            .attr({
            "pointer-events": "none",
            "d": function (d) { return path(d.data, d.index); },
            "stroke-width": 2 /* LineStrokeWidth */,
            "stroke-opacity": function (d) { return calculateStrokeOpacity(targetOpacity, pathType); },
            "stroke": function (d) { return _this._getSeriesColor(d.index); },
            "fill": function (d) { return _this._adjustFillForAreaStroke(d.data, d.index, pathType, lineStyle); },
            "fill-opacity": function (d) { return calculateFillOpacity(1, pathType); },
        });
    };
    AiTimeSeriesChart.prototype._updateClipPath = function () {
        // Update x, y, width and height for the clip path
        var clipPath = this._aiChart.svgElement.select("rect.fxc-monitorchart-clipPath-" + this._uniqueId);
        if (!clipPath.empty()) {
            clipPath
                .attr({
                "x": getPlottableAreaMargin().left,
                "y": 15 /* PaddingTop */ - 10,
                "width": Math.abs(this._chartWidth - getPlottableAreaMargin().right - getPlottableAreaMargin().left),
                "height": this._chartHeight - 25 /* PaddingBottom */ - 15 /* PaddingTop */ + 10,
            });
        }
    };
    /**
     * Transforms the display name shown on the legend.
     */
    AiTimeSeriesChart.prototype._transformLegendDisplayName = function (displayName) {
        if (!!displayName && typeof displayName === "string") {
            if (this.getVisualization().legend.position === 2 /* Bottom */) {
                // If there is only one legend on bottom, we don't ellipsify
                return (displayName.length > 23 && this._transformedData.length > 1 ? (displayName.substring(0, 20) + "...") : displayName);
            }
            else {
                return (displayName.length >= 17 ? (displayName.substring(0, 14) + "...") : displayName);
            }
        }
        else {
            return Util.isNullOrWhiteSpace(displayName) ? Strings.undefinedMetricOrSegment : displayName;
        }
    };
    AiTimeSeriesChart.prototype._processUnit = function (value, index, units) {
        // Ensure that the current summary data is not null else display "--"
        if (value !== false && !Util.isNullOrUndefined(value) && !isNaN(value)) {
            // Recalculate the legend values to display the highest unit value.
            var legendData = this._configureLegend(value, index);
            units.push(legendData.unit);
            return legendData.value;
        }
        else {
            units.push("");
            return "--";
        }
    };
    // IAccessibleChart methods
    AiTimeSeriesChart.prototype.focusFirstSeries = function () {
        this.focusSeries(0);
    };
    AiTimeSeriesChart.prototype.focusLastSeries = function () {
        this.focusSeries(this._transformedData.length - 1);
    };
    AiTimeSeriesChart.prototype.focusNextSeries = function () {
        this.focusSeries(this._keyboardSelectedSeriesIndex + 1);
    };
    AiTimeSeriesChart.prototype.focusPrevSeries = function () {
        this.focusSeries(this._keyboardSelectedSeriesIndex - 1);
    };
    AiTimeSeriesChart.prototype.focusNextDataPoint = function () {
        this.focusSeries(this._keyboardSelectedSeriesIndex);
        this.focusDataPoint(this._keyboardSelectedDataPointIndex + 1);
    };
    AiTimeSeriesChart.prototype.focusPrevDataPoint = function () {
        this.focusSeries(this._keyboardSelectedSeriesIndex);
        this.focusDataPoint(this._keyboardSelectedDataPointIndex - 1);
    };
    AiTimeSeriesChart.prototype.unfocusSeries = function () {
        this._removeSeriesVirtualFocus();
        this._isFocused = false;
    };
    AiTimeSeriesChart.prototype._removeSeriesVirtualFocus = function (isFocused) {
        if (isFocused === void 0) { isFocused = false; }
        // unselect all legends.
        this._aiChart.legendElement.selectAll(".fxc-monitorchart-legend").classed("notSelected", false);
        // remove highlight
        if (this._visualOptions.chartType === 1 /* Bar */) {
            this._aiChart.svgElement.selectAll(".fxc-monitorchart-bargroup").classed("notSelected", false);
            this._aiChart.svgElement.selectAll(".fxc-monitorchart-bargroup ").classed("Selected", false);
        }
        else if (this._visualOptions.chartType === 7 /* Scatter */) {
            this._aiChart.svgElement.selectAll(".scatterGroup").classed("notSelected", false);
            this._aiChart.svgElement.selectAll(".scatterGroup").classed("Selected", false);
            this._aiChart.svgElement.selectAll("circle.fxc-monitorchart-timeSeriesPoints-dot").attr("r", 3.5);
        }
        else if (this._visualOptions.chartType === 2 /* Line */ || this._visualOptions.chartType === 3 /* Area */) {
            this._aiChart.svgElement.selectAll(".fxc-monitorchart-lineContainer").classed("notSelected", false);
            this._aiChart.svgElement.selectAll(".fxc-monitorchart-lineContainer").classed("Selected", false);
        }
        // no active descendant.
        var div = document.getElementById(this._aiChart.realm);
        div.removeAttribute("aria-activedescendant");
        // no live updates.
        var ariaLiveDiv = document.getElementById(this._aiChart.realm + "_ariaLive");
        ariaLiveDiv.setAttribute("aria-live", "off");
    };
    AiTimeSeriesChart.prototype.deselect = function () {
        this._removeSeriesVirtualFocus();
        this.hoverOut();
        this._keyboardSelectedSeriesIndex = -1;
        this._keyboardSelectedDataPointIndex = -1;
        this._isFocused = true;
    };
    AiTimeSeriesChart.prototype.focusDataPoint = function (index) {
        // LiveMetrics is currently not supported.
        if (this._hasLiveMetrics) {
            return;
        }
        // When we first land on the chart, do not select a data point.
        if (index === undefined && this._keyboardSelectedDataPointIndex === -1) {
            return;
        }
        // by default, keep currently selected data point.
        if (index === undefined) {
            index = this._keyboardSelectedDataPointIndex;
        }
        var seriesPoints = this._transformedData[this._keyboardSelectedSeriesIndex] && this._transformedData[this._keyboardSelectedSeriesIndex].seriesPoints;
        var div = document.getElementById(this._aiChart.realm);
        if (seriesPoints && seriesPoints.length > 0) {
            // Determine the data points lying within view window.
            var lastDataPointIndex = seriesPoints.length - 1;
            var firstDatPointInViewportTimeRange = void 0;
            var lastDatPointInViewportTimeRange = void 0;
            if (this._viewPortTimeRange) {
                for (var i = 0; i <= lastDataPointIndex; i++) {
                    if (seriesPoints[i][0] >= this._viewPortTimeRange.startTime && firstDatPointInViewportTimeRange === undefined) {
                        firstDatPointInViewportTimeRange = i;
                    }
                    else if (seriesPoints[i][0] > this._viewPortTimeRange.endTime && lastDatPointInViewportTimeRange === undefined) {
                        lastDatPointInViewportTimeRange = i - 1;
                        break;
                    }
                }
            }
            if (firstDatPointInViewportTimeRange !== undefined) {
                if (lastDatPointInViewportTimeRange === undefined) {
                    lastDatPointInViewportTimeRange = lastDataPointIndex;
                }
                if (index < firstDatPointInViewportTimeRange) {
                    this._keyboardSelectedDataPointIndex = firstDatPointInViewportTimeRange;
                }
                else if (index > lastDatPointInViewportTimeRange) {
                    this._keyboardSelectedDataPointIndex = lastDatPointInViewportTimeRange;
                }
                else {
                    this._keyboardSelectedDataPointIndex = index;
                }
                var _a = this._transformedData[this._keyboardSelectedSeriesIndex].seriesPoints[this._keyboardSelectedDataPointIndex], dataPointTime = _a[0], dataPointValue = _a[1];
                var narratedDataPoint = void 0;
                var formattedTime = LocaleFormatter.formatTickTime(dataPointTime, this.getVisualization().axis.x.axisType === 3 /* DateUTC */);
                if (dataPointValue !== false && !Util.isNullOrUndefined(dataPointValue) && !isNaN(dataPointValue)) {
                    var valueAndUnit = this._configureLegend(dataPointValue, this._keyboardSelectedSeriesIndex);
                    narratedDataPoint = Strings.dataPointForNarrator.replace("{0}", valueAndUnit.value).replace("{1}", valueAndUnit.unit).replace("{2}", formattedTime);
                }
                else {
                    narratedDataPoint = Strings.legendNoValueForNarrator.replace("{0}", formattedTime);
                }
                // aria live is used to update the screen reader with the new value.
                var ariaLiveDiv = document.getElementById(this._aiChart.realm + "_ariaLive");
                div.removeAttribute("aria-activedescendant");
                if (ariaLiveDiv.getAttribute("aria-live") === "off") {
                    ariaLiveDiv.setAttribute("aria-live", "polite");
                }
                ariaLiveDiv.innerText = narratedDataPoint;
                this.hoverOn(dataPointTime, !this._hasLiveMetrics);
                return;
            }
        }
        var watermarktextId = "fxc-monitorchart-watermark-text-id-" + this._uniqueId;
        div.setAttribute("aria-activedescendant", watermarktextId);
    };
    AiTimeSeriesChart.prototype.focusSeries = function (index) {
        var _this = this;
        // LiveMetrics is currently not supported.
        if (this._hasLiveMetrics) {
            return;
        }
        // When we first land on the chart, do not select a series.
        if (this._isFocused === false && this._keyboardSelectedSeriesIndex === -1) {
            this._isFocused = true;
            return;
        }
        // if the same series is already selected, return.
        if (this._keyboardSelectedSeriesIndex !== -1 && this._keyboardSelectedSeriesIndex === index) {
            return;
        }
        // by default, keep currently selected series.
        if (index === undefined) {
            index = this._keyboardSelectedSeriesIndex;
        }
        var legendContainersSelection = this._aiChart.legendElement.selectAll(".fxc-monitorchart-legend");
        var numberOfSeries = legendContainersSelection[0].length;
        var lastSeriesIndex = this._transformedData.length - 1;
        var div = document.getElementById(this._aiChart.realm);
        if (legendContainersSelection && numberOfSeries > 0) {
            if (index < 0) {
                this._keyboardSelectedSeriesIndex = 0;
            }
            else if (index > lastSeriesIndex) {
                this._keyboardSelectedSeriesIndex = lastSeriesIndex;
            }
            else {
                this._keyboardSelectedSeriesIndex = index;
            }
            var activeDescendant = legendContainersSelection.classed("notSelected", function (d, i) {
                return i !== _this._keyboardSelectedSeriesIndex;
            }).filter(function (d, i) {
                return i === _this._keyboardSelectedSeriesIndex;
            }).attr("id");
            if (this._visualOptions.chartType === 1 /* Bar */) {
                this._aiChart.svgElement.selectAll(".fxc-monitorchart-bargroup").classed("notSelected", function (d, i) {
                    return i !== _this._keyboardSelectedSeriesIndex;
                });
                this._aiChart.svgElement.selectAll(".fxc-monitorchart-bargroup").classed("Selected", function (d, i) {
                    return i === _this._keyboardSelectedSeriesIndex;
                });
            }
            else if (this._visualOptions.chartType === 7 /* Scatter */) {
                this._aiChart.svgElement.selectAll(".scatterGroup").classed("notSelected", function (d, i) {
                    return i !== _this._keyboardSelectedSeriesIndex;
                });
                this._aiChart.svgElement.selectAll(".scatterGroup").classed("Selected", function (d, i) {
                    return i === _this._keyboardSelectedSeriesIndex;
                });
                this._aiChart.svgElement.selectAll("circle.fxc-monitorchart-timeSeriesPoints-dot").attr("r", 3.5);
                this._aiChart.svgElement.selectAll(".scatterGroup").filter(function (data, i) {
                    return _this._keyboardSelectedSeriesIndex === i;
                }).selectAll("circle.fxc-monitorchart-timeSeriesPoints-dot").attr("r", 4.5);
            }
            else if (this._visualOptions.chartType === 2 /* Line */ || this._visualOptions.chartType === 3 /* Area */) {
                this._aiChart.svgElement.selectAll(".fxc-monitorchart-lineContainer").classed("notSelected", function (d, i) {
                    return i !== _this._keyboardSelectedSeriesIndex;
                });
                this._aiChart.svgElement.selectAll(".fxc-monitorchart-lineContainer").classed("Selected", function (d, i) {
                    return i === _this._keyboardSelectedSeriesIndex;
                });
            }
            if (div.getAttribute("aria-activedescendant") !== activeDescendant) {
                div.setAttribute("aria-activedescendant", activeDescendant);
            }
        }
        else {
            var watermarktextId = "fxc-monitorchart-watermark-text-id-" + this._uniqueId;
            div.setAttribute("aria-activedescendant", watermarktextId);
        }
    };
    AiTimeSeriesChart.prototype._getD3LegendYValueDef = function (offset) {
        var legendHeight = this._visualOptions.legend.hideSubtitle ? 30 /* LegendHeightSmall */ : 50 /* LegendHeight */;
        legendHeight += 5 /* LegendPaddingTop */;
        var del = function (d) {
            return 5 /* LegendPaddingTop */ + d.index * (legendHeight) + offset;
        };
        return del;
    };
    AiTimeSeriesChart.prototype._getXValueDefForBottomLegend = function (offset) {
        var legendWidth = this._visualOptions.legend.hideSubtitle ? 100 /* LegendWidthSmall */ : 120 /* LegendWidth */;
        var del = function (d) {
            return 25 /* PaddingLeft */ + d.index * legendWidth + offset;
        };
        return del;
    };
    return AiTimeSeriesChart;
}());
exports.AiTimeSeriesChart = AiTimeSeriesChart;
//# sourceMappingURL=AiTimeSeriesChart.js.map