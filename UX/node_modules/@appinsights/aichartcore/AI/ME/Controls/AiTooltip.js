"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var d3 = require("d3");
var Util = require("../Utilities/Util");
var AiTooltip = /** @class */ (function () {
    // bbax: any casted here to avoid sending D3 to the typescrip defitions...
    function AiTooltip(toolTipConfiguration) {
        // bbax: this is superfuous now since AITimeSeriesChart does't even make us
        // when not in use, but keeping around if that changes makes us safely ignore
        // the world when we aren't enabled
        this._enabled = false;
        // this is used to let AiToolTip know the outside world will control the body!
        this._dynamicBody = false;
        // tell AiCharting to not intervene at all with the tooltip html.
        this._fullyOverriden = false;
        this._overrideString = "";
        if (Util.isNullOrUndefined(toolTipConfiguration)) {
            throw "ToolTip constructor provided invalid tooltip hints object";
        }
        this._enabled = toolTipConfiguration.enabled;
        if (Util.isNullOrUndefined(toolTipConfiguration.opacity) || toolTipConfiguration.opacity > 1 || toolTipConfiguration.opacity < 0) {
            this._landingOpacity = "1";
        }
        else {
            this._landingOpacity = toolTipConfiguration.opacity.toString();
        }
        if (!Util.isNullOrUndefined(toolTipConfiguration.tooltipOverride)) {
            this._dynamicBody = true;
            this._fullyOverriden = true;
            this._overrideString = toolTipConfiguration.tooltipOverride;
            return;
        }
        if (!Util.isNullOrUndefined(toolTipConfiguration.staticToolTipText)) {
            // bbax: you can't have BOTH static and dynamic tooltips; they will fight
            // with each other every render loop (movement will cause your static body while
            // your choice of render dynamic data.. will happen when you choose)
            if (toolTipConfiguration.dynamicBody) {
                throw "Tooltip can not be both dynamic and static!";
            }
            this._staticBody = toolTipConfiguration.staticToolTipText;
        }
        // bbax: used so internally we dont try to override the body during dynamic rendering
        // also used by AiTimeSeriesChart to decide when it should render a default body (if
        // both static text is missing and dynamic rendering is off it will make something up)
        if (!Util.isNullOrUndefined(toolTipConfiguration.dynamicBody)) {
            this._dynamicBody = toolTipConfiguration.dynamicBody;
        }
        var appendTarget = "body";
        if (!Util.isNullOrUndefined(toolTipConfiguration.htmlParentD3SelectPath)) {
            appendTarget = toolTipConfiguration.htmlParentD3SelectPath;
        }
        this._init(appendTarget);
        this._resetToDefaultBody();
    }
    // bbax: used internally and by AiTimeSeriesChart to decide how to handle
    // default body... used internal to decide how to handle dynamic body
    AiTooltip.prototype.ControlRequiresBody = function () {
        if (!this._enabled) {
            return false;
        }
        return Util.isNullOrUndefined(this._staticBody) && !this._dynamicBody;
    };
    // bbax: used by AiTimeSeriesChart (and exposed through Chart) for both default body
    // and the outside world to handle dyamic body
    AiTooltip.prototype.AddBody = function (body) {
        if (this._fullyOverriden) {
            throw "Functionality not available for fully overriden tooltip";
        }
        if (this._enabled !== true) {
            return;
        }
        this._divBodyRoot.html(body);
    };
    AiTooltip.prototype.ChangePosition = function (x, y, show) {
        if (this._enabled !== true) {
            return;
        }
        if (show && this._fullyOverriden) {
            this._divRoot = d3.select(this._overrideString);
        }
        var yFinal = y;
        var ch = this._divRoot.style("left", (x + 10) + "px").style("top", yFinal + "px");
        if (show) {
            this._resetToDefaultBody();
            ch.style("display", "block").transition().style("opacity", this._landingOpacity);
        }
    };
    AiTooltip.prototype.Hide = function () {
        if (this._enabled !== true) {
            return;
        }
        this._divRoot.transition().style("opacity", "0").transition()
            .duration(0).style("display", "none");
    };
    AiTooltip.prototype._init = function (appendTarget) {
        if (this._enabled !== true || this._fullyOverriden) {
            return;
        }
        // bbax: shouldn't be possible unless you passed undefined/null, body is default unless overriden
        if (Util.isNullOrUndefined(appendTarget)) {
            throw "A null appendTarget was given to the tooltip internals";
        }
        d3.selectAll("fxc-monitorchart-tooltip-root").remove();
        this._divRoot = d3.select(appendTarget).append("div")
            .attr("class", "fxc-monitorchart-tooltip-root");
        var padding = this._divRoot.append("div").attr("class", "fxc-monitorchart-tooltip-padding");
        padding.append("div").attr("class", "fxc-monitorchart-tooltip-chrome");
        this._divBodyRoot = padding.append("div").attr("class", "fxc-monitorchart-tooltip-body");
    };
    AiTooltip.prototype._resetToDefaultBody = function () {
        // bbax: if dynamic body or AiTimeSeriesChart will render out a body, ignore the static body.
        // this could be simplified to !this._staticBody, but one day more complex logic might dictate
        // when the parents render the default body
        if (this.ControlRequiresBody() || this._dynamicBody) {
            return;
        }
        this.AddBody(this._staticBody);
    };
    return AiTooltip;
}());
exports.AiTooltip = AiTooltip;
//# sourceMappingURL=AiTooltip.js.map