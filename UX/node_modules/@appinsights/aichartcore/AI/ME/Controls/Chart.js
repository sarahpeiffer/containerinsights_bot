"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Note: in portal side, "d3" need to be the first. so disable tslint rule for the line after
var d3 = require("d3");
var Strings = require("../../../Scripts/Strings/src/MELiteStrings");
var ChartUtils_1 = require("../Utilities/ChartUtils");
var Util_1 = require("../Utilities/Util");
var AiTimeSeriesChart_1 = require("./AiTimeSeriesChart");
var Chart = /** @class */ (function () {
    function Chart(realm, context, data, visualization, interactions, accessiblityOptions, skins) {
        this.skins = [];
        this.realm = realm;
        this._realmElement = document.getElementById(this.realm);
        this.telemetryContext = context;
        this._interactions = interactions;
        this._uniqueId = ChartUtils_1.generateUniqueId(this.telemetryContext);
        var containerId = this._createContainerWithSpinner(realm);
        this._visualization = Util_1.cloneProperties(ChartUtils_1.DefaultVisualizationOptions);
        if (visualization) {
            Util_1.extendVisualization(this._visualization, visualization);
        }
        this.svgContainerElement = d3.select("#" + containerId);
        this.svgElement = this.svgContainerElement.append("svg");
        this.svgElement.style({ "flex-grow": 1 });
        this.legendElement = this.svgContainerElement.append("svg");
        this._updateSvgContainerSize();
        // add defs
        var defs = this.svgElement.append("defs");
        defs.append("pattern")
            .attr({
            "id": "pattern-stripe-" + this._uniqueId,
            "width": "4",
            "height": "4",
            "patternUnits": "userSpaceOnUse",
            "patternTransform": "rotate(45)",
        })
            .append("rect")
            .attr({
            "width": "2",
            "height": "4",
            "transform": "translate(0,0)",
            "fill": "white",
        });
        defs.append("mask")
            .attr("id", "mask-stripe-" + this._uniqueId)
            .append("rect")
            .attr({
            "x": "0",
            "y": "0",
            "width": "100%",
            "height": "100%",
            "fill": "url(#pattern-stripe)",
        });
        defs.append("clipPath")
            .attr({
            "id": "viewPort-clip-" + this._uniqueId,
        })
            .append("rect")
            .classed("fxc-monitorchart-clipPath-" + this._uniqueId, true);
        // Create chart depending on chartType. Default is Bar if none is specified.
        this.chartControl = new AiTimeSeriesChart_1.AiTimeSeriesChart(this, this.telemetryContext, data, this._visualization, interactions);
        // Setup skins
        if (skins && skins.length > 0) {
            this.skins = skins;
        }
        // populate accessibility attributes
        if (this._realmElement) {
            this._initAccessibleOptions(accessiblityOptions);
        }
    }
    /**
     * Get the interactions defined for this chart
     *
     * @readonly
     * @type {Interfaces.IAiChartInteractions}
     * @memberOf Chart
     */
    Chart.prototype.getInteractions = function () {
        return this._interactions;
    };
    /**
     * Change the body of a tool tip.  This will work if the tool tip isn't visible, but
     * the changes won't become visible unless the tooltip is made visible (currently
     * through mouse being present in the graph area).
     *
     * @param body
     */
    Chart.prototype.changeToolTipBody = function (body) {
        this.chartControl.changeToolTipBody(body);
    };
    /**
     * The actual height of the Chart SVG element.
     *
     * @readonly
     * @type {number} The height of the Chart SVG element, in pixels.
     * @memberOf Chart
     */
    Chart.prototype.getActualHeight = function () {
        var bottomLegend = this._visualization && this._visualization.legend && this._visualization.legend.position !== 4 /* Right */;
        if (bottomLegend) {
            var legendVisible = this._visualization && this._visualization.legend && this._visualization.legend.isVisible;
            var smallLegend = legendVisible && this._visualization.legend.hideSubtitle;
            var legendHeight = legendVisible ? smallLegend ? 30 /* LegendHeightSmall */ : 50 /* LegendHeight */ : 0;
            var height = this._height - legendHeight;
            return height > 0 ? height : 0;
        }
        else {
            return this._height;
        }
    };
    /**
     * The actual width of the Chart SVG element.
     *
     * @readonly
     * @type {number} The width of the Chart SVG element, in pixels.
     * @memberOf Chart
     */
    Chart.prototype.getActualWidth = function () {
        var chartSVGWidth = this._getChartSVGWidth();
        if (chartSVGWidth - 30 /* ThresholdHandleMargin */ - 25 /* PaddingLeft */ - 25 /* PlottableLeftAreaMargin */ - 5 /* PaddingRight */ > 0) {
            return chartSVGWidth - 30 /* ThresholdHandleMargin */;
        }
        else {
            return 0;
        }
    };
    /**
     * Get visualization interface defined for this chart
     *
     * @type {Interfaces.IChartVisualization}
     * @memberOf Chart
     */
    Chart.prototype.getVisualization = function () {
        return this.chartControl.getVisualization();
    };
    Chart.prototype.setVisualization = function (newVisual) {
        this._visualization = newVisual;
        this._updateSvgContainerSize();
        // Note: don't do visualEqual check here. because when in iframe, and open the timecontext Panel, the visual doesn't change, but we still want to trigger a re-render.
        this.chartControl.setVisualization(newVisual);
        // Update visualization on skins too
        this.skins.forEach(function (skin) { skin.setVisualization(newVisual); });
    };
    Chart.prototype.hoverOn = function (timeTick, selection) {
        this.chartControl.hoverOn(timeTick, selection);
    };
    Chart.prototype.clearSelection = function () {
        this.chartControl.hoverOut();
    };
    Chart.prototype.clearData = function (dataStatus) {
        if (dataStatus === void 0) { dataStatus = 0 /* None */; }
        this.chartControl.clearData(dataStatus);
    };
    Chart.prototype.showSpinner = function () {
        this.chartControl.hideWatermark();
        if (this._divSvgContainer) {
            this._divSvgContainer.style.opacity = "0.2";
        }
        if (this._spinner) {
            this._spinner.style.display = "inherit";
        }
    };
    Chart.prototype.hideSpinner = function () {
        if (this._divSvgContainer) {
            this._divSvgContainer.style.opacity = "1";
        }
        if (this._spinner) {
            this._spinner.style.display = "none";
        }
    };
    Chart.prototype.updateData = function (data, cause) {
        if (this._realmElement) {
            this.chartControl.updateData(data, cause);
            // Data is updated, let's repaint the skins
            this.skins.forEach(function (skin) {
                skin.repaint(data, cause);
            });
        }
    };
    Chart.prototype.updateAccessiblityOptions = function (accessiblityOptions) {
        if (!this._realmElement) {
            return;
        }
        // ariaLabel has priority over ariaLabelledby
        if (accessiblityOptions && accessiblityOptions.ariaLabel) {
            this._setAttribute({
                "aria-label": accessiblityOptions.ariaLabel,
                "aria-labelledby": undefined,
            });
        }
        else {
            this._setAttribute({
                "aria-label": undefined,
                "aria-labelledby": accessiblityOptions && accessiblityOptions.ariaLabelledbyId,
            });
        }
        // the chart's role, aria-describedby, and tabbability are not allowed to be changed by the user.
    };
    Chart.prototype.getAccessiblityOptions = function () {
        return this._realmElement && {
            role: this._realmElement.getAttribute("role"),
            ariaLabel: this._realmElement.getAttribute("aria-label"),
            ariaLabelledbyId: this._realmElement.getAttribute("aria-labelledby"),
            ariaDescribedbyId: this._realmElement.getAttribute("aria-describedby"),
            tabbable: (this._realmElement.getAttribute("tabIndex") === "0"),
        };
    };
    Chart.prototype._setAttribute = function (ids) {
        var _this = this;
        Object.keys(ids).forEach(function (element) {
            if (ids[element]) {
                _this._realmElement.setAttribute(element, ids[element]);
            }
            else {
                _this._realmElement.removeAttribute(element);
            }
        });
    };
    Chart.prototype._getChartSVGWidth = function () {
        var rightLegend = this._visualization && this._visualization.legend && this._visualization.legend.isVisible &&
            this._visualization.legend.position === 4 /* Right */;
        if (rightLegend) {
            var smallLegend = this._visualization && this._visualization.legend && this._visualization.legend.isVisible && this._visualization.legend.hideSubtitle;
            var legentWidth = smallLegend ? 100 /* LegendWidthSmall */ : 120 /* LegendWidth */;
            var width = this._width - legentWidth;
            return width > 0 ? width : 0;
        }
        else {
            return this._width;
        }
    };
    Chart.prototype._updateSvgContainerSize = function () {
        this._height = this._visualization.containerSize && this._visualization.containerSize.height;
        this._width = this._visualization.containerSize && this._visualization.containerSize.width;
        if (Util_1.isNullOrUndefined(this._height) || this._height <= 0) {
            this._height = 300 /* DefaultMEChartHeight */;
        }
        if (Util_1.isNullOrUndefined(this._width) || this._width <= 0) {
            this._width = 700 /* DefaultMEChartWidth */;
        }
        this.svgContainerElement.style({
            "width": this._width + "px",
            "height": this._height + "px",
        });
        var rightLegend = this._visualization && this._visualization.legend && this._visualization.legend.isVisible &&
            this._visualization.legend.position === 4 /* Right */;
        this.svgContainerElement.style({
            "flex-direction": rightLegend ? "row" : "column",
        });
        var legendVisible = this._visualization && this._visualization.legend && this._visualization.legend.isVisible;
        var smallLegend = legendVisible && this._visualization.legend.hideSubtitle;
        var legendWidth = 0;
        var legendHeight = 0;
        if (legendVisible) {
            if (rightLegend) {
                // legend on the right
                legendHeight = this._height - 5 /* LegendPaddingTop */;
                if (smallLegend) {
                    legendWidth = 100 /* LegendWidthSmall */;
                }
                else {
                    legendWidth = 120 /* LegendWidth */;
                }
            }
            else {
                // legend on the bottom
                legendWidth = this._width;
                if (smallLegend) {
                    legendHeight = 30 /* LegendHeightSmall */;
                }
                else {
                    legendHeight = 50 /* LegendHeight */;
                }
            }
        }
        this.legendElement.style({
            "width": legendWidth + "px",
            "height": legendHeight + "px",
            "padding-top": rightLegend ? 5 /* LegendPaddingTop */ + "px" : "0px",
        });
        // Note: this is to workaround the issue that onHover in shell not working if the browser is not at maximized state.
        this.svgElement.style({
            "width": this._getChartSVGWidth() + "px",
            "height": this.getActualHeight() + "px",
        });
    };
    Chart.prototype._initAccessibleOptions = function (accessiblityOptions) {
        // Reason we use "group" instead of "figure" is that aria-activedescendant would not work with "figure" role.
        this._setAttribute({
            "role": "group",
            "aria-describedby": this.realm + "_keyboardShortcuts",
            "tabindex": "0",
        });
        this.updateAccessiblityOptions(accessiblityOptions);
        this.addKeyboardListener();
    };
    Chart.prototype.addKeyboardListener = function () {
        var _this = this;
        var isClick = false;
        this._realmElement.addEventListener("keydown", function (e) {
            isClick = false;
            var preventDefaults = true;
            switch (e.keyCode) {
                case 37: // left arrow
                    _this.chartControl.focusPrevDataPoint();
                    break;
                case 38: // up arrow
                    _this.chartControl.focusNextSeries();
                    break;
                case 39: // right arrow
                    _this.chartControl.focusNextDataPoint();
                    break;
                case 40: // down arrow
                    _this.chartControl.focusPrevSeries();
                    break;
                case 27: // ESC
                    _this.chartControl.deselect();
                    break;
                default:
                    preventDefaults = false;
                    break;
            }
            if (preventDefaults) {
                e.preventDefault();
                e.stopPropagation();
            }
        });
        this._realmElement.addEventListener("click", function (e) {
            isClick = true;
        });
        this._realmElement.addEventListener("blur", function (e) {
            _this.chartControl.hoverOut();
            _this.chartControl.unfocusSeries();
        });
        this._realmElement.addEventListener("focus", function (e) {
            setTimeout(function () {
                if (isClick) {
                    return;
                }
                // revive last focus state
                _this.chartControl.focusSeries();
                _this.chartControl.focusDataPoint();
            }, 100);
        });
    };
    Chart.prototype._createContainerWithSpinner = function (realm) {
        if (!this._realmElement) {
            // for unit test
            return this.realm + "svgContainer";
        }
        // Add spinner element
        var newDiv = document.createElement("div");
        newDiv.innerHTML =
            "<div id='spinner-" + this._uniqueId + "' class='fxc-monitorchartv2-progress'>" +
                "<div class='fxs-progress-dots'>" +
                "<div class='fxs-progress-dots-dot'></div>" +
                "<div class='fxs-progress-dots-dot'></div>" +
                "<div class='fxs-progress-dots-dot'></div>" +
                "</div>" +
                "</div>";
        this._realmElement.appendChild(newDiv);
        this._spinner = newDiv.getElementsByClassName("fxc-monitorchartv2-progress")[0];
        this._spinner.style.display = "none";
        // Add aria-describedBy element
        var descriptionDiv = document.createElement("div");
        descriptionDiv.id = this.realm + "_keyboardShortcuts";
        descriptionDiv.style.display = "none";
        descriptionDiv.innerText = Strings.chartKeyboardShortcutDescription;
        this._realmElement.appendChild(descriptionDiv);
        // Add aria-activedescendant element. Used to tell screen reader which element is in virtual focus.
        var activeDescendantDiv = document.createElement("div");
        activeDescendantDiv.id = this.realm + "_activedescendant";
        activeDescendantDiv.style.display = "none";
        this._realmElement.appendChild(activeDescendantDiv);
        // Add aria-live element. Used to tell screen reader the current data point value.
        var arialiveDiv = document.createElement("div");
        arialiveDiv.id = this.realm + "_ariaLive";
        arialiveDiv.className += " screenReaderText";
        arialiveDiv.setAttribute("aria-live", "off");
        arialiveDiv.setAttribute("tabindex", "-1");
        this._realmElement.appendChild(arialiveDiv);
        // Add chart container element
        this._divSvgContainer = document.createElement("div");
        this._divSvgContainer.id = this.realm + "svgContainer";
        // note: make sure use display: flex for the div, otherwise, it will somehow add 3px to the div, and push the control overall and result infinitely loop of control resizing.
        this._divSvgContainer.style.display = "flex";
        this._realmElement.appendChild(this._divSvgContainer);
        return this._divSvgContainer.id;
    };
    return Chart;
}());
exports.Chart = Chart;
//# sourceMappingURL=Chart.js.map