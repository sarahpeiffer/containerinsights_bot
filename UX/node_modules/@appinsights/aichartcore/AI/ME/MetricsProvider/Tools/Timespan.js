"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DateSpan_1 = require("../../DateSpan");
/**
 * Expand the timeRange based on the timeRangeCushionFactor with grain. THe passed in timeRange is expected to be snapped/alighed with the grain
 * (This method is called from providers)
 */
function expandTimespan(timeRange, grain, timeRangeCushionFactor) {
    // The passed in timeRange is already snapped so we need to make sure the additional added cushion is also properly snapped
    var rawCushionMs = Math.round((timeRange.endTime.getTime() - timeRange.startTime.getTime()) * timeRangeCushionFactor);
    var eachBucketMs = convertIsoDurationToMs(grain);
    // If eachBucketMs is greater than the cushionedMs, we will just take the eachBucketMs. This guarantee that we have cushion on end(s).
    // E.g. If our grain is 1 hour; and our duration is 2 hours with timeRangeCushionFactor = 0.25. So our rawCushionMs = 30 min ( 2hr * 0.25)
    // In this case, our rawCushionMs shall be 1 hour (ie. expand 1 hour on both ends)
    // we want to expand both end with multiple of bucket msInEachBucket
    var idealCusionMs = eachBucketMs > rawCushionMs ? eachBucketMs : Math.floor(rawCushionMs / eachBucketMs) * eachBucketMs;
    // Expand the start time/endtime.
    // TODO: Make sure we do not overboard with what's stored in the backend. E.g. If user
    // ask for past 89 days and we only store 90 days of data. We will probably need to be
    // smart to snap to 90 days (as opposed to 89 + 89*0.25)
    var expandedStartTime = new Date(timeRange.startTime.getTime() - idealCusionMs);
    // EndTime shouldn't pass now.
    var nowTime = Date.now();
    var cushionEndTime = timeRange.endTime.getTime() + idealCusionMs;
    var endtime;
    if (cushionEndTime > nowTime) {
        endtime = timeRange.endTime;
    }
    else {
        endtime = new Date(cushionEndTime);
    }
    return { startTime: expandedStartTime, endTime: endtime };
}
exports.expandTimespan = expandTimespan;
/**
 * Returns an absolute timespan from either an absolute or relative timespan.
 *
 * If an absolute timespan is provided, then a copy of that timespan is returned.
 *
 * If a relative timespan is provided, then an absolute timespan is created with
 * end = now and start = now - relative duration.
 */
function getAbsoluteTimespan(timespan) {
    var absoluteTimespan = timespan.absolute;
    var relativeTimespan = timespan.relative;
    var startTime = null;
    var endTime = null;
    if (absoluteTimespan) {
        endTime = absoluteTimespan.endTime;
        startTime = absoluteTimespan.startTime;
    }
    else if (relativeTimespan) {
        endTime = new Date();
        startTime = new Date(endTime.getTime() - relativeTimespan.durationMs);
    }
    else {
        throw new Error("Could not parse an absolute timespan because the provided "
            + "timespan did not have an absolute or relative property.");
    }
    return {
        startTime: startTime,
        endTime: endTime,
    };
}
exports.getAbsoluteTimespan = getAbsoluteTimespan;
/**
 * NOTE: When converting a duration represented as a string to a number, lots of "edge" cases must be
 * considered (such as daylight savings) to make the conversion 100% accurate. However, that logic
 * does not exist in this function. Instead, the following assumptions are made:
 *
 *  - 1 year = 365 days
 *  - 1 month = 30 days
 *  - 1 week = 7 days
 */
function convertIsoDurationToMs(isoDuration) {
    var dateSpan = DateSpan_1.convertIsoDurationToDateSpan(isoDuration);
    var durationMs = 0;
    if (dateSpan) {
        if (dateSpan.years) {
            durationMs += dateSpan.years * 31536000000 /* oneYearInMs */;
        }
        if (dateSpan.months) {
            durationMs += dateSpan.months * 2592000000 /* oneMonthInMs */;
        }
        if (dateSpan.days) {
            durationMs += dateSpan.days * 86400000 /* oneDayInMs */;
        }
        if (dateSpan.hours) {
            durationMs += dateSpan.hours * 3600000 /* oneHourInMs */;
        }
        if (dateSpan.minutes) {
            durationMs += dateSpan.minutes * 60000 /* oneMinuteInMs */;
        }
        if (dateSpan.seconds) {
            durationMs += dateSpan.seconds * 1000 /* oneSecondInMs */;
        }
    }
    return durationMs;
}
exports.convertIsoDurationToMs = convertIsoDurationToMs;
//# sourceMappingURL=Timespan.js.map