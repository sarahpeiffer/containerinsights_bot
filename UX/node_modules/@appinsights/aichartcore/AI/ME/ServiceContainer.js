"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ServiceContainer = /** @class */ (function () {
    function ServiceContainer() {
        this._dependencyMap = {};
        if (ServiceContainer._instance) {
            throw new Error("Error: Instantiation failed: use ServiceContainer.Instance() instead of new.");
        }
    }
    /**
     * Returns the singleton instance of ServiceContainer
     */
    ServiceContainer.Instance = function () {
        if (!ServiceContainer._instance) {
            ServiceContainer._instance = new ServiceContainer();
        }
        return ServiceContainer._instance;
    };
    ServiceContainer._reset = function () {
        ServiceContainer._instance = null;
    };
    /**
     * Registers the given callBack as a producer for the specified type.
     * Overrides any previous registrations for the previous type.
     */
    ServiceContainer.prototype.register = function (typeToResolve, callBack) {
        this._dependencyMap[typeToResolve] = callBack;
    };
    /**
     * Registers the given callBack as a producer for the specified type.
     * Will not override an existing registration for that specified type.
     * Returns true if registration succeeds, false if it fails due to prior registration.
     */
    ServiceContainer.prototype.registerIfUnset = function (typeToResolve, callBack) {
        if (!this._dependencyMap[typeToResolve]) {
            this._dependencyMap[typeToResolve] = callBack;
            return true;
        }
        return false;
    };
    /*
    * Allow ServiceContainer to hold globally available properties which allow other components to access the token.
    */
    ServiceContainer.prototype.registerProperties = function (properties) {
        var _this = this;
        Object.keys(properties).forEach(function (propertyName) {
            _this._dependencyMap[propertyName] = properties[propertyName];
        });
    };
    ServiceContainer.prototype.get = function (typeToResolve) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        if (this._dependencyMap[typeToResolve]) {
            var mapValue = this._dependencyMap[typeToResolve];
            return typeof mapValue === "function" ? mapValue.apply(void 0, params) : mapValue;
        }
    };
    ServiceContainer._instance = null;
    return ServiceContainer;
}());
exports.ServiceContainer = ServiceContainer;
//# sourceMappingURL=ServiceContainer.js.map