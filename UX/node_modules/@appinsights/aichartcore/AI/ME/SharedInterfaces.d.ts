import * as Constants from "./Constants";
import { DateSpan } from "./DateSpan";
import * as MELiteShared from "./MELiteShared";
import { ThresholdSkinsShared } from "./Skins/ThresholdSkinsShared";
/**
 * Disposable object which allows object lifetime management
 */
export interface IDisposable {
    dispose(): void;
}
/**
 * A subset of \src\SDK\Framework.Client\TypeScript\MsPortalFx\Utilities.Internal.ts
 * Need to create this so that iframe side can refer to this and implement createElement
 * becuase FxImpl is not available from within the iframe.
 */
export interface CreateElementOptions {
    "aria-label"?: string;
    "class"?: string;
    "id"?: string;
    "role"?: string;
    "title"?: string;
}
export interface IServiceContainer {
    /**
     * Registers the given callBack as a producer for the specified type.
     * Overrides any previous registrations for the previous type.
     */
    register(typeToResolve: string, callBack: any): void;
    /**
     * Registers the given callBack as a producer for the specified type.
     * Will not override an existing registration for that specified type.
     * Returns true if registration succeeds, false if it fails due to prior registration.
     */
    registerIfUnset(typeToResolve: string, callBack: any): boolean;
    registerProperties(properties: StringMap<any>): void;
    get<T>(typeToResolve: string, ...params: any[]): T;
}
export interface AIResourceProperties {
    AppId: string;
    ApplicationId: string;
    Application_Type?: string;
    Flow_Type?: string;
    InstrumentationKey: string;
    Name: string;
    CreationDate: string;
    PackageId?: any;
    provisioningState?: string;
    Request_Source?: string;
    SamplingPercentage?: number;
    TenantId?: string;
    Ver?: string;
}
export interface ARMResource {
    id: string;
    location: string;
    name: string;
    type: string;
    tags: any;
    properties?: AIResourceProperties;
}
export interface DebugModeData {
    isDebugModeActive: boolean;
    menuAlwaysOpen: boolean;
    expandedResourceSearch: boolean;
    useDarkTheme: boolean;
    onMenuAlwaysOpen(enable: boolean): void;
    onExpandedResourceSearch(enable: boolean): void;
    onUseDarkTheme(enable: boolean): void;
}
/**
 * If any field in this interface is changed, make sure MsPortalImpl.Controls\Controls\Visualization\MonitorChartV2\Tools\LegacyChartDefinitionAdapter.ts
 * ConvertLegacyChartDefinition method is updated accordingly
 */
export interface MetricsExplorerDataModelDataObject {
    title?: string;
    subtitle?: string;
    items?: MetricsExplorerItemDataModelDataObject[];
    jsonUri?: string;
    currentFilter?: IFilterBaseDataObject;
    timeContext?: MELiteShared.TimeContextRelativeData | MELiteShared.TimeContextAbsoluteData;
    version?: IVersion;
    isCustomDataModel?: boolean;
}
/**
 * If any field in this interface is changed, make sure MsPortalImpl.Controls\Controls\Visualization\MonitorChartV2\Tools\LegacyChartDefinitionAdapter.ts
 * ConvertLegacyChartDefinition method is updated accordingly
 */
export interface MetricsExplorerItemDataModelDataObject {
    id?: string;
    grouping?: GroupingDefinition;
    chartHeight?: number;
    metrics?: IMetricsExplorerMetricDataModel[];
    priorPeriod?: boolean;
    horizontalBars?: boolean;
    showOther?: boolean;
    aggregation?: Constants.Aggregation;
    palette?: string;
    jsonDefinitionId?: string;
    yAxisOptions?: AxisOptions;
    filters?: IBranchFilterDataObject;
    rawQuery?: string;
    title?: string;
    titleKind?: string;
    visualization?: IVisualization;
    appliedISOGrain?: string;
    alertThresholdOptions?: ThresholdSkinsShared.SkinsOptions;
    version?: IVersion;
}
export interface GroupingDefinition {
    kind: Constants.GroupingKind;
    dimension: DimensionDefinition;
    /**
     * Map of dimension values to chosen colors for those values.
     */
    colors?: StringMap<string>;
}
export interface IMetricsExplorerMetricDataModel {
    id: MetricId;
    color?: string;
    metricAggregation?: Constants.Aggregation;
    nativeDescription?: any;
}
export interface BladeReference {
    /**
     * Name of the blade
     */
    bladeName: string;
    /**
     * Name of the extension which this contains the blade
     * Defaults to Application Insights extension
     */
    extensionName?: string;
    /**
     * Parameters to pass to the child blade
     */
    parameters?: any;
    /**
     * If true this blade is opened as a context blade
     */
    isContextBlade?: boolean;
    /**
     * If true specified blade replaces current blade
     */
    inPlace?: boolean;
}
export interface AxisOptions {
    /**
     * Undefined means auto
     */
    minValue?: number;
    /**
     * Undefined means auto
     */
    maxValue?: number;
    options?: Constants.AxisPinningOptions;
}
export interface IVersion {
    major: number;
    minor: number;
    build: number;
}
export interface IMetricsDataModelFactory<T> {
    readFromJSON(rawJson: string): T;
}
export interface IStatusMessage {
    status: boolean;
    message: string;
}
export interface ITimeContext {
    maxBucketCount: number;
    getUseDashboardTimeRange(): boolean;
    getShowUTCTime(): boolean;
    toDataObject(): MELiteShared.TimeContextRelativeData | MELiteShared.TimeContextAbsoluteData;
    toTimeContextOptionData(): MELiteShared.TimeContextOptionData;
    getIsRelative(): boolean;
    /** The duration in ms. */
    getDurationMs(): number;
    /** represents start and endtime of this time context snapshot when this is called. */
    getTimerange(): MELiteShared.TimeRange;
    getHasAutoGrain(): boolean;
    getSnappedTimeContext(grainSpan: DateSpan, smartSnapping?: boolean): ITimeContext;
    cloneMetricTimespan(): MetricTimespan;
    update(timeData: MELiteShared.TimeContextRelativeData | MELiteShared.TimeContextAbsoluteData): void;
    clone(): ITimeContext;
    getGrain(): MELiteShared.Grain;
    setGrain(grain: MELiteShared.Grain): void;
    getAppliedISOGrain(): string;
    setAppliedISOGrain(isoGrain: string): void;
}
export interface RequestInfoProperties {
    /** Dashboard ID. */
    dashboardId?: string;
    /** Action type. */
    actionType?: string;
}
/**
 * Information about the route.
 */
export interface IRouteInfo {
    /** The original request URL. */
    originalUrl: string;
    /** The routed request URL. */
    url: string;
    /** The resource the request is against. */
    resourceId: IResourceInfo;
    /** Indicates if the request has been re-routed from its original destination. */
    isRedirected: boolean;
}
/**
 * Information about the resource.
 */
export interface IResourceInfo {
    /** Subscription ID the resource is associated with. */
    SubscriptionId: string;
    /** Resource group the resource is in. */
    ResourceGroup: string;
    /** Type of the resource. */
    ResourceType: string;
    /** Name of the resource. */
    Name: string;
    /** Segments that show up after the resource info in the path this was built from. */
    RemainingPathSegments?: Array<string>;
}
export interface ComponentId {
    /** Subscription ID the component is associated with. */
    SubscriptionId: string;
    /** Resource group the component is in. */
    ResourceGroup: string;
    /** Name of the component. */
    Name: string;
}
export interface QueryMetadata {
    /**
     * resourceId of this query.
     */
    resourceId: string;
    /**
     * Friendly name for the query so we can easily identify it rather than having to use the URL.
     */
    queryName: string;
    /**
     * Container of the query
     */
    containerName?: string;
    /**
     * chartId for the query.
     */
    chartId?: string;
    /**
     * The CacheControl value to add to the request.
     */
    cacheControl?: string;
    /**
     *  telemetry context
     */
    telemetryContext?: InsightsTelemetryContext;
}
/**
 * Request payload defines what's needed when querying the backend.
 */
export interface RequestPayload {
    MetricsToCalculate?: {
        Metric: {
            Key: string;
        };
        ApplyFunction: string;
    }[];
    MetricsOrderBy?: {
        Index: number;
        Direction: string;
    };
    AggregateByDimension?: {
        Dimensions: Dimension[];
    }[];
    FetchPopulatedDimensions?: boolean;
    DimensionFilters?: {
        Dimension: {
            Key: string;
        };
        FilterExpression?: string;
        Start?: string;
        End?: string;
    }[];
    Query?: {
        Text: string;
    };
}
/**
 * A dimension aggregation is analogous to a SQL "GROUP BY" clause and is used to group the results of the query by some dimension
 * @param Key The dimension to aggregate by.
 * @param Grain (Optional) Specifies the grain when aggregating by time, e.g.  year, quarter, month, week, day, hour, minute, second
 */
export interface Dimension {
    Key: string;
    Grain?: string;
    Top?: number;
}
export interface ControlData {
    chartSeriesData: ChartSeriesData[];
    userDataStatusWithError: UserDataStatusWithError;
    fetchStartTimeStamp?: number;
    timeContext?: ITimeContext;
}
export interface ChartSeriesData {
    metricUniqueId: string;
    metricResults: MetricResult;
    visualization?: ISeriesVisualization;
}
export interface UserDataStatusWithError {
    userDataStatus: Constants.UserDataStatus;
    error?: any;
}
export interface IAiChartInteractionsData extends IRegistrationInfo {
    chartType: Constants.ChartTypes;
    isLive?: boolean;
}
export interface IAiChartInteractionsSummaryData extends IAiChartInteractionsData {
    metricId: string;
    dimensionId: string;
}
export interface IAiChartInteractionsSeriesData extends IAiChartInteractionsSummaryData {
    x: Date;
    stackedDataIndex?: any;
    stackedDataColumn?: any[];
}
export interface IAiChartInteractionsZoomData extends IAiChartInteractionsData {
    xRange?: {
        from: Date;
        to: Date;
    };
    yRange?: {
        from: number;
        to: number;
    };
}
export interface IAiChartInteractions {
    OnHover?: (interactionData: IAiChartInteractionsData) => void;
    OnLeave?: (interactionData: IAiChartInteractionsData) => void;
    OnLeftClick?: (interactionData: IAiChartInteractionsData) => void;
    OnRightClick?: (interactionData: IAiChartInteractionsData) => void;
    OnZoom?: (interactionData: IAiChartInteractionsData) => void;
    OnToolTipWillShowPoint?: (interactionData: IAiChartInteractionsData) => void;
}
export interface IAiChartToolTip {
    ControlRequiresBody: () => boolean;
    AddBody: (body: String) => void;
    ChangePosition: (x: number, y: number, show: boolean) => void;
    Hide: () => void;
}
export interface IAiChartInteractionsRegistration extends IAiChartInteractions {
    id: string;
}
/**
 * Represent the data consumed by d3 to display the charts.
 *
 * seriesPoints: each point is represented as an array:
 * [time: Date,
 * value: number,
 * name: string]
 */
export interface ID3Metric {
    seriesPoints: Array<any>;
    summary: number;
    seriesMetadata: ISeriesVisualization;
}
export interface IToolTipConfiguration {
    staticToolTipText?: string;
    htmlParentD3SelectPath?: string;
    enabled: boolean;
    dynamicBody?: boolean;
    opacity?: number;
    tooltipOverride?: string;
}
/**
 * Represents the visual elements of a chart.
 */
export interface IVisualization {
    chartType?: Constants.ChartTypes;
    size?: ISizeAndSpacing;
    containerSize?: IContainerSize;
    palette?: string[];
    backgroundColor?: string;
}
export interface IChartVisualization extends IVisualization {
    legend?: ILegend;
    axis?: IAxis;
    timeBrushEnable?: boolean;
    toolTip?: IToolTipConfiguration;
}
export interface IGridVisualization extends IVisualization {
    sortMetricIndex?: number;
    sortOrder?: Constants.SortOrder;
}
/**
 * Information about the size and spacing of a chart.
 */
export interface ISizeAndSpacing {
    /**
     * The width of the Chart, in pixels as a number, or other
     * CSS-compatible form ("100%", "50rem", etc) as a string.
     */
    width?: number | string;
    /**
     * The height of the Chart, in pixels as a number, or other
     * CSS-compatible form ("100%", "50rem", etc) as a string.
     */
    height?: number | string;
}
export interface IContainerSize {
    width?: number;
    height?: number;
}
/**
 * Represents how to style a chart's legend.
 */
export interface ILegend {
    isVisible: boolean;
    position: Constants.Positions;
    hideSubtitle?: boolean;
}
/**
 * Structure used to hold a summary's value and unit.
 * value : this contains the value of number formatted (for e.g 12345 may be formatted as $12,345)
 */
export interface ILegendSummaryData {
    value: string;
    unit: string;
}
/**
 * Represent how to display a series.
 */
export interface ISeriesVisualization {
    displayName?: string;
    resourceDisplayName?: string;
    color?: string;
    unit?: Constants.MetricUnit;
    /**
     * If true, then display SI units (i.e.: GB, KB) for displaying bytes in the legend;
     * Otherwise (false/undefined), display IEC (GiB, KiB).
     * Note: This is for backend to specified the default displayIECUnit.
     *       Users can change it by advanced setting, which will get stored as part of part setting.
     */
    displaySIUnit?: boolean;
    /**
     * If true, the byte conversion are done using base 10 (i.e. 1000 b/kb);
     * If false or undefined, the byte conversion are done using base 2 (i.e. 1024 b/kb);
     * Note: SQL uses displaySIUnit: true and useSIConversions: false,
     */
    useSIConversions?: boolean;
    description?: string;
    /**
     * Specify how to fill the missing values.
     */
    missingDataFillType?: Constants.MissingDataFillingType;
}
/**
 * Represents how to display a chart's axis.
 */
export interface IAxis {
    x: IndividualAxis;
    y: IndividualAxis;
}
export interface IndividualAxis {
    isVisible: boolean;
    axisType: Constants.AxisType;
    min?: number;
    max?: number;
}
export interface IChart {
    realm: string;
    svgElement: any;
    svgContainerElement: any;
    legendElement: any;
    getActualHeight(): number;
    getActualWidth(): number;
    changeToolTipBody(body: string): void;
}
export interface FacetValue {
    value: string;
}
export interface IRegistrationInfo {
    id: string;
}
export interface IRegistrationMap {
    Register(info: IRegistrationInfo): void;
    Unregister(id: string): void;
    ExecuteAction(id: string, action: (element: any) => any): any;
    IsEmpty(): boolean;
    GetCallbackRegistrationInfo(id: string): IRegistrationInfo;
}
export interface IStore<TActions, TCallbacks> {
    Actions: TActions;
    Register(callbacks: TCallbacks): void;
    Unregister(callbacks: TCallbacks): void;
}
export interface IFilterBaseDataObject {
    filterType: Constants.FilterType;
    id: string;
}
export interface IBranchFilterDataObject extends IFilterBaseDataObject {
    OperandFilters: IFilterBaseDataObject[];
    LogicalOperator: Constants.FilterLogicalOperator;
}
export interface ILeafFilterDataObject extends IFilterBaseDataObject {
    OperandSelectedKey: DimensionDefinition;
    OperandSelectedValues: string[];
    ComparisonOperator: Constants.FilterComparisonOperator;
}
export interface IFilterUpdateAction {
    filter: IFilterBaseDataObject;
}
export interface IFilterRemoveAction {
    id: string;
}
export interface IFilterAddAction {
    parentFilterId: string;
    newFilter: IFilterBaseDataObject;
}
export interface ITimeContextActions {
    /**
     * Update TimeContext in the store.
     * @param telemetryContext Optional; When specified, allows logging for caller specific info. If not specified, will log general info.
     */
    UpdateTimeContext(raiseActionIdentifier: string, newData: MELiteShared.TimeContextRelativeData | MELiteShared.TimeContextAbsoluteData, telemetryContext?: InsightsTelemetryContext): void;
}
export interface ITimeContextCallback extends IRegistrationInfo {
    OnTimeContextUpdated(raiseActionIdentifier: string, timeContext: ITimeContext): void;
}
/**
 * IItemDataModelStore holds a collection of ItemDataModels. The object Registers/Unregisters with this store should identify itself with a chartId.
 * This allows the store to figure out which ItemDataModel is being updated
 */
export interface IItemDataModelStore<Actions, Callback> extends IStore<Actions, Callback> {
    AttachItemDataModel(itemDataModel: any): void;
    DetachItemDataModel(itemDataModel: any): void;
    /**
     * For the given chartId, returns action can be performed against the itemDataModel.
     */
    GetAction(chartId: string): Actions;
    /**
     * Return the itemDataModel for the given chartId, held by the store.
     */
    GetItemDataModel(chartId: string): IMetricsExplorerItemDataModel;
}
export interface IMetricsExplorerItemDataModel {
    id: string;
    jsonDefinitionId: string;
    grouping: GroupingDefinition;
    chartHeight: number;
    metrics: IMetricsExplorerMetricDataModel[];
    filters: IBranchFilterDataObject;
    priorPeriod: boolean;
    horizontalBars: boolean;
    showOther: boolean;
    aggregation: Constants.Aggregation;
    palette: string;
    editCount: number;
    title: string;
    titleKind: Constants.TitleKind;
    visualization: IVisualization;
    alertThresholdOptions: ThresholdSkinsShared.SkinsOptions;
    version?: IVersion;
    HasMetrics(): boolean;
    MetricCount(): number;
    GetJsonString(): string;
    ToDataObject(): MetricsExplorerItemDataModelDataObject;
}
export interface IMEGridItemDataModel extends IMetricsExplorerItemDataModel {
    visualization: IGridVisualization;
}
export interface IMEChartItemDataModel extends IMetricsExplorerItemDataModel {
    editCount: number;
    appliedISOGrain: string;
    visualization: IVisualization;
}
export interface IItemDataModelActions {
    UpdateFilter(raiseActionIdentifier: string, action: IFilterUpdateAction): void;
    RemoveFilter(raiseActionIdentifier: string, action: IFilterRemoveAction): void;
    AddFilter(raiseActionIdentifier: string, action: IFilterAddAction): void;
    AddMetric(raiseActionIdentifier: string, newMetric: IMetricsExplorerMetricDataModel, index: number): void;
    UpdateMetric(raiseActionIdentifier: string, index: number, metric: IMetricsExplorerMetricDataModel): void;
    RemoveMetric(raiseActionIdentifier: string, index: number): void;
    UpdateVisual(raiseActionIdentifier: string, newVisual: IVisualization): void;
    UpdateISOGrain(raiseActionIdentifier: string, isoGrain: string): void;
    /**
     * Update chart title.
     * @param titleKind titleKind. If it's Auto, the followed parameter @chartTitle will be ignored since it knows how to build the title by itself.
     *                             If None, chartTitle will be ignored since user does not want any title.
     * @param chartTitle chart title. For specifying custom title.
     */
    UpdateTitle(raiseActionIdentifier: string, titleKind: Constants.TitleKind, chartTitle?: string): string;
    /**
     * This method runs when the AiChart component for this DM finishes rendering.
     */
    HasRendered(raiseActionIdentifier: string): void;
    /**
     * This method is ONLY used in DevEdit Mode. Never use this method in production code.
     */
    UpdateItemDataModel(raiseActionIdentifier: string, newItemDataModel: MetricsExplorerItemDataModelDataObject): void;
    /**
     * Method to update grouping, pass in undefined to turn off itemDataModel grouping definition (ie non-segmented datamodel)
     */
    UpdateGrouping(raiseActionIdentifier: string, groupingDefinition: GroupingDefinition): void;
}
export declare type IItemDataModelPossibleCallbacks = IItemDataModelUpdateCallback | IItemDataModelRenderCallback;
export interface IItemDataModelCallback extends IRegistrationInfo {
    chartId: string;
}
export interface IItemDataModelUpdateCallback extends IItemDataModelCallback {
    OnFiltersUpdated(filtersRoot: IBranchFilterDataObject): void;
    OnMetricAdded(raiseActionIdentifier: string, newMetric: IMetricsExplorerMetricDataModel): void;
    OnMetricUpdated(raiseActionIdentifier: string, updatedMetric: IMetricsExplorerMetricDataModel): void;
    OnMetricRemoved(raiseActionIdentifier: string, removedMetric: IMetricsExplorerMetricDataModel): void;
    OnVisualUpdated(raiseActionIdentifier: string, updateVisual: IVisualization): void;
    OnTitleChanged(raiseActionIdentifier: string, newTitle: string, newTitleKind: Constants.TitleKind): void;
    /**
     * Notification happened when grouping is being updated.
     */
    OnGroupingUpdated(raiseActionIdentifier: string, grouping: GroupingDefinition): void;
    /**
     * This method is ONLY used in DevEdit Mode. Never use this method in production code.
     */
    ItemDataModelUpdated(raiseActionIdentifier: string, newItemDataModel: IMetricsExplorerItemDataModel): void;
}
export interface IItemDataModelRenderCallback extends IItemDataModelCallback {
    OnHasRendered(raiseActionIdentifier: string): void;
}
export interface IItemDataModelStoreCallback extends IRegistrationInfo {
    OnItemDataModelISOGrainChanged(raiseActionIdentifier: string, chartId: string, isoGrain: string): void;
    OnItemDataModelAttached(chartId: string): void;
    OnItemDataModelDetached(chartId: string): void;
    OnIdListChanged(raiseActionIdentifier: string): void;
    OnVariableGrainChanged(raiseActionIdentifier: string, isoGrain: string): void;
}
/**
 * Period of time over which metric histories are fetched.
 */
export interface MetricTimespan {
    /**
     * A relative timespan indicates that data points are plotted for a moving timespan, whose
     * end time is always now().
     */
    relative?: {
        /**
         * Length of time over which metrics are plotted.
         */
        durationMs: number;
    };
    /**
     * An absolute timespan indicates that data points are plotted for a fixed timespan.
     */
    absolute?: MELiteShared.TimeRange;
    timeGrain: string;
}
export interface Name {
    /**
     * The internal represents for giving name.
     */
    id: string;
    /**
     * The localized display name.
     * Make it option for two reasons:
     * 1. We may don't want to keep the localized name as part setting;
     * 2. We can query both metricResults and metadataResults at the same time for performance consideration.
     *    So metricResults can get issued without waiting for metadata results comes back.
     */
    displayName?: string;
}
/**
 * This interface is used in order to type legacy metric IDs that have a "kind" which need to be convertered to namespaces.
 */
export interface LegacyMetricId extends MetricId {
    kind: Name;
}
export interface MetricId {
    /**
     * Information that identifies the resource to which the metric belongs.
     */
    resourceDefinition: ResourceDefinition;
    /**
     * Information to identify the metric.
     */
    name: Name;
    /**
     * Information about which namespace this metric belongs to and used when querying for metric results.
     * Default to the resource type if not specified.
     * Note: It will show as namespace/sub-containers in UI.
     */
    namespace?: Namespace;
}
export interface MetricDefinition {
    /**
     * Information to identify the metric.
     */
    metricId: MetricId;
    /**
     * The default aggregation type.
     */
    defaultAggregation: Constants.Aggregation;
    /**
     * The supported aggregation types.
     */
    supportedAggregations: Constants.Aggregation[];
    /**
     * The metric unit.
     */
    unit: Constants.MetricUnit;
    /**
     * The supported timegrains for this metric definition.
     *
     * If this property is null or undefined, then any timegrain may be used when requesting
     * metric histories.
     */
    supportedTimegrains?: string[];
    /**
     * If this is defined, metrics for a giving resourceId will grouped by category, when shows in the metric nubbin.
     */
    category?: Name;
    /** Supported group by dimensions. */
    supportedGroupBy?: StringMap<string[]>;
    /** Default group by dimension key. */
    defaultGroupBy?: string;
    /** Description for a giving metric. Metadata Provider should get the localized name if applicable. */
    description?: string;
}
export interface Namespace {
    /** Name of the namespace to query for. */
    name: string;
    /** Used for AppServicePlans / Storage resources to determine what roles/subservice to query for */
    kind?: string;
    /** Name to show in the dropdown. For example, used to show "Blob" / "Queue" / "Table" for Storage resources. */
    displayName?: string;
    /** Category of this namespace: Standard or Custom */
    category?: string;
}
export interface MetricDataPoint {
    timestamp: Date;
    /**
     * optional since it can be null as a valid value.
     */
    value?: number;
    /**
     * indicating whether giving data point is a missing value.
     */
    missingValue?: boolean;
}
/**
 * Information to identify a dimension for grouping.
 */
export interface ISegment {
    key: string;
    /**
     * optional since it can be null as a valid value.
     */
    value?: string;
}
export interface MetricSeriesAndSummary {
    /**
     * The datapoints for the series.
     */
    dataPoints: MetricDataPoint[];
    /**
     * The summary value for this series.
     */
    summary?: number;
    /**
     * If the metric was segmented, the segment <key, value> to identify the segment.
     */
    segment?: ISegment[];
}
export interface ErrorObject {
    /**
     * Localized message that may be displayed to the user.
     */
    message?: string;
    /**
     * The error code.
     */
    code?: number;
    /**
     * The client-request-id of the request.
     */
    clientRequestId?: string;
    /**
     * The raw/original error object.
     */
    rawError: any;
}
export interface MetricResult {
    /**
     * The metric definition to which the metric history belongs.
     */
    metricId: MetricId;
    /**
     * The start time.
     */
    startTime: Date;
    /**
     * The end time.
     */
    endTime: Date;
    /**
     * Time grain, represented in [ISO-8601 duration](https://en.wikipedia.org/wiki/ISO_8601#Durations).
     */
    timeGrain: string;
    /**
     * The extended time range for series data, that will use for drawing the first and last datapoint in the view port.
     */
    timeRangeExtended?: MELiteShared.TimeRange;
    /**
     * The aggregation the metric result was fetched for.
     */
    aggregation: Constants.Aggregation;
    /**
     * If success, return the data points for the metric history.
     * If the metric is segmented, there will be an entry for each segment.
     * Otherwise, only one value for the total series and summary will exist.
     * If fail, return the error object.
     */
    data: MetricSeriesAndSummary[] | ErrorObject;
    displayName?: string;
    unit?: Constants.MetricUnit;
}
export interface AdditionalQueryParams {
    /**
     * How many items to query for.
     */
    top?: number;
    /**
     * The sorting order for query results: descending, ascending.
     */
    sort?: Constants.SortOrder;
    /**
     * Specifies whether the query will fetch series and/or summaries.
     * It is up to each query provider to respect this based on its capabilities.
     */
    fetchDataKind?: Constants.FetchDataKind;
}
/**
 * Information needed by the MetricProvider when querying for metric data.
 */
export interface MetricQueryParams {
    /**
     * The id of the metric including which resource the metric belongs to.
     */
    metricId: MetricId;
    /**
     * The aggregation func to apply to the metric when querying.
     */
    aggregation: Constants.Aggregation;
    /**
     * The dimension by which the metric is segmented/grouped by.
     * Note: Array for support multi-dimensional segmentation.
     */
    groupByDimensionIds?: string[];
    /**
     * The native metric description (e.g. for live metric this is the native QPS-format filter describing it)
     */
    nativeDescription?: any;
}
/**
 * Information needed by the IMetricsBackendProvider to query with a filter applied.
 */
export interface FilterQueryParams {
    /**
     * The id for this dimension.
     */
    dimensionId: string;
    /**
     * The operation performed on the dimensionId. (e.g., "=", ">", "<", etc.)
     */
    operator: Constants.FilterComparisonOperator;
    /**
     * The value of the filter applied.
     */
    value: string[];
}
/**
 * Information to identify a dimension.
 */
export interface DimensionDefinition {
    /**
     * The name for the dimension.
     */
    dimensionName: Name;
    /**
     * Description for the given.
     * Metadata Provider should get the localized name if applicable.
     */
    description?: string;
    /** The dimension type for giving dimension: custom, performance, request, …  */
    category?: Name;
}
export interface IMetricsBackendProvider {
    /**
     *  Gets namespaces for the resource definition in the current metrics provider.
     */
    getNamespaces(): Q.Promise<ReadonlyArray<Namespace>>;
    /**
     * Gets metric definitions for the resource definition in the current metrics provider.
     *
     * @return A promise that resolves to a an array of metric definitions.
     *
     * @throws Will throw if an error occurs while fetching metric definitions.
     */
    getMetricDefinitions(namespace?: string): Q.Promise<MetricDefinition[]>;
    /**
     * Gets metric history result for metric definitions over a timespan.
     *
     * @param metrics The metrics for which data should be fetched.
     * @param filters The filters to apply when fetching data.
     * @param timespan The timespan over which data should be fetched.
     * @param timegrain The timeGrain for which the data fetch should base on.
     * @return A promise that resolves to an array of metric data.
     *
     * @throws Will throw if an error occurs while fetching metric data.
     */
    getMetricResults(metrics: MetricQueryParams[], filters: FilterQueryParams[], params: AdditionalQueryParams, timespan: MELiteShared.TimeRange, timegrain: string, timespanCushionFactor?: number): Q.Promise<MetricResult[]>;
    /**
     * Gets dimensions definitions for the specified metric.
     *
     * @param metrics The metrics for which to get the grouping dimensions for.
     * @param timespan The timespan over which data should be fetched.
     * @return A list of dimension definitions.
     */
    getDimensionDefinitions?(metrics: MetricId[]): Q.Promise<DimensionDefinition[]>;
    /**
     * Gets dimension values for the selected definitions.
     * @param metrics The metrics for which to get the dimensions values for.
     * @param dimensionId The dimension id for which to get the dimension values for.
     * @param currentSelectedFacets The dimension filter that currently already been applied to the chart.
     * @param queryParam The query parameter (top n, sort) to apply on when getting the dimension values for.
     * @param timespan The timespan over which data should be fetched.
     * @return A list of dimension values.
     */
    getDimensionValues?(metrics: MetricId[], dimensionId: string, currentSelectedFacets: StringMap<string[]>, queryParam: AdditionalQueryParams, timespan: MELiteShared.TimeRange): Q.Promise<FacetValue[]>;
}
export interface IMetricsBackendProviderFactory {
    /**
     * Gets a metrics provider for the provided resource definition.
     *
     * @param resourceDefinition The resource definition.
     * @return A promise that resolves to a metrics provider, or null if no metrics provider
     *  could be found for the provided resource definition.
     */
    getProvider(resourceDefinition: ResourceDefinition): Q.Promise<IMetricsBackendProvider>;
}
export interface ResourceDefinition {
    /**
     * The resource id of the resource.
     */
    id: string;
    /**
     * The type of the resource.
     */
    type?: string;
    /**
     * The kind of the resource.
     */
    kind?: string;
    /**
     * The name for the resource.
     */
    name?: string;
    /**
     * The location for the resource.
     */
    location?: string;
    /**
     * The sku of the resource.
     */
    sku?: {
        /**
         * The sku name.
         */
        name?: string;
        /**
         * The sku tier.
         */
        tier?: string;
        /**
         * The sku size.
         */
        size?: string;
        /**
         * The sku family.
         */
        family?: string;
        /**
         * The sku model.
         */
        model?: string;
        /**
         * The sku capacity.
         */
        capacity?: string;
    };
    /**
     * Any additional information to be saved with the resource definition.
     * This could be unique to each metric provider.
     */
    otherProps?: any;
}
/**
 * Store common telemetry context that stay the same for the lifespan of telemetryService.
 */
export interface CommonInsightsTelemetryContext {
    sessionId?: string;
    userId?: string;
    userAlias?: string;
    partId?: string;
    entryPoint?: string;
    additionalTelemetryInfo?: CustomProperties;
}
/**
 * Store telemetry context that could be different for different charts.
 */
export interface InsightsTelemetryContext extends CommonInsightsTelemetryContext {
    itemDataModelId: string;
    itemDataModel?: IMetricsExplorerItemDataModel;
    clientRequestId?: string[];
    totalChartCount?: number;
    resourceId?: string;
    fetchPromises?: StringMap<Q.Promise<any>[]>;
    additionCustomProperties?: CustomProperties;
    customMetrics?: CustomMetrics;
}
export interface CustomProperties {
    [index: string]: any;
    Aggregation?: string;
    Aggregations?: string;
    BatchUrl?: string;
    BackendProviderTypes?: string;
    /** Indicates if a query was provided by a cache or not */
    Cached?: boolean;
    /** Id of chart/grid in Metrics Explorer View Model */
    ChartId?: string;
    ChartType?: string;
    ClientRequestId?: string;
    ContainerName?: string;
    CustomerAlias?: string;
    EndTime?: string;
    EntryPoint?: string;
    Error?: string;
    ErrorCode?: any;
    ErrorMessage?: string;
    ErrorObject?: any;
    Facet?: any;
    FilterId?: string;
    From?: string;
    GrainFrom?: string;
    GrainTo?: string;
    Grains?: string;
    GroupBy?: any;
    Grouping?: string;
    HandledAt?: any;
    HasBeenEdited?: boolean;
    IbizaSessionId?: string;
    IsCustomTimeRange?: boolean;
    IsConfigured?: string;
    LoadFailReason?: string;
    /** Reserved for indicating telemetry are from MEV2 */
    MEVersion?: string;
    /** In the case where a chart/grid has a single metric, this field is populated with that metric's Id */
    Metric?: string;
    /** Comma separated list of metric ids for a given chart/grid */
    Metrics?: string;
    MsCaching?: string;
    MissingInputs?: string;
    Name?: string;
    Namespaces?: string;
    NubbinType?: string;
    NubbinDropDownType?: string;
    /** The original action (usually a user action) that caused this code to run */
    OriginOperation?: string;
    Palette?: string;
    ParentFilterId?: string;
    PartInstance?: string;
    Payload?: string | ThresholdSkinsShared.DynamicThresholdSkinOptions | ThresholdSkinsShared.DynamicThresholdSkinResponse;
    Persisted?: boolean;
    QueryName?: string;
    QueryNames?: string;
    ReadyState?: any;
    Reason?: string;
    ResourceFilterType?: string;
    ResourceId?: string;
    ResourceIds?: string;
    ResourceProvider?: string;
    ResourceProviders?: string;
    ResourceType?: string;
    ResourceView?: string;
    Response?: string;
    ResponseText?: string;
    ResponseType?: string;
    Result?: string;
    SelectedTimeDuration?: string;
    SeriesUniqueIds?: string;
    StartTime?: string;
    Stack?: string;
    Status?: any;
    Status_Batch?: any;
    StatusText?: string;
    StatusText_Batch?: string;
    SubscriptionIds?: string;
    Timeout?: any;
    TimeRange?: any;
    Truncated?: boolean;
    To?: string;
    Type?: string;
    Types?: string;
    Unit?: string;
    Url?: string;
    Urls?: string;
    UTCTime?: boolean;
    Version?: string;
    VisibilityState?: any;
    WithCredentials?: boolean;
    WithinBatch?: boolean;
}
export interface CustomMetrics extends DurationMetrics {
    AggregationChanged?: number;
    ChartCount?: number;
    ChartEditCount?: number;
    ChartHeight?: number;
    ChartHeightFrom?: number;
    ChartWidth?: number;
    ChartWidthFrom?: number;
    CacheSize?: number;
    Count?: number;
    DimensionChanged?: number;
    DimensionValueChanged?: number;
    GroupByDimensionChanged?: number;
    MetricChanged?: number;
    MetricsCount?: number;
    NubbinCountMetric?: number;
    NubbinCountFilter?: number;
    NubbinCountGrouping?: number;
    QueryCount?: number;
    PillsCountConfigured?: number;
    ResourceChanged?: number;
    ResourceGroupFilters?: number;
    ResourceTypeFilters?: number;
    RetryDelay?: number;
    RetryCount?: number;
    ScreenHeight?: number;
    ScreenWidth?: number;
    SeriesCount?: number;
    SubContainerChanged?: number;
    SubscriptionCount?: number;
    SubscriptionFilters?: number;
    TypeFacetsCount?: number;
    Value?: number;
}
export interface DurationMetrics {
    ComponentDidMountTime?: number;
    ComponentDidUpdateTime?: number;
    ComponentInitialTime?: number;
    ComponentWillMountTime?: number;
    ComponentWillReceivePropsTime?: number;
    ComponentWillUpdateTime?: number;
    Duration?: number;
    Duration_ComponentUpdate?: number;
    Duration_ComponentMounted?: number;
    Duration_ComponentMountedExt?: number;
    Duration_MetricProvider?: number;
    Duration_Ajax?: number;
}
export interface ServerLocalizableString {
    value: string;
    localizedValue: string;
}
export interface ServerMetricAvailability {
    retention: string;
    timeGrain: string;
    location?: any;
    blobLocation?: any;
}
export interface ServerMetricDefinition {
    id: string;
    resourceId: string;
    namespace?: string;
    category?: string;
    name: ServerLocalizableString;
    isDimensionRequired?: boolean;
    unit: string;
    primaryAggregationType: string;
    supportedAggregationTypes?: string[];
    metricAvailabilities: ServerMetricAvailability[];
    dimensions?: ServerLocalizableString[];
}
export interface D3DataPoint {
    x: Date;
    y: number;
    y0: number;
    metric: string;
    segment?: string;
    missingValue?: boolean;
    previousValueMissing?: boolean;
    nextValueMissing?: boolean;
}
export interface TransformedMetricResult {
    d3StackDataSet: D3DataPoint[][];
    transformedMetricResult: MetricDataPoint[][];
}
export interface AccessiblityOptions {
    role?: string;
    ariaLabel?: string;
    ariaLabelledbyId?: string;
    ariaDescribedbyId?: string;
    tabbable?: boolean;
}
export interface Accessible {
    getAccessiblityOptions(): AccessiblityOptions;
    updateAccessiblityOptions(accessiblityOptions: AccessiblityOptions): void;
}
