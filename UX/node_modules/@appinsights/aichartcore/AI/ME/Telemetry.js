"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MapppedUtils_1 = require("../../Utils/MapppedUtils");
var TelemetryService = require("../../Utils/TelemetryService");
var Constants = require("./Constants");
var ResourceTypes_1 = require("./Utilities/ResourceTypes");
var Util = require("./Utilities/Util");
function PerformanceNow() {
    if (window.performance) {
        return window.performance.now();
    }
    else {
        return Date.now();
    }
}
exports.PerformanceNow = PerformanceNow;
// telemetry context map keep the telemetry context for each itemdatamodel.
exports.telemetryContextMap = {};
// Look up arrays for the enums.
// We have to use const enum in definition file, which means lookup is not supported (e.g. userDataStatusConst[userDataStatusConst.HasData]
// So use the 2 arrays below as workaround to act as lookup
var userDataStatusConst = ["None", "HasData", "NoData", "ErrorRetrievingData", "NoMetrics", "AuthorizationTokenFailed", "Throttled"];
// WARNING: when this is updated, please also update the mapping in Constants.ts
var ChartTypesStrings;
(function (ChartTypesStrings) {
    ChartTypesStrings[ChartTypesStrings["Bar"] = 1] = "Bar";
    ChartTypesStrings[ChartTypesStrings["Line"] = 2] = "Line";
    ChartTypesStrings[ChartTypesStrings["Area"] = 3] = "Area";
    ChartTypesStrings[ChartTypesStrings["Grid"] = 4] = "Grid";
    // Pie = 5,
    // Doughnut = 6,
    ChartTypesStrings[ChartTypesStrings["Scatter"] = 7] = "Scatter";
})(ChartTypesStrings || (ChartTypesStrings = {}));
function getClientRequestId(responseHeaders) {
    return responseHeaders && (responseHeaders["x-ms-request-id"] || responseHeaders["x-ms-correlation-request-id"]) || "";
}
exports.getClientRequestId = getClientRequestId;
/**
 * Make sure call this function to get telemetry context.
 */
function getOrCreateTelemetryContext(itemDataModel) {
    if (itemDataModel === void 0) { itemDataModel = undefined; }
    var telemetryContext;
    if (itemDataModel && itemDataModel.id) {
        telemetryContext = exports.telemetryContextMap[itemDataModel.id];
    }
    if (!telemetryContext) {
        // create telemetry context if it doesn't exist in the service container
        telemetryContext = {
            itemDataModelId: itemDataModel && itemDataModel.id,
            clientRequestId: [],
            itemDataModel: itemDataModel,
            additionCustomProperties: {},
            customMetrics: {},
        };
        MapppedUtils_1.extend(telemetryContext, TelemetryService.getCommonTelemetryContext());
    }
    if (itemDataModel && itemDataModel.id) {
        exports.telemetryContextMap[itemDataModel.id] = telemetryContext;
    }
    return telemetryContext;
}
exports.getOrCreateTelemetryContext = getOrCreateTelemetryContext;
function addPromiseToTelemetryContext(context, promiseType, promise) {
    if (context && promiseType) {
        if (!context.fetchPromises) {
            context.fetchPromises = {};
        }
        if (!context.fetchPromises[promiseType]) {
            context.fetchPromises[promiseType] = [];
        }
        context.fetchPromises[promiseType].push(promise);
    }
}
exports.addPromiseToTelemetryContext = addPromiseToTelemetryContext;
function setCommonTelemetryProperties(customProperties) {
    var currentContext = TelemetryService.getCommonTelemetryContext();
    var contextProperties = currentContext.additionalTelemetryInfo || {};
    MapppedUtils_1.extend(contextProperties, customProperties);
    currentContext.additionalTelemetryInfo = contextProperties;
}
exports.setCommonTelemetryProperties = setCommonTelemetryProperties;
function logError(message, context, rejectedReason, customProperties, customMetrics) {
    var allProperties = mergeAllProperties(context, customProperties, customMetrics);
    if (rejectedReason) {
        MapppedUtils_1.extend(allProperties.properties, extractPropertyForErrorObj(rejectedReason));
    }
    if (!allProperties.properties.ErrorMessage) {
        // Load warning message into the ErrorMessage filed so we don't lost it.
        allProperties.properties.ErrorMessage = message;
    }
    TelemetryService.logTelemetry(4 /* Error */, "Error logging", allProperties.properties, allProperties.metrics);
}
exports.logError = logError;
function logCustomEvent(eventName, context, customProperties, customMetrics) {
    var allProperties = mergeAllProperties(context, customProperties, customMetrics);
    TelemetryService.logTelemetry(1 /* Event */, eventName, allProperties.properties, allProperties.metrics);
}
exports.logCustomEvent = logCustomEvent;
function traceMessage(message, context, customProperties, customMetrics) {
    var allProperties = mergeAllProperties(context, customProperties, customMetrics);
    TelemetryService.logTelemetry(2 /* Trace */, message, allProperties.properties);
}
exports.traceMessage = traceMessage;
/**
 * log event with event name: AIWarningLogging
 */
function logWarning(warningMessage, context, customProperties, customMetrics) {
    var allProperties = mergeAllProperties(context, customProperties, customMetrics);
    if (!allProperties.properties.ErrorMessage) {
        // Load warning message into the ErrorMessage filed so we don't lost it.
        allProperties.properties.ErrorMessage = warningMessage;
    }
    TelemetryService.logTelemetry(3 /* Warning */, "Warning logging", allProperties.properties, allProperties.metrics);
}
exports.logWarning = logWarning;
function logContainerLoad(context, containerName, refreshReason, loadResult, dataStatus, customProperties, customMetrics) {
    if (refreshReason === 2 /* Auto */ && loadResult === Constants.Result.Succeed) {
        // don't log auto-refresh telemetry if it succeed.
        return;
    }
    var allProperties = mergeAllProperties(context, customProperties, customMetrics);
    allProperties.properties.Result = Constants.Result[loadResult];
    allProperties.properties.ContainerName = containerName;
    if (dataStatus) {
        if (dataStatus.userDataStatus) {
            allProperties.properties.IsConfigured = userDataStatusConst[dataStatus.userDataStatus];
        }
        if (dataStatus.error) {
            // MetricDataViewModel will make store error object in dataStatus.error. So extract properties from the error object.
            MapppedUtils_1.extend(allProperties.properties, extractPropertyForErrorObj(dataStatus.error));
        }
    }
    // if this is autorefresh, track it as refresh, otherwise track this as load
    var eventSuffix = refreshReason === 2 /* Auto */ ? " auto-refresh" : " load";
    var eventName = "Part" + eventSuffix;
    TelemetryService.logTelemetry(1 /* Event */, eventName, allProperties.properties, allProperties.metrics);
}
exports.logContainerLoad = logContainerLoad;
function logAjaxQuery(context, queryMetaData, queryResult, response, customProperties, customMetrics, loggableQueryPayload) {
    if (queryResult === Constants.Result.Fail) {
        var allProperties = mergeAllProperties(context, customProperties, customMetrics);
        var properties = extractPropertyForErrorObj(response);
        properties.Result = Constants.Result[queryResult];
        if (queryMetaData) {
            var additionCustomProperties = queryMetaData.telemetryContext && queryMetaData.telemetryContext.additionCustomProperties;
            if (additionCustomProperties) {
                MapppedUtils_1.extend(properties, additionCustomProperties);
            }
            properties.QueryName = queryMetaData.queryName;
            properties.ContainerName = queryMetaData.containerName;
            if (queryMetaData.chartId) {
                properties.ChartId = queryMetaData.chartId;
            }
        }
        MapppedUtils_1.extend(allProperties.properties, properties);
        TelemetryService.logTelemetry(1 /* Event */, "Ajax Query", allProperties.properties, allProperties.metrics);
    }
}
exports.logAjaxQuery = logAjaxQuery;
// Get the reject promise properties(only for the properties contain value have string or number type)
// For example, the rejected response promise, it will have status, statusText and responseText
function extractPropertyForErrorObj(errorObj) {
    if (!errorObj) {
        return { ErrorMessage: "extractProperty errorObj is falsy." };
    }
    var sanitizedErrorObj = errorObj;
    Util.sanitizeResponseTelemetry(sanitizedErrorObj);
    var customProperties = {};
    // Occasionally a string is passed in as the error object. Wrap that and return
    if (["string", "number", "boolean"].indexOf(typeof errorObj) !== -1) {
        customProperties.ErrorMessage = errorObj.toString();
        customProperties.Status = "-1";
        return customProperties;
    }
    for (var eachProperty in sanitizedErrorObj) {
        if (sanitizedErrorObj.hasOwnProperty(eachProperty)) {
            switch (String(eachProperty).toLowerCase()) {
                case "_errordata":
                    // When promise is rejected, it's coming back wrapped as MsPortalFx.FxError.FetchDataError
                    if (sanitizedErrorObj[eachProperty]) {
                        if (sanitizedErrorObj[eachProperty].reason) {
                            customProperties.Reason = sanitizedErrorObj[eachProperty].reason;
                        }
                        // pick up statusText/status since it's buried inside _errordata
                        if (sanitizedErrorObj[eachProperty].statusText) {
                            customProperties.StatusText = sanitizedErrorObj[eachProperty].statusText;
                        }
                        if (sanitizedErrorObj[eachProperty].status) {
                            customProperties.Status = sanitizedErrorObj[eachProperty].status;
                        }
                    }
                    break;
                case "clientrequestid":
                    customProperties.ClientRequestId = sanitizedErrorObj[eachProperty];
                    break;
                case "content": // Arm batch response
                    var armErrorContent = sanitizedErrorObj[eachProperty];
                    var armError = armErrorContent.error;
                    if (armError) {
                        if (armError.message) {
                            customProperties.ResponseText = armError.message;
                        }
                        if (armError.code) {
                            customProperties.ErrorCode = armError.code;
                        }
                    }
                    break;
                case "headers": // Arm batch response header
                    var armHeaders = sanitizedErrorObj[eachProperty];
                    customProperties.ClientRequestId = getClientRequestId(armHeaders);
                    break;
                case "message":
                    customProperties.ErrorMessage = sanitizedErrorObj[eachProperty];
                    break;
                case "reason":
                    if (sanitizedErrorObj[eachProperty]) {
                        customProperties.Reason = sanitizedErrorObj[eachProperty];
                    }
                    break;
                case "responsetext":
                    var responsetext = sanitizedErrorObj[eachProperty];
                    if (responsetext) {
                        if (typeof (responsetext) === "string") {
                            customProperties.ResponseText = responsetext;
                        }
                        else {
                            customProperties.ResponseText = JSON.stringify(responsetext);
                        }
                    }
                    break;
                case "status":
                case "httpstatuscode":
                    customProperties.Status = sanitizedErrorObj[eachProperty];
                    break;
                case "statustext":
                    customProperties.StatusText = sanitizedErrorObj[eachProperty];
                    break;
                case "timeout":
                    customProperties.Timeout = sanitizedErrorObj[eachProperty];
                    break;
                case "responsetype":
                    customProperties.ResponseType = sanitizedErrorObj[eachProperty];
                    break;
            }
        }
    }
    return customProperties;
}
function mergeAllProperties(context, customProperties, customMetrics) {
    var properties = {};
    var metrics = {};
    try {
        // if no context was passed, use the common context.
        populateCommonProperties(context || TelemetryService.getCommonTelemetryContext(), properties, metrics);
        // properties specified by the parameters will overwrite commonProperties, if they are using the same name.
        if (customProperties) {
            MapppedUtils_1.extend(properties, customProperties);
        }
        if (customMetrics) {
            MapppedUtils_1.extend(metrics, customMetrics);
        }
        if (context && context.customMetrics) {
            MapppedUtils_1.extend(metrics, context.customMetrics);
        }
    }
    catch (e) {
    }
    finally {
        return {
            properties: properties,
            metrics: metrics,
        };
    }
}
function populateCommonProperties(context, properties, customMetrics) {
    properties.MEVersion = "MEV2";
    // document visibility state when log container loaded event.
    properties.VisibilityState = Util.GetVisibilityState();
    if (context) {
        properties.EntryPoint = context.entryPoint || Util.GetEntryPoint();
        MapppedUtils_1.extend(properties, context.additionalTelemetryInfo);
        properties.IbizaSessionId = context.sessionId;
        properties.CustomerAlias = context.userAlias;
        properties.PartInstance = context.partId;
        if (context.clientRequestId) {
            properties.ClientRequestId = context.clientRequestId.toString();
        }
        populateItemDataModelProperties(context.itemDataModel, properties, customMetrics);
    }
    return properties;
}
function populateItemDataModelProperties(dataModel, properties, customMetrics) {
    if (dataModel) {
        properties.Version = dataModel.version && ("" + dataModel.version.major || "0." + dataModel.version.minor || "0." + dataModel.version.build);
        if (!properties.ChartId) {
            properties.ChartId = dataModel.id;
        }
        var chartType = dataModel.visualization && dataModel.visualization.chartType ? dataModel.visualization.chartType : 2 /* Line */;
        properties.ChartType = ChartTypesStrings[chartType];
        var grouping = dataModel.grouping;
        if (grouping && grouping.dimension) {
            properties.Grouping = grouping.dimension.dimensionName.id;
        }
        properties.Palette = dataModel.palette;
        properties.HasBeenEdited = dataModel.editCount > 0;
        customMetrics.ChartEditCount = dataModel.editCount;
        if (dataModel.aggregation) {
            properties.Aggregation = Constants.AggregationString[dataModel.aggregation];
        }
        customMetrics.MetricsCount = dataModel.metrics.length;
        if (dataModel.metrics && dataModel.metrics.length > 0) {
            var subscriptionIds_1 = [];
            var resourceIds_1 = [];
            var types = [];
            var metricIds_1 = [];
            var seriesIds_1 = [];
            var namespaces_1 = [];
            var resourceProviders_1 = [];
            var aggregations_1 = [];
            var backendProviderTypes_1 = [];
            dataModel.metrics.forEach(function (metric) {
                subscriptionIds_1.push(ResourceTypes_1.getSubscriptionId(metric.id.resourceDefinition.id));
                resourceIds_1.push(metric.id.resourceDefinition.id);
                metricIds_1.push(metric.id.name.id);
                seriesIds_1.push(Util.GetUniqueId(metric));
                // Only send default and don't send the name for custom namespaces (customer data) so send "customNamespace" instead
                var metricNamespace = metric.id.namespace && metric.id.namespace.name;
                if (metricNamespace) {
                    var defaultNamespace = ResourceTypes_1.getDefaultNamespaces(metric.id.resourceDefinition.id);
                    metricNamespace = defaultNamespace.some(function (namespace) { return namespace.name === metricNamespace; }) ? metricNamespace : "customNamespace";
                    namespaces_1.push(metricNamespace);
                }
                resourceProviders_1.push(ResourceTypes_1.getResourceProvider(metric.id.resourceDefinition.id));
                aggregations_1.push(Constants.AggregationString[metric.metricAggregation]);
                backendProviderTypes_1.push(ResourceTypes_1.getMetricBackendProviderType(metric.id));
            });
            subscriptionIds_1 = Util.uniqueAndSort(subscriptionIds_1);
            resourceIds_1 = Util.uniqueAndSort(resourceIds_1);
            types = Util.uniqueAndSort(types);
            metricIds_1 = Util.uniqueAndSort(metricIds_1);
            seriesIds_1 = seriesIds_1.sort();
            namespaces_1 = Util.uniqueAndSort(namespaces_1);
            resourceProviders_1 = Util.uniqueAndSort(resourceProviders_1);
            aggregations_1 = Util.uniqueAndSort(aggregations_1);
            backendProviderTypes_1 = Util.uniqueAndSort(backendProviderTypes_1);
            properties.SubscriptionIds = subscriptionIds_1.toString();
            properties.ResourceIds = resourceIds_1.toString();
            properties.Types = types.toString();
            properties.Metrics = metricIds_1.toString();
            properties.SeriesUniqueIds = seriesIds_1.toString();
            properties.Namespaces = namespaces_1.toString();
            properties.ResourceProviders = resourceProviders_1.toString();
            properties.Aggregations = aggregations_1.toString();
            properties.BackendProviderTypes = backendProviderTypes_1.toString();
        }
        if (dataModel.filters && dataModel.filters.OperandFilters && dataModel.filters.OperandFilters.length > 0) {
            customMetrics.TypeFacetsCount = dataModel.filters.OperandFilters.length;
        }
    }
}
exports.populateItemDataModelProperties = populateItemDataModelProperties;
function CreateOrAddOperation(operationName, operationTelemetry) {
    if (!operationTelemetry) {
        operationTelemetry = new OperationTimer(operationName);
    }
    var opStop = operationTelemetry.createOperationTimer(operationName);
    return { opTimer: operationTelemetry, opStop: opStop };
}
exports.CreateOrAddOperation = CreateOrAddOperation;
var OperationTimer = /** @class */ (function () {
    function OperationTimer(originOperation) {
        this._stats = {};
        this.originOperation = originOperation;
    }
    OperationTimer.prototype.createOperationTimer = function (operationName) {
        var _this = this;
        var startTime = PerformanceNow();
        this._stats[operationName] = this._stats[operationName] || [];
        return function () {
            _this._stats[operationName].push(PerformanceNow() - startTime);
        };
    };
    OperationTimer.prototype.getStats = function () {
        return this._stats;
    };
    return OperationTimer;
}());
exports.OperationTimer = OperationTimer;
//# sourceMappingURL=Telemetry.js.map