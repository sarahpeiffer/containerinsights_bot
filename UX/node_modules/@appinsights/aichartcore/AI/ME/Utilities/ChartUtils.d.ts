import * as Constants from "../Constants";
import { DateSpan } from "../DateSpan";
import * as MELiteShared from "../MELiteShared";
import { IChartVisualization, InsightsTelemetryContext, ITimeContext } from "../SharedInterfaces";
export interface IChartGrainUtils {
    getGrainDateSpanFromTimeContext(timeContext: ITimeContext): DateSpan;
    getSnappedTimeContext(timeContext: ITimeContext, isoGrain?: string): ITimeContext;
    getGrainDateSpanFromIsoGrain(isoGrain: string): DateSpan;
}
export declare const MinAgeOfResourceMs: number;
export declare class ChartGrainUtils implements IChartGrainUtils {
    getGrainDateSpanFromTimeContext(timeContext: ITimeContext): DateSpan;
    getGrainDateSpanFromIsoGrain(timeGrain: string): DateSpan;
    getSnappedTimeContext(timeContext: ITimeContext, isoGrain?: string, smartSnapping?: boolean): ITimeContext;
    /**
     * Returns the minimum allowable grain span in cases where the given grain span is less than allowed for the given startTime
     */
    private _getValidGrain;
    private _calculateGrainSpan;
    private _compare;
    private _mapGrainToGrainSpan;
}
/**
 * Converts a grain from DateSpan to string
 * @param grainSpan, the DateSpan representing the grain
 * @return a string representing the grain.  This string can be sent to elastic search as the "Grain" dimension
 */
export declare function getGrainString(grainSpan: DateSpan): string;
export declare function CovertToISO8601Grain(grain: DateSpan): string;
/**
 * Find a best fit timegrain based the closest to the maxBuckets.
 *
 *  1. Iterate over every time grain, and determine its distance (bucket count) from the max bucket count.
 *  2. Return the timegrain that has the smallest distance to the max bucket count, and have the bucket count less than the maxBuckets.
 */
export declare function findBestFitTimegrain(timeGrains: string[], timeSpan: MELiteShared.TimeRange, maxBuckets?: number, userChosenGrain?: MELiteShared.Grain): string;
/**
 * Computed max bucket size based on the chart type, chart total width, and chart visualSpacing.
 */
export declare function computeMaxBucketCount(chartTotalWidth: number, paddingLeft: number, paddingRight: number, chartType: Constants.ChartTypes): number;
export declare function computeTotalDataPoints(timeContext: ITimeContext, seriesCount: number, grain?: string): number;
export declare function findChosenGrain(timeGrains: string[], userChosenGrain: MELiteShared.Grain): string;
/**
 * This function generates a unique Id for the current chart.
 */
export declare function generateUniqueId(telemetryContext?: InsightsTelemetryContext): string;
export declare function isElementInViewport(el: any): boolean;
/**
 * Default visualization options.
 */
export declare const DefaultVisualizationOptions: IChartVisualization;
