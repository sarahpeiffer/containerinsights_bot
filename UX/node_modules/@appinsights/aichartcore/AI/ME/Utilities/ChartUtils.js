"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DateSpan_1 = require("../DateSpan");
var FeatureFlagService_1 = require("../FeatureFlagService");
var Timespan_1 = require("../MetricsProvider/Tools/Timespan");
var Telemetry = require("../Telemetry");
var DateUtils = require("../Utilities/DateUtils");
var TimeUnits = require("../Utilities/TimeUnits");
var Util_1 = require("./Util");
// =================================================== ChartGrainUtils ====================================================
// min age of resource we are showing is 5 minutes
exports.MinAgeOfResourceMs = 5 * DateUtils.unitsInMilliseconds.Minutes;
// Human understandable time intervals measured in seconds.
// These values MUST be in ascending order.
var secondGrains = [10, 30];
var minuteGrains = [1, 5, 15, 30].map(function (minute) { return minute * 60 /* secondsInAMinute */; }); /* note: 10 minutes is not a valid grain for MDM */
var hourGrains = [1, 6, 12].map(function (hour) { return hour * 3600 /* secondsInAnHour */; }); /* note: 2, 3, 4 hour are not valid grains for MDM */
var dayGrains = [1, 2, 7, 14, 30, 60].map(function (day) { return day * 86400 /* secondsInADay */; });
var ChartGrainUtils = /** @class */ (function () {
    function ChartGrainUtils() {
    }
    ChartGrainUtils.prototype.getGrainDateSpanFromTimeContext = function (timeContext) {
        var appliedISOGrain = timeContext.getAppliedISOGrain();
        if (!timeContext.getIsRelative() && appliedISOGrain) {
            var grainSpan = DateSpan_1.convertIsoDurationToDateSpan(appliedISOGrain);
            return this._getValidGrain(grainSpan);
        }
        return timeContext.getHasAutoGrain() ? this._calculateGrainSpan(timeContext.getDurationMs(), timeContext.maxBucketCount) : this._mapGrainToGrainSpan(timeContext.getGrain());
    };
    ChartGrainUtils.prototype.getGrainDateSpanFromIsoGrain = function (timeGrain) {
        var grainSpan = DateSpan_1.convertIsoDurationToDateSpan(timeGrain);
        return this._getValidGrain(grainSpan);
    };
    // If a timeContext is absolute, snap outwards to ensure data requested by user is visible.
    // Otherwise, snap into the future to ensure most current data is present, while maintaining the duration requested by the user.
    // Returned time range is always absolute.
    ChartGrainUtils.prototype.getSnappedTimeContext = function (timeContext, isoGrain, smartSnapping) {
        var grainSpan;
        if (isoGrain) {
            grainSpan = this.getGrainDateSpanFromIsoGrain(isoGrain);
        }
        else {
            grainSpan = this.getGrainDateSpanFromTimeContext(timeContext);
        }
        return timeContext.getSnappedTimeContext(grainSpan, smartSnapping);
    };
    /**
     * Returns the minimum allowable grain span in cases where the given grain span is less than allowed for the given startTime
     */
    ChartGrainUtils.prototype._getValidGrain = function (grainSpan) {
        var minimalGrainSpan;
        if (FeatureFlagService_1.shouldEnableAILiveMetric()) {
            minimalGrainSpan = new DateSpan_1.DateSpan(0, 0, 0, 0, 0, 1);
        }
        else {
            minimalGrainSpan = new DateSpan_1.DateSpan(0, 0, 0, 0, 1);
        }
        if (this._compare(grainSpan, minimalGrainSpan) >= 0) {
            return grainSpan;
        }
        else {
            return minimalGrainSpan;
        }
    };
    ChartGrainUtils.prototype._calculateGrainSpan = function (durationMs, maxBuckets) {
        if (!maxBuckets) {
            maxBuckets = 144 /* DefaultMaxBuckets */;
        }
        var seconds = TimeUnits.convert(durationMs, TimeUnits.milliseconds, TimeUnits.seconds);
        var minSecondsPerPoint = seconds / maxBuckets;
        // Find the smallest grain that results in fewer than _maxBuckets points.
        var isBestGrain = function (grain) { return minSecondsPerPoint <= grain; };
        var grainSpan = undefined;
        // Check to see if any of the **second** based grains match
        var grainInSeconds = Util_1.find(secondGrains, isBestGrain);
        if (grainInSeconds) {
            grainSpan = new DateSpan_1.DateSpan(0, 0, 0, 0, 0, grainInSeconds);
            return this._getValidGrain(grainSpan);
        }
        // Check to see if any of the **minute** based grains match
        grainInSeconds = Util_1.find(minuteGrains, isBestGrain);
        if (grainInSeconds) {
            grainSpan = new DateSpan_1.DateSpan(0, 0, 0, 0, grainInSeconds / 60 /* secondsInAMinute */);
            return this._getValidGrain(grainSpan);
        }
        // Check to see if any of the **hour** based grains match
        grainInSeconds = Util_1.find(hourGrains, isBestGrain);
        if (grainInSeconds) {
            grainSpan = new DateSpan_1.DateSpan(0, 0, 0, grainInSeconds / 3600 /* secondsInAnHour */);
            return this._getValidGrain(grainSpan);
        }
        // Check to see if any of the **day** based grains match
        grainInSeconds = Util_1.find(dayGrains, isBestGrain);
        if (grainInSeconds === undefined) {
            grainInSeconds = dayGrains[dayGrains.length - 1];
        }
        grainSpan = new DateSpan_1.DateSpan(0, 0, grainInSeconds / 86400 /* secondsInADay */);
        return this._getValidGrain(grainSpan);
    };
    ChartGrainUtils.prototype._compare = function (dateSpan, dateSpan2) {
        return DateUtils.dateSpanToSeconds(dateSpan) - DateUtils.dateSpanToSeconds(dateSpan2);
    };
    ChartGrainUtils.prototype._mapGrainToGrainSpan = function (grain) {
        switch (grain) {
            case 2 /* Minutely */:
                return new DateSpan_1.DateSpan(0, 0, 0, 0, 1);
            case 3 /* Hourly */:
                return new DateSpan_1.DateSpan(0, 0, 0, 1);
            case 4 /* Daily */:
                return new DateSpan_1.DateSpan(0, 0, 1);
            case 5 /* Weekly */:
                return new DateSpan_1.DateSpan(0, 0, 7);
            case 6 /* Monthly */:
                return new DateSpan_1.DateSpan(0, 1);
            case 7 /* Every_5_Minutes */:
                return new DateSpan_1.DateSpan(0, 0, 0, 0, 5);
            case 8 /* Every_15_Minutes */:
                return new DateSpan_1.DateSpan(0, 0, 0, 0, 15);
            case 9 /* Every_30_Minutes */:
                return new DateSpan_1.DateSpan(0, 0, 0, 0, 30);
            case 10 /* Every_6_Hours */:
                return new DateSpan_1.DateSpan(0, 0, 0, 6);
            case 11 /* Every_12_Hours */:
                return new DateSpan_1.DateSpan(0, 0, 0, 12);
            default:
                return undefined;
        }
    };
    return ChartGrainUtils;
}());
exports.ChartGrainUtils = ChartGrainUtils;
// =================================================== ChartGrainUtilsWithSetGrain ====================================================
/**
 * Converts a grain from DateSpan to string
 * @param grainSpan, the DateSpan representing the grain
 * @return a string representing the grain.  This string can be sent to elastic search as the "Grain" dimension
 */
function getGrainString(grainSpan) {
    if (grainSpan.months > 0) {
        return grainSpan.months.toString() + "M";
    }
    else if (grainSpan.days > 0 && grainSpan.days % 7 === 0) {
        return (grainSpan.days / 7).toString() + "w";
    }
    else if (grainSpan.days > 0) {
        return grainSpan.days.toString() + "d";
    }
    else if (grainSpan.hours > 0) {
        return grainSpan.hours.toString() + "h";
    }
    else if (grainSpan.minutes > 0) {
        return grainSpan.minutes.toString() + "m";
    }
    else {
        return grainSpan.seconds.toString() + "s";
    }
}
exports.getGrainString = getGrainString;
// Map from stringGrain (m/h/d/w/M) to units supported by Draft.
var _iso8601Map = {
    "m": [30, 15, 10, 5, 1],
    "h": [12, 6, 4, 3, 2, 1],
    "d": [1],
    "w": [1],
    "M": [1],
};
// Convert AI grain into ISO 8601 grain.
function CovertToISO8601Grain(grain) {
    var telemetryContext = Telemetry.getOrCreateTelemetryContext();
    var stringGrain = getGrainString(grain);
    if (!stringGrain) {
        Telemetry.logWarning("GetISO8601Grain; stringGrain is falsy, return default \'PT1M\'", telemetryContext, { ContainerName: "GetISO8601Grain" });
        return "PT1M";
    }
    var totalLen = stringGrain.length;
    // Data coming back as append with unit (e.g. 5m, 1h), try get the last char to determine the aiUnit.
    var aiUnit = stringGrain.substr(totalLen - 1);
    if (aiUnit === "s") {
        return "PT1M"; // When grain is in second, return grain as 1 minute.
    }
    var intervals = _iso8601Map[aiUnit];
    if (!intervals) {
        Telemetry.logWarning("GetISO8601Grain; unrecognizable stringGrain. return default \"PT1M\"", telemetryContext);
        return "PT1M";
    }
    // User pass in bogus value (e.g. "ah").
    var grainNumber = parseInt(stringGrain.substr(0, totalLen - 1), 10);
    if (isNaN(grainNumber)) {
        Telemetry.logWarning("GetISO8601Grain; not parsable number. return default \"PT1M\"", telemetryContext);
        return "PT1M";
    }
    // Iterate thru the list, find one that fits.
    var matchedIntervals = intervals.filter(function (e) { return grainNumber >= e; });
    if (matchedIntervals.length > 0) {
        var idealISONumber = matchedIntervals[0];
        switch (aiUnit) {
            case "m": return "PT" + idealISONumber + "M";
            case "h": return "PT" + idealISONumber + "H";
            case "d": return "P" + idealISONumber + "D";
            case "w": return "P" + idealISONumber + "W";
            case "M": return "P" + idealISONumber + "M";
        }
    }
    else {
        Telemetry.logWarning("Invalid grain " + stringGrain + ". Return default \"PT1M\"", telemetryContext);
        return "PT1M";
    }
    return "PT1M";
}
exports.CovertToISO8601Grain = CovertToISO8601Grain;
/**
 * Find a best fit timegrain based the closest to the maxBuckets.
 *
 *  1. Iterate over every time grain, and determine its distance (bucket count) from the max bucket count.
 *  2. Return the timegrain that has the smallest distance to the max bucket count, and have the bucket count less than the maxBuckets.
 */
function findBestFitTimegrain(timeGrains, timeSpan, maxBuckets, userChosenGrain) {
    if (maxBuckets === void 0) { maxBuckets = 144; }
    if (userChosenGrain === void 0) { userChosenGrain = 1 /* Automatic */; }
    if (!timeGrains || timeGrains.length === 0) {
        return undefined;
    }
    if (timeGrains.length === 1) {
        return timeGrains[0];
    }
    if (!timeSpan) {
        Telemetry.logWarning("ChartUtils: no timespan specified", null);
        return undefined;
    }
    // If user choose some grain that is not automatic, we will try to match it first.
    var chosenGrain = findChosenGrain(timeGrains, userChosenGrain);
    if (chosenGrain) {
        return chosenGrain;
    }
    if (!maxBuckets) {
        maxBuckets = 144 /* DefaultMaxBuckets */;
    }
    var durationMs = timeSpan.endTime.getTime() - timeSpan.startTime.getTime();
    var smallestDistance = Number.MAX_VALUE;
    var bestFitTimegrain;
    var coarsestTimegrain;
    var coarsestTimegrainInMs = 0;
    timeGrains.forEach(function (grain) {
        var timegrainMs = Timespan_1.convertIsoDurationToMs(grain);
        var bucketCount = durationMs / timegrainMs;
        var distanceFromTargetBucketCount = maxBuckets - bucketCount;
        if (0 <= distanceFromTargetBucketCount && distanceFromTargetBucketCount < smallestDistance) {
            bestFitTimegrain = grain;
            smallestDistance = distanceFromTargetBucketCount;
        }
        if (timegrainMs > coarsestTimegrainInMs) {
            coarsestTimegrain = grain;
            coarsestTimegrainInMs = timegrainMs;
        }
    });
    if (Util_1.isNullOrUndefined(bestFitTimegrain)) {
        // Failed to find a grain that meet the maxBuckets retriction, so use the coarsest time grain.
        bestFitTimegrain = coarsestTimegrain;
    }
    return bestFitTimegrain;
}
exports.findBestFitTimegrain = findBestFitTimegrain;
/**
 * Computed max bucket size based on the chart type, chart total width, and chart visualSpacing.
 */
function computeMaxBucketCount(chartTotalWidth, paddingLeft, paddingRight, chartType) {
    var maxBucketCount = 0;
    var chartWidth = chartTotalWidth - paddingLeft - paddingRight - 25 /* PlottableLeftAreaMargin */;
    switch (chartType) {
        case 1 /* Bar */:
            maxBucketCount = Math.floor(chartWidth / (5 /* BarWidthPerPointMin */ + 3 /* BarSeparationWidthMin */));
            maxBucketCount = maxBucketCount > 0 ? maxBucketCount : 1;
            break;
        case 3 /* Area */:
            maxBucketCount = Math.floor(chartWidth / 3 /* AreaPerAggMin */);
            maxBucketCount = maxBucketCount > 1 ? maxBucketCount : 2;
            break;
        case 7 /* Scatter */:
            maxBucketCount = Math.floor(chartWidth / 7 /* DotLinePerPointMin */);
            maxBucketCount = maxBucketCount > 0 ? maxBucketCount : 1;
            break;
        case 2 /* Line */:
        default: // tslint:disable-line:no-switch-case-fall-through
            maxBucketCount = Math.floor(chartWidth / 3 /* LinePerAggMin */);
            maxBucketCount = maxBucketCount > 1 ? maxBucketCount : 2;
    }
    return maxBucketCount;
}
exports.computeMaxBucketCount = computeMaxBucketCount;
function computeTotalDataPoints(timeContext, seriesCount, grain) {
    var timeRange = timeContext.getTimerange();
    var grainSpan = (grain && new ChartGrainUtils().getGrainDateSpanFromIsoGrain(grain)) || new ChartGrainUtils().getGrainDateSpanFromTimeContext(timeContext);
    var seconds = DateUtils.dateSpanToSeconds(grainSpan);
    var perSeriesDataPoints = Math.ceil((timeRange.endTime.getTime() - timeRange.startTime.getTime()) / (1000 * seconds));
    return perSeriesDataPoints * seriesCount;
}
exports.computeTotalDataPoints = computeTotalDataPoints;
function findChosenGrain(timeGrains, userChosenGrain) {
    var grain;
    if (userChosenGrain !== 1 /* Automatic */ && timeGrains && timeGrains.length > 0) {
        switch (userChosenGrain) {
            case 2 /* Minutely */:
                if (timeGrains.indexOf("PT1M") >= 0) {
                    grain = "PT1M";
                }
                break;
            case 3 /* Hourly */:
                if (timeGrains.indexOf("PT1H") >= 0) {
                    grain = "PT1H";
                }
                break;
            case 4 /* Daily */:
                if (timeGrains.indexOf("P1D") >= 0) {
                    grain = "P1D";
                }
                break;
            case 5 /* Weekly */:
                if (timeGrains.indexOf("P1W") >= 0) {
                    grain = "P1W";
                }
                break;
            case 6 /* Monthly */:
                if (timeGrains.indexOf("P1M") >= 0) {
                    grain = "P1M";
                }
                break;
            case 7 /* Every_5_Minutes */:
                if (timeGrains.indexOf("PT5M") >= 0) {
                    grain = "PT5M";
                }
                break;
            case 8 /* Every_15_Minutes */:
                if (timeGrains.indexOf("PT15M") >= 0) {
                    grain = "PT15M";
                }
                break;
            case 9 /* Every_30_Minutes */:
                if (timeGrains.indexOf("PT30M") >= 0) {
                    grain = "PT30M";
                }
                break;
            case 10 /* Every_6_Hours */:
                if (timeGrains.indexOf("PT6H") >= 0) {
                    grain = "PT6H";
                }
                break;
            case 11 /* Every_12_Hours */:
                if (timeGrains.indexOf("PT12H") >= 0) {
                    grain = "PT12H";
                }
                break;
        }
    }
    return grain;
}
exports.findChosenGrain = findChosenGrain;
/**
 * This function generates a unique Id for the current chart.
 */
function generateUniqueId(telemetryContext) {
    return "A" + ((telemetryContext && telemetryContext.itemDataModelId) || Util_1.GUID());
}
exports.generateUniqueId = generateUniqueId;
function isElementInViewport(el) {
    var element = document.getElementById(el);
    if (element) {
        var rect = element.getBoundingClientRect();
        return (rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.left <= (window.innerWidth || document.documentElement.clientWidth) &&
            rect.bottom >= 0 &&
            rect.right >= 0);
    }
    return false;
}
exports.isElementInViewport = isElementInViewport;
/**
 * Default visualization options.
 */
exports.DefaultVisualizationOptions = {
    // default chartType to line.
    chartType: 2 /* Line */,
    legend: {
        isVisible: true,
        position: 2 /* Bottom */,
        hideSubtitle: false,
    },
    axis: {
        x: {
            isVisible: true,
            axisType: 2 /* DateLocal */,
        },
        y: {
            isVisible: true,
            axisType: 1 /* Number */,
        },
    },
    size: {
        width: "100%",
        height: 300,
    },
    timeBrushEnable: false,
};
//# sourceMappingURL=ChartUtils.js.map