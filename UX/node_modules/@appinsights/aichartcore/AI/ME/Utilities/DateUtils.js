"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TimeUnits = require("./TimeUnits");
var _minuteBuckets = [5, 10, 15, 30, 60];
var _hourBuckets = [2, 3, 6, 12, 18, 24];
var _dayBuckets = [2, 3, 5, 7, 14, 30];
var _monthBuckets = [2, 3, 6, 9, 12];
var _yearBuckets = [2, 3];
/**
 * Represents the number of milliseconds in the specified time unit.
 * DEPRECATED - PLEASE USE TimeUnits INSTEAD
 */
exports.unitsInMilliseconds = {
    /** 1/10,000 of a millisecond for data returned from Elastic Search */
    Ticks: .0001,
    /** 1 ms */
    Milliseconds: 1,
    /** 1 s = 1,000 ms */
    Seconds: 1e3,
    /** 1 m = 60,000 ms */
    Minutes: 6e4,
    /** 1 h = 3,600,000 ms */
    Hours: 36e5,
    /** 1 d = 86,400,000 ms */
    Days: 864e5,
    /** 1 y = 31,536,000,000 ms */
    Years: 31536e6,
};
exports.priorPeriodOffsetMs = exports.unitsInMilliseconds.Days * 7; // 7 days - prior week
/**
 * Convert a string to a date object
 */
function ToDate(datetimeStr) {
    if (datetimeStr && typeof (datetimeStr) === "string") {
        var dateTimeObject = new Date(datetimeStr);
        if (dateTimeObject && !isNaN(dateTimeObject.getTime())) {
            return dateTimeObject;
        }
    }
}
exports.ToDate = ToDate;
function addDate(date, value, unit) {
    return new Date(date.getTime() + Math.round(TimeUnits.convert(value, unit, TimeUnits.milliseconds)));
}
exports.addDate = addDate;
/**
 * Returns a new Date that adds the specified number of days to the specified date.
 *
 * @param value The number of days to add. Value can be positive or negative, and can include a fractional part of a day.
 */
function addDays(date, value) {
    return addDate(date, value, TimeUnits.days);
}
exports.addDays = addDays;
/**
 * Returns a new Date that adds the specified number of hours to the specified date.
 *
 * @param value The number of hours to add. Value can be positive or negative, and can include a fractional part of an hour.
 */
function addHours(date, value) {
    return addDate(date, value, TimeUnits.hours);
}
exports.addHours = addHours;
/**
 * Returns a new Date that adds the specified number of milliseconds to the specified date.
 *
 * @param value The number of milliseconds to add. Value can be positive or negative.
 *              Values that include a fractional part of a millisecond will be rounded to the nearest millisecond.
 */
function addMilliseconds(date, value) {
    return addDate(date, value, TimeUnits.milliseconds);
}
exports.addMilliseconds = addMilliseconds;
/**
 * Returns a new Date that adds the specified number of minutes to the specified date.
 *
 * @param value The number of minutes to add. Value can be positive or negative, and can include a fractional part of a minute.
 */
function addMinutes(date, value) {
    return addDate(date, value, TimeUnits.minutes);
}
exports.addMinutes = addMinutes;
/**
 * Returns a new Date that adds the specified number of seconds to the specified date.
 *
 * @param value The number of seconds to add. Value can be positive or negative, and can include a fractional part of a seconds.
 */
function addSeconds(date, value) {
    return addDate(date, value, TimeUnits.seconds);
}
exports.addSeconds = addSeconds;
/**
 * Compares two dates and returns the difference between them in ms. If either date is null/undefined, NaN will be returned.
 */
function compare(endDate, startDate) {
    if (!startDate || !endDate) {
        return Number.NaN;
    }
    return endDate.getTime() - startDate.getTime();
}
exports.compare = compare;
/**
 * Check if date is in range between start and end time
 */
function inRange(dateToValidate, start, end) {
    if (!dateToValidate || !start || !end) {
        return false;
    }
    else {
        return compare(dateToValidate, start) >= 0 && compare(dateToValidate, end) <= 0;
    }
}
exports.inRange = inRange;
/**
 * Returns a new Date that is rounded to the nearest specified date unit (e.g. month, day, minute).
 *
 * @param dateUnit A DateKind enum representing the unit to round the date to, e.g. month, day, minute.
 * @param roundDown (Optional) If true, the date will always round down. Otherwise, the time will be rounded as normal.
 * @param roundUp (Optional) If true while roundDown is false, the date will always round up. Otherwise, the time will be rounded as normal.
 * @param interval (Optional) A number indicating the interval which the date should be rounded to, e.g. 2 minutes, 5 minutes.
 */
function roundDate(date, unit, roundDown, roundUp, interval) {
    var offset = TimeUnits.getScalar(unit, TimeUnits.milliseconds);
    var roundFunc = roundDown ? Math.floor : (roundUp ? Math.ceil : Math.round);
    if (interval) {
        offset *= interval;
    }
    return new Date(roundFunc(date.getTime() / offset) * offset);
}
exports.roundDate = roundDate;
/*
 * Convert datespan to seconds
 */
function dateSpanToSeconds(dateSpan) {
    return (dateSpan.seconds +
        TimeUnits.convert(dateSpan.minutes, TimeUnits.minutes, TimeUnits.seconds) +
        TimeUnits.convert(dateSpan.hours, TimeUnits.hours, TimeUnits.seconds) +
        TimeUnits.convert(dateSpan.days, TimeUnits.days, TimeUnits.seconds) +
        TimeUnits.convert(dateSpan.months * 31, TimeUnits.days, TimeUnits.seconds) +
        TimeUnits.convert(dateSpan.years * 365, TimeUnits.days, TimeUnits.seconds));
}
exports.dateSpanToSeconds = dateSpanToSeconds;
function GetMidNightLastMonday(date) {
    var midNightMonday = new Date(date.getTime());
    midNightMonday.setHours(0, 0, 0, 0);
    midNightMonday = addDays(midNightMonday, -(6 + midNightMonday.getDay()) % 7);
    return midNightMonday;
}
exports.GetMidNightLastMonday = GetMidNightLastMonday;
/**
 *  Convert the ISO 8601 formatted duration (e.g PT30M) to number of milliseconds
 */
function convertISODurationToMilliseconds(input) {
    var months = 0;
    var weeks = 0;
    var days = 0;
    var hours = 0;
    var minutes = 0;
    var seconds = 0;
    var totalseconds = 0;
    var regExISODuration = /^P((([0-9]*\.?[0-9]*)Y)?(([0-9]*\.?[0-9]*)M)?(([0-9]*\.?[0-9]*)W)?(([0-9]*\.?[0-9]*)D)?)?(T(([0-9]*\.?[0-9]*)H)?(([0-9]*\.?[0-9]*)M)?(([0-9]*\.?[0-9]*)S)?)?$/;
    if (regExISODuration.test(input)) {
        var matches = regExISODuration.exec(input);
        if (matches[5]) {
            months = parseFloat(matches[5]);
        }
        if (matches[7]) {
            weeks = parseFloat(matches[7]);
        }
        if (matches[9]) {
            days = parseFloat(matches[9]);
        }
        if (matches[12]) {
            hours = parseFloat(matches[12]);
        }
        if (matches[14]) {
            minutes = parseFloat(matches[14]);
        }
        if (matches[16]) {
            seconds = parseFloat(matches[16]);
        }
        totalseconds = months * 2592000 + weeks * 604800 + days * 86400 + hours * 3600 + minutes * 60 + seconds;
    }
    return (totalseconds * 1000);
}
exports.convertISODurationToMilliseconds = convertISODurationToMilliseconds;
function ToGrain(isoGrain) {
    switch (isoGrain) {
        case "Auto": return 1 /* Automatic */;
        case "PT1M": return 2 /* Minutely */;
        case "PT5M": return 7 /* Every_5_Minutes */;
        case "PT15M": return 8 /* Every_15_Minutes */;
        case "PT30M": return 9 /* Every_30_Minutes */;
        case "PT1H": return 3 /* Hourly */;
        case "PT6H": return 10 /* Every_6_Hours */;
        case "PT12H": return 11 /* Every_12_Hours */;
        case "P1D": return 4 /* Daily */;
        case "P1W": return 5 /* Weekly */;
        case "P1M": return 6 /* Monthly */;
        default: return 1 /* Automatic */;
    }
}
exports.ToGrain = ToGrain;
/**
 * Get the buckets that the duration is in
 *
 * @param {number} durationMs - Duration in the unit of ms
 * @return {string} - Description of the bucket, e.g. "10 mins"
 */
function _getDurationBucket(durationMs) {
    var positiveDuration = durationMs < 0 ? -durationMs : durationMs;
    var years = TimeUnits.convert(positiveDuration, TimeUnits.milliseconds, TimeUnits.years);
    var months = TimeUnits.convert(positiveDuration, TimeUnits.milliseconds, TimeUnits.months);
    var days = TimeUnits.convert(positiveDuration, TimeUnits.milliseconds, TimeUnits.days);
    var hours = TimeUnits.convert(positiveDuration, TimeUnits.milliseconds, TimeUnits.hours);
    var minutes = TimeUnits.convert(positiveDuration, TimeUnits.milliseconds, TimeUnits.minutes);
    // None of the strings below are exposed to customers. They are only used in telemetry hence do not need to be localized
    if (years > 1) {
        return _getBucketByInterval(years, _yearBuckets, "years");
    }
    else if (months > 1) {
        return _getBucketByInterval(months, _monthBuckets, "months");
    }
    else if (days > 1) {
        return _getBucketByInterval(days, _dayBuckets, "days");
    }
    else if (hours > 1) {
        return _getBucketByInterval(hours, _hourBuckets, "hours");
    }
    else if (minutes > 0) {
        return _getBucketByInterval(minutes, _minuteBuckets, "minutes");
    }
    else {
        return "Empty duration";
    }
}
exports._getDurationBucket = _getDurationBucket;
function _getBucketByInterval(value, buckets, displayUnit) {
    // None of the strings below are exposed to customers. They are only used in telemetry hence do not need to be localized
    var currentBucket = 0;
    for (var i = 0; i < buckets.length; i++) {
        currentBucket = buckets[i];
        if (value <= currentBucket) {
            return currentBucket + " " + displayUnit;
        }
    }
    return "More than " + currentBucket + " " + displayUnit;
}
//# sourceMappingURL=DateUtils.js.map