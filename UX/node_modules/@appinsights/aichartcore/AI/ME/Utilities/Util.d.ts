import { BackendProviderType, MissingDataFillingType, VisibilityState } from "../Constants";
import { TimeRange } from "../MELiteShared";
import * as Interfaces from "../SharedInterfaces";
export declare function GetBackendProvider(url: string): BackendProviderType;
/**
 * For the given IMetricsExplorerMetricDataModel object, this method return unique id scoped under MetricId + aggregation + optional_seriesType
 * Delimited using "#"
 */
export declare function GetUniqueId(metric: Interfaces.IMetricsExplorerMetricDataModel): string;
export declare function toStringMap<T>(data: any): StringMap<T>;
export declare function GetEntryPoint(): string;
export declare function getNextColor(metrics: Interfaces.IMetricsExplorerMetricDataModel[], colorIndex: number): string;
export declare function getNextColorWithUsedColors(usedColors: string[], colorIndex: number): string;
/**
 * Note: TO BE DEPRECATED FOR THE BELOW FUNCTION
 * Rejected the promise only when when all promised failed. We need to wait for all the promises though as we might have multiple successes.
 */
export declare function handleAggregatePromises<T>(fetchPromises: Q.Promise<T>[], callback: () => T): Q.Promise<T>;
/**
 * Rejected the promise only when when all promised failed. We need to wait for all the promises though as we might have multiple successes.
 * This function will also call .then(..) on each of the promises and aggregate the results.
 */
export declare function joinAggregatePromises<T>(promises: Q.Promise<T[]>[]): Q.Promise<T[]>;
export declare function NamespaceEquals(left: Interfaces.Namespace, right: Interfaces.Namespace): boolean;
export declare function NameEquals(left: Interfaces.Name, right: Interfaces.Name): boolean;
export declare function ResourceEquals(left: Interfaces.ResourceDefinition, right: Interfaces.ResourceDefinition): boolean;
export declare function DimensionDefinitionEquals(left: Interfaces.DimensionDefinition, right: Interfaces.DimensionDefinition, onlyCheckIds?: boolean): boolean;
/**
 * Method to return appropriate error message for the given dataStatusWithError. In the event when
 * We cannot map specific error code, we will return the default passed in error message.
 */
export declare function getErrorMessage(dataStatusWithError: Interfaces.UserDataStatusWithError, defaultErrorMessage: string): string;
/**
 * Method to return appropriate error message for the given error object. In the event when
 * We cannot map specific error code, we will return the default passed in error message.
 */
export declare function getMessageForError(error: any, defaultErrorMessage: string): string;
export declare function getHTTPStatusCodeFromError(error: any): number;
/**
 * Method to determine whether we are running inside Ibiza or outside ibiza via checking the presence of ShellVersion in the urlParams.
 */
export declare function isHostedInsideIbiza(): boolean;
/**
 * Method to determine whether we are running inside dashboard.
 */
export declare function isHostedInDashboard(): boolean;
/**
 * Method to determine whether we are running inside extension iframe.
 */
export declare function isHostedInExtensionIFrame(): boolean;
/**
 * Indicates whether the specified object is null or undefined.
 * @param value The value to test.
 * @returns True if the value parameter is null or undefined; otherwise, false.
 */
export declare function isNullOrUndefined(value: any): boolean;
/**
 * Checks if the string is null, undefined or whitespace.
 * @param  value The target string.
 * @return true if the string is null, undefined or whitespace; otherwise, false.
 */
export declare function isNullOrWhiteSpace(value: any): boolean;
/**
 * Returns a GUID such as xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx.
 * @return New GUID.
 */
export declare function GUID(): string;
/**
 * Clone properties from source and copy them to target.
 * Performs a deep clone.
 * @export
 * @param {*} source Source of the object to copy property from.
 * @param {boolean} [deep=true] Whether existing props should be overwritten.
 */
export declare function cloneProperties<T>(source: T, deep?: boolean): T;
/**
 * Get a hash code for a giving string
 * @param str
 */
export declare function hashCode(str: string): number;
/**
 * Replaces all instances of a value in a string.
 * @param input The input string.
 * @param searchValue The value to replace.
 * @param replaceValue The value to replace with.
 * @return A new string with all instances of searchValue replaced with replaceValue.
 */
export declare function replaceAll(input: string, searchValue: string, replaceValue: string): string;
/**
 * Determines whether the needle exists in the haystack.
 * Order of values does not matter. Order of params does since we are trying to see if needle exists in haystack and NOT vice versa.
 */
export declare function arrayContainsAnotherArray(needle: string[], haystack: string[]): boolean;
/**
 * Return the intersection of two string arrays.
 */
export declare function intersect(array1: string[], array2: string[]): string[];
export declare function uniqueAndSort(array: string[]): string[];
/**
 * Return the unique value in a string array.
 */
export declare function unique(array: string[]): string[];
/**
 * Maps a [key] -> value to [values]
 * @param {boolean} outputAUniqueArray : If set to true, removes duplicates
 */
export declare function stringMapToArray<T>(stringMap: StringMap<T>): T[];
/**
 * Returns the first index of an array where the predicate function matches.
 */
export declare function indexOf<T>(array: T[], predicate: (value: T) => boolean): number;
export declare function extendVisualization(target: Interfaces.IVisualization, source: Interfaces.IVisualization): void;
/**
 * Sanitize the response text to exclude any PII data in response text when logging telemetry.
 * IMPORTANT: Each query should exercise the response and properly implement this to exclude unwanted data in response.
 * @param {any} - The response to be sanitized
 */
export declare function sanitizeResponseTelemetry(response: any): void;
/**
 * Determine if the passed in data object is an empty JavaScript object (ie {})
 * @param data
 */
export declare function isEmptyObject(data: any): boolean;
/**
 * Finds the first item in the array that matches the predicate.
 * Returns undefined if there was no matching item.
 *
 * Once we are able to use ES6, we can delete this method.
 */
export declare function find<T>(findIn: Array<T>, predicate: (arg: T) => boolean): T;
/**
 * Compares two arrays.
 *
 * @export
 * @template T
 * @param {Array<T>} array1
 * @param {Array<T>} array2
 * @param {(e1: T, e2: T) => boolean} [equalityFunction] Only needed when non-primitive objects are passed.
 * @returns {boolean}
 */
export declare function compareArrays<T>(array1: Array<T>, array2: Array<T>, equalityFunction?: (e1: T, e2: T) => boolean): boolean;
export declare function getKey(timeRange: TimeRange, roundingInterval?: number): string;
export declare function GetVisibilityState(): VisibilityState;
/***
 * Transform metric result for D3: align data point to xValues, and filling the missing value if needed;
 * if zeroFillMissingValues is NoFill, don't fill the missing values;
 * if zeroFillMissingValues is FillWithZero, fill the missing values with zero;
 * if zeroFillMissingValues is FillWithValueInThePath, fill the missing values with the value that computed based on the previous/next non null values.
 *                                if there is no previous value, the value filled in will be the next non null value,
 *                                if there is no value after, the value filled in will be the previous non null value.
 * isStackedChart: if this is true, we will need to create a datapoint for every series, event the whole series is empty, otherwise, d3 won't be able to stack.
 * Note: this method assumes the data giving is in sorted order.
 */
export declare function transformMetricResultForD3(xValues: Date[], data: Interfaces.MetricSeriesAndSummary[], metricDisplayName: string, fillingMissing?: MissingDataFillingType, isAILiveMetric?: boolean, isStackedChart?: boolean): Interfaces.TransformedMetricResult;
export declare function chartVisualEqual(left: Interfaces.IChartVisualization, right: Interfaces.IChartVisualization): boolean;
