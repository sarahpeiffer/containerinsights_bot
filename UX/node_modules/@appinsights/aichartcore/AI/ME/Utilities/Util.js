"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Strings = require("../../../Scripts/Strings/src/MELiteStrings");
var ArmConfigProvider_1 = require("../../../Utils/ArmConfigProvider");
var MappedUtil = require("../../../Utils/MapppedUtils");
var Constants_1 = require("../Constants");
var DraftConfigProvider_1 = require("../MetricsProvider/Draft/DraftConfigProvider");
var ServiceContainer_1 = require("../ServiceContainer");
var DateUtils = require("../Utilities/DateUtils");
var ResourceTypes_1 = require("../Utilities/ResourceTypes");
var TimeUnits = require("../Utilities/TimeUnits");
function GetBackendProvider(url) {
    if (url) {
        var urlLowerCase = url.toLowerCase();
        // check whether it is arm or legacy endpoint.
        var armEndpoint = ArmConfigProvider_1.GetArmEndpoint().toLowerCase();
        var legacyEndpoint = ArmConfigProvider_1.GetLegacyEndpoint().toLowerCase();
        if (urlLowerCase.indexOf(armEndpoint) !== -1) {
            return 1 /* ARM */;
        }
        else if (urlLowerCase.indexOf(legacyEndpoint) !== -1) {
            return 4 /* Legacy */;
        }
        var urlEndpoint = MappedUtil.getUrlEndpoint(urlLowerCase);
        if (DraftConfigProvider_1.getAllDraftHosts().indexOf(urlEndpoint) !== -1) {
            return 2 /* Draft */;
        }
        else if (stringMapToArray(DraftConfigProvider_1.LiveHosts).indexOf(urlEndpoint) !== -1) {
            return 3 /* AILive */;
        }
    }
    return 0 /* None */;
}
exports.GetBackendProvider = GetBackendProvider;
/**
 * For the given MetricId object, this method return uniqueId scoped under resource+dataSource.
 * Delimited using _metridIdDelimiter. e.g. myResourceId-myDataSource-availabilityResults/availabilityPercentage#Sum
 */
function GetUniqueMetricId(metricId) {
    if (!metricId) {
        return "";
    }
    return [
        metricId.resourceDefinition && metricId.resourceDefinition.id,
        metricId.namespace && metricId.namespace.name,
        metricId.name && metricId.name.id,
    ].filter(function (part) { return part; }).join("-");
}
/**
 * For the given IMetricsExplorerMetricDataModel object, this method return unique id scoped under MetricId + aggregation + optional_seriesType
 * Delimited using "#"
 */
function GetUniqueId(metric) {
    var id = "";
    if (metric) {
        id = GetUniqueMetricId(metric.id);
        if (metric.metricAggregation) {
            id += "#" + Constants_1.AggregationString[metric.metricAggregation];
        }
    }
    return id;
}
exports.GetUniqueId = GetUniqueId;
function toStringMap(data) {
    var properties = {};
    for (var key in data) {
        if (data.hasOwnProperty(key)) {
            var eachVal = data[key];
            properties[key] = eachVal === undefined ? "" : eachVal;
        }
    }
    return properties;
}
exports.toStringMap = toStringMap;
function GetEntryPoint() {
    var entryPoint = "";
    if (isHostedInDashboard()) {
        entryPoint = "Dashboard:";
    }
    else if (isHostedInExtensionIFrame()) {
        entryPoint = "IFrame:";
    }
    else {
        entryPoint = "localHost: ";
    }
    var resourceId = ServiceContainer_1.ServiceContainer.Instance().get(Constants_1.TypeNames.ResourceId);
    if (resourceId) {
        var rp = ResourceTypes_1.getResourceProvider(resourceId);
        if (rp) {
            entryPoint += rp;
        }
    }
    return entryPoint;
}
exports.GetEntryPoint = GetEntryPoint;
function getNextColor(metrics, colorIndex) {
    // Get next unused color
    var usedColors = metrics.filter(function (metric) { return !isNullOrWhiteSpace(metric.color); }).map(function (metric) { return metric.color; });
    return getNextColorWithUsedColors(usedColors, colorIndex);
}
exports.getNextColor = getNextColor;
function getNextColorWithUsedColors(usedColors, colorIndex) {
    // Get next unused color
    var palette = Constants_1.Colors.palettes.multiColor;
    var nextColor = palette[colorIndex % palette.length];
    if (usedColors && usedColors.length > 0 && usedColors.length < palette.length) {
        var counter = 0;
        while (usedColors.indexOf(nextColor) >= 0 && counter++ < palette.length) {
            nextColor = palette[++colorIndex % palette.length];
        }
    }
    return nextColor;
}
exports.getNextColorWithUsedColors = getNextColorWithUsedColors;
/**
 * Note: TO BE DEPRECATED FOR THE BELOW FUNCTION
 * Rejected the promise only when when all promised failed. We need to wait for all the promises though as we might have multiple successes.
 */
function handleAggregatePromises(fetchPromises, callback) {
    return Q.allSettled(fetchPromises).then(function (queryValues) {
        var resolvedCount = 0;
        var rejectReason;
        queryValues.forEach(function (qv) {
            if (qv.state === "fulfilled") {
                resolvedCount++;
            }
            else {
                rejectReason = qv.reason;
            }
        });
        // resolved the promise if any backend have success data back.
        if ((fetchPromises && fetchPromises.length === 0) || resolvedCount > 0) {
            var result = callback();
            return Q.resolve(result);
        }
        return Q.reject(rejectReason);
    });
}
exports.handleAggregatePromises = handleAggregatePromises;
/**
 * Rejected the promise only when when all promised failed. We need to wait for all the promises though as we might have multiple successes.
 * This function will also call .then(..) on each of the promises and aggregate the results.
 */
function joinAggregatePromises(promises) {
    return Q.allSettled(promises).then(function (values) {
        var rejectReason;
        var resolvedPromises;
        var result = values.reduce(function (accumulator, current) {
            if (current.state === "fulfilled") {
                resolvedPromises = true;
                return accumulator.concat(current.value);
            }
            else {
                rejectReason = current.reason;
                return accumulator;
            }
        }, []);
        if (resolvedPromises) {
            return result;
        }
        return Q.reject(rejectReason);
    });
}
exports.joinAggregatePromises = joinAggregatePromises;
function NamespaceEquals(left, right) {
    if (left && right) { // Both namespaces are specified
        return left.name === right.name;
    }
    return true;
}
exports.NamespaceEquals = NamespaceEquals;
function NameEquals(left, right) {
    if (!left && !right) {
        return true;
    }
    if (left && left.id && right && right.id) {
        return left.id.toLowerCase() === right.id.toLowerCase();
    }
}
exports.NameEquals = NameEquals;
function ResourceEquals(left, right) {
    if (!left && !right) {
        return true;
    }
    if (left && right && left.id && right.id) {
        return left.id.toLowerCase() === right.id.toLowerCase();
    }
}
exports.ResourceEquals = ResourceEquals;
function DimensionDefinitionEquals(left, right, onlyCheckIds) {
    if (onlyCheckIds === void 0) { onlyCheckIds = false; }
    if (!left && !right) {
        return true;
    }
    else if ((left && !right) || (right && !left)) {
        return false;
    }
    else {
        if (!left.dimensionName && !right.dimensionName) {
            return true;
        }
        else if ((left.dimensionName && !right.dimensionName) || (right.dimensionName && !left.dimensionName)) {
            return false;
        }
        else {
            var sameId = (left.dimensionName.id === right.dimensionName.id);
            return sameId && (onlyCheckIds || (left.dimensionName.displayName === right.dimensionName.displayName &&
                left.description === right.description &&
                left.category === right.category));
        }
    }
}
exports.DimensionDefinitionEquals = DimensionDefinitionEquals;
/**
 * Method to return appropriate error message for the given dataStatusWithError. In the event when
 * We cannot map specific error code, we will return the default passed in error message.
 */
function getErrorMessage(dataStatusWithError, defaultErrorMessage) {
    if (!dataStatusWithError) {
        return defaultErrorMessage;
    }
    switch (dataStatusWithError.userDataStatus) {
        case 7 /* TooManyDataPoint */:
            return Strings.tooManyDataPoints;
        case 8 /* GrainNotSupported */:
            return Strings.grainNotSupported;
        case 9 /* NoCommonGrain */:
            return Strings.noCommonGrain;
        default:
            return getMessageForError(dataStatusWithError.error, defaultErrorMessage);
    }
}
exports.getErrorMessage = getErrorMessage;
/**
 * Method to return appropriate error message for the given error object. In the event when
 * We cannot map specific error code, we will return the default passed in error message.
 */
function getMessageForError(error, defaultErrorMessage) {
    var httpCode = getHTTPStatusCodeFromError(error);
    switch (httpCode) {
        case 429 /* Throttled */: return Strings.throttledMessage; // 429:
        case 401 /* Unauthorized */: // 401
            var errorCode = findPropertyFromHierarchyChain(error, ["content", "error", "code"]) || findPropertyFromHierarchyChain(error, ["reason", "content", "error", "code"]);
            if (errorCode === "InvalidAuthenticationTokenTenant") {
                // if the errorCode is InvalidAuthenticationTokenTenant, we want to show "Access permission denied." instead of "Session expired.".
                return Strings.forbiddenMessage;
            }
            else {
                // "Session expired."
                return Strings.unauthorizedMessage;
            }
        case 403 /* Forbidden */: return Strings.forbiddenMessage; // tslint:disable-line:no-switch-case-fall-through // 403
        case 404 /* NotFound */: return Strings.resourceNotfoundMessage; // 404
        case 400 /* BadRequest */:
            // Show messages "Selected dimension(s) are not supported by metric(s).", instead of "error retrieving data".
            // If we are getting 400 (bad request), due to sending invalid dimensions.
            // mdm or legacy
            var errorMessage = void 0;
            var rawMessage = findPropertyFromHierarchyChain(error, ["content", "message"]) || findPropertyFromHierarchyChain(error, ["message"]);
            if (rawMessage && rawMessage.indexOf(Constants_1.NotSupportedDimension) >= 0) {
                errorMessage = Strings.dimensionNotSupported;
                var index = rawMessage.indexOf(Constants_1.SupportedOnesAre);
                if (index >= 0) {
                    var supportedList = rawMessage.substr(index + Constants_1.SupportedOnesAre.length + 1);
                    if (supportedList) {
                        errorMessage += " " + Strings.supportedDimensions.replace("{0}", supportedList);
                    }
                }
                return errorMessage;
            }
            // draft
            var code1 = findPropertyFromHierarchyChain(error, ["error", "code"]);
            if (code1 === "BadArgumentError") {
                var detail = JSON.stringify(error);
                if (detail && detail.indexOf("dimensions are not valid") >= 0) {
                    return Strings.dimensionNotSupported;
                }
            }
    }
    return defaultErrorMessage;
}
exports.getMessageForError = getMessageForError;
function getHTTPStatusCodeFromError(error) {
    var httpStatus = 0;
    if (error) {
        // Error can come in can be as
        //      { status: 401 }
        //      { httpStatusCode: 401 }
        //      { reason: { status: 401 }, state: "reject" }  Some places uses Q.AllSettled with an array of promises.
        //      { reason: { jqXHR: { status: 401 }} }         Uses MsPortalFx.Base.Net2.ajax call.
        //      { reason: { httpStatusCode: 401 }, state: "reject" }   The format we get when the access token is from the wrong issuer, we should treat the same as 401 (Unauthorized)
        // Add logic here so we can handle these formats.
        var errorStatus = findPropertyFromHierarchyChain(error, ["status"]) ||
            findPropertyFromHierarchyChain(error, ["jqXHR", "status"]) ||
            findPropertyFromHierarchyChain(error, ["httpStatusCode"]) ||
            findPropertyFromHierarchyChain(error, ["reason", "status"]) ||
            findPropertyFromHierarchyChain(error, ["reason", "jqXHR", "status"]) ||
            findPropertyFromHierarchyChain(error, ["reason", "httpStatusCode"]);
        if (errorStatus) {
            httpStatus = Number(errorStatus);
        }
    }
    return httpStatus;
}
exports.getHTTPStatusCodeFromError = getHTTPStatusCodeFromError;
/**
 * Find property via an array of property names (in hierarchical order). E.g.
 * var obj = {a : { b: { c: 200}}}};
 * call findPropertyFromHierarchyChain(obj, ["a", "b", "c"]) returns 200 back.
 */
function findPropertyFromHierarchyChain(obj, hierarchyNames) {
    var foundObj = obj;
    // Iterate thru the hierarchy chain to find the property we're interested.
    for (var i = 0; i < hierarchyNames.length && foundObj; i++) {
        foundObj = findProperty(foundObj, hierarchyNames[i].toLowerCase());
    }
    return foundObj;
}
function findProperty(obj, searchPropName) {
    if (obj) {
        for (var p in obj) {
            if (obj.hasOwnProperty(p) && p.toLowerCase() === searchPropName) {
                return obj[p];
            }
        }
    }
}
/**
 * Method to determine whether we are running inside Ibiza or outside ibiza via checking the presence of ShellVersion in the urlParams.
 */
function isHostedInsideIbiza() {
    return (window.urlParams && !isNullOrWhiteSpace(window.urlParams.shellVersion) || (window.fx && window.location.hostname !== "localhost"));
}
exports.isHostedInsideIbiza = isHostedInsideIbiza;
/**
 * Method to determine whether we are running inside dashboard.
 */
function isHostedInDashboard() {
    return ServiceContainer_1.ServiceContainer.Instance().get(Constants_1.TypeNames.HostingEnvironment) === 2 /* PortalShell */;
}
exports.isHostedInDashboard = isHostedInDashboard;
/**
 * Method to determine whether we are running inside extension iframe.
 */
function isHostedInExtensionIFrame() {
    return ServiceContainer_1.ServiceContainer.Instance().get(Constants_1.TypeNames.HostingEnvironment) === 1 /* ExtensionIframe */;
}
exports.isHostedInExtensionIFrame = isHostedInExtensionIFrame;
/**
 * Indicates whether the specified object is null or undefined.
 * @param value The value to test.
 * @returns True if the value parameter is null or undefined; otherwise, false.
 */
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * Checks if the string is null, undefined or whitespace.
 * @param  value The target string.
 * @return true if the string is null, undefined or whitespace; otherwise, false.
 */
function isNullOrWhiteSpace(value) {
    // http://jsperf.com/empty-string-test-regex-vs-trim/4
    var regex_NonSpace = /\S/;
    return isNullOrUndefined(value) ||
        (typeof value === "string" && !regex_NonSpace.test(value)); // if can't find any characters other than space.
}
exports.isNullOrWhiteSpace = isNullOrWhiteSpace;
/**
 * Returns a GUID such as xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx.
 * @return New GUID.
 */
function GUID() {
    return MappedUtil.newGuid();
}
exports.GUID = GUID;
/**
 * Clone properties from source and copy them to target.
 * Performs a deep clone.
 * @export
 * @param {*} source Source of the object to copy property from.
 * @param {boolean} [deep=true] Whether existing props should be overwritten.
 */
function cloneProperties(source, deep) {
    if (deep === void 0) { deep = true; }
    return MappedUtil.clone(source, deep);
}
exports.cloneProperties = cloneProperties;
/**
 * Get a hash code for a giving string
 * @param str
 */
function hashCode(str) {
    /* tslint:disable:no-bitwise */
    var hash = 0;
    if (str.length === 0) {
        return hash;
    }
    var char;
    for (var i = 0; i < str.length; i++) {
        char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
    /* tslint:enable:no-bitwise */
}
exports.hashCode = hashCode;
/**
 * Replaces all instances of a value in a string.
 * @param input The input string.
 * @param searchValue The value to replace.
 * @param replaceValue The value to replace with.
 * @return A new string with all instances of searchValue replaced with replaceValue.
 */
function replaceAll(input, searchValue, replaceValue) {
    return input.replace(new RegExp(regexEscape(searchValue), "g"), replaceValue);
}
exports.replaceAll = replaceAll;
/**
 * Escapes regular expression special characters -[]/{}()*+?.\^$|
 * @param str The string to escape.
 * @return The escaped string.
 */
function regexEscape(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
/**
 * Determines whether the needle exists in the haystack.
 * Order of values does not matter. Order of params does since we are trying to see if needle exists in haystack and NOT vice versa.
 */
function arrayContainsAnotherArray(needle, haystack) {
    if (isNullOrUndefined(needle) || isNullOrUndefined(haystack)) {
        return false;
    }
    // Ensure every value of the needle exists in the haystack.
    for (var index = 0; index < needle.length; index++) {
        if (haystack.indexOf(needle[index]) === -1) {
            return false;
        }
    }
    return true;
}
exports.arrayContainsAnotherArray = arrayContainsAnotherArray;
/**
 * Return the intersection of two string arrays.
 */
function intersect(array1, array2) {
    // Short circuit for falsy arrays.
    if (isNullOrUndefined(array1) || isNullOrUndefined(array2)) {
        return [];
    }
    // For every element in array1, check to see if the element exists in array2.
    return array1.filter(function (element) {
        return array2.indexOf(element) !== -1;
    });
}
exports.intersect = intersect;
function uniqueAndSort(array) {
    array = unique(array);
    return array.sort();
}
exports.uniqueAndSort = uniqueAndSort;
/**
 * Return the unique value in a string array.
 */
function unique(array) {
    return array.filter(function (v, i, a) { return a.indexOf(v) === i; });
}
exports.unique = unique;
/**
 * Maps a [key] -> value to [values]
 * @param {boolean} outputAUniqueArray : If set to true, removes duplicates
 */
function stringMapToArray(stringMap) {
    return Object.keys(stringMap).map(function (key) { return stringMap[key]; });
}
exports.stringMapToArray = stringMapToArray;
/**
 * Returns the first index of an array where the predicate function matches.
 */
function indexOf(array, predicate) {
    if (array && array.length > 0 && !!predicate) {
        for (var i = 0; i < array.length; i++) {
            var currentValue = array[i];
            if (predicate(currentValue)) {
                return i;
            }
        }
    }
    return -1;
}
exports.indexOf = indexOf;
function extendVisualization(target, source) {
    MappedUtil.extend(target, source, true);
    /* If the target sets max or min of y axis as undefined, we want to honor that,
    to enable using auto calculations */
    if (source && source.axis && source.axis.y) {
        if (source.axis.y.min === undefined) {
            target.axis.y.min = undefined;
        }
        if (source.axis.y.max === undefined) {
            target.axis.y.max = undefined;
        }
    }
}
exports.extendVisualization = extendVisualization;
/**
 * Sanitize the response text to exclude any PII data in response text when logging telemetry.
 * IMPORTANT: Each query should exercise the response and properly implement this to exclude unwanted data in response.
 * @param {any} - The response to be sanitized
 */
function sanitizeResponseTelemetry(response) {
    if (response && response.responsetext && response.responsetext.error && response.responsetext.error.message &&
        typeof (response.responsetext.error.message) === "string" && response.responsetext.error.message.length > 0) {
        var sanitizedString_1 = response.responsetext.error.message;
        // This regular expression may match some invalid email address.
        var emails = sanitizedString_1.match(/\b\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*\b/g);
        if (emails && emails.length > 0) {
            var code_1;
            emails.forEach(function (e) {
                if (e && e.toLowerCase().indexOf("@microsoft.com") === -1) {
                    code_1 = hashCode(e);
                    sanitizedString_1 = replaceAll(sanitizedString_1, e, code_1.toString());
                }
            });
            response.responsetext.error.message = sanitizedString_1;
        }
    }
}
exports.sanitizeResponseTelemetry = sanitizeResponseTelemetry;
/**
 * Determine if the passed in data object is an empty JavaScript object (ie {})
 * @param data
 */
function isEmptyObject(data) {
    if (!isNullOrWhiteSpace(data) && typeof (data) === "object" && !Array.isArray(data) && !(data instanceof Date)) {
        return Object.keys(data).length === 0;
    }
    return false;
}
exports.isEmptyObject = isEmptyObject;
/**
 * Finds the first item in the array that matches the predicate.
 * Returns undefined if there was no matching item.
 *
 * Once we are able to use ES6, we can delete this method.
 */
function find(findIn, predicate) {
    for (var _i = 0, findIn_1 = findIn; _i < findIn_1.length; _i++) {
        var item = findIn_1[_i];
        if (predicate(item)) {
            return item;
        }
    }
}
exports.find = find;
/**
 * Compares two arrays.
 *
 * @export
 * @template T
 * @param {Array<T>} array1
 * @param {Array<T>} array2
 * @param {(e1: T, e2: T) => boolean} [equalityFunction] Only needed when non-primitive objects are passed.
 * @returns {boolean}
 */
function compareArrays(array1, array2, equalityFunction) {
    if ((!array1 && array2) || (array1 && !array2)) {
        return false;
    }
    if (!array1 && !array2) {
        return true;
    }
    if (array1.length !== array2.length) {
        return false;
    }
    return array1.every(function (element, index) {
        if ((typeof (element) === "object") && equalityFunction) {
            return equalityFunction(element, array2[index]);
        }
        else {
            return element === array2[index];
        }
    });
}
exports.compareArrays = compareArrays;
function getKey(timeRange, roundingInterval) {
    if (roundingInterval === void 0) { roundingInterval = 5; }
    var roundedTimeRange = {
        endTime: DateUtils.roundDate(timeRange.endTime, TimeUnits.minutes, true, false, roundingInterval),
        startTime: DateUtils.roundDate(timeRange.startTime, TimeUnits.minutes, true, false, roundingInterval),
    };
    return "timeContext={endTime=" + roundedTimeRange.endTime.toISOString() + ";startTime=" + roundedTimeRange.startTime.toISOString() + "}";
}
exports.getKey = getKey;
function GetVisibilityState() {
    var hidden = document["hidden"];
    if (hidden === undefined) {
        return Constants_1.VisibilityState.None;
    }
    else if (hidden) {
        return Constants_1.VisibilityState.Hidden;
    }
    else {
        return Constants_1.VisibilityState.Visible;
    }
}
exports.GetVisibilityState = GetVisibilityState;
// =================================================== transform metric result so D3 can consume ====================================================
/***
 * Transform metric result for D3: align data point to xValues, and filling the missing value if needed;
 * if zeroFillMissingValues is NoFill, don't fill the missing values;
 * if zeroFillMissingValues is FillWithZero, fill the missing values with zero;
 * if zeroFillMissingValues is FillWithValueInThePath, fill the missing values with the value that computed based on the previous/next non null values.
 *                                if there is no previous value, the value filled in will be the next non null value,
 *                                if there is no value after, the value filled in will be the previous non null value.
 * isStackedChart: if this is true, we will need to create a datapoint for every series, event the whole series is empty, otherwise, d3 won't be able to stack.
 * Note: this method assumes the data giving is in sorted order.
 */
function transformMetricResultForD3(xValues, data, metricDisplayName, fillingMissing, isAILiveMetric, isStackedChart) {
    var metricResultDataPoints = [];
    var d3StackDataSet = [];
    if (isNullOrUndefined(fillingMissing)) {
        fillingMissing = 0 /* NoFill */;
    }
    if (xValues && xValues.length > 0 && data) {
        var isSegmented_1 = !!(data && data[0] && data[0].segment && data[0].segment[0]);
        var grainDistanceUnit_1 = xValues.length > 1 ? xValues[1].getTime() - xValues[0].getTime() : 0;
        var missingDataValue_1;
        if (data.length > 0) {
            data.forEach(function (series) {
                var dataIndex = 0;
                var d3DataPoints = [];
                var adjustedDataPoints = [];
                if (series && series.dataPoints && series.dataPoints.length > 0) {
                    var displayName = isSegmented_1 ? series.segment[0].value : metricDisplayName;
                    var xIndex = 0;
                    var xValueProcessed = void 0;
                    while (xIndex < xValues.length) {
                        missingDataValue_1 = fillingMissing === 1 /* FillWithZero */ ? 0 : undefined;
                        xValueProcessed = true; // default always move on to next xValue.
                        if (dataIndex < series.dataPoints.length) {
                            var nextDataPoint = series.dataPoints[dataIndex];
                            var currentDistances = xValues[xIndex].getTime() - nextDataPoint.timestamp.getTime();
                            if (currentDistances >= 0) {
                                if (currentDistances <= grainDistanceUnit_1) {
                                    // found data for giving xValue
                                    adjustedDataPoints.push({ timestamp: xValues[xIndex], value: nextDataPoint.value, missingValue: false });
                                    d3DataPoints.push({
                                        x: xValues[xIndex],
                                        y: nextDataPoint.value,
                                        y0: 0,
                                        metric: displayName,
                                        segment: undefined,
                                        missingValue: false,
                                    });
                                }
                                else {
                                    // current data is too far left (>1 grain) from the current xValue, move on to next value to try to fill the xValue.
                                    xValueProcessed = false;
                                }
                                dataIndex++;
                            }
                            else {
                                // missing data for giving xValue
                                if (fillingMissing === 2 /* FillWithValueInThePath */ || fillingMissing === 3 /* FillWithLastValue */) {
                                    if (dataIndex === 0) {
                                        // there is no more data point on the left
                                        missingDataValue_1 = nextDataPoint.value;
                                    }
                                    else {
                                        var previousDataPoint = series.dataPoints[dataIndex - 1];
                                        if (fillingMissing === 2 /* FillWithValueInThePath */) {
                                            var distanceCount = Math.round((nextDataPoint.timestamp.getTime() - previousDataPoint.timestamp.getTime()) / grainDistanceUnit_1);
                                            var valueUnit = (nextDataPoint.value - previousDataPoint.value) / distanceCount;
                                            missingDataValue_1 = previousDataPoint.value + valueUnit * Math.floor((xValues[xIndex].getTime() - previousDataPoint.timestamp.getTime()) / grainDistanceUnit_1);
                                        }
                                        else {
                                            // previous's data value.
                                            missingDataValue_1 = previousDataPoint.value;
                                        }
                                    }
                                }
                                if (dataIndex === 0 && isAILiveMetric) {
                                    // Don't fill the missing value for the begining of the chart if it is AI live metric.
                                }
                                else if (fillingMissing !== 0 /* NoFill */) {
                                    adjustedDataPoints.push({ timestamp: xValues[xIndex], value: missingDataValue_1, missingValue: true });
                                    d3DataPoints.push({
                                        x: xValues[xIndex],
                                        y: missingDataValue_1,
                                        y0: 0,
                                        metric: displayName,
                                        segment: undefined,
                                        missingValue: true,
                                    });
                                }
                            }
                        }
                        else {
                            // There is no more data point on the right.
                            if (fillingMissing === 2 /* FillWithValueInThePath */ || fillingMissing === 3 /* FillWithLastValue */) {
                                missingDataValue_1 = series.dataPoints[series.dataPoints.length - 1].value;
                            }
                            if (fillingMissing !== 0 /* NoFill */) {
                                adjustedDataPoints.push({ timestamp: xValues[xIndex], value: missingDataValue_1, missingValue: true });
                                d3DataPoints.push({
                                    x: xValues[xIndex],
                                    y: missingDataValue_1,
                                    y0: 0,
                                    metric: displayName,
                                    segment: undefined,
                                    missingValue: true,
                                });
                            }
                        }
                        // only move on to next xValue if current xValue is processed (either filled with value, or it is confirmed to be missing value).
                        if (xValueProcessed) {
                            xIndex++;
                        }
                    }
                }
                else if (isStackedChart) {
                    var emptyData = createEmptyD3StackDataPoints(xValues, metricDisplayName);
                    d3DataPoints = emptyData.d3DataPoints;
                    adjustedDataPoints = emptyData.metricDataPoints;
                }
                // Fill in the value for previousValueMissing/nextValueMissing, if there are missing data point.
                // Note: previousValueMissing/nextValueMissing is used to draw the svg path for missing data, we need to use different line style
                //       for both lines from/to missing data points.
                if (xValues.length > series.dataPoints.length) {
                    var dIndex = 0;
                    while (dIndex < d3DataPoints.length) {
                        d3DataPoints[dIndex].previousValueMissing = dIndex > 0 ? d3DataPoints[dIndex - 1].missingValue : undefined;
                        d3DataPoints[dIndex].nextValueMissing = dIndex < d3DataPoints.length - 1 ? d3DataPoints[dIndex + 1].missingValue : undefined;
                        dIndex++;
                    }
                }
                d3StackDataSet.push(d3DataPoints);
                metricResultDataPoints.push(adjustedDataPoints);
            });
        }
        else {
            if (isStackedChart) {
                var emptyData = createEmptyD3StackDataPoints(xValues, metricDisplayName);
                d3StackDataSet.push(emptyData.d3DataPoints);
                metricResultDataPoints.push(emptyData.metricResultDataPoints);
            }
            else {
                d3StackDataSet.push([]);
                metricResultDataPoints.push([]);
            }
        }
    }
    return {
        d3StackDataSet: d3StackDataSet,
        transformedMetricResult: metricResultDataPoints,
    };
}
exports.transformMetricResultForD3 = transformMetricResultForD3;
function createEmptyD3StackDataPoints(xValues, metricDisplayName) {
    var d3StackDataSet = [];
    var metricResultDataPoints = [];
    if (xValues && xValues.length > 0) {
        xValues.forEach(function (x) {
            d3StackDataSet.push({
                x: x,
                y: 0,
                y0: 0,
                metric: metricDisplayName,
                segment: undefined,
                missingValue: true,
            });
            metricResultDataPoints.push({ timestamp: x, value: 0, missingValue: true });
        });
    }
    return {
        d3DataPoints: d3StackDataSet,
        metricDataPoints: metricResultDataPoints,
    };
}
function chartVisualEqual(left, right) {
    if (!left && !right) {
        return true;
    }
    if (left && right) {
        return left.chartType === right.chartType &&
            legendEquals(left.legend, right.legend) &&
            axisEquals(left.axis, right.axis) &&
            sizeEquals(left.containerSize, right.containerSize) &&
            backGroundColorEquals(left.backgroundColor, right.backgroundColor);
    }
    return false;
}
exports.chartVisualEqual = chartVisualEqual;
function legendEquals(left, right) {
    if (!left && !right) {
        return true;
    }
    if (left && right) {
        return left.isVisible === right.isVisible && left.position === right.position && left.hideSubtitle === right.hideSubtitle;
    }
    return false;
}
function axisEquals(left, right) {
    if (!left && !right) {
        return true;
    }
    if (left && right) {
        return individualAxisEquals(left.x, right.x) && individualAxisEquals(left.y, right.y);
    }
    return false;
}
function individualAxisEquals(left, right) {
    if (!left && !right) {
        return true;
    }
    if (left && right) {
        return left.isVisible === right.isVisible && left.axisType === right.axisType &&
            left.max === right.max && left.min === right.min;
    }
    return false;
}
function sizeEquals(left, right) {
    if (!left && !right) {
        return true;
    }
    if (left && right) {
        return left.height === right.height && left.width === right.width;
    }
    return false;
}
function backGroundColorEquals(left, right) {
    if (!left && !right) {
        return true;
    }
    return left && right ? left === right : false;
}
//# sourceMappingURL=Util.js.map