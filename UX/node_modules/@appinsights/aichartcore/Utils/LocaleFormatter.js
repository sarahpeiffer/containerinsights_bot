"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Note: in portal side, "d3" need to be the first. so disable tslint rule for the line after
var d3 = require("d3");
var TimeUnits = require("../AI/ME/Utilities/TimeUnits");
var Strings = require("../Scripts/Strings/src/MELiteStrings");
var _d3DateIndexLookUp = [
    function (d, isUTC) { return isUTC ? !!d.getUTCMilliseconds() : !!d.getMilliseconds(); },
    function (d, isUTC) { return isUTC ? !!d.getUTCSeconds() : !!d.getSeconds(); },
    function (d, isUTC) { return isUTC ? !!d.getUTCMinutes() : !!d.getMinutes(); },
    function (d, isUTC) { return isUTC ? !!d.getUTCHours() : !!d.getHours(); },
    function (d, isUTC) { return isUTC ? (d.getUTCDay() && d.getUTCDate() !== 1) : (d.getDay() && d.getDate() !== 1); },
    function (d, isUTC) { return isUTC ? (d.getUTCDate() !== 1) : (d.getDate() !== 1); },
    function (d, isUTC) { return isUTC ? !!d.getUTCMonth() : !!d.getMonth(); },
    function (d, isUTC) { return true; },
];
var _globalizedDateTimeFormatOptionsForD3DefaultFormat = [
    ".%L",
    ":%S",
    "%I:%M",
    "%I %p",
    "%a %d",
    "%b %d",
    "%B",
    "%Y",
];
// helper to look up which index match the _d3DateIndexLookUp
function _getDateFormatingIndex(d, isUTC) {
    var lookup = _d3DateIndexLookUp;
    var index = 0;
    while (index < lookup.length) {
        if (lookup[index](d, isUTC)) {
            return index;
        }
        index++;
    }
    return index - 1;
}
function formatTickTime(value, isUTC) {
    var format;
    if (isUTC) {
        format = d3.time.format.utc("%b %d %I:%M %p");
    }
    else {
        format = d3.time.format("%b %d %I:%M %p");
    }
    return format(value);
}
exports.formatTickTime = formatTickTime;
function formatTime(actualValue, currentUnit, isAxisTick) {
    // convert to milliseconds, and get the target display unit
    var resultUnit = TimeUnits.getDisplayUnit(actualValue, currentUnit, isAxisTick);
    var scaledResultValue = TimeUnits.convert(actualValue, currentUnit, resultUnit);
    return { value: scaledResultValue !== 0 ? d3.format(".2r")(scaledResultValue) : "0", unit: resultUnit.name };
}
exports.formatTime = formatTime;
function formatAxisTime(actualValue, isUtc) {
    var index = _getDateFormatingIndex(actualValue, isUtc);
    var format = _globalizedDateTimeFormatOptionsForD3DefaultFormat[index];
    // Fallback to d3 format for now.
    return isUtc ? d3.time.format.utc(format)(actualValue) : d3.time.format(format)(actualValue);
}
exports.formatAxisTime = formatAxisTime;
function formatCounts(actualValue) {
    // The existing Ibiza control shows 2 decimals of precision.  We will follow that.
    var formatter = d3.formatPrefix(actualValue);
    var unit = formatter.symbol;
    switch (unit) {
        case "G":
            unit = Strings.billionUnit;
            break;
        case "M":
            unit = Strings.millionUnit;
            break;
        case "k":
            unit = Strings.kiloUnit;
            break;
    }
    var scaledValue = formatter.scale(actualValue);
    var hasFraction = Math.round(scaledValue * 100) % 100 !== 0;
    if (hasFraction) {
        return { value: d3.format(".2f")(scaledValue), unit: unit };
    }
    else {
        return { value: Math.round(scaledValue).toString(10), unit: unit };
    }
}
exports.formatCounts = formatCounts;
function formatBytes(bytes, useSIConversions, displaySIUnit) {
    var factor = useSIConversions ? 1000 : 1024;
    var str = displaySIUnit ? "" : "i";
    var scaledValue = undefined;
    var unit = undefined;
    if (bytes < factor) {
        scaledValue = bytes;
        unit = "B";
    }
    else if (bytes < factor * factor) {
        scaledValue = bytes / factor;
        unit = "K" + str + "B";
    }
    else if (bytes < factor * factor * factor) {
        scaledValue = bytes / factor / factor;
        unit = "M" + str + "B";
    }
    else if (bytes < factor * factor * factor * factor) {
        scaledValue = bytes / factor / factor / factor;
        unit = "G" + str + "B";
    }
    else {
        scaledValue = bytes / factor / factor / factor / factor;
        unit = "T" + str + "B";
    }
    var hasFraction = Math.round(scaledValue * 10) % 10 !== 0;
    return { value: hasFraction ? d3.format(",.1f")(scaledValue) : d3.format(",.0f")(scaledValue), unit: unit };
}
exports.formatBytes = formatBytes;
function formatPercentages(actualValue) {
    if (Math.floor(actualValue / 1000) > 0) {
        // It's possible the backend return percentage number which is greater than 100 (e.g. metric 'CPU Percentage' )
        // When it's over 1000 (5321),  we will try render something like 5.3k %
        actualValue = Math.floor(actualValue / 100) * 100;
        // only need one digit from the mansissa to avoid overlapping with '%' sign
        var formatted = formatCounts(actualValue);
        return { value: formatted.value + formatted.unit, unit: "%" };
    }
    else {
        var hasFraction = Math.round(actualValue * 100) % 100 !== 0;
        // Consider when actualValue is 24.9999995, hasFraction will be false due to rounding.  Do a Math.round so we return "25" accordingly.
        return { value: hasFraction ? d3.format(".2f")(actualValue) : (Math.round(actualValue * 100) / 100).toString(), unit: "%" };
    }
}
exports.formatPercentages = formatPercentages;
//# sourceMappingURL=LocaleFormatter.js.map