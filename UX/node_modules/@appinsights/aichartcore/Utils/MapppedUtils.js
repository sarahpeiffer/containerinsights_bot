"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function createElement(tagName, options) {
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    var element = document.createElement(tagName);
    Object.keys(options).forEach(function (key) {
        if (key === "class") {
            element.className = options.class;
        }
        else {
            element.setAttribute(key, options[key]);
        }
    });
    if (children) {
        children.forEach(function (child) {
            if (typeof child === "string") {
                element.append ? element.append(child) : element.innerHTML += child;
            }
            else {
                element.appendChild(child);
            }
        });
    }
    return element;
}
exports.createElement = createElement;
function getUrlEndpoint(uri) {
    // Note: cannot use MsPortalFx.Base.UriBuilder.getSchemeAndAuthority(), because it throw exception for some uri.
    var pathSeparator = "/";
    var start = 0;
    var end = 3;
    return uri.split(pathSeparator, 4).slice(start, end).join(pathSeparator);
}
exports.getUrlEndpoint = getUrlEndpoint;
function clone(source, deep) {
    if (deep === void 0) { deep = true; }
    if (isPrimitive(source)) {
        return source;
    }
    var target = Array.isArray(source) ? [] : {};
    return extend(target, source, deep);
}
exports.clone = clone;
/**
 * Returns a GUID such as xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx.
 * @return New GUID.
 */
var __hexValues__ = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
function newGuid() {
    /* tslint:disable:no-bitwise */
    // c.f. rfc4122 (UUID version 4 = xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx)
    var oct = "";
    var tmp = 0;
    for (var a = 0; a < 4; a++) {
        tmp = (4294967296 * Math.random()) | 0;
        oct += __hexValues__[tmp & 0xF]
            + __hexValues__[tmp >> 4 & 0xF]
            + __hexValues__[tmp >> 8 & 0xF]
            + __hexValues__[tmp >> 12 & 0xF]
            + __hexValues__[tmp >> 16 & 0xF]
            + __hexValues__[tmp >> 20 & 0xF]
            + __hexValues__[tmp >> 24 & 0xF]
            + __hexValues__[tmp >> 28 & 0xF];
    }
    // "Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively"
    var clockSequenceHi = __hexValues__[8 + (Math.random() * 4) | 0];
    return oct.substr(0, 8) + "-" + oct.substr(9, 4) + "-4" + oct.substr(13, 3) + "-" + clockSequenceHi + oct.substr(16, 3) + "-" + oct.substr(19, 12);
    /* tslint:enable:no-bitwise */
}
exports.newGuid = newGuid;
var array_forEach = _uncurryThis(Array.prototype.forEach);
var primitiveTypes = {};
array_forEach(["boolean", "number", "string", "symbol"], function (item) { primitiveTypes[item] = true; });
/**
 * Returns whether the given data is primitive data type.
 * ECMAScript 6 standard defines 6 primitive data types: Boolean, Null, Undefined, Number, String, Symbol(new in ECMAScript 6)
 *
 * @param data The input data.
 * @return A boolean value indicating whether the data is primitive data type.
 */
function isPrimitive(data) {
    return data === null || data === undefined || typeof data in primitiveTypes;
}
/**
 * Extends the target object with the properties from source object.
 *
 * @param target The object that is to be extended. This object is modified and returned.
 * @param source The object whose properties are to be copied over.
 * @param deep A flag indicating whether the operation is to be performed recursively.
 * @return The same target object (after extension).
 */
function extend(target, source, deep) {
    if (deep) {
        return jqueryExtend(true, target, source);
    }
    else {
        return jqueryExtend(target, source);
    }
}
exports.extend = extend;
var jqueryExtend = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var options, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, deep = false;
    // Handle a deep copy situation
    if (typeof target === "boolean") {
        deep = target;
        // Skip the boolean and the target
        target = arguments[i] || {};
        i++;
    }
    // Handle case when target is a string or something (possible in deep copy)
    if (typeof target !== "object" && typeof target === "function") {
        target = {};
    }
    var length = arguments.length;
    // Extend jQuery itself if only one argument is passed
    if (i === length) {
        target = this;
        i--;
    }
    for (; i < length; i++) {
        // Only deal with non-null/undefined values
        /* tslint:disable:triple-equals */
        if ((options = arguments[i]) != null) {
            /* tslint:enable:triple-equals */
            // Extend the base object
            for (var name_1 in options) {
                if (options.hasOwnProperty(name_1)) {
                    src = target[name_1];
                    copy = options[name_1];
                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }
                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (isPlainObject(copy) ||
                        (copyIsArray = Array.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && Array.isArray(src) ? src : [];
                        }
                        else {
                            clone = src && isPlainObject(src) ? src : {};
                        }
                        // Never move original objects, clone them
                        target[name_1] = jqueryExtend(deep, clone, copy);
                        // Don't bring in undefined values
                    }
                    else if (copy !== undefined) {
                        target[name_1] = copy;
                    }
                }
            }
        }
    }
    // Return the modified object
    return target;
};
function _uncurryThis(f) {
    return function () {
        return Function.call.apply(f, arguments);
    };
}
var object_hasOwnProperty = _uncurryThis(Object.prototype.hasOwnProperty);
function isPlainObject(obj) {
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (typeof obj !== "object" || obj.nodeType || isWindow(obj)) {
        return false;
    }
    var constror = obj.constructor;
    var proto = constror && constror.prototype;
    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return !(proto && !object_hasOwnProperty(proto, "isPrototypeOf"));
}
function isWindow(obj) {
    return obj && obj === obj.window;
}
//# sourceMappingURL=MapppedUtils.js.map