"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var Strings = require("PillResources");
var TimeUtils = require("./TimeUtils");
var DatePicker_1 = require("./DatePicker");
require("./Styles/CustomTimePicker");
var CustomTimePicker = /** @class */ (function (_super) {
    __extends(CustomTimePicker, _super);
    function CustomTimePicker(props) {
        var _this = _super.call(this, props) || this;
        _this.state = _this._importTimeContext(props.value);
        return _this;
    }
    CustomTimePicker.prototype.componentWillReceiveProps = function (nextProps) {
        if (!absoluteTimeRangesEquals(nextProps.value, this.props.value)) {
            var tmpState_1 = this._importTimeContext(nextProps.value);
            this.setState(function () {
                return { timeRange: tmpState_1.timeRange };
            });
        }
    };
    CustomTimePicker.prototype._onChange = function (isValidDate, isStartDate) {
        this.props.onChange(this._exportDates(), isValidDate, isStartDate);
    };
    CustomTimePicker.prototype._importTimeContext = function (time) {
        if (!time) {
            return { timeRange: { endTime: new Date(), startTime: new Date() } };
        }
        if (TimeUtils.isAbsolute(time) && time.absolute) {
            return {
                timeRange: {
                    endTime: time.absolute.endTime,
                    startTime: time.absolute.startTime
                }
            };
        }
        return { timeRange: { endTime: new Date(), startTime: new Date() } };
    };
    CustomTimePicker.prototype._exportDates = function () {
        var absoluteData = {
            options: this.props.value.options,
            absolute: this.state.timeRange
        };
        return absoluteData;
    };
    CustomTimePicker.prototype._onStartChanged = function (date, isValidDate) {
        var _this = this;
        this.setState(function (prevState) {
            return {
                timeRange: {
                    startTime: date,
                    endTime: prevState.timeRange.endTime,
                },
            };
        }, function () {
            _this._onChange(isValidDate, true);
        });
    };
    CustomTimePicker.prototype._onEndChanged = function (date, isValidDate) {
        var _this = this;
        this.setState(function (prevState) {
            return {
                timeRange: {
                    startTime: prevState.timeRange.startTime,
                    endTime: date,
                },
            };
        }, function () {
            _this._onChange(isValidDate, false);
        });
    };
    CustomTimePicker.prototype.render = function () {
        var showUTC = this.props.value.options.showUTCTime;
        var startTimeValidation = this.props.startTimeValidation;
        var endTimeValidation = this.props.endTimeValidation;
        var validationMessage;
        if (!startTimeValidation.isValid && startTimeValidation.reason) {
            validationMessage = React.createElement("span", { className: "time-picker-validation-message" }, startTimeValidation.reason);
        }
        else if (!endTimeValidation.isValid && endTimeValidation.reason) {
            validationMessage = React.createElement("span", { className: "time-picker-validation-message" }, endTimeValidation.reason);
        }
        return React.createElement("div", { className: "custom-time-picker" },
            React.createElement("span", null, Strings.startTime),
            React.createElement(DatePicker_1.DatePicker, { isStartTime: true, validation: startTimeValidation, selected: this.state.timeRange.startTime, onChange: this._onStartChanged.bind(this), showUTC: showUTC }),
            React.createElement("span", null, Strings.endTime),
            React.createElement(DatePicker_1.DatePicker, { isStartTime: false, validation: endTimeValidation, selected: this.state.timeRange.endTime, onChange: this._onEndChanged.bind(this), showUTC: showUTC }),
            validationMessage);
    };
    CustomTimePicker.defaultProps = {};
    return CustomTimePicker;
}(React.Component));
exports.CustomTimePicker = CustomTimePicker;
function absoluteTimeRangesEquals(leftTimeData, rightTimeData) {
    if ((!leftTimeData && rightTimeData) || (leftTimeData && !rightTimeData)) {
        return false;
    }
    if (TimeUtils.isAbsolute(leftTimeData) && TimeUtils.isAbsolute(rightTimeData)) {
        return (leftTimeData.absolute.startTime.getTime() === rightTimeData.absolute.startTime.getTime()) &&
            (leftTimeData.absolute.endTime.getTime() === rightTimeData.absolute.endTime.getTime());
    }
    else {
        return false;
    }
}
exports.absoluteTimeRangesEquals = absoluteTimeRangesEquals;
//# sourceMappingURL=CustomTimePicker.js.map