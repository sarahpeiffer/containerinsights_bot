"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var Pikaday = require("pikaday");
var React = require("react");
var ReactDOM = require("react-dom");
var Calendar_1 = require("./Images/Calendar");
var Strings = require("PillResources");
require("./Styles/Date-picker");
require("pikaday/css/pikaday.css");
var DATE_FORMAT = "L";
var TIME_FORMAT = "LT";
var DatePicker = /** @class */ (function (_super) {
    __extends(DatePicker, _super);
    function DatePicker(props) {
        var _this = _super.call(this, props) || this;
        _this._pickerVisible = false;
        _this._handleClickOutside = _this._handleClickOutside.bind(_this);
        _this.state = {
            currentDate: props.selected,
            isValidDate: true,
            dateValue: props.selected && moment(props.selected).format(DATE_FORMAT),
            timeValue: props.selected && moment(props.selected).format(TIME_FORMAT),
            isDateFocused: false,
            isTimeFocused: false,
            visibility: false,
        };
        return _this;
    }
    /** Helper function that gets around broken "contains" method
     * Root cause is "psuedo-elements" not having parents
     */
    DatePicker.prototype._hasParent = function (target, search) {
        if (!target) {
            return false;
        }
        else if (target.className === "pika-lendar") {
            return true;
        }
        return target === search ? true : this._hasParent(target.parentElement, search);
    };
    /** This manages the textbox focus highlighting even when
     * interacting with the calendar instead of the textbox.
     * It also manages closing the calendar if anything but the calendar is clicked.
     */
    DatePicker.prototype._onMouseDown = function (ev) {
        if (this._dateBox) {
            var calendar = this._dateBox.parentElement.getElementsByClassName("pika-single").item(0);
            var calendarButton = this._dateBox.parentElement.getElementsByClassName("calendar-button").item(0);
            if (calendar && !this._hasParent(ev.target, calendar) && !this._hasParent(ev.target, calendarButton)) {
                this._hidePicker();
            }
        }
    };
    DatePicker.prototype._hidePicker = function () {
        this._picker.hide();
        this._pickerVisible = false;
    };
    DatePicker.prototype._showPicker = function () {
        this._picker.show();
        this._pickerVisible = true;
    };
    DatePicker.prototype._togglePicker = function () {
        if (!this._pickerVisible) {
            this._showPicker();
        }
        else {
            this._hidePicker();
        }
    };
    DatePicker.prototype._handleClickOutside = function (event) {
        var domNode = ReactDOM.findDOMNode(this);
        if ((!domNode || !domNode.contains(event.target))) {
            this._hidePicker();
        }
    };
    DatePicker.prototype.componentDidMount = function () {
        var _this = this;
        this._picker = new Pikaday({
            field: this._dateBox,
            format: DATE_FORMAT,
            bound: false,
            trigger: this._button,
            // Adding class azure-date-picker-override which other users of this control
            // can use to override the fixed styles
            theme: "azure-date-picker-override azure-date-picker",
            onOpen: this._onOpenCalendar.bind(this),
            onSelect: this.onSelected.bind(this)
        });
        this._hidePicker();
        this.setState(function (prevState, currentProps) {
            return _this._updateDate(prevState.currentDate, currentProps.showUTC);
        });
        document.addEventListener("click", this._handleClickOutside, true);
        // Helper function that gets around broken "contains" method
        // Root cause is "psuedo-elements" not having parents
        var hasParent = function (target, search) {
            if (!target) {
                return false;
            }
            else if (target.className === "pika-lendar") {
                return true;
            }
            return target === search ? true : hasParent(target.parentElement, search);
        };
        // This manages the textbox focus highlighting even when
        // interacting with the calendar instead of the textbox.
        // It also manages closing the calendar if anything but the calendar is clicked.
        window.addEventListener("mousedown", this._onMouseDown);
    };
    DatePicker.prototype.componentWillReceiveProps = function (nextProps, nextContext) {
        var _this = this;
        if ((this.props.selected.getTime() !== nextProps.selected.getTime() &&
            nextProps.selected.getTime() !== this.state.currentDate.getTime()) ||
            this.props.showUTC !== nextProps.showUTC) {
            this.setState(function () {
                return _this._updateDate(nextProps.selected, nextProps.showUTC);
            });
        }
    };
    DatePicker.prototype._onDateClicked = function (e) {
        this.setState(function () {
            return { isDateFocused: true, isTimeFocused: false };
        });
    };
    DatePicker.prototype._onTimeClicked = function (e) {
        this.setState(function () {
            return { isDateFocused: false, isTimeFocused: true };
        });
    };
    DatePicker.prototype._onDateBlur = function (e) {
        this.setState(function () {
            return { isDateFocused: false };
        });
    };
    DatePicker.prototype._onTimeBlur = function (e) {
        this.setState(function () {
            return { isTimeFocused: false };
        });
    };
    DatePicker.prototype._updateDate = function (updatedDate, showUTC) {
        if (showUTC) {
            var momentValue = moment.utc(updatedDate);
            return {
                currentDate: momentValue.toDate(),
                dateValue: momentValue.utc().format(DATE_FORMAT),
                timeValue: momentValue.utc().format(TIME_FORMAT),
                isValidDate: true,
            };
        }
        else {
            var momentValue = moment(updatedDate);
            return {
                currentDate: momentValue.toDate(),
                dateValue: momentValue.format(DATE_FORMAT),
                timeValue: momentValue.format(TIME_FORMAT),
                isValidDate: true,
            };
        }
    };
    DatePicker.prototype._onOpenCalendar = function () {
        if (this._picker) {
            // make sure that the picker has a correct date selected
            var d = new Date(this.state.currentDate.getTime());
            d = new Date(d.setHours(0, 0, 0, 0));
            this._picker._d = d;
            this._picker.gotoDate(d);
        }
    };
    DatePicker.prototype.onSelected = function (date) {
        var _this = this;
        this.setState(function (prevState, currentProps) {
            // We don"t set state.currentDate directly in some cases so that
            // user specified hour+min are retained
            var updatedDate = new Date(prevState.currentDate);
            updatedDate.setMonth(date.getMonth());
            updatedDate.setFullYear(date.getFullYear());
            updatedDate.setDate(date.getDate());
            return _this._updateDate(updatedDate, currentProps.showUTC);
        }, function () {
            _this._hidePicker();
            _this.onChange(_this.state.currentDate, _this.state.isValidDate);
        });
    };
    DatePicker.prototype.onManualTimeChange = function (e) {
        if (shouldReactToEvent(e)) {
            this.onManualChange(e, false);
        }
    };
    DatePicker.prototype.onManualDateChange = function (e) {
        if (shouldReactToEvent(e)) {
            this.onManualChange(e, true);
        }
    };
    DatePicker.prototype.onManualChange = function (e, isDateChange) {
        var _this = this;
        var value = e.target.value;
        var format = isDateChange ? DATE_FORMAT : TIME_FORMAT;
        var locale = moment.locale();
        var isValid = moment(value, format, locale).isValid();
        if (isValid) {
            this.setState(function (prevState, prevProps) {
                var updateValue;
                if (_this.props.showUTC) {
                    updateValue = moment.utc(value, format, locale);
                }
                else {
                    updateValue = moment(value, format, locale);
                }
                var originalDate = prevState.currentDate;
                if (isDateChange) {
                    // restore original time values
                    updateValue.hours(originalDate.getHours());
                    updateValue.minutes(originalDate.getMinutes());
                    updateValue.seconds(originalDate.getSeconds());
                    updateValue.milliseconds(originalDate.getMilliseconds());
                }
                else {
                    // restore original date values
                    updateValue.date(originalDate.getDate());
                    updateValue.month(originalDate.getMonth());
                    updateValue.year(originalDate.getFullYear());
                }
                var updatedState = _this._updateDate(updateValue.toDate(), prevProps.showUTC);
                updatedState.isValidDate = true;
                if (updatedState.currentDate.toISOString() !== originalDate.toISOString()) {
                    _this.onChange(updatedState.currentDate, updatedState.isValidDate);
                }
                return updatedState;
            }, function () {
                _this._hidePicker();
            });
        }
        else {
            this.setState(function (prevState) {
                if (prevState.isValidDate) {
                    _this.onChange(prevState.currentDate, false);
                }
                return { isValidDate: false };
            }, function () {
                _this._hidePicker();
            });
        }
    };
    DatePicker.prototype.onChange = function (updatedDate, isValidDate) {
        if (this.props.onChange) {
            this.props.onChange(updatedDate, isValidDate);
        }
    };
    DatePicker.prototype.onDateValueChange = function (e) {
        var updatedValue = e.target.value;
        this.setState(function () {
            return { dateValue: updatedValue };
        });
    };
    DatePicker.prototype.onTimeValueChange = function (e) {
        var updatedValue = e.target.value;
        this.setState(function () {
            return { timeValue: updatedValue };
        });
    };
    DatePicker.prototype.componentWillUnmount = function () {
        document.removeEventListener("click", this._handleClickOutside, true);
        window.removeEventListener("mousedown", this._onMouseDown);
    };
    DatePicker.prototype.render = function () {
        var _this = this;
        var dateLabel = this.props.isStartTime ? Strings.startDate : Strings.endDate;
        var timeLabel = this.props.isStartTime ? Strings.startTime : Strings.endTime;
        var textBoxClassName = " panel-control" + (this.props.validation.isValid ? "" : " invalid");
        return React.createElement("div", { className: "date-picker-input" },
            React.createElement("div", { className: "date-picker" + textBoxClassName + (this.state.isDateFocused && this.props.validation.isValid ? " focus" : ""), onClick: this._onDateClicked.bind(this), onBlur: this._onDateBlur.bind(this) },
                React.createElement("input", { type: "text", role: "textbox", ref: function (db) { return _this._dateBox = db; }, "aria-label": dateLabel, value: this.state.dateValue, onChange: this.onDateValueChange.bind(this), onKeyUp: this.onManualDateChange.bind(this), onBlur: this.onManualDateChange.bind(this) }),
                React.createElement("div", { role: "button", "aria-label": Strings.selectDate, className: "calendar-button", onClick: function () { return _this._togglePicker(); }, ref: function (t) { return _this._button = t; } },
                    React.createElement("span", { className: "calendar-icon" },
                        React.createElement(Calendar_1.CalendarSvg, null)))),
            React.createElement("div", { className: textBoxClassName + (this.state.isTimeFocused && this.props.validation.isValid ? " focus" : ""), onClick: this._onTimeClicked.bind(this), onBlur: this._onTimeBlur.bind(this) },
                React.createElement("input", { type: "text", role: "textbox", "aria-label": timeLabel, value: this.state.timeValue, onChange: this.onTimeValueChange.bind(this), onKeyUp: this.onManualTimeChange.bind(this), onBlur: this.onManualTimeChange.bind(this) })));
    };
    DatePicker.defaultProps = {
        isStartTime: null,
        selected: null,
        validation: null,
        onChange: null,
        showUTC: null
    };
    return DatePicker;
}(React.Component));
exports.DatePicker = DatePicker;
function shouldReactToEvent(e) {
    var keyEvent = e;
    if (keyEvent && keyEvent.key) {
        return keyEvent.key === "Enter";
    }
    return true;
}
//# sourceMappingURL=DatePicker.js.map