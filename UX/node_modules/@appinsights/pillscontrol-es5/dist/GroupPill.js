"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var Select = require("@appinsights/react-select");
var Strings = require("PillResources");
var VirtualizedSelectMenu_1 = require("./VirtualizedSelectMenu");
var DropdownIcon_1 = require("./Images/DropdownIcon");
var GroupPillData_1 = require("./GroupPillData");
var Utils_1 = require("./Utils");
require("@appinsights/react-select/dist/react-select.css");
require("./Styles/GroupPill");
require("./Styles/DropdownPill");
require("./Styles/TextPill");
var GroupPill = /** @class */ (function (_super) {
    __extends(GroupPill, _super);
    function GroupPill(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.state = {
            valuePickerList: props && props.pickerLists && props.pickerLists.valueList,
            limitValue: props && props.defaultLimitValue,
            menuRenderer: VirtualizedSelectMenu_1.createVirtualizedMenuRenderFunction()
        };
        _this._instanceIndex = ++GroupPill.globalInstanceIndex;
        _this._handleSelectionChange = Utils_1.debounce(_this, _this._handleSelectionChange.bind(_this), 200); // debouncing function to 200ms & binding this
        _this._onChangeValue = _this._onChangeValue.bind(_this);
        _this._shouldExpandDropdowns = true;
        return _this;
    }
    GroupPill.prototype.componentWillMount = function () {
        this.updateAriaLabel(this.props.selection, this.state.limitValue);
    };
    GroupPill.prototype.componentWillReceiveProps = function (nextProps, nextContext) {
        // Update configured status when entering edit mode
        var _this = this;
        this.setState(function (prevState) {
            var limitValue = prevState.limitValue;
            var groupPillValidation;
            if (limitValue < _this.props.minLimitValue || limitValue > _this.props.maxLimitValue) {
                groupPillValidation = {
                    isValid: false,
                    reason: Strings.limitGroupPillMessage.replace("{0}", nextProps.minLimitValue.toString()).replace("{1}", nextProps.maxLimitValue.toString()),
                };
            }
            var updatedState = {
                valuePickerList: prevState.valuePickerList,
                limitValue: prevState.limitValue,
                groupPillValidation: groupPillValidation,
            };
            var groupValues = nextProps.pickerLists && nextProps.pickerLists.valueList;
            // Update Group options
            if (groupValues && groupValues.length > 0) {
                updatedState.valuePickerList = groupValues;
            }
            else if (nextProps.areValuesLoading) {
                updatedState.valuePickerList = [Utils_1.getLoadingEntry()];
            }
            else {
                updatedState.valuePickerList = [Utils_1.getNoResultsEntry()];
            }
            _this.updateAriaLabel(nextProps.selection, _this.state.limitValue, nextProps);
            if (!_this.props.editMode && nextProps.editMode) {
                _this._shouldExpandDropdowns = true;
                nextProps.updateConfiguredStatus(_this._isConfigured(nextProps.selection, _this.state.limitValue));
            }
            return updatedState;
        });
    };
    GroupPill.prototype.render = function () {
        if (this.props.editMode) {
            return this.renderDropdowns();
        }
        else {
            return this.renderCollapsed();
        }
    };
    GroupPill.prototype.renderDropdowns = function () {
        var className = Utils_1.getDropdownWrapperClassName(this.props.showLabels, "group-pill ");
        var validationMessage;
        var noLabelClassName = (Utils_1.isNullOrUndefined(this.props.showLabels) || this.props.showLabels === false) ? " no-label" : "";
        var groupPillValidation = this.state.groupPillValidation;
        if (groupPillValidation && !groupPillValidation.isValid && groupPillValidation.reason) {
            validationMessage = React.createElement("span", { className: "aim-group-validation-message" + noLabelClassName }, groupPillValidation.reason);
        }
        return React.createElement("div", { className: "aim-group-pill-flex" },
            validationMessage,
            React.createElement("div", { className: className },
                this.renderDropdownWithLabel(this.renderValuesDropdown(), Strings.values, !validationMessage),
                this.props.enableLimit ? this.renderLimitTextboxWithLabel(Strings.limit, !validationMessage) : undefined,
                this.props.enableSort ? this.renderDropdownWithLabel(this.renderSortDropdown(), Strings.sort, !validationMessage) : undefined));
    };
    GroupPill.prototype.renderCollapsed = function () {
        var selection = this.props.selection;
        var displayedValue = React.createElement("span", { className: "not-configured" }, Strings.notConfigured);
        if (this._isConfigured(selection, this.state.limitValue)) {
            var showLimitCollapsed = this.showLimitCollapsed();
            var showSortCollapsed = this.showSortCollapsed();
            var showValueComma = this.props.enableLimit && (showLimitCollapsed || showSortCollapsed);
            var showLimitComma = this.props.enableSort && showSortCollapsed;
            var valueCollapsed = void 0;
            if (this.showValueCollapsed()) {
                valueCollapsed = React.createElement("div", { className: "value" }, selection.selectedValue.label + (showValueComma ? ", " : ""));
            }
            var limitCollapsed = void 0;
            if (this.props.enableLimit && showLimitCollapsed) {
                limitCollapsed = React.createElement("div", { className: "limit" },
                    Strings.limit + ": ",
                    " ",
                    this.state.limitValue + (showLimitComma ? ", " : ""));
            }
            var sortCollapsed = void 0;
            if (this.props.enableSort && showSortCollapsed) {
                sortCollapsed = React.createElement("div", { className: "sort" }, selection.selectedSort.label);
            }
            /* Display localized value like "Split By = <dimension> <[1..50]> <Ascending/Descending>" */
            displayedValue = (React.createElement("div", { className: "aim-group-pill aim-group-configured" },
                React.createElement("div", null, Strings.splitByPillHeader),
                React.createElement("div", { style: { minWidth: "auto", } }, "="),
                valueCollapsed,
                limitCollapsed,
                sortCollapsed));
        }
        return React.createElement("span", { className: "pillcontent" }, displayedValue);
    };
    GroupPill.prototype.showValueCollapsed = function () {
        return this.props.showValueCollapsed !== undefined && this.props.showValueCollapsed !== null && this.props.showValueCollapsed;
    };
    GroupPill.prototype.showLimitCollapsed = function () {
        return this.props.showLimitCollapsed ||
            (this.props.showChangedValueOnCollapse &&
                !(this.state.limitValue === undefined ||
                    (this.state.limitValue === this.props.defaultLimitValue)));
    };
    GroupPill.prototype.showSortCollapsed = function () {
        var selection = this.props.selection;
        return this.props.showSortCollapsed ||
            (this.props.showChangedValueOnCollapse &&
                !(selection.selectedSort.value === this.props.defaultSortValue));
    };
    GroupPill.prototype.renderDropdownWithLabel = function (dropdownFn, label, isValid) {
        return React.createElement("div", { className: "aim-pill-dropdown-with-labels" },
            this.props.showLabels && isValid ? React.createElement("label", { id: "aim-pill-label-" + label }, label) : null,
            dropdownFn);
    };
    GroupPill.prototype.renderLimitTextboxWithLabel = function (label, isValid) {
        var textBoxClassName = " aim-pill-text-input aim-pill-group-text" + (!isValid ? " invalid-text" : "");
        var showLabels = this.props.showLabels && isValid;
        var textLabel;
        if (showLabels) {
            textLabel = React.createElement("label", { id: "aim-group-pill-label-" + label, className: "aim-group-pill-label" }, label);
        }
        var placeholder = this.props.defaultLimitValue ? (this.props.defaultLimitValue + "") : undefined;
        return React.createElement("div", { className: "aim-pill-dropdown-with-labels" },
            textLabel,
            React.createElement("div", null,
                React.createElement("input", { type: "number", "aria-labelledby": showLabels ? "aim-pill-label-limit" : undefined, "aria-label": !showLabels ? Strings.limit : undefined, value: this.state.limitValue, min: this.props.minLimitValue, max: this.props.maxLimitValue, placeholder: placeholder, className: textBoxClassName, onChange: this._onChangeValue })));
    };
    GroupPill.prototype._onChangeValue = function (event) {
        var limit = (event.target !== null && event.target.value === "") ? undefined : parseInt(event.target.value, 10);
        this.setState({ limitValue: limit });
        return this._handleSelectionChange(GroupPillData_1.SelectionGroupChangeType.Limit, undefined, limit);
    };
    GroupPill.prototype.renderValuesDropdown = function () {
        var _this = this;
        var menuRenderer = this.state.menuRenderer;
        var optionRenderer = this.props.customOptionRenderers && this.props.customOptionRenderers.valueRenderer;
        var valueRenderer = this.props.customValueRenderers && this.props.customValueRenderers.valueRenderer;
        return React.createElement(Select.default, { id: "dropdown-groups" + this._instanceIndex, name: "selectedValues", "aria-labelledby": this.props.showLabels ? "aim-pill-label-values" : undefined, "aria-label": !this.props.showLabels ? Strings.values : undefined, ref: function (element) {
                var hasRef = !!_this._valueRef;
                _this._valueRef = element;
                if (!hasRef) {
                    _this._autoExpandDropdowns(_this.props.selection);
                }
            }, className: "aim-pill-dropdown virtualized", clearable: false, placeholder: Strings.selectValues, value: this.props.selection && this.props.selection.selectedValue, onChange: function (newVal) { return _this._handleSelectionChange(GroupPillData_1.SelectionGroupChangeType.Value, newVal); }, options: this.props.pickerLists.valueList, isLoading: this.props.areValuesLoading, arrowRenderer: DropdownIcon_1.DropdownIcon, openAfterFocus: true, openOnFocus: true, showTags: false, menuRenderer: menuRenderer, optionRenderer: optionRenderer, valueRenderer: valueRenderer, backspaceRemoves: false, tabSelectsValue: false, inputProps: { autoComplete: "off", autoCorrect: "off", spellCheck: "off" } });
    };
    GroupPill.prototype.renderSortDropdown = function () {
        var _this = this;
        var menuRenderer = this.state.menuRenderer;
        var optionRenderer = this.props.customOptionRenderers && this.props.customOptionRenderers.sortRenderer;
        var valueRenderer = this.props.customValueRenderers && this.props.customValueRenderers.sortRenderer;
        return React.createElement(Select.default, { id: "dropdown-sort" + this._instanceIndex, name: "selectedSort", "aria-labelledby": this.props.showLabels ? "aim-pill-label-sort" : undefined, "aria-label": !this.props.showLabels ? Strings.sort : undefined, className: "aim-pill-dropdown virtualized", clearable: false, placeholder: Strings.selectSort, value: this.props.selection && this.props.selection.selectedSort, onChange: function (newVal) { return _this._handleSelectionChange(GroupPillData_1.SelectionGroupChangeType.Sort, newVal); }, options: this.props.pickerLists.sortList, arrowRenderer: DropdownIcon_1.DropdownIcon, openAfterFocus: true, openOnFocus: true, showTags: false, menuRenderer: menuRenderer, optionRenderer: optionRenderer, valueRenderer: valueRenderer, backspaceRemoves: false, tabSelectsValue: false, inputProps: { autoComplete: "off", autoCorrect: "off", spellCheck: "off" } });
    };
    GroupPill.prototype.updateAriaLabel = function (selection, limit, nextProps) {
        var newLabel = Strings.notConfigured;
        if (this._isConfigured(selection, limit)) {
            newLabel = this._getSelectionString(selection, limit, nextProps);
        }
        this.props.updateAriaLabel(newLabel);
    };
    GroupPill.prototype._handleSelectionChange = function (changeType, newValue, limitValue) {
        var newSelection = this.props.selection ||
            {
                selectedValue: undefined,
                selectedSort: undefined,
            };
        var newLimitValue = Number(this.state.limitValue) || limitValue;
        switch (changeType) {
            case GroupPillData_1.SelectionGroupChangeType.Value:
                newSelection.selectedValue = newValue;
                break;
            case GroupPillData_1.SelectionGroupChangeType.Limit:
                newLimitValue = limitValue;
                break;
            case GroupPillData_1.SelectionGroupChangeType.Sort:
                newSelection.selectedSort = newValue;
                break;
        }
        // Change the appropriate selection
        var pickerLists = {
            valueList: this.state.valuePickerList,
            sortList: this.props.pickerLists.sortList,
        };
        this._shouldExpandDropdowns = true;
        this._autoExpandDropdowns(newSelection);
        this.props.updateConfiguredStatus(this._isConfigured(newSelection, newLimitValue));
        this.props.onSelectionChange(changeType, newSelection, this._isConfigured(newSelection, newLimitValue), pickerLists, newLimitValue);
        this.updateAriaLabel(newSelection, newLimitValue);
    };
    GroupPill.prototype._isConfigured = function (selection, limit) {
        return selection &&
            !Utils_1.isNullOrUndefined(selection.selectedValue) &&
            (!this.props.enableLimit || limit === undefined || (!isNaN(limit) && (limit >= 1 && limit <= 50))) &&
            (!this.props.enableSort || !!selection.selectedSort);
    };
    GroupPill.prototype._getSelectionString = function (selection, limit, nextProps) {
        if (this._isConfigured(selection, limit)) {
            var groupString = "";
            if (selection && selection.selectedValue) {
                var enableLimit = (nextProps && nextProps.enableLimit) || this.props.enableLimit;
                var enableSort = (nextProps && nextProps.enableSort) || this.props.enableSort;
                var showValueComma = enableLimit || enableSort;
                groupString += selection.selectedValue.label + (showValueComma ? ", " : "");
                if (enableLimit && (limit === undefined || !isNaN(limit))) {
                    groupString += Strings.limit + ": ";
                    groupString += (limit || this.props.defaultLimitValue) + ", ";
                }
                if (enableSort && selection.selectedSort) {
                    groupString += Strings.sort + " ";
                    groupString += selection.selectedSort.label;
                }
            }
            return groupString;
        }
        return null;
    };
    GroupPill.prototype._autoExpandDropdowns = function (selection) {
        if (this.props.autoOpen && this._shouldExpandDropdowns) {
            if (selection && !selection.selectedValue) {
                if (this._valueRef) {
                    this._valueRef.focus();
                    this._shouldExpandDropdowns = false;
                }
            }
        }
    };
    GroupPill.globalInstanceIndex = 0;
    return GroupPill;
}(React.Component));
exports.GroupPill = GroupPill;
//# sourceMappingURL=GroupPill.js.map