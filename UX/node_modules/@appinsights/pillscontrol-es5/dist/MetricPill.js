"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var react_select_1 = require("@appinsights/react-select"); // Can't use Select.default inside Typescript, so need to import default class separately
var Strings = require("PillResources");
var DefaultAddIcon_1 = require("./Images/DefaultAddIcon");
var DropdownIcon_1 = require("./Images/DropdownIcon");
var Utils_1 = require("./Utils");
var VirtualizedSelectMenu_1 = require("./VirtualizedSelectMenu");
var MetricPillData_1 = require("./MetricPillData");
require("@appinsights/react-select/dist/react-select.css");
require("./Styles/MetricPill");
require("./Styles/DropdownPill");
var MetricPill = /** @class */ (function (_super) {
    __extends(MetricPill, _super);
    function MetricPill(props, context) {
        var _this = _super.call(this, props, context) || this;
        var selection = props && props.selection
            ? props.selection
            : {
                selectedResource: null,
                selectedNamespace: null,
                selectedMetric: null,
                selectedAggregation: null,
            };
        _this.state = {
            selection: selection,
            metricList: props && props.pickerLists && props.pickerLists.metricsList,
            areNamespacesLoading: false,
            areMetricsLoading: false,
            areAggregationsLoading: false
        };
        _this._instanceIndex = ++MetricPill.globalInstanceIndex;
        _this._handleSelectionChange = _this._handleSelectionChange.bind(_this);
        _this._shouldExpandDropdowns = true;
        return _this;
    }
    MetricPill.prototype.componentWillMount = function () {
        this.updateAriaLabel(this.state.selection);
    };
    MetricPill.prototype.componentWillReceiveProps = function (nextProps, nextContext) {
        var _this = this;
        var currentProps = this.props;
        this.setState(function (prevState) {
            var updatedState = {
                areNamespacesLoading: prevState.areNamespacesLoading,
                areMetricsLoading: prevState.areMetricsLoading,
                areAggregationsLoading: prevState.areAggregationsLoading,
                selection: nextProps.selection,
                metricList: prevState.metricList,
            };
            var nextPickerLists = nextProps.pickerLists;
            var metrics = nextPickerLists.metricsList;
            // Update loading indicators
            if (currentProps.areNamespacesLoading && !nextProps.areNamespacesLoading) {
                updatedState.areNamespacesLoading = false;
            }
            if (currentProps.areMetricsLoading && !nextProps.areMetricsLoading) {
                updatedState.areMetricsLoading = false;
            }
            if (currentProps.areAggregationsLoading && !nextProps.areAggregationsLoading) {
                updatedState.areAggregationsLoading = false;
            }
            _this.updateAriaLabel(updatedState.selection);
            // Update Metric options
            if (metrics && metrics.length > 0) {
                updatedState.metricList = metrics;
            }
            else if (nextProps.areMetricsLoading) {
                updatedState.metricList = [Utils_1.getLoadingEntry()];
            }
            else {
                updatedState.metricList = [Utils_1.getNoResultsEntry()];
            }
            if (!currentProps.editMode && nextProps.editMode) {
                _this._shouldExpandDropdowns = true;
                nextProps.updateConfiguredStatus(_this._isConfigured(updatedState.selection));
            }
            // If the lists have changed, re-evaluate auto expand
            if (HaveListsChanged(currentProps, nextProps)) {
                _this._autoExpandDropdowns(updatedState.selection);
            }
            if (HaveSelectedMetricsListsChanged(currentProps, nextProps)) {
                nextProps.updateConfiguredStatus(false);
            }
            return updatedState;
        });
    };
    MetricPill.prototype.render = function () {
        if (this.props.editMode) {
            var result = this.renderDropdowns();
            return result;
        }
        else {
            return this.renderCollapsed();
        }
    };
    MetricPill.prototype.renderDropdowns = function () {
        var className = Utils_1.getDropdownWrapperClassName(this.props.showLabels, "metric-pill ");
        // Assign a unique id suffix to each dropdown label when created
        var uniqueId = Utils_1.newGuid().toLowerCase();
        return (React.createElement("div", { className: className },
            this.renderDropdownWithLabel(this.renderResourceButton(), Strings.resourceLabel, "ResourceLabel-" + uniqueId),
            this.renderNamespaceDropdownWithLabel(this.renderNamespaceDropdown(uniqueId), uniqueId),
            this.renderDropdownWithLabel(this.renderMetricDropdown(uniqueId), Strings.metricLabel, "MetricLabel-" + uniqueId),
            this.renderDropdownWithLabel(this.renderAggregationDropdown(uniqueId), Strings.aggregationLabel, "AggregationLabel-" + uniqueId)));
    };
    MetricPill.prototype.renderCollapsed = function () {
        var selection = this.state.selection;
        var displayedValue = React.createElement("span", { className: "not-configured" }, Strings.notConfigured);
        if (this._isConfigured(selection)) {
            var showResourceComma = (this.props.showNamespaceCollapsed && this.props.showNamespaceSelection) || this.props.showMetricCollapsed || this.props.showAggregationCollapsed;
            var showNamespaceComma = this.props.showMetricCollapsed || this.props.showAggregationCollapsed;
            displayedValue = (React.createElement("div", { className: "metric-pill metric-configured" },
                this.props.showResourceCollapsed ? React.createElement("div", { className: "resource" }, selection.selectedResource.label + (showResourceComma ? ", " : "")) : undefined,
                (this.props.showNamespaceCollapsed && this.props.showNamespaceSelection) ? React.createElement("div", { className: "namespace" }, selection.selectedNamespace.label + (showNamespaceComma ? ", " : "")) : undefined,
                this.props.showMetricCollapsed ? React.createElement("div", { className: "metric" }, selection.selectedMetric.label + (this.props.showAggregationCollapsed ? ", " : "")) : undefined,
                this.props.showAggregationCollapsed ? React.createElement("div", { className: "aggregations" }, this._getSelectedAggregationString(selection)) : undefined));
        }
        return React.createElement("span", { className: "pillcontent" }, displayedValue);
    };
    MetricPill.prototype.renderDropdownWithLabel = function (DropdownFn, label, labelName) {
        return this.renderDropdownWithLabelElement(DropdownFn, this.getSimpleLabel(label, labelName), labelName);
    };
    MetricPill.prototype.renderResourceButton = function () {
        var _this = this;
        var icon = React.createElement(DefaultAddIcon_1.DefaultAddIcon, null);
        var label = Strings.resourceSelectPlaceholder;
        var buttonSettings = this.props.resourceButtonSettings;
        var className = "aim-pill-button aim-pill-secondary resource-button " + buttonSettings.className;
        if (this.state.selection.selectedResource) {
            icon = undefined;
            label = this.state.selection.selectedResource.label;
        }
        return React.createElement("div", { className: className, onClick: buttonSettings.callback, role: "button", "aria-label": label, onKeyDown: function (evt) {
                _this._handleResourceTabKey(evt);
                if (evt.key === "Enter" || evt.key === "Space") {
                    buttonSettings.callback();
                }
            }, tabIndex: 0 },
            icon,
            React.createElement("span", { title: label }, label));
    };
    MetricPill.prototype.renderNamespaceDropdownWithLabel = function (DropdownFn, uniqueId) {
        var labelName = "NamespaceLabel-" + uniqueId;
        var label = (this.props.namespaceDropdownSettings && this.props.namespaceDropdownSettings.label) || this.getSimpleLabel(Strings.namespaceLabel, labelName);
        return this.renderDropdownWithLabelElement(DropdownFn, label, labelName);
    };
    MetricPill.prototype.getSimpleLabel = function (label, labelName) {
        return React.createElement("label", { id: "aim-pill-label-" + labelName.toLowerCase() }, label);
    };
    MetricPill.prototype.renderDropdownWithLabelElement = function (DropdownFn, labelElement, labelName) {
        if (DropdownFn) {
            return (React.createElement("div", { className: "aim-pill-dropdown-with-labels aim-pill-group-" + labelName.toLowerCase() },
                this.props.showLabels ? labelElement : null,
                DropdownFn));
        }
        else {
            return null;
        }
    };
    MetricPill.prototype._handleResourceTabKey = function (evt) {
        if (evt.key === "Tab") {
            if (evt.shiftKey) {
                this._aggRef.focus();
            }
            else {
                this.props.showNamespaceSelection ? this._namespaceRef.focus() : this._metricRef.focus();
            }
            evt.stopPropagation();
            evt.preventDefault();
        }
    };
    MetricPill.prototype.renderNamespaceDropdown = function (uniqueId) {
        var _this = this;
        if (this.props.showNamespaceSelection) {
            var namespaceSettings = this.props.namespaceDropdownSettings;
            var namespaceClassName = (namespaceSettings && namespaceSettings.className) || "";
            var className = "aim-pill-dropdown aim-metric-namespace virtualized " + namespaceClassName;
            var menuRenderer = VirtualizedSelectMenu_1.createVirtualizedMenuRenderFunction(this.props.banner && this.props.banner.namespaceDropdownContent, this.props.additionalContent && this.props.additionalContent.namespaceDropdownContent);
            var optionRenderer = this.props.customOptionRenderers && this.props.customOptionRenderers.namespaceRenderer;
            var valueRenderer = this.props.customValueRenderers && this.props.customValueRenderers.namespaceRenderer;
            var options = this.props.pickerLists.namespaceList && this.props.pickerLists.namespaceList.length === 0 ? [Utils_1.getNoResultsEntry()] : this.props.pickerLists.namespaceList;
            return (React.createElement(react_select_1.default, { id: "metric-namespace" + this._instanceIndex, "aria-labelledby": this.props.showLabels ? "aim-pill-label-namespacelabel-" + uniqueId : undefined, "aria-label": !this.props.showLabels ? Strings.namespaceLabel : undefined, ref: function (element) {
                    var hasRef = !!_this._namespaceRef;
                    _this._namespaceRef = element;
                    if (!hasRef) {
                        _this._autoExpandDropdowns(_this.state.selection);
                    }
                }, name: "selectedNamespace", className: className, clearable: false, placeholder: Strings.namespacePlaceholder, value: this.state.selection.selectedNamespace, onOpen: function () { return _this._onOpen(MetricPillData_1.ChangeType.Namespace); }, onChange: function (newVal) { return _this._handleSelectionChange(MetricPillData_1.ChangeType.Namespace, newVal); }, onInputKeyDown: function (evt) {
                    if (evt.key === "Tab" && !evt.shiftKey) {
                        evt.stopPropagation();
                        evt.preventDefault();
                        _this._metricRef.focus();
                    }
                }, options: options, isLoading: this.state.areNamespacesLoading, arrowRenderer: DropdownIcon_1.DropdownIcon, openAfterFocus: true, openOnFocus: true, disabled: this.props.disableNamespaceSelection, optionRenderer: optionRenderer, valueRenderer: valueRenderer, menuRenderer: menuRenderer, matchProp: "label", backspaceRemoves: false, tabSelectsValue: false, inputProps: { autoComplete: "off", autoCorrect: "off", spellCheck: "off" } }));
        }
        return null;
    };
    MetricPill.prototype.renderMetricDropdown = function (uniqueId) {
        var _this = this;
        var className = "aim-pill-dropdown aim-metric-metric virtualized";
        var optionRenderer = this.props.customOptionRenderers && this.props.customOptionRenderers.metricRenderer;
        var valueRenderer = this.props.customValueRenderers && this.props.customValueRenderers.metricRenderer;
        var menuRenderer = VirtualizedSelectMenu_1.createVirtualizedMenuRenderFunction(this.props.banner && this.props.banner.metricDropdownContent, this.props.additionalContent && this.props.additionalContent.metricDropdownContent, this.props.metricDropdownSettings && this.props.metricDropdownSettings.defaultMetricOptionRowHeight);
        return (React.createElement(react_select_1.default, { id: "metric-metric" + this._instanceIndex, "aria-labelledby": this.props.showLabels ? "aim-pill-label-metriclabel-" + uniqueId : undefined, "aria-label": !this.props.showLabels ? Strings.metricLabel : undefined, ref: function (element) {
                var hasRef = !!_this._metricRef;
                _this._metricRef = element;
                if (!hasRef) {
                    _this._autoExpandDropdowns(_this.state.selection);
                }
            }, name: "selectedMetric", className: className, clearable: false, placeholder: Strings.metricPlaceholder, value: this.state.selection.selectedMetric, onOpen: function () { return _this._onOpen(MetricPillData_1.ChangeType.Metric); }, onChange: function (newVal) { return _this._handleSelectionChange(MetricPillData_1.ChangeType.Metric, newVal); }, options: this.state.metricList, isLoading: this.state.areMetricsLoading, arrowRenderer: DropdownIcon_1.DropdownIcon, openAfterFocus: true, openOnFocus: true, disabled: this.props.disableMetricSelection, menuRenderer: menuRenderer, noResultsText: this.props.metricDropdownSettings && this.props.metricDropdownSettings.noResultsText, optionRenderer: optionRenderer, valueRenderer: valueRenderer, matchProp: "label", backspaceRemoves: false, tabSelectsValue: false, inputProps: { autoComplete: "off", autoCorrect: "off", spellCheck: "off" } }));
    };
    MetricPill.prototype.renderAggregationDropdown = function (uniqueId) {
        var _this = this;
        var selectedValue = undefined;
        var className = "aim-pill-dropdown aim-metric-aggregation";
        if (this.props.enableAggregationMultiSelect) {
            selectedValue = this.state.selection.selectedAggregation;
            className += " multiselect";
        }
        else if (this.state.selection.selectedAggregation && this.state.selection.selectedAggregation.length > 0) {
            selectedValue = this.state.selection.selectedAggregation[0];
        }
        var optionRenderer = this.props.customOptionRenderers && this.props.customOptionRenderers.aggregationRenderer;
        var valueRenderer = this.props.customValueRenderers && this.props.customValueRenderers.aggregationRenderer;
        return (React.createElement(react_select_1.default, { ref: function (element) {
                _this._aggRef = element;
            }, id: "metric-aggregation" + this._instanceIndex, "aria-labelledby": this.props.showLabels ? "aim-pill-label-aggregationlabel-" + uniqueId : undefined, "aria-label": !this.props.showLabels ? Strings.aggregationLabel : undefined, name: "selectedAggregation", className: className, clearable: false, placeholder: Strings.aggregationPlaceholder, value: selectedValue, onOpen: function () { return _this._onOpen(MetricPillData_1.ChangeType.Aggregation); }, onChange: function (newVal) { return _this._handleSelectionChange(MetricPillData_1.ChangeType.Aggregation, newVal); }, options: this.props.pickerLists.aggregationsList, isLoading: this.state.areAggregationsLoading, arrowRenderer: DropdownIcon_1.DropdownIcon, openAfterFocus: true, openOnFocus: true, multi: this.props.enableAggregationMultiSelect, closeOnSelect: !this.props.enableAggregationMultiSelect, showCheckbox: this.props.enableAggregationMultiSelect, showTags: false, disabled: this.props.disableAggregationSelection, optionRenderer: optionRenderer, valueRenderer: valueRenderer, matchProp: "label", backspaceRemoves: false, tabSelectsValue: false, inputProps: { autoComplete: "off", autoCorrect: "off", spellCheck: "off" } }));
    };
    MetricPill.prototype._onOpen = function (changeType) {
        this.setState(function (prevState, props) {
            var updatedState = {
                areNamespacesLoading: prevState.areNamespacesLoading,
                areMetricsLoading: prevState.areMetricsLoading,
                areAggregationsLoading: prevState.areAggregationsLoading,
            };
            // Only propagate sub/RG loading indicators on open
            switch (changeType) {
                case MetricPillData_1.ChangeType.Namespace:
                    updatedState.areNamespacesLoading = props.areNamespacesLoading;
                    if (props.namespaceDropdownSettings && props.namespaceDropdownSettings.onOpenNamespaceDropdown) {
                        props.namespaceDropdownSettings.onOpenNamespaceDropdown(props.pillId, prevState.selection.selectedResource);
                    }
                    break;
                case MetricPillData_1.ChangeType.Metric:
                    updatedState.areMetricsLoading = props.areMetricsLoading;
                    if (props.metricDropdownSettings && props.metricDropdownSettings.onOpenMetricDropdown) {
                        props.metricDropdownSettings.onOpenMetricDropdown(props.pillId, prevState.selection.selectedResource, prevState.selection.selectedNamespace);
                    }
                    break;
                case MetricPillData_1.ChangeType.Aggregation:
                    updatedState.areAggregationsLoading = props.areAggregationsLoading;
                    break;
            }
            return updatedState;
        });
    };
    MetricPill.prototype.updateAriaLabel = function (selection) {
        var newLabel = Strings.notConfigured;
        if (this._isConfigured(selection)) {
            newLabel = this._getSelectionString(selection);
        }
        this.props.updateAriaLabel(newLabel);
    };
    MetricPill.prototype._handleSelectionChange = function (changeType, newValue) {
        var _this = this;
        var newSelection = this.state.selection;
        switch (changeType) {
            case MetricPillData_1.ChangeType.Namespace:
                newSelection.selectedNamespace = newValue;
                break;
            case MetricPillData_1.ChangeType.Metric:
                newSelection.selectedMetric = newValue;
                break;
            case MetricPillData_1.ChangeType.Aggregation:
                // Keeping consistent external interface by treating single-select as single value in array
                if (newValue instanceof Array) {
                    newSelection.selectedAggregation = newValue;
                }
                else {
                    newSelection.selectedAggregation = [newValue];
                }
                break;
        }
        // Change the appropriate selection
        this.setState(function () {
            return { selection: newSelection };
        });
        this.props.onSelectionChange(changeType, newSelection, this._isConfigured(newSelection)).then(function (finalSelection) {
            _this._shouldExpandDropdowns = true;
            _this._autoExpandDropdowns(finalSelection);
            _this.updateAriaLabel(finalSelection);
            _this.props.updateConfiguredStatus(_this._isConfigured(finalSelection));
        });
    };
    MetricPill.prototype._getSelectionString = function (selection) {
        if (this._isConfigured(selection)) {
            var metricString = "";
            var selectedResource = selection.selectedResource;
            if (selectedResource.subscription) {
                metricString += Strings.subscriptionLabel + " ";
                metricString += selectedResource.subscription + ", ";
            }
            if (selectedResource.resourceGroup) {
                metricString += Strings.resourceGroupLabel + " ";
                metricString += selectedResource.resourceGroup + ", ";
            }
            metricString += Strings.resourceLabel + " ";
            metricString += selection.selectedResource.label + ", ";
            if (this.props.showNamespaceSelection) {
                metricString += Strings.namespaceLabel + " ";
                metricString += selection.selectedNamespace.label + ", ";
            }
            metricString += Strings.metricLabel + " ";
            metricString += selection.selectedMetric.label + ", ";
            metricString += Strings.aggregationLabel + " ";
            metricString += selection.selectedAggregation.map(function (option) { return option.label; }).join(", ");
            return metricString;
        }
        return null;
    };
    MetricPill.prototype._getSelectedAggregationString = function (selection) {
        if (selection && selection.selectedAggregation && selection.selectedAggregation.length > 0) {
            return selection.selectedAggregation.map(function (option) { return option.label; }).join(", ");
        }
        return "";
    };
    MetricPill.prototype._isConfigured = function (selection) {
        return ConfiguredSelection(selection, this.props.showNamespaceSelection);
    };
    MetricPill.prototype._autoExpandDropdowns = function (selection) {
        if (this.props.autoOpen && this._shouldExpandDropdowns) {
            if (selection.selectedResource) {
                if (!selection.selectedNamespace && this.props.showNamespaceSelection) {
                    if (this._namespaceRef && !this._namespaceRef.props.disabled) {
                        this._namespaceRef.focus();
                        this._shouldExpandDropdowns = false;
                    }
                }
                else if (!selection.selectedMetric) {
                    if (this._metricRef && !this._metricRef.props.disabled) {
                        this._metricRef.focus();
                        this._shouldExpandDropdowns = false;
                    }
                }
            }
        }
    };
    MetricPill.defaultProps = {
        selection: {
            selectedResource: null,
            selectedNamespace: null,
            selectedMetric: null,
            selectedAggregation: null,
        },
    };
    MetricPill.globalInstanceIndex = 0;
    return MetricPill;
}(React.Component));
exports.MetricPill = MetricPill;
function ConfiguredSelection(selection, showNamespaceSelection) {
    return (selection &&
        !Utils_1.isNullOrUndefined(selection.selectedResource) &&
        (!Utils_1.isNullOrUndefined(selection.selectedNamespace) || !showNamespaceSelection) &&
        !Utils_1.isNullOrUndefined(selection.selectedMetric) &&
        !Utils_1.isNullOrUndefined(selection.selectedAggregation) &&
        selection.selectedAggregation.length > 0 && !Utils_1.isNullOrUndefined(selection.selectedAggregation[0]));
}
function HaveListsChanged(currentProps, nextProps) {
    var currentLists = currentProps && currentProps.pickerLists;
    var nextLists = nextProps && nextProps.pickerLists;
    if (currentLists && nextLists) {
        if ((currentLists.namespaceList && currentLists.namespaceList.length) !== (nextLists.namespaceList && nextLists.namespaceList.length)) {
            return true;
        }
        if ((currentLists.metricsList && currentLists.metricsList.length) !== (nextLists.metricsList && nextLists.metricsList.length)) {
            return true;
        }
    }
    return false;
}
function HaveSelectedMetricsListsChanged(currentProps, nextProps) {
    // This function is brittle as heck. Do not modify without first wrapping in a spec.
    var currentLists = currentProps.pickerLists;
    var nextLists = nextProps.pickerLists;
    var currentSelection = currentProps.selection;
    var nextSelection = nextProps.selection;
    // Does not fire if
    // 1) lists or selections are absent.
    if (currentLists && nextLists && currentSelection && nextSelection) {
        // 2) The metric picker lists have not changed.
        if ((currentLists.metricsList && currentLists.metricsList.length) !== (nextLists.metricsList && nextLists.metricsList.length)) {
            var currentMetric = currentSelection.selectedMetric;
            var nextMetric = nextSelection.selectedMetric;
            // 3) the updated metric retains the same value (when resources are the same type and share a common metric.)
            return !(currentMetric && nextMetric && currentMetric.value === nextMetric.value);
        }
    }
    return false;
}
//# sourceMappingURL=MetricPill.js.map