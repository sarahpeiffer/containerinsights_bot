"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var Strings = require("PillResources");
var TimeUtils = require("./TimeUtils");
var CustomTimePicker_1 = require("./CustomTimePicker");
var Utils_1 = require("./Utils");
var typescript_string_operations_1 = require("typescript-string-operations");
var TimeInterfaces_1 = require("./TimeInterfaces");
var TimePillData_1 = require("./TimePillData");
require("./Styles/TimePill");
var TimePill = /** @class */ (function (_super) {
    __extends(TimePill, _super);
    function TimePill(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this._handleTimeValueChange = _this._handleTimeValueChange.bind(_this);
        _this._handleApply = _this._handleApply.bind(_this);
        _this._handleCancel = _this._handleCancel.bind(_this);
        _this._handleGrainSelection = _this._handleGrainSelection.bind(_this);
        _this._handleTimeZoneValueChange = _this._handleTimeZoneValueChange.bind(_this);
        _this._onTimeValueKeyUp = _this._onTimeValueKeyUp.bind(_this);
        _this._onTimeZoneKeyUp = _this._onTimeZoneKeyUp.bind(_this);
        _this._onDialogKeyDown = _this._onDialogKeyDown.bind(_this);
        if (props) {
            _this.state = {
                editTimeData: TimeUtils.clone(props.timeData) || TimeUtils.getDefaultTimeData(),
                supportedTimes: props.supportedTimes || getDefaultSupportedTimes(),
                supportedGrains: (props.timeGrainOptions && props.timeGrainOptions.supportedTimeGrains) || _this._getDefaultSupportedTimeGrains(),
                isValidTime: true,
                startTimeValidation: { isValid: true },
                endTimeValidation: { isValid: true }
            };
        }
        else {
            _this.state = {
                editTimeData: TimeUtils.getDefaultTimeData(),
                supportedTimes: getDefaultSupportedTimes(),
                supportedGrains: _this._getDefaultSupportedTimeGrains(),
                isValidTime: true,
                startTimeValidation: { isValid: true },
                endTimeValidation: { isValid: true }
            };
        }
        return _this;
    }
    TimePill.prototype.componentWillMount = function () {
        this.updateAriaLabel(this.props.timeData);
        // Time pill defaults to a value selected
        this.props.updateConfiguredStatus(true);
    };
    TimePill.prototype.componentWillReceiveProps = function (nextProps, nextContext) {
        var _this = this;
        if (nextProps.timeData || nextProps.supportedTimes) {
            this.setState(function (prevState) {
                var updatedState = {
                    editTimeData: TimeUtils.clone(prevState.editTimeData),
                    supportedTimes: prevState.supportedTimes && prevState.supportedTimes.slice(),
                    supportedGrains: prevState.supportedGrains && prevState.supportedGrains.slice(),
                };
                // don't overwrite the current time data from props while in edit mode
                if (nextProps.timeData && !nextProps.editMode) {
                    updatedState.editTimeData = TimeUtils.clone(nextProps.timeData);
                    if (nextProps.timeData.options.hideActualGrain) {
                        updatedState.editTimeData.options.actualGrain = undefined;
                    }
                }
                if (nextProps.supportedTimes) {
                    updatedState.supportedTimes = nextProps.supportedTimes;
                }
                updatedState.supportedGrains = (nextProps.timeGrainOptions && nextProps.timeGrainOptions.supportedTimeGrains) || _this._getDefaultSupportedTimeGrains();
                if (!updatedState.editTimeData.options) {
                    updatedState.editTimeData.options = {
                        appliedISOGrain: "Auto"
                    };
                }
                else if (Utils_1.isNullOrWhiteSpace(updatedState.editTimeData.options.appliedISOGrain)) {
                    updatedState.editTimeData.options.appliedISOGrain = "Auto";
                }
                _this.updateAriaLabel(updatedState.editTimeData);
                return updatedState;
            });
        }
        // If we are closing the edit area with isValidTime false, this means that, 
        // while Apply was disabled one of these happened: 1) The cancel button has 
        // been clicked, 2) ESC was pressed or 3) the user clicked outside the edit 
        // area. In any case we need to clear the validation which is done in cancelEdit
        if (nextProps.editMode === false && this.props.editMode === true) {
            // Outside of render() the check for this.state.XYZ can typically only be done
            // safely in a setState callback
            this.setState(function () { }, function () {
                if (!_this.state.isValidTime) {
                    _this._cancelEdit();
                }
            });
        }
    };
    TimePill.prototype._validateAndChangeCustomTime = function (timeData, startChanged) {
        var startTimeValidation = { isValid: true };
        var endTimeValidation = { isValid: true };
        var startDate = timeData.absolute.startTime.getTime();
        if (this.props.customTimeValidator) {
            var startAndEndValidation = this.props.customTimeValidator(timeData, startChanged);
            startTimeValidation = startAndEndValidation.startValidation;
            endTimeValidation = startAndEndValidation.endValidation;
        }
        if (startTimeValidation.isValid) {
            // Built in time validation
            if (startDate >= timeData.absolute.endTime.getTime()) {
                var validationForChange = startChanged ? startTimeValidation : endTimeValidation;
                validationForChange.isValid = false;
                validationForChange.reason = Strings.validateStartTimeBeforeEndTime;
            }
            else if (startDate > new Date().getTime()) {
                startTimeValidation.isValid = false;
                startTimeValidation.reason = Strings.validateStartTimeBeforeNow;
            }
        }
        var isValid = startTimeValidation.isValid && endTimeValidation.isValid;
        this.props.updateConfiguredStatus(isValid);
        this.setState(function (prevState) {
            var updatedState = {
                startTimeValidation: startTimeValidation,
                endTimeValidation: endTimeValidation,
                isValidTime: isValid,
                editTimeData: prevState.editTimeData,
            };
            if (isValid) {
                updatedState.editTimeData = timeData;
            }
            return updatedState;
        });
    };
    TimePill.prototype._onCustomTimeChange = function (timeData, isValidDate, isStartDate) {
        if (!isValidDate) {
            if (isStartDate) {
                this.setState(function (prevState) {
                    var updatedState = {
                        isValidTime: false,
                        startTimeValidation: prevState.startTimeValidation,
                    };
                    updatedState.startTimeValidation.isValid = false;
                    return updatedState;
                });
            }
            else {
                this.setState(function (prevState) {
                    var updatedState = {
                        isValidTime: false,
                        endTimeValidation: prevState.endTimeValidation,
                    };
                    updatedState.endTimeValidation.isValid = false;
                    return updatedState;
                });
            }
        }
        else {
            this._validateAndChangeCustomTime(timeData, isStartDate);
        }
    };
    TimePill.prototype.render = function () {
        var _this = this;
        var editDialog = null;
        // Clear out refs since we're re-rendering
        this._timeValRefs = [];
        this._timeZoneRefs = [];
        if (this.props.editMode) {
            var halfPoint = Math.ceil(this.state.supportedTimes.length / 2);
            var evenTimeOptionRows = this._getTimeOptionTableRows(0, halfPoint);
            var oddTimeOptionRows = this._getTimeOptionTableRows(halfPoint);
            var optionsConfig = this._createOptionsUI();
            var selectorClass = "aim-pill-time-selector";
            if (!!optionsConfig) {
                selectorClass += " aim-pill-time-selector-border";
            }
            var customPicker = undefined;
            if (TimeUtils.isAbsolute(this.state.editTimeData)) {
                customPicker = React.createElement("div", { key: "customTimeOptionsColumn", className: "aim-time-options-column" },
                    React.createElement(CustomTimePicker_1.CustomTimePicker, { value: this.state.editTimeData, onChange: this._onCustomTimeChange.bind(this), startTimeValidation: this.state.startTimeValidation, endTimeValidation: this.state.endTimeValidation }));
            }
            var applyButtonEnabled = this.state.isValidTime && this._hasChanged();
            editDialog = React.createElement("div", { className: "aim-pill-timeEditDialog", onKeyDown: this._onDialogKeyDown },
                React.createElement("div", { className: "aim-pill-time-config" },
                    React.createElement("div", { className: selectorClass, role: "radiogroup" },
                        React.createElement("span", { tabIndex: -1, role: "label", className: "aim-pill-time-title", id: "aim-time-value-title" }, Strings.timeRange),
                        React.createElement("div", { className: "aim-pill-time-selector-columns" },
                            React.createElement("div", { key: "leftTimeOptionsColumn", className: "aim-time-options-column" }, evenTimeOptionRows),
                            React.createElement("div", { key: "rightTimeOptionsColumn", className: "aim-time-options-column" }, oddTimeOptionRows)),
                        customPicker),
                    optionsConfig),
                React.createElement("div", { className: "aim-time-edit-buttons" },
                    React.createElement("div", { className: "aim-pill-button aim-pill-primary" + (applyButtonEnabled ? "" : " is-disabled"), onClick: this._handleApply, onKeyPress: function (e) { Utils_1.keyHandler(e, "Enter", _this._handleApply); }, "aria-label": Strings.apply, "aria-disabled": !applyButtonEnabled, role: "button", tabIndex: applyButtonEnabled ? 0 : -1 },
                        React.createElement("span", null, Strings.apply)),
                    React.createElement("div", { className: "aim-pill-button aim-pill-secondary", ref: function (element) { if (!!element) {
                            _this._lastElement = element;
                        } }, onClick: this._handleCancel, onKeyPress: function (e) { Utils_1.keyHandler(e, "Enter", _this._handleCancel); }, "aria-label": Strings.cancel, role: "button", tabIndex: 0 },
                        React.createElement("span", null, Strings.cancel))));
        }
        var timeData = this.props.timeData;
        var displayString = (timeData.options.appliedISOGrain === "Auto" && !timeData.options.hideActualGrain && timeData.options.actualGrain) ?
            this._getDisplayString(timeData, Strings.timeGrainDisplayFormatAutomatic) :
            this._getDisplayString(timeData, Strings.timeGrainDisplayFormat);
        return React.createElement("div", { className: "aim-time-pill-content" },
            React.createElement("span", null, displayString),
            editDialog);
    };
    TimePill.prototype.updateAriaLabel = function (timeData) {
        var grainLocalization = undefined;
        if (timeData.options.appliedISOGrain === "Auto" && timeData.options.hideActualGrain && timeData.options.actualGrain) {
            grainLocalization = Strings.timeGrainAriaDisplayFormatAutomatic;
        }
        else {
            grainLocalization = Strings.timeGrainAriaDisplayFormat;
        }
        this.props.updateAriaLabel(this._getDisplayString(timeData, grainLocalization));
    };
    // tslint:disable:no-bitwise
    TimePill.prototype._getDisplayString = function (timeData, grainFormat) {
        var displayOption = this.props.displayAs || TimePillData_1.TimeDisplayOptions.Time;
        var displayString = new typescript_string_operations_1.StringBuilder("");
        if ((displayOption & TimePillData_1.TimeDisplayOptions.Zone) === TimePillData_1.TimeDisplayOptions.Zone) {
            var zoneString = timeData.options.showUTCTime ? Strings.uTCTime : Strings.localTime;
            displayString.Append(zoneString + ": ");
        }
        else if ((displayOption & TimePillData_1.TimeDisplayOptions.Title) === TimePillData_1.TimeDisplayOptions.Title) {
            displayString.Append(Strings.timeRange + ": ");
        }
        if ((displayOption & TimePillData_1.TimeDisplayOptions.Time) === TimePillData_1.TimeDisplayOptions.Time) {
            displayString.Append(TimeUtils.toDisplayString(timeData));
        }
        if ((displayOption & TimePillData_1.TimeDisplayOptions.Grain) === TimePillData_1.TimeDisplayOptions.Grain) {
            var displayGrain = timeData.options.appliedISOGrain;
            if ((displayGrain === "Auto") && !timeData.options.hideActualGrain && timeData.options.actualGrain) {
                if (timeData.options.actualGrain) {
                    displayGrain = timeData.options.actualGrain;
                }
                // Adding - to display as (Automatic - 6 hours) for example 
                displayString.AppendFormat(grainFormat, "- " + TimeUtils.fromISOStringToDisplayString(displayGrain));
            }
            else {
                displayString.AppendFormat(grainFormat, TimeUtils.fromISOStringToDisplayString(displayGrain));
            }
        }
        return displayString.ToString();
    };
    // tslint:enable:no-bitwise
    TimePill.prototype._getTimeOptionTableRows = function (startIndex, endIndex) {
        if (startIndex === void 0) { startIndex = 0; }
        if (endIndex === void 0) { endIndex = this.state.supportedTimes.length; }
        var rows = [];
        for (var timeIndex = startIndex; timeIndex < endIndex; timeIndex++) {
            var timeOption = this._createTimeRadio(timeIndex);
            rows.push(timeOption);
        }
        return rows;
    };
    TimePill.prototype._createTimeRadio = function (timeIndex) {
        var _this = this;
        var time = this.state.supportedTimes[timeIndex];
        var id = "timeRadio" + timeIndex;
        var optionName = TimeUtils.getTimeValueDisplayString(time);
        var isChecked = function (value) { return TimeUtils.getTimeValue(_this.state.editTimeData) === time; };
        return this._createRadio(id, optionName, time, isChecked, function () { return _this._handleTimeValueChange(time); }, function (event) { return _this._onTimeValueKeyUp(timeIndex, event); }, this._timeValRefs, "aim-time-value-title", true);
    };
    TimePill.prototype._createRadio = function (id, optionName, value, isChecked, handleValueChange, onKeyUp, refsArray, labelId, shouldAutoFocus) {
        var _this = this;
        if (shouldAutoFocus === void 0) { shouldAutoFocus = false; }
        var inputId = id + "input";
        return React.createElement("div", { id: id, key: id, ref: function (element) {
                if (!!element) {
                    refsArray.push(element);
                    if (isChecked(value) && labelId === "aim-time-value-title") {
                        _this._firstElement = element;
                    }
                }
            }, onKeyDown: onKeyUp, 
            // onClick is needed for Narrator Scan mode to detect activation
            onClick: function () { onKeyUp(); }, role: "radio", "aria-checked": isChecked(value), "aria-labelledby": labelId + " " + inputId + "-text", className: "aim-pill-radio-wrapper", 
            // Should only be able to tab to checked radio option
            // Use up/down to select a new option from the group
            tabIndex: isChecked(value) ? 0 : -1 },
            React.createElement("input", { id: inputId, type: "radio", name: optionName, value: value, checked: isChecked(value), autoFocus: shouldAutoFocus && isChecked(value), onChange: handleValueChange, tabIndex: -1, "aria-hidden": true }),
            React.createElement("label", { className: "aim-radio-label", htmlFor: inputId, onClick: handleValueChange },
                React.createElement("span", { className: "aim-radio-outer" },
                    React.createElement("span", { className: "aim-radio-inner" })),
                React.createElement("span", { className: "aim-radio-text", id: inputId + "-text" }, optionName)));
    };
    TimePill.prototype._createOptionsUI = function () {
        var _this = this;
        var timeGrainEnabled = !this.props.timeGrainOptions || !this.props.timeGrainOptions.disableTimeGrainSelection;
        if (timeGrainEnabled || !this.props.disableZoneSelection) {
            var timeGrainUI = undefined;
            if (timeGrainEnabled) {
                var grainOptions = this.state.supportedGrains.map(function (grain) {
                    return React.createElement("option", { key: TimeUtils.toISOString(grain), value: TimeUtils.toISOString(grain) }, TimeUtils.timeGrainDisplayString(grain));
                });
                timeGrainUI = React.createElement("div", { className: "aim-pill-timegrain" },
                    React.createElement("span", { tabIndex: -1, role: "label", className: "aim-pill-time-title", id: "aim-time-grain-title" }, Strings.timeGranularity),
                    React.createElement("select", { value: this.state.editTimeData.options.appliedISOGrain, className: "aim-pill-dropdown", "aria-labelledby": "aim-time-grain-title", onChange: this._handleGrainSelection }, grainOptions));
            }
            var timeZoneUI = undefined;
            if (!this.props.disableZoneSelection) {
                timeZoneUI = React.createElement("div", { className: "aim-pill-timeZone", role: "radiogroup" },
                    React.createElement("span", { tabIndex: -1, role: "label", className: "aim-pill-time-title", id: "aim-time-zone-title" }, Strings.showTimeAs),
                    this._createRadio("timeRadioUTC", Strings.uTCGMT, "true", function (value) { return !!_this.state.editTimeData.options.showUTCTime; }, function () { return _this._handleTimeZoneValueChange(true); }, function (event) { return _this._onTimeZoneKeyUp(false, 0, event); }, this._timeZoneRefs, "aim-time-zone-title"),
                    this._createRadio("timeRadioLocal", Strings.local, "false", function (value) { return !_this.state.editTimeData.options.showUTCTime; }, function () { return _this._handleTimeZoneValueChange(false); }, function (event) { return _this._onTimeZoneKeyUp(true, 1, event); }, this._timeZoneRefs, "aim-time-zone-title"));
            }
            return React.createElement("div", { className: "aim-pill-time-options" },
                timeGrainUI,
                timeZoneUI);
        }
        else {
            return undefined;
        }
    };
    TimePill.prototype._getDefaultSupportedTimeGrains = function () {
        return [
            TimeInterfaces_1.TimeGrains.Auto,
            TimeInterfaces_1.TimeGrains.Minute,
            TimeInterfaces_1.TimeGrains.FiveMinute,
            TimeInterfaces_1.TimeGrains.FifteenMinute,
            TimeInterfaces_1.TimeGrains.ThirtyMinute,
            TimeInterfaces_1.TimeGrains.Hour,
            TimeInterfaces_1.TimeGrains.SixHours,
            TimeInterfaces_1.TimeGrains.TwelveHours,
            TimeInterfaces_1.TimeGrains.Day,
            TimeInterfaces_1.TimeGrains.Week,
            TimeInterfaces_1.TimeGrains.Month
        ];
    };
    TimePill.prototype._onDialogKeyDown = function (e) {
        if (e.key === "Tab") {
            if (e.shiftKey) {
                // moving backwards
                if (document.activeElement === this._firstElement) {
                    this._lastElement.focus();
                    e.preventDefault();
                }
            }
            else {
                // moving forward
                if (document.activeElement === this._lastElement) {
                    this._firstElement.focus();
                    e.preventDefault();
                }
            }
        }
    };
    TimePill.prototype._onTimeValueKeyUp = function (index, keyBoardEvent) {
        var newIndex;
        if (!keyBoardEvent) {
            // This handles onClick
            this._handleTimeValueChange(this.state.supportedTimes[index]);
        }
        else if (keyBoardEvent.key === "ArrowUp" && index !== 0) {
            newIndex = --index;
            this._handleTimeValueChange(this.state.supportedTimes[newIndex]);
            this._timeValRefs[newIndex].focus();
        }
        else if (keyBoardEvent.key === "ArrowDown" && index !== this.state.supportedTimes.length - 1) {
            newIndex = ++index;
            this._handleTimeValueChange(this.state.supportedTimes[newIndex]);
            this._timeValRefs[newIndex].focus();
        }
        if (newIndex) {
            this._firstElement = this._timeValRefs[newIndex];
        }
    };
    TimePill.prototype._onTimeZoneKeyUp = function (newValue, index, keyBoardEvent) {
        var newIndex;
        if (!keyBoardEvent) {
            // This handles onClick
            this._handleTimeZoneValueChange(newValue);
        }
        else if (keyBoardEvent.key === "ArrowUp" && index !== 0) {
            newIndex = --index;
            this._handleTimeZoneValueChange(newValue);
            this._timeZoneRefs[newIndex].focus();
        }
        else if (keyBoardEvent.key === "ArrowDown" && index !== this._timeZoneRefs.length - 1) {
            newIndex = ++index;
            this._handleTimeZoneValueChange(newValue);
            this._timeZoneRefs[newIndex].focus();
        }
    };
    TimePill.prototype._handleTimeValueChange = function (newTime) {
        if (newTime > 0) {
            this.setState(function (prevState) {
                return {
                    editTimeData: {
                        options: prevState.editTimeData.options,
                        relative: {
                            duration: newTime
                        }
                    },
                    isValidTime: true,
                };
            });
        }
        else {
            this.setState(function (prevState) {
                var updatedState = {
                    isValidTime: true
                };
                if (TimeUtils.isRelative(prevState.editTimeData)) {
                    var endTime = new Date();
                    var startTime = TimeUtils.getStartTime(endTime, prevState.editTimeData.relative.duration);
                    updatedState.editTimeData = {
                        options: prevState.editTimeData.options,
                        absolute: {
                            startTime: startTime,
                            endTime: endTime
                        }
                    };
                }
                return updatedState;
            });
        }
    };
    TimePill.prototype._handleApply = function (event) {
        if (!this.state.isValidTime) {
            return;
        }
        this._commitEdit();
    };
    TimePill.prototype._commitEdit = function () {
        this.updateAriaLabel(this.state.editTimeData);
        this.props.onTimeUpdated(this.state.editTimeData);
        this.props.editingComplete();
    };
    TimePill.prototype._handleCancel = function (event) {
        this._cancelEdit();
    };
    TimePill.prototype._cancelEdit = function () {
        var _this = this;
        this.setState(function (prevState, currentProps) {
            return {
                editTimeData: currentProps.timeData,
                startTimeValidation: { isValid: true },
                endTimeValidation: { isValid: true },
                isValidTime: true
            };
        }, function () {
            _this.props.editingComplete();
        });
    };
    TimePill.prototype._handleGrainSelection = function (event) {
        var selectedGrainIso = event.currentTarget.value;
        if (this.state.editTimeData.options.appliedISOGrain !== selectedGrainIso) {
            this.setState(function (prevState) {
                var updatedState = {
                    editTimeData: TimeUtils.clone(prevState.editTimeData),
                };
                updatedState.editTimeData.options.appliedISOGrain = selectedGrainIso;
                return updatedState;
            });
        }
    };
    TimePill.prototype._handleTimeZoneValueChange = function (showUTC) {
        if (this.state.editTimeData.options.showUTCTime !== showUTC) {
            this.setState(function (prevState) {
                var updatedState = {
                    editTimeData: TimeUtils.clone(prevState.editTimeData),
                };
                updatedState.editTimeData.options.showUTCTime = showUTC;
                return updatedState;
            });
        }
    };
    TimePill.prototype._hasChanged = function () {
        if (!this.state || !this.props) {
            return true;
        }
        return !TimeUtils.isTimeDataEqual(this.state.editTimeData, this.props.timeData);
    };
    return TimePill;
}(React.Component));
exports.TimePill = TimePill;
function getDefaultSupportedTimes() {
    return [
        TimeInterfaces_1.TimeValues.Last30Minutes,
        TimeInterfaces_1.TimeValues.LastHour,
        TimeInterfaces_1.TimeValues.Last4Hours,
        TimeInterfaces_1.TimeValues.Last12Hours,
        TimeInterfaces_1.TimeValues.LastDay,
        TimeInterfaces_1.TimeValues.Last2Days,
        TimeInterfaces_1.TimeValues.Last3Days,
        TimeInterfaces_1.TimeValues.Last7Days,
        TimeInterfaces_1.TimeValues.Last30Days,
        TimeInterfaces_1.TimeValues.Custom
    ];
}
exports.getDefaultSupportedTimes = getDefaultSupportedTimes;
//# sourceMappingURL=TimePill.js.map