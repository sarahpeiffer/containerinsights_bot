"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Strings = require("PillResources");
var typescript_string_operations_1 = require("typescript-string-operations");
/**
 * Indicates whether the specified object is null or undefined.
 * @param value The value to test.
 * @returns True if the value parameter is null or undefined; otherwise, false.
 */
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * Checks if the string is null, undefined or whitespace.
 * @param  value The target string.
 * @return true if the string is null, undefined or whitespace; otherwise, false.
 */
function isNullOrWhiteSpace(value) {
    // http://jsperf.com/empty-string-test-regex-vs-trim/4
    var regex_NonSpace = /\S/;
    return isNullOrUndefined(value) ||
        (typeof value === "string" && !regex_NonSpace.test(value)); // if can't find any characters other than space.
}
exports.isNullOrWhiteSpace = isNullOrWhiteSpace;
/**
 * Merge the source object into target object. Returns the extended object.
 */
function extendObject(target, source) {
    if (source) {
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
}
exports.extendObject = extendObject;
/**
 * Executes `fn` only when the key pressed in `event` matches passed in `key`.
 */
function keyHandler(event, key, fn) {
    if (key === event.key) {
        fn();
    }
}
exports.keyHandler = keyHandler;
function getDropdownWrapperClassName(showLabels, wrapperClassName) {
    var className = new typescript_string_operations_1.StringBuilder("aim-pill-pickers ");
    if (showLabels) {
        className.Append("with-labels ");
    }
    if (!isNullOrWhiteSpace(wrapperClassName)) {
        className.Append(wrapperClassName);
    }
    return className.ToString();
}
exports.getDropdownWrapperClassName = getDropdownWrapperClassName;
function getNoResultsEntry(label) {
    if (label === void 0) { label = Strings.noResultsFound; }
    var emptyEntry = {
        label: label,
        value: "noresults-ai-internal-entry",
        disabled: true,
        optionType: 3,
    };
    return emptyEntry;
}
exports.getNoResultsEntry = getNoResultsEntry;
function getLoadingEntry() {
    var loadingEntry = {
        label: Strings.loading,
        value: "loading-ai-internal-entry",
        disabled: true,
        optionType: 3,
    };
    return loadingEntry;
}
exports.getLoadingEntry = getLoadingEntry;
function debounce(context, func, wait) {
    var timeout;
    return function () {
        var args = arguments;
        var later = function () {
            timeout = null;
            func.apply(context, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}
exports.debounce = debounce;
function isIE11() {
    // https://stackoverflow.com/questions/21825157/internet-explorer-11-detection
    return !!window.MSInputMethodContext && !!document.documentMode;
}
exports.isIE11 = isIE11;
/**
 * Returns a GUID such as xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx.
 * @return New GUID.
 */
var __hexValues__ = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
function newGuid() {
    /* tslint:disable:no-bitwise */
    // c.f. rfc4122 (UUID version 4 = xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx)
    var oct = "";
    var tmp = 0;
    for (var a = 0; a < 4; a++) {
        tmp = (4294967296 * Math.random()) | 0;
        oct += __hexValues__[tmp & 0xF]
            + __hexValues__[tmp >> 4 & 0xF]
            + __hexValues__[tmp >> 8 & 0xF]
            + __hexValues__[tmp >> 12 & 0xF]
            + __hexValues__[tmp >> 16 & 0xF]
            + __hexValues__[tmp >> 20 & 0xF]
            + __hexValues__[tmp >> 24 & 0xF]
            + __hexValues__[tmp >> 28 & 0xF];
    }
    // "Set the two most significant bits (bits 6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively"
    var clockSequenceHi = __hexValues__[8 + (Math.random() * 4) | 0];
    return oct.substr(0, 8) + "-" + oct.substr(9, 4) + "-4" + oct.substr(13, 3) + "-" + clockSequenceHi + oct.substr(16, 3) + "-" + oct.substr(19, 12);
    /* tslint:enable:no-bitwise */
}
exports.newGuid = newGuid;
var array_forEach = _uncurryThis(Array.prototype.forEach);
var primitiveTypes = {};
array_forEach(["boolean", "number", "string", "symbol"], function (item) { primitiveTypes[item] = true; });
function clone(source, deep) {
    if (deep === void 0) { deep = true; }
    if (source === null || source === undefined || typeof source in primitiveTypes) {
        return source;
    }
    return extend((Array.isArray(source) && []) || {}, source, deep);
}
exports.clone = clone;
function extend(target, source, deep) {
    if (deep) {
        return jqueryExtend(true, target, source);
    }
    else {
        return jqueryExtend(target, source);
    }
}
exports.extend = extend;
var jqueryExtend = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var options, src, copy, copyIsArray, clonedObj, target = arguments[0] || {}, i = 1, deep = false;
    // Handle a deep copy situation
    if (typeof target === "boolean") {
        deep = target;
        // Skip the boolean and the target
        target = arguments[i] || {};
        i++;
    }
    // Handle case when target is a string or something (possible in deep copy)
    if (typeof target !== "object" && typeof target === "function") {
        target = {};
    }
    var length = arguments.length;
    // Extend jQuery itself if only one argument is passed
    if (i === length) {
        target = this;
        i--;
    }
    for (; i < length; i++) {
        // Only deal with non-null/undefined values
        /* tslint:disable:triple-equals */
        if ((options = arguments[i]) != null) {
            /* tslint:enable:triple-equals */
            // Extend the base object
            for (var name_1 in options) {
                if (options.hasOwnProperty(name_1)) {
                    src = target[name_1];
                    copy = options[name_1];
                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }
                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (isPlainObject(copy) ||
                        (copyIsArray = Array.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clonedObj = src && Array.isArray(src) ? src : [];
                        }
                        else {
                            clonedObj = src && isPlainObject(src) ? src : {};
                        }
                        // Never move original objects, clone them
                        target[name_1] = jqueryExtend(deep, clonedObj, copy);
                        // Don't bring in undefined values
                    }
                    else if (copy !== undefined) {
                        target[name_1] = copy;
                    }
                }
            }
        }
    }
    // Return the modified object
    return target;
};
var object_hasOwnProperty = _uncurryThis(Object.prototype.hasOwnProperty);
function _uncurryThis(f) {
    return function () {
        return Function.call.apply(f, arguments);
    };
}
function isPlainObject(obj) {
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not "[object Object]"
    // - DOM nodes
    // - window
    if (typeof obj !== "object" || obj.nodeType || (obj && obj === obj.window)) {
        return false;
    }
    var constror = obj.constructor;
    var proto = constror && constror.prototype;
    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return !(proto && !object_hasOwnProperty(proto, "isPrototypeOf"));
}
//# sourceMappingURL=Utils.js.map