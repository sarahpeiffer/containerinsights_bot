import * as tslib_1 from "tslib";
import * as React from 'react';
import * as Pikaday from 'pikaday';
import * as moment from 'moment';
import { CalendarSvg } from '../Svgs';
import { TooltipService } from './TooltipService';
var DatePicker = /** @class */ (function (_super) {
    tslib_1.__extends(DatePicker, _super);
    function DatePicker(props) {
        var _this = _super.call(this, props) || this;
        _this.format = 'L LT';
        _this.pickerVisible = false;
        _this.state = {
            isFocused: false,
            currentDate: props.selected
        };
        return _this;
    }
    DatePicker.prototype.hidePicker = function () {
        if (this.picker) {
            this.pickerVisible = false;
            this.picker.hide();
        }
    };
    DatePicker.prototype.showPicker = function () {
        if (this.picker) {
            this.pickerVisible = true;
            this.picker.show();
        }
    };
    DatePicker.prototype.togglePicker = function () {
        if (!this.pickerVisible) {
            this.showPicker();
        }
        else {
            this.hidePicker();
        }
    };
    DatePicker.prototype.componentWillUpdate = function (nextProps, nextState) {
        if (this.props.selected.getTime() !== nextProps.selected.getTime() &&
            nextProps.selected.getTime() !== this.state.currentDate.getTime()) {
            nextState.currentDate = nextProps.selected;
            this.updateStateWithDate(nextState, nextState.currentDate);
        }
    };
    DatePicker.prototype.componentDidMount = function () {
        var _this = this;
        this.picker = new Pikaday({
            field: this.box,
            format: this.format,
            bound: false,
            trigger: this.button,
            // Adding class azure-date-picker-override which other users of this control
            // can use to override the fixed styles
            theme: 'azure-date-picker-override azure-date-picker',
            onSelect: this.onSelected.bind(this),
            onOpen: this.onOpen.bind(this)
        });
        this.hidePicker();
        this.setState(function (prevState) {
            return _this.updateStateWithDate(prevState, _this.state.currentDate);
        });
        // Helper function that gets around broken "contains" method
        // Root cause is "psuedo-elements" not having parents
        var hasParent = function (target, search) {
            if (!target) {
                return false;
            }
            else if (target.className === 'pika-lendar') {
                return true;
            }
            return target === search ? true : hasParent(target.parentElement, search);
        };
        // This manages the textbox focus highlighting even when
        // interacting with the calendar instead of the textbox.
        // It also manages closing the calendar if anything but the calendar is clicked.
        this.onMouseDown = function (ev) {
            if (!_this.box) {
                return;
            }
            var calendar = _this.box.parentElement.getElementsByClassName('pika-single').item(0);
            var calendarButton = _this.box.parentElement.getElementsByClassName('calendar-button').item(0);
            if (calendar && !hasParent(ev.target, calendar) && !hasParent(ev.target, calendarButton)) {
                _this.hidePicker();
            }
            if (!_this.box.parentElement.contains(ev.target)) {
                _this.setState({
                    isFocused: false
                });
            }
        };
        window.addEventListener('mousedown', this.onMouseDown);
    };
    DatePicker.prototype.onClicked = function (e) {
        this.setState({
            isFocused: true
        });
    };
    DatePicker.prototype.onOpen = function () {
        // Pikaday will sometimes open by itself because it's decided to.
        // (One known case is onblur after the value of the textbox has changed)
        // We need to strictly control its open state, so force it back closed
        if (!this.pickerVisible) {
            this.hidePicker();
        }
    };
    DatePicker.prototype.updateStateWithDate = function (state, date) {
        // We don't set state.currentDate directly in some cases so that
        // user specified hour+min are retained
        var prevDate = state.currentDate;
        prevDate.setMonth(date.getMonth());
        prevDate.setFullYear(date.getFullYear());
        prevDate.setDate(date.getDate());
        state.currentDate = prevDate;
        this.box.value = moment(state.currentDate).format(this.format);
        // make sure that the picker has a correct date selected
        var d = new Date(state.currentDate.getTime());
        d = new Date(d.setHours(0, 0, 0, 0));
        this.picker._d = d;
        this.picker.gotoDate(d);
        return state;
    };
    DatePicker.prototype.onSelected = function (date) {
        var _this = this;
        this.setState(function (prevState) {
            return _this.updateStateWithDate(prevState, date);
        }, function () {
            _this.hidePicker();
            _this.onChange();
        });
    };
    DatePicker.prototype.onManualDateChange = function (e) {
        var _this = this;
        var value = e.target.value;
        var parsed = Date.parse(value);
        if (!isNaN(parsed)) {
            this.setState({ currentDate: new Date(parsed) }, function () {
                _this.onChange();
            });
        }
    };
    DatePicker.prototype.onChange = function () {
        if (this.props.onChange) {
            this.props.onChange(this.state.currentDate);
        }
    };
    DatePicker.prototype.componentWillUnmount = function () {
        window.removeEventListener('mousedown', this.onMouseDown);
    };
    DatePicker.prototype.render = function () {
        var _this = this;
        var validationBoxProps = {
            className: 'validationbox'
        };
        TooltipService.registerTooltipForElement(validationBoxProps, function () { return _this.validationBoxDomElement; }, this.props.validation.reason);
        var onFocus = this.props.onFocus ? this.props.onFocus.bind(this) : null;
        return React.createElement("div", { className: 'date-picker-input' },
            React.createElement("div", { className: 'input-title' }, this.props.title),
            React.createElement("div", { className: 'panel-control' + (this.state.isFocused ? ' focus' : '') +
                    (this.props.validation.isValid ? '' : ' invalid'), onClick: this.onClicked.bind(this) },
                React.createElement("div", tslib_1.__assign({}, validationBoxProps, { ref: function (elm) { return _this.validationBoxDomElement = elm; } }), "!"),
                React.createElement("input", { type: 'text', ref: function (t) { return _this.box = t; }, role: 'textbox', "aria-label": this.props.title, defaultValue: moment(this.state.currentDate).format(this.format), onFocus: onFocus, onChange: this.onManualDateChange.bind(this), "aria-invalid": !this.props.validation.isValid }),
                React.createElement("div", { role: 'button', className: 'calendar-button', onClick: function () { return _this.togglePicker(); }, ref: function (t) { return _this.button = t; } },
                    React.createElement("span", { className: 'calendar-icon' },
                        React.createElement(CalendarSvg, null)))),
            React.createElement("div", { className: 'acc-hidden', role: 'alert', "aria-live": 'assertive', "aria-atomic": 'true' }, this.props.validation.isValid ? '' : this.props.validation.reason));
    };
    DatePicker.defaultProps = {
        onChange: null,
        selected: null,
        title: null,
        validation: null
    };
    return DatePicker;
}(React.Component));
export { DatePicker };
//# sourceMappingURL=DatePicker.js.map