import { DatePicker } from './DatePicker';
import * as Pikaday from 'pikaday';
import { TestUtilities } from '../TestUtilities';
var DatePickerBuilder = /** @class */ (function () {
    function DatePickerBuilder() {
        this.props = {
            title: '',
            selected: new Date(0),
            onChange: function () { return null; },
            validation: { isValid: true }
        };
        spyOn(this.props, 'onChange');
        this.addEventListenerSpy = spyOn(window, 'addEventListener');
        this.removeEventListenerSpy = spyOn(window, 'removeEventListener');
    }
    DatePickerBuilder.prototype.withSelectedDate = function (date) {
        this.props.selected = date;
        return this;
    };
    DatePickerBuilder.prototype.withTitle = function (title) {
        this.props.title = title;
        return this;
    };
    DatePickerBuilder.prototype.withValidationState = function (isValid, reason) {
        this.props.validation = { isValid: isValid, reason: reason };
        return this;
    };
    DatePickerBuilder.prototype.build = function () {
        var datePicker = new DatePicker(this.props);
        spyOn(datePicker, 'setState').and.callFake(function (statefn, cb) {
            datePicker.state = TestUtilities.SetState(datePicker.state, datePicker.props, statefn);
            return cb ? cb() : null;
        });
        // Simulate mounted component
        var parentElm = document.createElement('div');
        var datepickerInput = document.createElement('input');
        parentElm.appendChild(datepickerInput);
        datePicker.box = datepickerInput;
        datePicker.componentDidMount();
        return datePicker;
    };
    return DatePickerBuilder;
}());
describe('DatePicker', function () {
    var builder;
    beforeEach(function () {
        builder = new DatePickerBuilder();
    });
    describe('componentWillUpdate', function () {
        it('should not call updateStateWithDate when nextProps.selected == state.currentDate', function () {
            var picker = builder.build();
            picker.props.selected = new Date('01/29/1984');
            picker.state.currentDate = new Date('03/29/1984');
            spyOn(picker, 'updateStateWithDate');
            var nextState = Object.assign({}, picker.state);
            var nextProps = Object.assign({}, picker.props);
            nextProps.selected = picker.state.currentDate;
            picker.componentWillUpdate(nextProps, nextState);
            expect(picker.updateStateWithDate).toHaveBeenCalledTimes(0);
        });
        it('should not call updateStateWithDate when nextProps.selected == props.selected', function () {
            var picker = builder.build();
            picker.props.selected = new Date('01/29/1984');
            picker.state.currentDate = new Date('03/29/1984');
            spyOn(picker, 'updateStateWithDate');
            var nextState = Object.assign({}, picker.state);
            var nextProps = Object.assign({}, picker.props);
            picker.componentWillUpdate(nextProps, nextState);
            expect(picker.updateStateWithDate).toHaveBeenCalledTimes(0);
        });
        it('should call updateStateWithDate when props have changed and the props are not the current state', function () {
            var picker = builder.build();
            picker.props.selected = new Date('01/29/1984');
            picker.state.currentDate = new Date('03/29/1984');
            spyOn(picker, 'updateStateWithDate');
            var nextState = Object.assign({}, picker.state);
            var nextProps = Object.assign({}, picker.props);
            nextProps.selected = new Date('04/29/1984');
            picker.componentWillUpdate(nextProps, nextState);
            expect(picker.updateStateWithDate).toHaveBeenCalledTimes(1);
            expect(nextState.currentDate.getTime()).toBe(nextProps.selected.getTime());
        });
    });
    describe('componentDidMount', function () {
        // componentDidMount is automatically called by build
        it('should generate a Pikaday object', function () {
            var picker = builder.build();
            expect(picker.picker instanceof Pikaday).toBeTruthy();
        });
        it('should add a mousedown listener that hides the calendar if the mouse clicks outside it', function () {
            var picker = builder.build();
            picker.picker.show();
            spyOn(picker.picker, 'hide');
            expect(builder.addEventListenerSpy).toHaveBeenCalledWith('mousedown', jasmine.any(Function));
            var mouseDown = builder.addEventListenerSpy.calls.mostRecent().args[1];
            mouseDown({ target: document.createElement('div') });
            expect(picker.picker.hide).toHaveBeenCalledTimes(1);
        });
        it('should add a mousedown listener that does not hide the calendar if the mouse clicks on it', function () {
            var picker = builder.build();
            picker.picker.show();
            spyOn(picker.picker, 'hide');
            expect(builder.addEventListenerSpy).toHaveBeenCalledWith('mousedown', jasmine.any(Function));
            var mouseDown = builder.addEventListenerSpy.calls.mostRecent().args[1];
            mouseDown({ target: picker.box.parentElement.getElementsByClassName('pika-single').item(0) });
            expect(picker.picker.hide).toHaveBeenCalledTimes(0);
        });
        it('should add a mousedown listener that removes focus if the mouse clicks off the control', function () {
            var picker = builder.build();
            picker.picker.show();
            picker.state.isFocused = true;
            expect(builder.addEventListenerSpy).toHaveBeenCalledWith('mousedown', jasmine.any(Function));
            var mouseDown = builder.addEventListenerSpy.calls.mostRecent().args[1];
            mouseDown({ target: document.createElement('div') });
            expect(picker.state.isFocused).toBeFalsy();
        });
        it('should add a mousedown listener that does not remove focus if the mouse clicks on the control', function () {
            var picker = builder.build();
            picker.picker.show();
            picker.state.isFocused = true;
            expect(builder.addEventListenerSpy).toHaveBeenCalledWith('mousedown', jasmine.any(Function));
            var mouseDown = builder.addEventListenerSpy.calls.mostRecent().args[1];
            mouseDown({ target: picker.box });
            expect(picker.state.isFocused).toBeTruthy();
        });
    });
    describe('onClicked', function () {
        it('should set focus state to true', function () {
            var picker = builder.build();
            picker.state.isFocused = false;
            picker.onClicked(null);
            expect(picker.state.isFocused).toBeTruthy();
        });
    });
    describe('componentWillUnmount', function () {
        it('should dispose mouse handler', function () {
            var picker = builder.build();
            picker.onMouseDown = {};
            picker.componentWillUnmount();
            expect(builder.removeEventListenerSpy).toHaveBeenCalledWith('mousedown', picker.onMouseDown);
        });
    });
    describe('updateStateWithDate', function () {
        it('should update the date but not the time when no new time is applied', function () {
            var picker = builder.build();
            picker.state.currentDate = new Date('1/1/2012 11:00 PM');
            var newDate = new Date('12/12/2013');
            picker.updateStateWithDate(picker.state, newDate);
            expect(picker.state.currentDate.getTime()).toBe(new Date('12/12/2013 11:00 PM').getTime());
        });
        it('should update the date but not the time when a new time is applied', function () {
            var picker = builder.build();
            picker.state.currentDate = new Date('1/1/2012 11:00 PM');
            var newDate = new Date('12/12/2013 10:00 AM');
            picker.updateStateWithDate(picker.state, newDate);
            expect(picker.state.currentDate.getTime()).toBe(new Date('12/12/2013 11:00 PM').getTime());
        });
    });
    describe('onSelected', function () {
        it('should update the state with the new date from updateStateWithDate', function () {
            var picker = builder.build();
            var newDate = new Date('1/1/2013');
            picker.state.currentDate = new Date('12/12/2012');
            spyOn(picker, 'updateStateWithDate').and.returnValue({
                isFocused: true,
                currentDate: newDate
            });
            picker.onSelected(new Date(0));
            expect(picker.updateStateWithDate).toHaveBeenCalledWith(jasmine.any(Object), new Date(0));
            expect(picker.state.currentDate.getTime()).toBe(newDate.getTime());
        });
        it('should hide the calendar', function () {
            var picker = builder.build();
            spyOn(picker.picker, 'hide');
            picker.onSelected(new Date(0));
            expect(picker.picker.hide).toHaveBeenCalledTimes(1);
        });
        it('should call onChange', function () {
            var picker = builder.build();
            picker.onSelected(new Date(0));
            expect(picker.props.onChange).toHaveBeenCalledTimes(1);
        });
    });
    describe('onManualDateChange', function () {
        it('should call onChange for a valid date string', function () {
            var picker = builder.build();
            var event = { target: { value: '1/1/2016 1:00 AM' } };
            spyOn(picker, 'onChange');
            picker.onManualDateChange(event);
            expect(picker.onChange).toHaveBeenCalledTimes(1);
        });
        it('should update state for a valid date string', function () {
            var picker = builder.build();
            var event = { target: { value: '1/1/2016 1:00 AM' } };
            spyOn(picker, 'onChange');
            picker.onManualDateChange(event);
            expect(picker.state.currentDate.getTime()).toBe(new Date(event.target.value).getTime());
        });
        it('should not call onChange for an invalid date string', function () {
            var picker = builder.build();
            var event = { target: { value: '1/1/2016 1QAM' } };
            spyOn(picker, 'onChange');
            picker.onManualDateChange(event);
            expect(picker.onChange).toHaveBeenCalledTimes(0);
        });
        it('should not update state for an invalid date string', function () {
            var picker = builder.build();
            var event = { target: { value: '1/1/2016 1QAM' } };
            spyOn(picker, 'onChange');
            picker.onManualDateChange(event);
            expect(picker.state.currentDate.getTime() === new Date(event.target.value).getTime()).toBeFalsy();
        });
    });
    describe('onChange', function () {
        it('should call props.onChange', function () {
            var picker = builder.build();
            picker.onChange();
            expect(picker.props.onChange).toHaveBeenCalledTimes(1);
        });
    });
    describe('render', function () {
        it('should render a title', function () {
            var picker = builder.withTitle('test').build();
            var pickerElm = picker.render();
            var element = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.props.className === 'input-title';
            }));
            expect(element.type).toBe('div');
            expect(element.props.children).toBe('test');
        });
        it('should render a textbox prefilled with the selected date', function () {
            var picker = builder.withSelectedDate(new Date('5/14/2005')).build();
            var pickerElm = picker.render();
            var element = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.type === 'input' && elm.props.type === 'text';
            }));
            expect(element.props.defaultValue).toBe('05/14/2005 12:00 AM');
        });
        it('should validate the text field when manually changed', function () {
            var picker = builder.withSelectedDate(new Date('5/14/2005')).build();
            spyOn(picker, 'onManualDateChange');
            var pickerElm = picker.render();
            var element = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.type === 'input' && elm.props.type === 'text';
            }));
            element.props.onChange({ target: document.createElement('input') });
            expect(picker.onManualDateChange).toHaveBeenCalledTimes(1);
        });
        it('should focus the control when clicked', function () {
            var picker = builder.withSelectedDate(new Date('5/14/2005')).build();
            var pickerElm = picker.render();
            picker.state.isFocused = false;
            var element = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.props.className === 'panel-control';
            }));
            element.props.onClick();
            expect(picker.state.isFocused).toBeTruthy();
        });
        it('should render a button that opens the calendar when closed and closes when open', function () {
            var picker = builder.build();
            var pickerElm = picker.render();
            spyOn(picker.picker, 'show');
            spyOn(picker.picker, 'hide');
            var element = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.props.className === 'calendar-button';
            }));
            element.props.onClick();
            expect(picker.picker.show).toHaveBeenCalledTimes(1);
            expect(picker.picker.hide).toHaveBeenCalledTimes(0);
            element.props.onClick();
            expect(picker.picker.show).toHaveBeenCalledTimes(1);
            expect(picker.picker.hide).toHaveBeenCalledTimes(1);
        });
        it('should use the focus class when in a focused state', function () {
            var picker = builder.build();
            picker.state.isFocused = true;
            var pickerElm = picker.render();
            var element = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.props.className === 'panel-control focus';
            }));
            expect(element).toBeDefined();
        });
        it('should not use the focus class when not in a focused state', function () {
            var picker = builder.build();
            picker.state.isFocused = false;
            var pickerElm = picker.render();
            var element = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.props.className === 'panel-control focus';
            }));
            var unFocusedElement = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.props.className === 'panel-control';
            }));
            expect(element).toBeNull();
            expect(unFocusedElement).toBeDefined();
        });
        it('should use the invalid class when in a failed validation state', function () {
            var picker = builder.withValidationState(false).build();
            var pickerElm = picker.render();
            var element = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.props.className === 'panel-control invalid';
            }));
            expect(element).toBeDefined();
        });
        it('should not use the invalid class when not in a failed validation state', function () {
            var picker = builder.build();
            var pickerElm = picker.render();
            var element = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.props.className === 'panel-control invalid';
            }));
            var validElement = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.props.className === 'panel-control';
            }));
            expect(element).toBeNull();
            expect(validElement).toBeDefined();
        });
        it('should include the accessible validation failure reason', function () {
            var picker = builder.withValidationState(false, 'reason').build();
            var pickerElm = picker.render();
            var element = TestUtilities.FindSingle(pickerElm, (function (elm) {
                return elm.props.className === 'acc-hidden';
            }));
            expect(element).toBeDefined();
        });
    });
});
//# sourceMappingURL=DatePicker.spec.js.map