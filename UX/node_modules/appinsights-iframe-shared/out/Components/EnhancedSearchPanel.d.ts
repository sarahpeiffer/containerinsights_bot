/// <reference types="react" />
import * as React from 'react';
import * as KQLTable from '../KQLTableInterfaces';
import { StringMap } from '../SharedInterfaces';
import { TimeContext } from '../TimeContext';
import { SearchPanelSortOrderOption } from './SearchPanel';
import { ODataEvent } from '../TelemetryType';
export declare enum SearchStyle {
    Curated = 0,
    Classic = 1,
}
export interface FilterItem {
    kql: string;
    label?: {
        name: string;
        value: string;
    };
}
export interface SearchPanelFilterData {
    queryFns?: string;
    table: string;
    overrideTimeRange?: boolean;
    filterItems: FilterItem[];
}
export interface EnhancedSearchPanelData {
    timestamp: Date;
    eventId: string;
    data: string;
    extraFields?: {
        name: string;
        value: string;
    }[];
    type?: string;
    kqlItem?: KQLTable.KQLData;
    oDataItem?: ODataEvent;
}
export interface EnhSearchPanelCacheData {
    items: EnhancedSearchPanelData[];
    isSampled: boolean;
    isChronological: boolean;
}
export interface EnhSearchPanelProps {
    strings: StringMap<string>;
    title: string;
    filterData: SearchPanelFilterData;
    timeContext: TimeContext;
    selectedItemId?: string;
    showWarningIfSampled?: boolean;
    iconProvider?: IconProvider;
    searchStyle?: SearchStyle;
    initialItemsCache?: EnhSearchPanelCacheData;
    onClose: () => void;
    onClick?: (item: EnhancedSearchPanelData, wasSuggested: boolean, itemsCache: EnhSearchPanelCacheData) => void;
    queryRunner: (queryName: string, query: string) => Promise<KQLTable.KQLData[]>;
    resultsCallback?: (numResultsChron: number, numResultsRelevant: number) => void;
}
export interface IconProvider {
    onPropsChange(obj: React.Component<any, any>, props: EnhSearchPanelProps): void;
    generateIcon(data: KQLTable.KQLData, props: EnhSearchPanelProps, state: EnhSearchPanelState): JSX.Element;
}
export interface EnhSearchPanelState {
    isLoadingChronological: boolean;
    isFailedChronological: boolean;
    isLoadingRelevant: boolean;
    isFailedRelevant: boolean;
    isSortingChronologically: boolean;
    chronologicalSamples: EnhancedSearchPanelData[];
    relevantSamples: EnhancedSearchPanelData[];
    /** store data used by icon provider, keep this in state obj so that we always get correct data even processing setState */
    iconProviderData?: any;
    hasInteracted: boolean;
}
/** A wrapper around SearchPanel with embedded querying logic. */
export declare class EnhancedSearchPanel extends React.Component<EnhSearchPanelProps, EnhSearchPanelState> {
    private entryLimit;
    private lastSelectedId;
    private queryId;
    private suggestedQueryId;
    constructor(props: EnhSearchPanelProps);
    componentWillReceiveProps(nextProps: EnhSearchPanelProps): void;
    updateSort(sortChronologically: boolean): void;
    getSortOrder(): SearchPanelSortOrderOption[];
    render(): JSX.Element;
    private updateSamples();
    private shouldShowSampleWarning(samples);
    private updateChronologicalSamples();
    private separateCountFromSamples(samples);
    private updateRelevantSamples();
    /** Build a query to get items sorted by timestamp.
     * This mus be a different query than relevance because of the limit.
     */
    private getChronologicalQuery();
    /** Build a query to get items sorted by "relevance". The top "relevant" item is the "suggested" item.
     *  This must be a different query than chronological because of the limit.
     */
    private getRelevantQuery();
    private generateSearchPanelData(data, isSuggested, isSampled);
    private generateEnhancedSearchPanelData(samples);
    private generateDataForRequest(item);
    private generateDataForDependency(item);
    private generateDataForException(item);
    private generateDataForTrace(item);
    private generateDataForPageView(item);
    private generateDataForCustomEvent(item);
    private generateDataForAvailability(item);
    private getSeverityString(severityLevel);
    private switchSelected(item, wasSuggested, itemsCache);
}
