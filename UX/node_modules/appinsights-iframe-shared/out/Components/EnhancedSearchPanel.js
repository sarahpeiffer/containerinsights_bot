import * as tslib_1 from "tslib";
import * as React from 'react';
import * as KQLTable from '../KQLTableInterfaces';
import { getDurationString } from '../NumberUtils';
import { Utils } from '../Utils';
import { SearchPanel } from './SearchPanel';
import { TimeContextToKQLTimeRange } from '..';
export var SearchStyle;
(function (SearchStyle) {
    SearchStyle[SearchStyle["Curated"] = 0] = "Curated";
    SearchStyle[SearchStyle["Classic"] = 1] = "Classic";
})(SearchStyle || (SearchStyle = {}));
/** A wrapper around SearchPanel with embedded querying logic. */
var EnhancedSearchPanel = /** @class */ (function (_super) {
    tslib_1.__extends(EnhancedSearchPanel, _super);
    function EnhancedSearchPanel(props) {
        var _this = _super.call(this, props) || this;
        _this.entryLimit = 250;
        _this.lastSelectedId = '';
        _this.queryId = 0;
        _this.suggestedQueryId = 0;
        _this.state = {
            isLoadingChronological: true,
            isFailedChronological: false,
            isLoadingRelevant: _this.props.searchStyle !== SearchStyle.Classic,
            isFailedRelevant: false,
            chronologicalSamples: [],
            relevantSamples: [],
            isSortingChronologically: _this.props.initialItemsCache ?
                _this.props.initialItemsCache.isChronological : _this.props.searchStyle === SearchStyle.Classic,
            hasInteracted: false
        };
        _this.updateSamples();
        // skip if we don't need to show snapshot icons
        if (props.iconProvider) {
            props.iconProvider.onPropsChange(_this, props);
        }
        return _this;
    }
    EnhancedSearchPanel.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        if (!Utils.deepEqual(nextProps.filterData, this.props.filterData) ||
            !Utils.deepEqual(nextProps.timeContext, this.props.timeContext)) {
            this.setState({
                isLoadingChronological: true,
                isFailedChronological: false,
                isLoadingRelevant: nextProps.searchStyle !== SearchStyle.Classic,
                isFailedRelevant: false,
                chronologicalSamples: [],
                relevantSamples: []
            }, function () {
                _this.updateSamples();
                // skip if we don't need to show snapshot icons
                if (nextProps.iconProvider) {
                    nextProps.iconProvider.onPropsChange(_this, nextProps);
                }
            });
        }
    };
    EnhancedSearchPanel.prototype.updateSort = function (sortChronologically) {
        var _this = this;
        this.setState({ isSortingChronologically: sortChronologically, hasInteracted: true }, function () {
            _this.updateSamples();
        });
    };
    EnhancedSearchPanel.prototype.getSortOrder = function () {
        if (this.props.searchStyle === SearchStyle.Classic) {
            return null;
        }
        return [
            { label: Utils.getString(this.props.strings, 'searchPanelSortRelevance', 'Relevance'),
                value: false, selected: !this.state.isSortingChronologically },
            { label: Utils.getString(this.props.strings, 'searchPanelSortDate', 'Date'),
                value: true, selected: this.state.isSortingChronologically }
        ];
    };
    EnhancedSearchPanel.prototype.render = function () {
        var _this = this;
        var noticeUrl = 'https://docs.microsoft.com/azure/application-insights/app-insights-sampling';
        var notice = React.createElement("div", null,
            this.props.strings['searchPanelSamplingNotice'] + ' ',
            React.createElement("a", { href: noticeUrl, target: '_blank' }, this.props.strings['searchPanelLearnMoreLink']));
        var isUsingCache = this.props.initialItemsCache && !this.state.hasInteracted;
        var currentLoading = this.state.isSortingChronologically ? this.state.isLoadingChronological : this.state.isLoadingRelevant;
        var currentFailed = this.state.isSortingChronologically ? this.state.isFailedChronological : this.state.isFailedRelevant;
        var currentSamples = this.state.isSortingChronologically ? this.state.chronologicalSamples : this.state.relevantSamples;
        var hasSuggested = this.state.relevantSamples && this.state.relevantSamples.length > 0;
        var isSampled = this.shouldShowSampleWarning(currentSamples);
        if (isUsingCache) {
            currentLoading = false;
            currentSamples = this.props.initialItemsCache.items;
            hasSuggested = !this.state.isSortingChronologically;
        }
        return React.createElement(SearchPanel, { strings: this.props.strings, title: this.props.title, limit: this.entryLimit, showTypes: this.props.searchStyle === SearchStyle.Classic, notice: isSampled ? notice : undefined, results: this.generateSearchPanelData(currentSamples, false, isSampled), suggestedResults: hasSuggested ? this.generateSearchPanelData(currentSamples, true, isSampled) : [], filterLabels: this.props.filterData.filterItems.map(function (v) { return v.label || { name: '', value: v.kql }; }), isLoading: currentLoading, isLoadingSuggested: hasSuggested ? false : this.state.isLoadingRelevant, isFailed: currentFailed, sortOrderOptions: this.getSortOrder(), onSortOrderChanged: function (v) { return _this.updateSort(v.value); }, onClose: this.props.onClose });
    };
    EnhancedSearchPanel.prototype.updateSamples = function () {
        // Don't run queries if we have a valid cache
        if (!this.state.hasInteracted && this.props.initialItemsCache) {
            return;
        }
        if (this.props.searchStyle !== SearchStyle.Classic) {
            this.updateRelevantSamples(); // Always query relevant samples because it's used to populate the "suggested" item
            // Only query chronological if we have to (non-default case, user must act)
            if (this.state.isSortingChronologically) {
                this.updateChronologicalSamples();
            }
        }
        else {
            // Classic uses only chronological
            this.updateChronologicalSamples();
        }
    };
    EnhancedSearchPanel.prototype.shouldShowSampleWarning = function (samples) {
        if (!this.state.hasInteracted && this.props.initialItemsCache && this.props.initialItemsCache.isSampled) {
            return this.props.showWarningIfSampled;
        }
        if (!samples || !this.props.showWarningIfSampled) {
            return false;
        }
        for (var i = 0; i < samples.length; i++) {
            var item = samples[i];
            var kqlCount = item.kqlItem && item.kqlItem.itemCount;
            var oDataCount = item.oDataItem && item.oDataItem.count;
            if (kqlCount && parseInt(kqlCount, 10) > 1) {
                return true;
            }
            else if (oDataCount && oDataCount > 1) {
                return true;
            }
        }
        return false;
    };
    EnhancedSearchPanel.prototype.updateChronologicalSamples = function () {
        var _this = this;
        this.queryId++;
        var id = this.queryId;
        this.props.queryRunner('SearchPanel_ChronologicalSamples', this.getChronologicalQuery())
            .then(function (rawSamples) {
            if (id !== _this.queryId) {
                return;
            }
            var _a = _this.separateCountFromSamples(rawSamples), samples = _a.samples, count = _a.count;
            if (_this.props.resultsCallback) {
                _this.props.resultsCallback(count, undefined);
            }
            _this.setState({
                chronologicalSamples: _this.generateEnhancedSearchPanelData(samples),
                isLoadingChronological: false
            });
        })
            .catch(function (_) {
            if (id !== _this.queryId) {
                return;
            }
            _this.setState({
                isFailedChronological: true,
                isLoadingChronological: false
            });
        });
    };
    EnhancedSearchPanel.prototype.separateCountFromSamples = function (samples) {
        // This is necessary because Kusto doesn't seem to guarantee union order
        samples = samples || [];
        var countRow;
        for (var i = 0; i < samples.length; i++) {
            if (samples[i]['Count']) {
                countRow = i;
                break;
            }
        }
        return {
            count: samples.length ? parseInt(samples[countRow]['Count'], 10) : 0,
            samples: samples.slice(0, countRow).concat(samples.slice(countRow + 1))
        };
    };
    EnhancedSearchPanel.prototype.updateRelevantSamples = function () {
        var _this = this;
        this.suggestedQueryId++;
        var id = this.suggestedQueryId;
        this.props.queryRunner('SearchPanel_RelevantSamples', this.getRelevantQuery())
            .then(function (rawSamples) {
            if (id !== _this.suggestedQueryId) {
                return;
            }
            var _a = _this.separateCountFromSamples(rawSamples), samples = _a.samples, count = _a.count;
            if (_this.props.resultsCallback) {
                _this.props.resultsCallback(undefined, count);
            }
            _this.setState({
                relevantSamples: _this.generateEnhancedSearchPanelData(samples),
                isLoadingRelevant: false
            });
        })
            .catch(function (_) {
            if (id !== _this.suggestedQueryId) {
                return;
            }
            _this.setState({
                isFailedRelevant: true,
                isLoadingRelevant: false
            });
        });
    };
    /** Build a query to get items sorted by timestamp.
     * This mus be a different query than relevance because of the limit.
     */
    EnhancedSearchPanel.prototype.getChronologicalQuery = function () {
        var baseQuery = this.props.filterData.table + "\n            " + (!this.props.filterData.overrideTimeRange ? TimeContextToKQLTimeRange(this.props.timeContext) : '') + "\n            " + this.props.filterData.filterItems.map(function (v) { return "| where " + v.kql; }).join('\n');
        return (this.props.filterData.queryFns || '') + "\n            let total = " + baseQuery + " | count;\n            let samples = " + baseQuery + " | top 250 by timestamp desc;\n            union total, samples";
    };
    /** Build a query to get items sorted by "relevance". The top "relevant" item is the "suggested" item.
     *  This must be a different query than chronological because of the limit.
     */
    EnhancedSearchPanel.prototype.getRelevantQuery = function () {
        var filterClauses = this.props.filterData.filterItems.map(function (v) { return "| where " + v.kql; }).join('\n');
        var baseQuery = this.props.filterData.table + "\n            " + (!this.props.filterData.overrideTimeRange ?
            TimeContextToKQLTimeRange(this.props.timeContext) : '') + "\n            " + filterClauses + "\n            | summarize arg_min(ai_hash(operation_Id), *) by operation_Id";
        // NOTE: Strange summarize is a hack to efficiently keep only distinct operation ids
        // arg_min operator is used because of the second parameter allowing rows to pass through unmodified
        // unlike any(*) which appends any_ to column names
        return "let min_length_8 = (s: string) {\n            let len = strlen(s);\n            case(len == 1, strcat(s, s, s, s, s, s, s, s),\n                len == 2 or len == 3, strcat(s, s, s, s),\n                len == 4 or len == 5 or len == 6 or len == 7, strcat(s, s),\n                s)\n        };\n        let ai_hash = (s: string) {\n            abs(toint(__hash_djb2(min_length_8(s))))\n        };\n        " + (this.props.filterData.queryFns || '') + "\n        let total = " + baseQuery + " | count;\n        let samples = " + baseQuery + " | top " + this.entryLimit + " by min_ asc;\n        union total, samples";
    };
    EnhancedSearchPanel.prototype.generateSearchPanelData = function (data, isSuggested, isSampled) {
        var _this = this;
        if (!data) {
            return [];
        }
        var itemsCache = {
            items: data,
            isChronological: this.state.isSortingChronologically,
            isSampled: isSampled
        };
        return (isSuggested ? data.slice(0, 1) : data).map(function (x) { return (tslib_1.__assign({}, x, { isSelected: _this.props.selectedItemId ? x.eventId === (_this.props.selectedItemId || _this.lastSelectedId) : false, onClick: function () { return _this.switchSelected(x, isSuggested, itemsCache); }, icon: _this.props.iconProvider && x.kqlItem && _this.props.iconProvider.generateIcon(x.kqlItem, _this.props, _this.state) })); });
    };
    EnhancedSearchPanel.prototype.generateEnhancedSearchPanelData = function (samples) {
        var _this = this;
        return samples.map(function (item) {
            switch (item.itemType) {
                case KQLTable.KQLItems.Requests:
                    return _this.generateDataForRequest(item);
                case KQLTable.KQLItems.Dependencies:
                    return _this.generateDataForDependency(item);
                case KQLTable.KQLItems.Exceptions:
                    return _this.generateDataForException(item);
                case KQLTable.KQLItems.Availability:
                    return _this.generateDataForAvailability(item);
                case KQLTable.KQLItems.CustomEvents:
                    return _this.generateDataForCustomEvent(item);
                case KQLTable.KQLItems.PageViews:
                    return _this.generateDataForPageView(item);
                case KQLTable.KQLItems.Traces:
                    return _this.generateDataForTrace(item);
            }
        });
    };
    EnhancedSearchPanel.prototype.generateDataForRequest = function (item) {
        return {
            timestamp: new Date(item.timestamp),
            type: item.itemType,
            data: item.name,
            eventId: item.itemId,
            kqlItem: item,
            extraFields: [
                {
                    name: this.props.strings['searchPanelDurationField'],
                    value: getDurationString(item.duration, this.props.strings)
                },
                {
                    name: this.props.strings['searchPanelResponseCodeField'],
                    value: '' + item.resultCode
                }
            ]
        };
    };
    EnhancedSearchPanel.prototype.generateDataForDependency = function (item) {
        return {
            timestamp: new Date(item.timestamp),
            type: item.itemType,
            data: item.target ? item.target.split(' | ')[0] : '',
            eventId: item.itemId,
            kqlItem: item,
            extraFields: [
                {
                    name: this.props.strings['searchPanelDurationField'],
                    value: getDurationString(item.duration, this.props.strings)
                },
                {
                    name: this.props.strings['searchPanelResponseCodeField'],
                    value: '' + item.resultCode
                },
                {
                    name: 'Dependency name',
                    value: item.name
                }
            ]
        };
    };
    EnhancedSearchPanel.prototype.generateDataForException = function (item) {
        return {
            timestamp: new Date(item.timestamp),
            type: item.itemType,
            data: item.outerMessage,
            eventId: item.itemId,
            kqlItem: item,
            extraFields: [
                { name: this.props.strings['searchPanelProblemIdField'], value: item.problemId }
            ]
        };
    };
    EnhancedSearchPanel.prototype.generateDataForTrace = function (item) {
        var severityLevel = this.getSeverityString(item.severityLevel);
        var extraFields = severityLevel ? [{
                name: Utils.getString(this.props.strings, 'searchPanelSeverityLevelField', 'Severity level'),
                value: severityLevel
            }] : [];
        return {
            timestamp: new Date(item.timestamp),
            type: item.itemType,
            data: item.message,
            eventId: item.itemId,
            kqlItem: item,
            extraFields: extraFields
        };
    };
    EnhancedSearchPanel.prototype.generateDataForPageView = function (item) {
        return {
            timestamp: new Date(item.timestamp),
            type: item.itemType,
            data: item.name,
            eventId: item.itemId,
            kqlItem: item,
            extraFields: [
                {
                    name: this.props.strings['attributeMetadataDescriptionViewUrl'],
                    value: item.url
                },
                {
                    name: this.props.strings['metricMetadataDescriptionViewDurationMetricValue'],
                    value: getDurationString(item.duration, this.props.strings)
                },
                {
                    name: this.props.strings['attributeMetadataDescriptionContextDeviceBrowserVersion'],
                    value: item.client_Browser
                }
            ]
        };
    };
    EnhancedSearchPanel.prototype.generateDataForCustomEvent = function (item) {
        return {
            timestamp: new Date(item.timestamp),
            type: item.itemType,
            data: item.name,
            eventId: item.itemId,
            kqlItem: item,
            extraFields: []
        };
    };
    EnhancedSearchPanel.prototype.generateDataForAvailability = function (item) {
        return {
            timestamp: new Date(item.timestamp),
            type: item.itemType,
            data: item.name,
            eventId: item.itemId,
            kqlItem: item,
            extraFields: [
                {
                    name: Utils.getString(this.props.strings, 'searchPanelAvailabilityResultField', 'Availability result'),
                    value: item.success === '1' ?
                        Utils.getString(this.props.strings, 'searchPanelAvailabilityResultSuccess', 'Successful') :
                        Utils.getString(this.props.strings, 'searchPanelAvailabilityResultFailed', 'Failed')
                },
                {
                    name: Utils.getString(this.props.strings, 'searchPanelAvailabilityLocationField', 'Availability location'),
                    value: item.location
                },
                {
                    name: Utils.getString(this.props.strings, 'searchPanelDurationField', 'Duration'),
                    value: getDurationString(item.duration, this.props.strings)
                }
            ]
        };
    };
    EnhancedSearchPanel.prototype.getSeverityString = function (severityLevel) {
        var severityLevels = [
            Utils.getString(this.props.strings, 'messageSeverityLevelVerbose', 'Verbose'),
            Utils.getString(this.props.strings, 'messageSeverityLevelInformational', 'Information'),
            Utils.getString(this.props.strings, 'messageSeverityLevelWarning', 'Warning'),
            Utils.getString(this.props.strings, 'messageSeverityLevelError', 'Error'),
            Utils.getString(this.props.strings, 'messageSeverityLevelCritical', 'Critical')
        ];
        return severityLevels[severityLevel] || null;
    };
    EnhancedSearchPanel.prototype.switchSelected = function (item, wasSuggested, itemsCache) {
        this.lastSelectedId = item.eventId; // Hack to allow selection to show immediately
        if (!!this.props.onClick) {
            this.props.onClick(item, wasSuggested, itemsCache);
        }
    };
    return EnhancedSearchPanel;
}(React.Component));
export { EnhancedSearchPanel };
//# sourceMappingURL=EnhancedSearchPanel.js.map