import * as tslib_1 from "tslib";
import * as React from 'react';
import { ReactEventUtils } from './ReactEventUtils';
import { AccessibilityUtils } from '../AccessibilityUtils';
export var TooltipPosition;
(function (TooltipPosition) {
    TooltipPosition["None"] = "";
    TooltipPosition["Above"] = "above";
    TooltipPosition["Below"] = "below";
})(TooltipPosition || (TooltipPosition = {}));
var TooltipServiceRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TooltipServiceRenderer, _super);
    /** Do not use directly! Use TooltipService.getRenderer  */
    function TooltipServiceRenderer(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            visible: false,
            x: 0,
            y: 0,
            position: TooltipPosition.None,
            text: '',
            locked: false
        };
        /* tslint:disable */
        // Tslint is disabled for this because of a false-positive use-before-declare flag.
        // It is invalid JS for TooltipService to be defined before TooltipServiceRenderer
        TooltipService.registerRenderer(_this.updateState.bind(_this));
        return _this;
        /* tslint:enable */
    }
    TooltipServiceRenderer.prototype.updateState = function (newState) {
        this.setState(function (prevState, props) {
            return newState;
        });
    };
    TooltipServiceRenderer.prototype.getTooltip = function () {
        if (!this.state.visible) {
            return null;
        }
        var style = {
            right: "calc(100% - " + this.state.x + "px)"
        };
        switch (this.state.position) {
            case TooltipPosition.Above:
                style.bottom = "calc(100% - " + this.state.y + "px)";
                break;
            case TooltipPosition.Below:
                style.top = this.state.y + "px";
                break;
        }
        // stopPropagation allows the tooltip to be clicked on without closing it (for text selection)
        return React.createElement("div", { className: "tooltip " + this.state.position, style: style, onClick: function (e) { return e.stopPropagation(); } }, this.state.text);
    };
    TooltipServiceRenderer.prototype.render = function () {
        // Use a locked class to make the tooltip container eat all clicks
        // When the locked class is active (someone clicked to make a tooltip sticky)
        // no other interaction is allowed, except for selecting the tooltip text, or
        // clicking anywhere else to close the tooltip
        /* tslint:disable */
        return React.createElement("div", { className: 'tooltip-container ' + (this.state.locked ? 'locked' : ''), role: 'presentation', onClick: function () { return TooltipService.hideActiveTooltip(); } }, this.getTooltip());
        /* tslint:enable */
    };
    return TooltipServiceRenderer;
}(React.Component));
export { TooltipServiceRenderer };
/** A messenger between components requesting a tooltip and the tooltip renderer */
var TooltipService = /** @class */ (function () {
    function TooltipService() {
    }
    TooltipService.generateDefaultTooltip = function () {
        return {
            text: '',
            visible: false,
            x: 0,
            y: 0,
            position: TooltipPosition.None,
            locked: false
        };
    };
    TooltipService.hideActiveTooltip = function () {
        TooltipService.lockState = false;
        TooltipService.rendererUpdateState(TooltipService.generateDefaultTooltip());
    };
    TooltipService.registerRenderer = function (updateMethod) {
        TooltipService.rendererUpdateState = updateMethod;
    };
    TooltipService.registerTooltipForElement = function (elementAttributes, getDomElement, text) {
        var tooltipState = TooltipService.generateDefaultTooltip();
        tooltipState.text = text;
        var updateTooltip = function (visible) {
            var domElement = getDomElement();
            if (!domElement) {
                return;
            }
            var rect = domElement.getBoundingClientRect();
            tooltipState.x = rect.left + (rect.right - rect.left) / 2;
            if (rect.top > 60) {
                tooltipState.y = rect.top;
                tooltipState.position = TooltipPosition.Above;
            }
            else {
                tooltipState.y = rect.bottom;
                tooltipState.position = TooltipPosition.Below;
            }
            tooltipState.visible = visible;
            tooltipState.locked = TooltipService.lockState;
        };
        // Display tooltip on hover (hide again when hover ends)
        var onMouseEnter = function (evt) {
            if (!TooltipService.lockState) {
                updateTooltip(true);
                TooltipService.rendererUpdateState(tooltipState);
            }
        };
        var onMouseLeave = function (evt) {
            if (!TooltipService.lockState) {
                updateTooltip(false);
                TooltipService.rendererUpdateState(tooltipState);
            }
        };
        // Lock tooltip to display on click
        var onClick = function (evt) {
            if (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }
            TooltipService.lockState = !TooltipService.lockState;
            updateTooltip(TooltipService.lockState);
            TooltipService.rendererUpdateState(tooltipState);
        };
        var onKeyPress = function (evt) {
            if (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }
            onClick(null);
        };
        elementAttributes.onMouseEnter = ReactEventUtils.appendHandler(elementAttributes.onMouseEnter, onMouseEnter);
        elementAttributes.onMouseLeave = ReactEventUtils.appendHandler(elementAttributes.onMouseLeave, onMouseLeave);
        elementAttributes.onClick = ReactEventUtils.appendHandler(elementAttributes.onClick, onClick);
        elementAttributes.onKeyPress = ReactEventUtils.appendHandler(elementAttributes.onKeyPress, onKeyPress);
        elementAttributes['aria-label'] = text;
        elementAttributes.id = AccessibilityUtils.getRandomElementId();
    };
    /** Get the rendering canvas for the global tooltip layer.
     *  Place this at the root HTML element to cover all elements.
     *  This should only be used once
     */
    TooltipService.getRenderer = function () {
        return TooltipService.renderer;
    };
    TooltipService.renderer = React.createElement(TooltipServiceRenderer, null);
    TooltipService.lockState = false;
    return TooltipService;
}());
export { TooltipService };
//# sourceMappingURL=TooltipService.js.map