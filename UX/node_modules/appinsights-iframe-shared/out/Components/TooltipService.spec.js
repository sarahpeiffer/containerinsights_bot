import { TooltipService, TooltipServiceRenderer } from './TooltipService';
import { ReactEventUtils } from './ReactEventUtils';
describe('TooltipService', function () {
    beforeEach(function () {
        TooltipService['rendererUpdateState'] = function () { return null; };
        TooltipService['mouseService'] = new ReactEventUtils();
        TooltipService['lockState'] = false;
        spyOn(TooltipService, 'rendererUpdateState');
    });
    describe('getRenderer', function () {
        it('should return a TooltipServiceRenderer component', function () {
            var renderer = TooltipService.getRenderer();
            expect(renderer.type).toBe(TooltipServiceRenderer);
        });
        it('should always return the same TooltipServiceRenderer component', function () {
            var renderer = TooltipService.getRenderer();
            expect(TooltipService.getRenderer()).toBe(renderer);
        });
    });
    describe('hideActiveTooltip', function () {
        it('should set the lockState to false if originally true', function () {
            TooltipService['lockState'] = true;
            TooltipService.hideActiveTooltip();
            expect(TooltipService['lockState']).toBe(false);
        });
        it('should set the lockState to false if originally false', function () {
            TooltipService['lockState'] = false;
            TooltipService.hideActiveTooltip();
            expect(TooltipService['lockState']).toBe(false);
        });
    });
    describe('registerRenderer', function () {
        it('should set rendererUpdateState', function () {
            var oldStateMethod = TooltipService['rendererUpdateState'];
            var newStateMethod = function () { return null; };
            TooltipService.registerRenderer(newStateMethod);
            expect(TooltipService['rendererUpdateState']).toBe(newStateMethod);
            expect(oldStateMethod === newStateMethod).toBeFalsy();
        });
    });
    describe('registerTooltipForElement', function () {
        it('should add event handlers to element', function () {
            var props = {};
            var domElement = document.createElement('div');
            TooltipService.registerTooltipForElement(props, function () { return domElement; }, 'test');
            expect(props.onMouseEnter).not.toBeNull();
            expect(props.onMouseLeave).not.toBeNull();
            expect(props.onClick).not.toBeNull();
            expect(props.onKeyPress).not.toBeNull();
        });
        it('should add a click callback that locks the tooltip', function () {
            var props = {};
            var domElement = document.createElement('div');
            TooltipService.registerTooltipForElement(props, function () { return domElement; }, 'test');
            var event = {
                type: 'click',
                stopPropagation: function () { },
                preventDefault: function () { }
            };
            props.onClick(event);
            expect(TooltipService['lockState']).toBe(true);
            expect(TooltipService['rendererUpdateState']).toHaveBeenCalledWith({
                x: 0,
                y: 0,
                position: 'below',
                visible: true,
                locked: true,
                text: 'test'
            });
        });
        it('should add a click callback that locks the tooltip', function () {
            var props = {};
            var domElement = document.createElement('div');
            TooltipService.registerTooltipForElement(props, function () { return domElement; }, 'test');
            var e = {
                stopPropagation: function () { }
            };
            var event = {
                type: 'click',
                stopPropagation: function () { },
                preventDefault: function () { }
            };
            props.onClick(event);
            expect(TooltipService['lockState']).toBe(true);
            expect(TooltipService['rendererUpdateState']).toHaveBeenCalledWith({
                x: 0,
                y: 0,
                position: 'below',
                visible: true,
                locked: true,
                text: 'test'
            });
        });
        it('should add a mouse enter callback that shows the tooltip', function () {
            var props = {};
            var domElement = document.createElement('div');
            TooltipService.registerTooltipForElement(props, function () { return domElement; }, 'test');
            props.onMouseEnter({});
            expect(TooltipService['lockState']).toBe(false);
            expect(TooltipService['rendererUpdateState']).toHaveBeenCalledWith({
                x: 0,
                y: 0,
                position: 'below',
                visible: true,
                locked: false,
                text: 'test'
            });
        });
        it('should update the position property for elements lower than 60px', function () {
            var props = {};
            var domElement = document.createElement('div');
            spyOn(domElement, 'getBoundingClientRect').and.returnValue({
                left: 0,
                right: 0,
                top: 61,
                bottom: 0
            });
            TooltipService.registerTooltipForElement(props, function () { return domElement; }, 'test');
            props.onMouseEnter({});
            expect(TooltipService['lockState']).toBe(false);
            expect(TooltipService['rendererUpdateState']).toHaveBeenCalledWith({
                x: 0,
                y: 61,
                position: 'above',
                visible: true,
                locked: false,
                text: 'test'
            });
        });
        it('should add a mouse leave callback that hides the tooltip', function () {
            var props = {};
            var domElement = document.createElement('div');
            TooltipService.registerTooltipForElement(props, function () { return domElement; }, 'test');
            props.onMouseLeave({});
            expect(TooltipService['lockState']).toBe(false);
            expect(TooltipService['rendererUpdateState']).toHaveBeenCalledWith({
                x: 0,
                y: 0,
                position: 'below',
                visible: false,
                locked: false,
                text: 'test'
            });
        });
        it('should add a onKeyPress callback that locks the tooltip', function () {
            var props = {};
            var domElement = document.createElement('div');
            TooltipService.registerTooltipForElement(props, function () { return domElement; }, 'test');
            var event = {
                type: 'keypress',
                stopPropagation: function () { },
                preventDefault: function () { }
            };
            props.onKeyPress(event);
            expect(TooltipService['lockState']).toBe(true);
            expect(TooltipService['rendererUpdateState']).toHaveBeenCalledWith({
                x: 0,
                y: 0,
                position: 'below',
                visible: true,
                locked: true,
                text: 'test'
            });
        });
    });
});
describe('TooltipServiceRenderer', function () {
    var getRenderer = function () {
        var renderer = new TooltipServiceRenderer(null);
        spyOn(renderer, 'setState').and.callFake(function (statefn) {
            renderer.state = statefn(renderer.state);
        });
        return renderer;
    };
    beforeEach(function () {
        TooltipService['rendererUpdateState'] = function () { return null; };
        TooltipService['mouseService'] = new ReactEventUtils();
        TooltipService['lockState'] = false;
    });
    describe('getTooltip', function () {
        it('should contain the text provided in state if visible flag is true', function () {
            var renderer = getRenderer();
            renderer.updateState({
                x: 0,
                y: 0,
                position: 'below',
                visible: true,
                locked: false,
                text: 'test'
            });
            var tooltip = renderer.getTooltip();
            expect(tooltip.props.children).toBe('test');
        });
        it('should return null if visible flag is false', function () {
            var renderer = getRenderer();
            renderer.updateState({
                x: 0,
                y: 0,
                position: '',
                visible: false,
                locked: false,
                text: 'test'
            });
            var tooltip = renderer.getTooltip();
            expect(tooltip).toBe(null);
        });
    });
    describe('render', function () {
        it('should call getTooltip', function () {
            var renderer = getRenderer();
            spyOn(renderer, 'getTooltip');
            renderer.render();
            expect(renderer.getTooltip).toHaveBeenCalledTimes(1);
        });
        it('should not be locked if props are not', function () {
            var renderer = getRenderer();
            renderer.updateState({
                x: 0,
                y: 0,
                position: 'below',
                visible: true,
                locked: false,
                text: 'test'
            });
            var render = renderer.render();
            expect(render.props.className).toBe('tooltip-container ');
        });
        it('should be locked if props are', function () {
            var renderer = getRenderer();
            renderer.updateState({
                x: 0,
                y: 0,
                position: 'below',
                visible: true,
                locked: true,
                text: 'test'
            });
            var render = renderer.render();
            expect(render.props.className).toBe('tooltip-container locked');
        });
        it('should make an element that calls hideActiveTooltip on the TooltipService when clicked', function () {
            var renderer = getRenderer();
            spyOn(TooltipService, 'hideActiveTooltip');
            var render = renderer.render();
            render.props.onClick();
            expect(TooltipService.hideActiveTooltip).toHaveBeenCalled();
        });
    });
});
//# sourceMappingURL=TooltipService.spec.js.map