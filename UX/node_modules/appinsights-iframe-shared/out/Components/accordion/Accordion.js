import * as tslib_1 from "tslib";
import * as React from 'react';
import * as KeyCodes from '../../KeyCodes';
import { AccessibleMenu } from '../../AccessibleMenu';
import { AccessibilityUtils } from '../../AccessibilityUtils';
/**
 * Accessible accordion that supports expanding and collapsing with all necessary keyboard actions supported.
 */
var Accordion = /** @class */ (function (_super) {
    tslib_1.__extends(Accordion, _super);
    function Accordion(props) {
        var _this = _super.call(this, props) || this;
        _this._onKeyDown = _this.onKeyDown.bind(_this);
        _this._ref = function (ul) { return _this._div = ul; };
        _this.state = {
            expanded: {},
        };
        props.items.forEach(function (item) {
            if (typeof _this.state.expanded[item.id] !== 'undefined') {
                throw new Error('Accordion received duplicate ID for item ' + item.id);
            }
            else {
                _this.state.expanded[item.id] = item.isExpanded;
            }
        });
        _this._menu = new AccessibleMenu(false, props.items.map(function (t) { return ''; }), 0, true);
        return _this;
    }
    Accordion.prototype.componentWillReceiveProps = function (nextProps) {
        var _this = this;
        var expanded = Object.assign({}, this.state.expanded);
        nextProps.items.forEach(function (item, i) {
            var oldItem = _this.props.items && _this.props.items.filter(function (t) { return t.id === item.id; })[0];
            var wasExpanded = !!(oldItem && oldItem.isExpanded);
            var isExpanded = !!item.isExpanded;
            if (item.forcedisExpanded !== expanded[item.id] && typeof item.forcedisExpanded === 'boolean') {
                expanded[item.id] = item.forcedisExpanded;
            }
            else if (isExpanded !== wasExpanded) {
                expanded[item.id] = isExpanded;
            }
        });
        this.setState({ expanded: expanded });
        this._menu.items = nextProps.items.map(function (t) { return ''; });
    };
    Accordion.prototype.render = function () {
        var additionalProps = this.props.props || {};
        return React.createElement("div", tslib_1.__assign({}, additionalProps, { className: additionalProps.className || '', onKeyDown: this._onKeyDown, ref: this._ref }), this.getItems());
    };
    Accordion.prototype.getItems = function () {
        var _this = this;
        var treeItems = [];
        this.props.items.forEach(function (item, i) {
            var contentId = AccessibilityUtils.getRandomElementId();
            var additionalProps = item.props || {};
            var isExpanded = !!_this.state.expanded[item.id];
            var labelProps = {};
            if (item.headingLabel) {
                labelProps['aria-label'] = item.headingLabel;
            }
            else {
                labelProps['aria-labelledby'] = item.id;
            }
            treeItems.push(React.createElement("div", { role: 'presentation', key: item.id },
                React.createElement("h3", tslib_1.__assign({ id: item.id }, additionalProps, { className: 'unstyled-h3' + (' ' + (additionalProps.className || '')) }),
                    React.createElement("div", tslib_1.__assign({ className: 'accordion-button', role: 'button', tabIndex: 0, onKeyDown: function (e) { return _this.onItemKeyDown(e, item); }, onClick: function () { return _this.onItemClick(item); } }, labelProps, { "aria-controls": contentId, onFocus: function () { _this._menu.index = i; }, "aria-expanded": isExpanded }), item.heading(isExpanded))),
                React.createElement("div", { id: contentId, role: 'presentation' }, _this.state.expanded[item.id] ? item.content : null)));
        });
        return treeItems;
    };
    Accordion.prototype.onKeyDown = function (e) {
        var prevIndex = this._menu.index;
        var index = this._menu.onKeyDown(e);
        if (index !== prevIndex) {
            e.stopPropagation();
            this.focus(index);
        }
    };
    Accordion.prototype.onItemKeyDown = function (e, item) {
        if (e.keyCode === KeyCodes.ENTER || e.keyCode === KeyCodes.SPACEBAR) {
            this.onItemClick(item);
            e.preventDefault();
        }
    };
    Accordion.prototype.onItemClick = function (item) {
        this.toggleExpansion(item);
    };
    Accordion.prototype.toggleExpansion = function (item) {
        var _this = this;
        this.setState(function (s) {
            var expanded = Object.assign({}, s.expanded);
            expanded[item.id] = !s.expanded[item.id];
            if (_this.props.onItemChanged) {
                _this.props.onItemChanged(item, expanded[item.id]);
            }
            return {
                expanded: expanded
            };
        });
    };
    Accordion.prototype.focus = function (index) {
        if (this._div && this._div.childNodes.length > index && index >= 0) {
            var child = this._div.childNodes.item(index);
            var button = child.getElementsByClassName('accordion-button');
            if (button.length) {
                button.item(0).focus();
            }
        }
    };
    return Accordion;
}(React.Component));
export { Accordion };
//# sourceMappingURL=Accordion.js.map