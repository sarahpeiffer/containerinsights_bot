import { Accordion } from './Accordion';
import { TestUtilities, MockChildNodes } from '../../TestUtilities';
import * as KeyCodes from '../../KeyCodes';
describe('Accordion', function () {
    var props;
    var accordion;
    function verifyExpanded(rendered, i) {
        var item = props.items[i];
        var child = rendered.props.children[i];
        expect(child).toBeTruthy();
        var header = child.props.children[0];
        var button = header.props.children;
        expect(button.props['aria-expanded']).toBe(true);
        expect(button.props.children).toBe(item.heading(true));
        var content = child.props.children[1];
        expect(content).not.toBeNull();
        expect(content.props.id).toBe(button.props['aria-controls']);
        expect(content.props.children).toBe(item.content);
    }
    function verifyCollapsed(rendered, i) {
        var item = props.items[i];
        var child = rendered.props.children[i];
        expect(child).toBeTruthy();
        var header = child.props.children[0];
        var button = header.props.children;
        expect(button.props['aria-expanded']).toBe(false);
        expect(button.props.children).toBe(item.heading(false));
        var content = child.props.children[1];
        expect(content.props.children).toBeFalsy();
    }
    function mount(rendered) {
        var children = [];
        props.items.forEach(function (item, i) {
            var button = {
                focus: function () { }
            };
            spyOn(button, 'focus');
            children.push({
                getElementsByClassName: function (e) {
                    expect(e).toBe('accordion-button');
                    return new MockChildNodes([button]);
                }
            });
        });
        var div = {
            childNodes: new MockChildNodes(children)
        };
        rendered.ref(div);
        return div;
    }
    function verifyFocused(i, div) {
        var child = div.childNodes.item(i);
        var button = child.getElementsByClassName('accordion-button').item(0);
        expect(button.focus).toHaveBeenCalledTimes(1);
    }
    beforeEach(function () {
        var expandedHeading = {};
        var collapsedHeading = {};
        props = {
            items: [
                {
                    content: {},
                    heading: function () { return {}; },
                    headingLabel: 'hi',
                    id: 'item1',
                    isExpanded: false,
                    props: {
                        className: 'item class 1'
                    }
                },
                {
                    content: {},
                    heading: function () { return {}; },
                    headingLabel: 'hi',
                    id: 'item2',
                    isExpanded: false,
                    props: {
                        className: 'item class 2'
                    }
                },
                {
                    content: {},
                    heading: function () { return {}; },
                    headingLabel: 'hi',
                    id: 'item3',
                    isExpanded: false,
                    props: {
                        className: 'item class 3'
                    }
                }
            ],
            props: {
                className: 'my class'
            }
        };
        props.items.forEach(function (item) {
            spyOn(item, 'heading').and.callFake(function (isExpanded) {
                return isExpanded ? expandedHeading : collapsedHeading;
            });
        });
        accordion = new Accordion(props);
        spyOn(accordion, 'setState').and.callFake(function (s) {
            accordion.state = TestUtilities.SetState(accordion.state, accordion.props, s);
        });
    });
    describe('render', function () {
        it('should have outer container if class name speced', function () {
            var result = accordion.render();
            expect(result.props.className).toBe(props.props.className);
        });
        it('should have outer container if class name not speced', function () {
            props.props = null;
            var result = accordion.render();
            expect(result.props.className).toBe('');
        });
        it('should have collapsed items', function () {
            var result = accordion.render();
            props.items.forEach(function (item, i) {
                var child = result.props.children[i];
                expect(child).toBeTruthy();
                var header = child.props.children[0];
                expect(header.type).toBe('h3');
                expect(header.props.id).toBe(item.id);
                expect(header.props.className).toBe('unstyled-h3 ' + item.props.className);
                var button = header.props.children;
                expect(button.type).toBe('div');
                expect(button.props.role).toBe('button');
                expect(button.props.className).toBe('accordion-button');
                expect(button.props.tabIndex).toBe(0);
                expect(button.props['aria-label']).toBe(item.headingLabel);
                expect(button.props['aria-expanded']).toBe(item.isExpanded);
                expect(button.props.children).toBe(item.heading(item.isExpanded));
                var content = child.props.children[1];
                expect(content.props.children).toBeFalsy();
            });
        });
        it('should have expanded item', function () {
            var index = 1;
            props.items[index].isExpanded = true;
            accordion = new Accordion(props);
            var result = accordion.render();
            verifyExpanded(result, index);
        });
        describe('onItemClick', function () {
            var onItemClick = [];
            var rendered;
            beforeEach(function () {
                rendered = accordion.render();
                var onClicks = [];
                props.items.forEach(function (item, i) {
                    var child = rendered.props.children[i];
                    var button = TestUtilities.FindSingle(child, function (t) { return t.props.role === 'button'; });
                    expect(button).not.toBeNull();
                    onClicks.push(button.props.onClick);
                });
                onItemClick = onClicks;
            });
            it('should expand item if clicked', function () {
                onItemClick[1]();
                rendered = accordion.render();
                verifyExpanded(rendered, 1);
            });
            it('should collapse item if clicked', function () {
                onItemClick[1]();
                onItemClick[1]();
                rendered = accordion.render();
                verifyCollapsed(rendered, 1);
            });
            it('should collapse item after expanded with force prop', function () {
                onItemClick[1]();
                var nextProps = Object.assign({}, accordion.props);
                nextProps.items = nextProps.items.slice();
                nextProps.items[1] = Object.assign({}, nextProps.items[1]);
                nextProps.items[1].forcedisExpanded = false;
                accordion.componentWillReceiveProps(nextProps);
                accordion.props = nextProps;
                rendered = accordion.render();
                verifyCollapsed(rendered, 1);
            });
        });
        describe('onItemKeyDown', function () {
            var onItemKeyDown;
            var rendered;
            var e = {
                preventDefault: function () { }
            };
            beforeEach(function () {
                rendered = accordion.render();
                var onKeyDowns = [];
                props.items.forEach(function (item, i) {
                    var child = rendered.props.children[i];
                    var button = TestUtilities.FindSingle(child, function (t) { return t.props.role === 'button'; });
                    expect(button).not.toBeNull();
                    onKeyDowns.push(button.props.onKeyDown);
                });
                onItemKeyDown = onKeyDowns;
                spyOn(e, 'preventDefault');
            });
            it('should expand item if enter pressed', function () {
                e.keyCode = KeyCodes.ENTER;
                onItemKeyDown[1](e);
                rendered = accordion.render();
                verifyExpanded(rendered, 1);
                expect(e.preventDefault).toHaveBeenCalled();
            });
            it('should collapse item enter pressed', function () {
                e.keyCode = KeyCodes.ENTER;
                onItemKeyDown[1](e);
                onItemKeyDown[1](e);
                rendered = accordion.render();
                verifyCollapsed(rendered, 1);
                expect(e.preventDefault).toHaveBeenCalled();
            });
            it('should expand item if spacebar pressed', function () {
                e.keyCode = KeyCodes.SPACEBAR;
                onItemKeyDown[1](e);
                rendered = accordion.render();
                verifyExpanded(rendered, 1);
                expect(e.preventDefault).toHaveBeenCalled();
            });
            it('should collapse item spacebar pressed', function () {
                e.keyCode = KeyCodes.SPACEBAR;
                onItemKeyDown[1](e);
                onItemKeyDown[1](e);
                rendered = accordion.render();
                verifyCollapsed(rendered, 1);
                expect(e.preventDefault).toHaveBeenCalled();
            });
            it('should not expand item if other key pressed', function () {
                e.keyCode = KeyCodes.END;
                onItemKeyDown[1](e);
                rendered = accordion.render();
                verifyCollapsed(rendered, 1);
                expect(e.preventDefault).not.toHaveBeenCalled();
            });
        });
        describe('onKeyDown', function () {
            var onKeyDown;
            var onFocus;
            var div;
            var rendered;
            var e = {
                stopPropagation: function () { },
                preventDefault: function () { }
            };
            beforeEach(function () {
                rendered = accordion.render();
                div = mount(rendered);
                onKeyDown = rendered.props.onKeyDown;
                spyOn(e, 'stopPropagation');
                spyOn(e, 'preventDefault');
                onFocus = [];
                props.items.forEach(function (item, i) {
                    var child = rendered.props.children[i];
                    expect(child).not.toBeNull();
                    var button = TestUtilities.FindSingle(child, function (t) { return t.props.role === 'button'; });
                    expect(button).not.toBeNull();
                    onFocus.push(button.props.onFocus);
                });
            });
            it('should focus on next item if down arrow pressed', function () {
                e.keyCode = KeyCodes.DOWN_ARROW;
                e.key = 'ArrowDown';
                onKeyDown(e);
                expect(e.stopPropagation).toHaveBeenCalled();
                expect(e.preventDefault).toHaveBeenCalled();
                verifyFocused(1, div);
            });
            it('should focus on prev item if up arrow pressed', function () {
                onFocus[1]();
                e.keyCode = KeyCodes.UP_ARROW;
                e.key = 'ArrowUp';
                onKeyDown(e);
                expect(e.stopPropagation).toHaveBeenCalled();
                expect(e.preventDefault).toHaveBeenCalled();
                verifyFocused(0, div);
            });
            it('should circle to first item if down arrow pressed', function () {
                onFocus[2]();
                e.keyCode = KeyCodes.DOWN_ARROW;
                e.key = 'ArrowDown';
                onKeyDown(e);
                expect(e.stopPropagation).toHaveBeenCalled();
                expect(e.preventDefault).toHaveBeenCalled();
                verifyFocused(0, div);
            });
            it('should circle to last item if up arrow pressed', function () {
                e.keyCode = KeyCodes.UP_ARROW;
                onKeyDown(e);
                e.key = 'ArrowUp';
                expect(e.stopPropagation).toHaveBeenCalled();
                expect(e.preventDefault).toHaveBeenCalled();
                verifyFocused(2, div);
            });
            it('should focus on last item if end pressed', function () {
                e.keyCode = KeyCodes.END;
                e.key = 'End';
                onKeyDown(e);
                expect(e.stopPropagation).toHaveBeenCalled();
                expect(e.preventDefault).toHaveBeenCalled();
                verifyFocused(2, div);
            });
            it('should focus on first item if home pressed', function () {
                onFocus[2]();
                e.keyCode = KeyCodes.HOME;
                e.key = 'Home';
                onKeyDown(e);
                expect(e.stopPropagation).toHaveBeenCalled();
                expect(e.preventDefault).toHaveBeenCalled();
                verifyFocused(0, div);
            });
        });
    });
    describe('componentWillReceiveProps', function () {
        it('should expand item that was collapsed by default', function () {
            var nextProps = Object.assign({}, props);
            nextProps.items = props.items.map(function (t) { return Object.assign({}, t); });
            nextProps.items[1].isExpanded = true;
            accordion.componentWillReceiveProps(nextProps);
            var rendered = accordion.render();
            verifyExpanded(rendered, 1);
        });
        it('should collapse item that was expanded by default', function () {
            props.items[1].isExpanded = true;
            var nextProps = Object.assign({}, props);
            nextProps.items = props.items.map(function (t) { return Object.assign({}, t); });
            nextProps.items[1].isExpanded = false;
            accordion.componentWillReceiveProps(nextProps);
            var rendered = accordion.render();
            verifyCollapsed(rendered, 1);
        });
        it('should do nothing if default unchanged', function () {
            var nextProps = Object.assign({}, props);
            nextProps.items = props.items.map(function (t) { return Object.assign({}, t); });
            accordion.componentWillReceiveProps(nextProps);
            var rendered = accordion.render();
            verifyCollapsed(rendered, 1);
        });
    });
});
//# sourceMappingURL=Accordion.spec.js.map