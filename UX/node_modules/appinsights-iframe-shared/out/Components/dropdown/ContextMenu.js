import * as tslib_1 from "tslib";
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { Flyout } from '../dropdown/Flyout';
import { EllipsisSvg, AccessibilityUtils } from '../..';
import * as KeyCodes from '../../KeyCodes';
var ContextMenu = /** @class */ (function (_super) {
    tslib_1.__extends(ContextMenu, _super);
    function ContextMenu(props) {
        var _this = _super.call(this, props) || this;
        _this._onClick = _this.onClick.bind(_this);
        _this._onClose = _this.close.bind(_this);
        _this._onKeyDown = _this.onKeyDown.bind(_this);
        _this._onWindowClick = _this.onWindowClick.bind(_this);
        _this.state = {
            visible: false
        };
        return _this;
    }
    ContextMenu.prototype.focus = function () {
        if (this._button) {
            this._button.focus();
        }
    };
    ContextMenu.prototype.onClick = function () {
        this.setState({ visible: !this.state.visible });
    };
    ContextMenu.prototype.componentWillMount = function () {
        window.addEventListener('click', this._onWindowClick);
    };
    ContextMenu.prototype.componentDidMount = function () {
        this.adjust();
    };
    ContextMenu.prototype.componentWillUpdate = function (nextProps, nextState) {
        var visible = nextState.visible;
        if (visible && !this._container) {
            this._container = document.createElement('div');
            document.body.appendChild(this._container);
        }
        else if (!visible && this._container) {
            document.body.removeChild(this._container);
            this._container = null;
        }
    };
    ContextMenu.prototype.componentDidUpdate = function (prevProps, prevState) {
        var options = this.props.options;
        var prevOptions = prevProps.options;
        var optionsChanged = options.length !== prevOptions.length;
        var nowVisible = this.state.visible && !prevState.visible;
        if (!optionsChanged && !nowVisible) {
            options.forEach(function (option, i) {
                if (option.displayName !== prevOptions[i].displayName) {
                    optionsChanged = true;
                    return;
                }
            });
        }
        if (optionsChanged || nowVisible) {
            this.adjust();
        }
        if (nowVisible && this._flyout) {
            this._flyout.focus();
        }
    };
    ContextMenu.prototype.componentWillUnmount = function () {
        if (this._container) {
            document.body.removeChild(this._container);
        }
        window.removeEventListener('click', this._onWindowClick);
    };
    ContextMenu.prototype.render = function () {
        var _this = this;
        var flyout = React.createElement(Flyout, { flyoutClassName: 'dropdown-flyout context-menu-flyout', ref: function (r) { return _this._flyout = r; }, onClose: this._onClose, options: this.props.options, messageService: this.props.messageService, expanded: this.state.visible });
        var a11yProps = AccessibilityUtils.getAccessibilityProps({
            onClick: this._onClick,
            onKeyPress: this._onKeyDown,
            ref: function (r) { return _this._button = r; },
            tabIndex: this.props.tabindex
        });
        return React.createElement("div", tslib_1.__assign({}, a11yProps),
            React.createElement(EllipsisSvg, null),
            this.state.visible && ReactDOM.createPortal(flyout, this._container));
    };
    ContextMenu.prototype.adjust = function () {
        if (this._flyout && this._button) {
            var buttonRect = this._button.getBoundingClientRect();
            var flyoutRect = this._flyout.getBoundingClientRect();
            var buttonTop = buttonRect.top + (buttonRect.height / 2);
            var top_1 = buttonTop + flyoutRect.height >= document.body.scrollHeight ?
                document.body.scrollHeight - flyoutRect.height : buttonTop;
            var left = buttonRect.left - flyoutRect.width - 6;
            this._flyout.setAttribute('style', "top: " + top_1 + "px; left: " + left + "px;");
        }
    };
    ContextMenu.prototype.close = function () {
        this.setState({ visible: false });
        if (this._button) {
            this._button.focus();
        }
    };
    ContextMenu.prototype.onKeyDown = function (e) {
        if (e.keyCode === KeyCodes.TAB && this.state.visible) {
            this.close();
        }
    };
    ContextMenu.prototype.onWindowClick = function (e) {
        if (this.state.visible && this._button && !this._button.contains(e.target)) {
            this.close();
        }
    };
    return ContextMenu;
}(React.Component));
export { ContextMenu };
//# sourceMappingURL=ContextMenu.js.map