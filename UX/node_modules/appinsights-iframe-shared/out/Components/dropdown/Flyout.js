import * as tslib_1 from "tslib";
import * as React from 'react';
import { DropdownLinkOption } from './DropdownLinkOption';
import { DropdownMessageOption } from './DropdownMessageOption';
import { DropdownActionOption } from './DropdownActionOption';
import { DropdownLink, DropdownMessage, DropdownAction, DropdownDivider } from './DropdownTypes';
import { AccessibleMenu } from '../../AccessibleMenu';
import * as KeyCodes from '../../KeyCodes';
import { DropdownDividerOption } from './DropdownDividerOption';
/**
 * A pull-down menu that supports ARIA role of menu with all associated behaviors and keyboard actions.
 */
var Flyout = /** @class */ (function (_super) {
    tslib_1.__extends(Flyout, _super);
    function Flyout(props) {
        var _this = _super.call(this, props) || this;
        _this._onKeyDown = _this.onKeyDown.bind(_this);
        _this.state = {
            focusIndex: -1
        };
        _this._bindFlyout = function (e) { return _this._flyout = e; };
        _this._menu = new AccessibleMenu(false, _this.getFocusableItems().map(function (t) { return t.displayName; }), 0);
        return _this;
    }
    Object.defineProperty(Flyout.prototype, "offsetWidth", {
        get: function () {
            return this._flyout && this._flyout.offsetWidth;
        },
        enumerable: true,
        configurable: true
    });
    Flyout.prototype.focus = function () {
        this._menu.setFocusToFirstItem();
        this.setState({ focusIndex: this._menu.index });
    };
    Flyout.prototype.getBoundingClientRect = function () {
        return this._flyout && this._flyout.getBoundingClientRect();
    };
    Flyout.prototype.onKeyDown = function (e) {
        if (e.keyCode === KeyCodes.UP_ARROW || e.keyCode === KeyCodes.DOWN_ARROW) {
            e.preventDefault();
            e.stopPropagation();
        }
        if (this.props.expanded) {
            if (e.keyCode === KeyCodes.ESCAPE && this.props.onClose) {
                e.preventDefault();
                e.stopPropagation();
                this.props.onClose();
            }
            else {
                var index = this._menu.onKeyDown(e);
                this.setState({ focusIndex: index });
            }
        }
    };
    Flyout.prototype.setAttribute = function (qualifiedName, value) {
        if (this._flyout) {
            this._flyout.setAttribute(qualifiedName, value);
        }
    };
    Flyout.prototype.componentWillUpdate = function (nextProps) {
        this._menu.items = this.getFocusableItems().map(function (t) { return t.displayName; });
    };
    Flyout.prototype.componentDidUpdate = function (nextProps) {
        if (nextProps.expanded !== this.props.expanded) {
            this._menu.index = -1;
            this.setState({ focusIndex: -1 });
        }
    };
    Flyout.prototype.render = function () {
        var _this = this;
        var elements = [];
        var offset = false;
        this.props.options.forEach(function (op) {
            if (op instanceof DropdownDivider) {
                offset = true;
            }
        });
        var onHover = function (op) {
            if (_this.props.onHover) {
                _this.props.onHover(op);
            }
        };
        var onHoverEnd = function () {
            if (_this.props.onHoverEnd) {
                _this.props.onHoverEnd();
            }
        };
        var index = 0;
        var group = '';
        this.props.options.forEach(function (op) {
            var itemContent = null;
            var props = {
                focusIndex: _this.state.focusIndex,
                group: group,
                index: index,
                name: op.displayName,
                onClick: function (dontClose) {
                    if (!dontClose && _this.props.onClose) {
                        _this.props.onClose();
                    }
                    if (_this.props.onChange) {
                        _this.props.onChange(op);
                    }
                },
                onHover: function () { return onHover(op); },
                onHoverEnd: onHoverEnd
            };
            if (op instanceof DropdownLink && op.url) {
                itemContent = React.createElement(DropdownLinkOption, tslib_1.__assign({}, props, { url: op.url, key: op.id, offset: offset, icon: op.icon }));
            }
            else if (op instanceof DropdownMessage && op.message) {
                itemContent = React.createElement(DropdownMessageOption, tslib_1.__assign({ key: op.id, offset: offset, data: op.data, message: op.message, messageService: _this.props.messageService, icon: op.icon }, props));
            }
            else if (op instanceof DropdownAction) {
                itemContent = React.createElement(DropdownActionOption, tslib_1.__assign({ key: op.id, offset: offset, icon: op.icon, role: op.role, checkboxState: op.checkboxState }, props, { onClick: function () {
                        props.onClick(op.dontCloseOnSelect);
                        op.dispatchActionCallback();
                    } }));
            }
            else if (op instanceof DropdownDivider) {
                index--;
                group = op.displayName;
                itemContent = React.createElement(DropdownDividerOption, { key: op.id, name: op.displayName });
            }
            if (itemContent) {
                elements.push(itemContent);
                index++;
            }
        });
        return React.createElement("ul", { role: 'menu', "aria-expanded": this.props.expanded, onKeyDown: this._onKeyDown, ref: this._bindFlyout, className: (this.props.flyoutClassName || 'dropdown-flyout') +
                (!this.props.expanded ? ' collapsed' : ''), id: this.props.id }, elements);
    };
    Flyout.prototype.getFocusableItems = function () {
        var isFocusable = function (t) {
            if (t instanceof DropdownMessage && !t.message) {
                return false;
            }
            if (t instanceof DropdownLink && !t.url) {
                return false;
            }
            if (t instanceof DropdownDivider) {
                return false;
            }
            return true;
        };
        return this.props.options ? this.props.options.filter(function (t) { return isFocusable(t); }) : [];
    };
    return Flyout;
}(React.Component));
export { Flyout };
//# sourceMappingURL=Flyout.js.map