import { RadioGroup } from './RadioGroup';
import * as KeyCodes from '../../KeyCodes';
import { MockChildNodes, TestUtilities } from '../../TestUtilities';
describe('RadioGroup', function () {
    var props;
    var radioGroup;
    function verifySelected(rendered, index) {
        var child = rendered.props.children[index];
        expect(child).toBeTruthy();
        expect(child.props['aria-checked']).toBe(true);
        expect(child.props.tabIndex).toBe(0);
        expect(props.onChange).toHaveBeenCalledTimes(1);
        expect(props.onChange).toHaveBeenCalledWith(props.items[index]);
    }
    function mount(rendered) {
        var items = [];
        props.items.forEach(function (tab, i) {
            var li = {
                focus: function () { }
            };
            spyOn(li, 'focus');
            items.push(li);
        });
        var ulist = {
            childNodes: new MockChildNodes(items)
        };
        rendered.ref(ulist);
        return ulist;
    }
    function verifyFocused(dom, index) {
        var target = dom.childNodes.item(index);
        expect(target).toBeTruthy();
        expect(target.focus).toHaveBeenCalledTimes(1);
    }
    beforeEach(function () {
        props = {
            className: 'my class',
            items: [
                {
                    className: 'class1',
                    content: {},
                    contentId: 'contentid1',
                    id: 'id1',
                    value: 'value1'
                },
                {
                    className: 'class2',
                    content: {},
                    contentId: 'contentid2',
                    id: 'id2',
                    value: 'value2'
                },
                {
                    className: 'class3',
                    content: {},
                    contentId: 'contentid3',
                    id: 'id3',
                    value: 'value3'
                }
            ],
            label: 'my label',
            onChange: function () { },
            selectedIndex: 0
        };
        spyOn(props, 'onChange');
        radioGroup = new RadioGroup(props);
        spyOn(radioGroup, 'setState').and.callFake(function (s) {
            radioGroup.state = TestUtilities.SetState(radioGroup.state, radioGroup.props, s);
        });
    });
    describe('render', function () {
        it('should have a list of radio buttons', function () {
            var rendered = radioGroup.render();
            expect(rendered.type).toBe('ul');
            expect(rendered.props.role).toBe('radiogroup');
            expect(rendered.props.className).toBe('unstyled-list ' + props.className);
            expect(rendered.props['aria-label']).toBe(props.label);
        });
        it('should have radio buttons', function () {
            var rendered = radioGroup.render();
            props.items.forEach(function (item, i) {
                var child = rendered.props.children[i];
                expect(child.type).toBe('li');
                expect(child.key).toBe(item.id);
                expect(child.props.id).toBe(item.id);
                expect(child.props.className).toBe('list-item ' + item.className);
                expect(child.props['aria-labelledby']).toBe(item.contentId);
                expect(child.props.children).toBe(item.content);
            });
        });
        it('should select button if clicked', function () {
            var rendered = radioGroup.render();
            var child = rendered.props.children[2];
            child.props.onClick();
            rendered = radioGroup.render();
            verifySelected(rendered, 2);
        });
        it('should select button selected with keyboard', function () {
            var rendered = radioGroup.render();
            var child = rendered.props.children[2];
            var e = {
                preventDefault: function () { }
            };
            spyOn(e, 'preventDefault');
            e.keyCode = KeyCodes.ENTER;
            child.props.onKeyDown(e);
            rendered = radioGroup.render();
            verifySelected(rendered, 2);
        });
        describe('onKeyDown', function () {
            var rendered;
            var dom;
            var e;
            var keydown;
            beforeEach(function () {
                rendered = radioGroup.render();
                dom = mount(rendered);
                e = {
                    preventDefault: function () { }
                };
                spyOn(e, 'preventDefault');
                keydown = rendered.props.onKeyDown;
            });
            it('should select next item if down arrow pressed', function () {
                var state = Object.assign({}, radioGroup.state);
                e.keyCode = KeyCodes.DOWN_ARROW;
                keydown(e);
                expect(e.preventDefault).toHaveBeenCalledTimes(1);
                rendered = radioGroup.render();
                radioGroup.componentDidUpdate(radioGroup.props, state);
                verifyFocused(dom, 1);
            });
            it('should select next item if right arrow pressed', function () {
                var state = Object.assign({}, radioGroup.state);
                e.keyCode = KeyCodes.RIGHT_ARROW;
                keydown(e);
                expect(e.preventDefault).toHaveBeenCalledTimes(1);
                rendered = radioGroup.render();
                radioGroup.componentDidUpdate(radioGroup.props, state);
                verifyFocused(dom, 1);
            });
            it('should select prev item if left arrow pressed', function () {
                var nextProps = Object.assign({}, props);
                nextProps.selectedIndex = 1;
                radioGroup.componentWillReceiveProps(nextProps);
                var state = Object.assign({}, radioGroup.state);
                e.keyCode = KeyCodes.LEFT_ARROW;
                keydown(e);
                expect(e.preventDefault).toHaveBeenCalledTimes(1);
                rendered = radioGroup.render();
                radioGroup.componentDidUpdate(radioGroup.props, state);
                verifyFocused(dom, 0);
            });
            it('should select prev item if up arrow pressed', function () {
                var nextProps = Object.assign({}, props);
                nextProps.selectedIndex = 1;
                radioGroup.componentWillReceiveProps(nextProps);
                var state = Object.assign({}, radioGroup.state);
                e.keyCode = KeyCodes.UP_ARROW;
                keydown(e);
                expect(e.preventDefault).toHaveBeenCalledTimes(1);
                rendered = radioGroup.render();
                radioGroup.componentDidUpdate(radioGroup.props, state);
                verifyFocused(dom, 0);
            });
        });
    });
});
//# sourceMappingURL=RadioGroup.spec.js.map