import * as tslib_1 from "tslib";
import * as React from 'react';
import { SGSortOrder } from './SelectableGridData';
import { AutoSizer } from 'react-virtualized/dist/es/AutoSizer';
import { List } from 'react-virtualized/dist/es/List';
import { Utils } from '../../Utils';
import { InfoSvg, ChevronDownSvg, ChevronUpSvg, SortUpSvg, SortDownSvg, SortNoneSvg } from '../../Svgs';
import { TooltipService } from '../TooltipService';
import * as GridAccessibilityHelpers from './GridAccessibilityHelpers';
import { TooltipDetector } from './SGHelper';
import * as KeyCodes from '../../KeyCodes';
var SelectableGrid = /** @class */ (function (_super) {
    tslib_1.__extends(SelectableGrid, _super);
    function SelectableGrid(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this._maxSort = {};
        _this._hasChildren = false;
        _this._minColWidths = {};
        _this._horizontalScrollbarBodies = {};
        _this._horizontalScrollAmounts = {};
        return _this;
    }
    SelectableGrid.prototype.keyDownHelperForGridHeader = function (event) {
        if (!event || !event.target) {
            return;
        }
        var key = event.which || event.keyCode;
        if (key === KeyCodes.F1 && event.shiftKey) {
            var tooltipDiv = event.target.getElementsByClassName('sg-tooltip');
            var tooltipElement = tooltipDiv[0];
            if (tooltipElement) {
                event.preventDefault();
                event.stopPropagation();
                return tooltipElement.click();
            }
        }
        return GridAccessibilityHelpers.handleKeyboardNavigation(event);
    };
    SelectableGrid.prototype.componentDidMount = function () {
        // Calculate width of scrollbar (to offset header columns)
        var elm = document.createElement('div');
        elm.style.width = elm.style.height = '100px';
        elm.style.overflow = 'scroll';
        elm.style.position = 'absolute';
        elm.style.left = '-100%';
        document.body.appendChild(elm);
        this.setState(function (prevState) {
            var scrollbarWidth = elm.offsetWidth - elm.clientWidth;
            document.body.removeChild(elm);
            return {
                scrollbarWidth: scrollbarWidth
            };
        });
    };
    SelectableGrid.prototype.onRowHeaderClicked = function (column) {
        if (!this.props.columns[column].sortable) {
            return;
        }
        if (column === this.props.sortColumn) {
            var currentOrder = this.props.columns[column].sortOrder;
            this.props.onSortOrderChanged(column, currentOrder === SGSortOrder.Descending ? SGSortOrder.Ascending : SGSortOrder.Descending);
        }
        else {
            this.props.onSortColumnChanged(column);
        }
    };
    /** Generates the HTML for the grid header (row with columns bearing the title of each column in the dataset) */
    SelectableGrid.prototype.getHeader = function (scrollbarWidth) {
        var _this = this;
        var keyCounter = 0;
        var headerPadding = scrollbarWidth + "px";
        var entries = this.props.columns.map(function (column, index) {
            if (column.hidden) {
                return;
            }
            var key = 'sg-head-' + keyCounter++;
            var flexWidth = column.width === 0 ? '1 1 0px' : "0 1 " + column.width + "px";
            var isSelected = _this.props.sortColumn === index;
            var sortOrder = column.sortOrder === SGSortOrder.Ascending ? 'asc' : 'desc';
            var ariaSort = column.sortOrder === SGSortOrder.Ascending ? 'ascending' : 'descending';
            var sortClass = 'sg-sorted-' + sortOrder;
            var sortIndicator = isSelected ? sortOrder : 'none';
            var sortElm = column.sortable && _this.props.sortIndicators && _this.props.sortIndicators[sortIndicator];
            var headerPlugin = column.headerPlugin && column.headerPlugin({ isSelected: isSelected, sortOrder: column.sortOrder });
            var tooltipDOMElement = null;
            var className = 'sg-col ' + sortClass + (column.className ? ' ' + column.className : '');
            var tooltipProps = {};
            if (column.infoText) {
                TooltipService.registerTooltipForElement(tooltipProps, function () { return tooltipDOMElement; }, column.infoText);
            }
            var tooltip = React.createElement("div", tslib_1.__assign({ key: key + '-tooltip' }, tooltipProps, { className: 'sg-tooltip', ref: function (r) { return tooltipDOMElement = r; } }),
                React.createElement(InfoSvg, null));
            return React.createElement("div", { className: className, key: key, style: { flex: flexWidth }, "data-sgselected": isSelected, onClick: function () { return _this.onRowHeaderClicked(index); }, role: 'columnheader', "aria-label": column.name, "aria-describedby": column.infoText && tooltipProps.id, "aria-rowindex": 0, "aria-colindex": keyCounter, "aria-sort": column.sortable && isSelected ? ariaSort : 'none', "aria-selected": isSelected, tabIndex: -1, onKeyDown: function (event) { return _this.keyDownHelperForGridHeader(event); } },
                React.createElement("div", { role: 'presentation', className: 'sg-headerplugin', style: { width: column.useOnlyHeaderPlugin ? '100%' : undefined } }, headerPlugin),
                !column.useOnlyHeaderPlugin && React.createElement("div", { role: 'presentation', className: 'sg-text' },
                    React.createElement("div", { className: 'sg-column-name', role: 'presentation', ref: TooltipDetector(column.name) }, column.name),
                    !!column.infoText && tooltip),
                !column.useOnlyHeaderPlugin && React.createElement("div", { role: 'presentation', className: 'sg-sortindicator' }, sortElm));
        });
        return React.createElement("div", { className: 'sg-head sg-row', role: 'row', style: { paddingRight: headerPadding, height: this.props.rowHeight + "px", lineHeight: this.props.rowHeight + "px" } }, entries);
    };
    /** Helper function to handle rendering cells at the proper offset */
    SelectableGrid.prototype.repositionElementForHorizontalScroll = function (elm, columnIndex) {
        var scrollLeft = -this._horizontalScrollbarBodies[columnIndex].parentElement.scrollLeft;
        if (columnIndex > 0) {
            elm.children[0].style.left = scrollLeft + 'px';
        }
        else {
            // The first column is special because it's actually many invisible columns merged into one
            // This is for things such as the color indicator or the expand/collapse control
            elm.style.marginLeft = scrollLeft + 'px';
            elm.style.minWidth = '0px';
            elm.style.minWidth = elm.offsetWidth - scrollLeft + 'px';
            var elms = elm.parentElement.querySelectorAll(".sg-row-depthspacer");
            for (var i = 0; i < elms.length; i++) {
                elms[i].style.left = scrollLeft + 'px';
            }
        }
    };
    /** Generates the HTML for the grid footer (horizontal scrollbars) */
    SelectableGrid.prototype.getHorizontalScrollbars = function (scrollbarWidth, showingVerticalScrollbar) {
        var _this = this;
        var keyCounter = 0;
        var headerPadding = showingVerticalScrollbar ? scrollbarWidth + "px" : '0px';
        var first = true;
        var entries = this.props.columns.map(function (column, index) {
            var key = 'sg-hscroll-' + keyCounter++;
            var flexWidth = column.width === 0 ? '1 1 0px' : "0 1 " + column.width + "px";
            var scrolling = false;
            var scrollHandler = function (e) {
                if (!scrolling) {
                    scrolling = true;
                    requestAnimationFrame(function () {
                        var scrollLeft = -_this._horizontalScrollbarBodies[index].parentElement.scrollLeft;
                        if (first) {
                            _this._horizontalScrollbarBodies[index].parentElement.scrollLeft = -_this._horizontalScrollAmounts[index];
                        }
                        if (_this._horizontalScrollAmounts[index] !== scrollLeft || first) {
                            _this._horizontalScrollAmounts[index] = scrollLeft;
                            var control = _this._horizontalScrollbarBodies[index].parentElement.parentElement.parentElement;
                            var elms = control.querySelectorAll("div[data-sgcolumn=\"" + index + "\"]");
                            for (var i = 0; i < elms.length; i++) {
                                _this.repositionElementForHorizontalScroll(elms[i], index);
                            }
                        }
                        first = false;
                        scrolling = false;
                    });
                }
            };
            return React.createElement("div", { className: 'sg-hscroll', key: key, style: { flex: flexWidth, pointerEvents: _this._minColWidths[index] > 0 ? 'all' : 'none' }, onScroll: scrollHandler },
                React.createElement("div", { className: 'sg-hscroll-body', style: { width: _this._minColWidths[index] + 'px' || 0 }, ref: function (e) {
                        if (e !== null) {
                            _this._horizontalScrollbarBodies[index] = e;
                            e.parentElement.scrollLeft = _this._horizontalScrollAmounts[index] || 0;
                        }
                    } }));
        });
        return React.createElement("div", { className: 'sg-hscroll-contain', style: { paddingRight: headerPadding, height: scrollbarWidth + "px" } }, entries);
    };
    /** Generates the HTML for a given DataRow (column divs with the appropriate cell model for each, populated with data) */
    SelectableGrid.prototype.getRow = function (row, rowKeyIndex, depth) {
        var _this = this;
        var indentationWidth = this._hasChildren ? this.props.childIndentation * (depth + 1) : 0;
        var skipColumnCount = 0;
        var cols = row.columnData.map(function (data, columnIndex) {
            // Adjust index for hidden columns to avoid accessibility issues
            var column = _this.props.columns[columnIndex];
            if (column.hidden) {
                skipColumnCount++;
                return;
            }
            columnIndex -= skipColumnCount;
            var ariaColumnIndex = columnIndex + 1;
            var props = {
                value: data,
                rowSelected: row.selected
            };
            var key = rowKeyIndex + '-sgcol-' + columnIndex;
            var columnWidth = columnIndex > 0 ? column.width : column.width - indentationWidth;
            var flexWidth = column.width === 0 ? '1 1 0px' : "0 1 " + columnWidth + "px";
            var className = 'sg-col' + (column.showSortBar ? ' sg-barbacked' : '') + (column.className ? ' ' + column.className : '')
                + (row.className ? ' ' + row.className : '');
            var tabIndex = (!_this.props.keyboardNavigateOnlyRows && rowKeyIndex === 0 && columnIndex === 0) ? 0 : -1;
            var cell = column.cell(props);
            if (!column.showSortBar) {
                return React.createElement("div", { className: className, key: key, style: { flex: flexWidth }, "data-sgcolumn": columnIndex, ref: _this.getCellRef(columnIndex, indentationWidth), role: 'gridcell', tabIndex: tabIndex, onKeyDown: GridAccessibilityHelpers.handleKeyboardNavigation, "aria-selected": row.selected, "aria-expanded": !(row.children && !!row.children.length) ? undefined : row.expanded, "aria-colindex": ariaColumnIndex, "aria-rowindex": rowKeyIndex + 1, "aria-label": cell.props['aria-label'] }, cell);
            }
            else {
                var maxVal = _this._maxSort[columnIndex];
                var barWidth = 80 * (row.columnData[columnIndex] / maxVal);
                var style = { width: "calc(" + barWidth + "% - 1px)", backgroundColor: column.sortBarColor };
                return React.createElement("div", { className: className, key: key, style: { flex: flexWidth }, "data-sgcolumn": columnIndex, ref: _this.getCellRef(columnIndex, indentationWidth), role: 'presentation' },
                    React.createElement("div", { className: 'sg-bb-colvm', role: 'gridcell', tabIndex: tabIndex, "aria-rowindex": rowKeyIndex + 1, "aria-selected": row.selected, "aria-colindex": ariaColumnIndex, "aria-expanded": !(row.children && !!row.children.length) ? undefined : row.expanded, onKeyDown: GridAccessibilityHelpers.handleKeyboardNavigation, "aria-label": cell.props['aria-label'] }, cell),
                    React.createElement("div", { className: 'sg-bb-bar', style: style, role: 'presentation' }));
            }
        });
        var outerClassName = 'sg-row' + (row === this.props.fixedRow ? ' sg-fixedrow' : '');
        var depthCol = React.createElement("div", { className: 'sg-row-depthspacer', key: rowKeyIndex + '-sgcol-depthspacer', role: 'presentation', style: { flex: "0 0 " + indentationWidth + "px" }, onClick: function (e) {
                // This interaction is handled by GridAccessibilityHelpers for keyboard navigation
                if (row.children && !!row.children.length) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.props.onRowCollapseChanged(row.value, row.expanded);
                }
            } },
            row.children && !!row.children.length && row.expanded && this.props.nestingIndicators.collapse,
            row.children && !!row.children.length && !row.expanded && this.props.nestingIndicators.expand);
        cols.unshift(depthCol);
        if (this.props.rowColor) {
            var colorCol = React.createElement("div", { className: 'sg-row-colorindicator', key: rowKeyIndex + '-sgcol-colorCol', style: { backgroundColor: this.props.rowColor(row) }, role: 'presentation' });
            cols.unshift(colorCol);
        }
        return React.createElement("div", { key: 'sgrow-' + rowKeyIndex, role: 'row', className: outerClassName, "data-sgselected": row.selected, "data-sgdisabled": !!row.disabled, "data-sgdepth": depth, "data-sgchildren": row.children && !!row.children.length, "data-sgexpanded": row.expanded, "aria-selected": row.selected, "aria-level": depth, "aria-rowindex": rowKeyIndex, "aria-expanded": !(row.children && !!row.children.length) ? undefined : row.expanded, tabIndex: this.props.keyboardNavigateOnlyRows && rowKeyIndex === 0 ? 0 : -1, onKeyDown: GridAccessibilityHelpers.handleKeyboardNavigation, style: { height: this.props.rowHeight + "px", lineHeight: this.props.rowHeight + "px" }, onClick: function () { if (!row.disabled) {
                _this.props.onSelect(row.value);
            } } }, cols);
    };
    /** Generates appropriate ref for horizontal scrollbar support  */
    SelectableGrid.prototype.getCellRef = function (columnIndex, indentationWidth) {
        var _this = this;
        var column = this.props.columns[columnIndex];
        // Because cells are placed in divs representing each row, we have to create virtual scrollbars
        // for horizontal scrolling in individual columns that have cells that are too large.
        // The code below measures the current cell's intrinsic width to keep track of the minimum necessary
        // width for the scrollbar. Note that this is loaded lazily, so we don't impact the performance
        // of virtualized vertical scrolling. The impact of this is that the scrollbar might only first appear
        // when a cell that is too large is almost in view (although this size will be cached from then onward
        // unless a re-render is triggered - e.g. props change).
        if (column.showHorizontalScrollbar) {
            return function (outerElm) {
                if (!outerElm) {
                    // elm is null when element is unmounted by react
                    return;
                }
                var elm = outerElm.children[0];
                if (elm.className === 'sg-bb-colvm') {
                    elm = elm.children[0]; // Special case for bar-backed cells
                }
                var intrinsicWidth = elm.scrollWidth + indentationWidth + 10; // "magic" number 10 is for padding
                var scrollbarBody = _this._horizontalScrollbarBodies[columnIndex];
                var minWidth = Math.max(intrinsicWidth, _this._minColWidths[columnIndex] || 0);
                _this._minColWidths[columnIndex] = minWidth;
                _this.repositionElementForHorizontalScroll(outerElm, columnIndex);
                if (scrollbarBody && scrollbarBody.style.width !== minWidth + 'px') {
                    // Guard above avoids set (and potential browser render cycle), if unnecessary
                    scrollbarBody.style.width = minWidth + 'px';
                    scrollbarBody.parentElement.style.pointerEvents = 'all';
                }
            };
        }
        return null;
    };
    /** Converts the DataRow tree structure to a flat array by applying a supplied function to each row and traversing depth-first */
    SelectableGrid.prototype.flattenRows = function (rows, fn) {
        var _this = this;
        if (!this.props.columns || this.props.columns.length === 0) {
            return [];
        }
        var sortFunc = function (a, b) { return null; };
        var sortCol = this.props.sortColumn;
        var ret = [];
        if (sortCol !== null) {
            sortFunc = this.getSortFuncForColumn(sortCol, true);
            rows.sort(function (a, b) { return sortFunc(a.columnData[sortCol], b.columnData[sortCol]); });
        }
        rows.forEach(function (row) {
            row.traverse(function (innerRow, depth) {
                ret.push(fn(innerRow, depth));
            }, true, _this.props.sortColumn, sortFunc);
        });
        return ret;
    };
    SelectableGrid.prototype.getSortFuncForColumn = function (column, followSortOrder) {
        var sortDir = this.props.columns[column].sortOrder;
        var sortFunc = this.props.columns[column].sortFunc || (function (a, b) { return (a === b) ? 0 : a < b ? -1 : 1; });
        if (followSortOrder && sortDir === SGSortOrder.Descending) {
            var origSortFunc_1 = sortFunc;
            sortFunc = function (a, b) { return origSortFunc_1(a, b) * -1; };
        }
        return sortFunc;
    };
    /** Gets row data for use in rendering */
    SelectableGrid.prototype.getRows = function () {
        var _this = this;
        var rowData = this.props.data;
        if (typeof this.props.maxRows !== 'undefined') {
            rowData = rowData.slice(0, Math.min(this.props.maxRows, rowData.length));
        }
        var rows = this.flattenRows(rowData, function (row, depth) {
            if (depth > 0) {
                _this._hasChildren = true;
            }
            return { row: row, depth: depth };
        });
        if (this.props.fixedRow) {
            rows = [{ row: this.props.fixedRow, depth: 0 }].concat(rows);
        }
        // Get sort fns
        var sortFns = {};
        for (var i = 0; i < this.props.columns.length; i++) {
            sortFns[i] = this.getSortFuncForColumn(i, false);
        }
        // Calculate the max value of root nodes in all columns 
        this._maxSort = {};
        for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            if (row.depth === 0) {
                for (var col = 0; col < row.row.columnData.length; col++) {
                    var data = row.row.columnData[col];
                    var maxData = this._maxSort[col];
                    if (maxData === undefined || sortFns[col](data, maxData) > 0) {
                        this._maxSort[col] = data;
                    }
                }
            }
        }
        return rows;
    };
    SelectableGrid.prototype.onGridResize = function (height) {
        this.setState({ gridBodyHeight: height });
    };
    SelectableGrid.prototype.render = function () {
        var _this = this;
        this._minColWidths = {};
        var rows = this.getRows();
        var scrollIndex = undefined;
        var rowCount = rows.length;
        if (this.props.showEmptyRows && this.state) {
            rowCount = Math.floor(Math.max(rowCount, this.state.gridBodyHeight / this.props.rowHeight));
        }
        if (typeof this.props.scrollToRowWithValue !== 'undefined') {
            for (var i = 0; i < rows.length; i++) {
                if (Utils.deepEqual(rows[i].row.value, this.props.scrollToRowWithValue)) {
                    // Padding is to place the selected row in the middle of the grid.
                    // Without it, the grid is scrolled to make the selected row the last visible row
                    var padding = this.state ? (Math.round(this.state.gridBodyHeight / this.props.rowHeight / 2) + 1) : 0;
                    scrollIndex = Math.min(rows.length - 1, i + padding);
                    break;
                }
            }
        }
        var rowRenderer = function (index) {
            if (rows[index]) {
                return _this.getRow(rows[index].row, index, rows[index].depth);
            }
            else {
                // This is used by "showEmptyRows" mode to fill any remaining space with row lines
                return React.createElement("div", { className: 'sg-row', key: 'sgrow-' + index, style: { height: _this.props.rowHeight + "px" } });
            }
        };
        // List control has hardcoded accessibility attributes
        // These attributes are incorrect for our use case
        var ariaFixerRef = function (elm) {
            if (!elm) {
                return;
            }
            var parent = elm.children[0];
            parent.setAttribute('role', 'presentation');
            parent.setAttribute('tabindex', '-1');
            var list = elm.children[0].children[0];
            list.removeAttribute('aria-label');
            list.setAttribute('role', 'presentation');
            list.setAttribute('tabindex', '-1');
        };
        var showingScrollbar = this.state ? (this.state.gridBodyHeight < this.props.rowHeight * rows.length) : false;
        var showingHorizScrollbar = this.props.columns.filter(function (v) { return v.showHorizontalScrollbar; }).length > 0;
        var scrollbarWidth = this.state ? this.state.scrollbarWidth : 0;
        var adjustedRowHeight = this.props.rowHeight + (scrollbarWidth / rowCount);
        return React.createElement("div", { className: 'selectable-grid', role: 'treegrid', "aria-readonly": 'true', "aria-rowcount": rowCount, "aria-label": this.props.accessibleTitle },
            !this.props.hideHeader ? this.getHeader(showingScrollbar ? scrollbarWidth : 0) : null,
            React.createElement("div", { className: 'sg-body' + (this.props.hideHeader ? ' sg-noheader' : ''), ref: ariaFixerRef, role: 'presentation', tabIndex: -1 },
                React.createElement(AutoSizer, { onResize: function (_a) {
                        var height = _a.height;
                        return _this.onGridResize(height);
                    } }, function (_a) {
                    var width = _a.width, height = _a.height;
                    return (React.createElement(List, { style: { outline: 'none' }, height: height, overscanRowCount: Math.ceil(height / _this.props.rowHeight), noRowsRenderer: function () { return null; }, rowCount: rowCount, rowHeight: showingHorizScrollbar ? adjustedRowHeight : _this.props.rowHeight, rowRenderer: function (_a) {
                            var index = _a.index, style = _a.style, key = _a.key;
                            // New react marks style as readonly. Setting style directly will fail at runtime - not compile time
                            // Use object.assign to modify a new object instead
                            var newStyle = Object.assign({}, style);
                            // We manipulate the height we tell List we are, so there's extra space at the bottom
                            // This allows the horizontal scrollbars to appear, with content behind them
                            if (showingHorizScrollbar) {
                                newStyle.height = _this.props.rowHeight + 'px';
                                newStyle.top = _this.props.rowHeight * index + 'px';
                            }
                            return React.createElement("div", { style: newStyle, key: key, role: 'presentation' }, rowRenderer(index));
                        }, onScroll: function (p) { return _this.onScroll(p); }, scrollToIndex: scrollIndex, width: width }));
                }),
                showingHorizScrollbar && this.getHorizontalScrollbars(scrollbarWidth, showingScrollbar),
                !!this.props.children && React.createElement("div", { className: 'sg-children', style: { right: showingScrollbar ? this.state.scrollbarWidth : 0 } }, this.props.children)));
    };
    SelectableGrid.prototype.onScroll = function (params) {
        if (this.props.onScrollToEnd) {
            if (Math.floor(params.scrollTop) === Math.floor(params.scrollHeight - params.clientHeight) && params.clientHeight) {
                this.props.onScrollToEnd();
            }
        }
    };
    SelectableGrid.defaultProps = {
        sortColumn: null,
        rowHeight: 35,
        childIndentation: 15,
        nestingIndicators: { collapse: ChevronDownSvg({}), expand: ChevronUpSvg({}) },
        sortIndicators: { asc: SortUpSvg({}), desc: SortDownSvg({}), none: SortNoneSvg({}) },
        onSelect: function () { return null; },
        onSortColumnChanged: function () { return null; },
        onSortOrderChanged: function () { return null; },
        onRowCollapseChanged: function () { return null; }
    };
    return SelectableGrid;
}(React.Component));
export { SelectableGrid };
//# sourceMappingURL=SelectableGrid.js.map