import * as React from 'react';
import { SelectableGrid } from './SelectableGrid';
import { SGDataRow, SGSortOrder } from './SelectableGridData';
import { SGPlainCell } from './SGPlainCell';
import { AutoSizer, List } from 'react-virtualized';
var SelectableGridBuilder = /** @class */ (function () {
    function SelectableGridBuilder() {
        this.props = {
            columns: [{ name: 'A', width: 75, cell: SGPlainCell }],
            data: [],
            sortColumn: 0,
            onSelect: function () { return null; },
            rowHeight: 35,
            onSortColumnChanged: function () { return null; },
            onSortOrderChanged: function () { return null; },
            scrollToRowWithValue: undefined
        };
    }
    SelectableGridBuilder.prototype.withColumns = function (columns) {
        this.props.columns = columns;
        return this;
    };
    SelectableGridBuilder.prototype.withData = function (dataRows) {
        this.props.data = dataRows;
        return this;
    };
    SelectableGridBuilder.prototype.withFixedRow = function (fixedRow) {
        this.props.fixedRow = fixedRow;
        return this;
    };
    SelectableGridBuilder.prototype.withSortIndicators = function (indicators) {
        this.props.sortIndicators = indicators;
        return this;
    };
    SelectableGridBuilder.prototype.withHeaderHidden = function (hidden) {
        this.props.hideHeader = hidden;
        return this;
    };
    SelectableGridBuilder.prototype.withScrollToRowWithValue = function (value) {
        this.props.scrollToRowWithValue = value;
        return this;
    };
    SelectableGridBuilder.prototype.withOnScroll = function (v) {
        this.props.onScrollToEnd = v;
        return this;
    };
    SelectableGridBuilder.prototype.build = function () {
        spyOn(this.props, 'onSelect');
        spyOn(this.props, 'onSortColumnChanged');
        spyOn(this.props, 'onSortOrderChanged');
        var sg = new SelectableGrid(this.props);
        return sg;
    };
    return SelectableGridBuilder;
}());
describe('SelectableGrid', function () {
    var builder;
    beforeEach(function () {
        builder = new SelectableGridBuilder();
    });
    describe('getHeader', function () {
        it('should make sure onKeyDown on grid header causes tooltip onClick if it exists and Shift+F1 is pressed', function () {
            var columns = [
                { name: 'A', width: 75, cell: SGPlainCell, infoText: 'testTooltip' }
            ];
            var header = builder.withColumns(columns).build().getHeader(0);
            var cols = header.props.children;
            expect(cols[0].props.children[1].props.children[1].props.className).toBe('sg-tooltip');
            var tooltipClassName = cols[0].props.children[1].props.children[1].props.className;
            var mockDomManipulator = {};
            var wasCalled = false;
            mockDomManipulator.getElementsByClassName = function (className) {
                expect(className).toBe(tooltipClassName);
                return [{ click: function () {
                            wasCalled = true;
                        } }];
            };
            var event = {
                type: 'keydown',
                keyCode: 112,
                shiftKey: true,
                target: mockDomManipulator,
                stopPropagation: function () { },
                preventDefault: function () { }
            };
            header.props.children[0].props.onKeyDown(event);
            expect(wasCalled).toBe(true);
        });
        it('should return a parent div with sg-head, sg-row classes', function () {
            var header = builder.build().getHeader(0);
            expect(header.type).toBe('div');
            expect(header.props.className).toBe('sg-head sg-row');
            expect(header.props.role).toBe('row');
        });
        it('should return a child div for each column (without indicators)', function () {
            var columns = [
                { name: 'A', width: 75, cell: SGPlainCell, sortOrder: SGSortOrder.Ascending },
                { name: 'B', width: 25, cell: SGPlainCell },
                { name: 'Hidden', width: 25, cell: SGPlainCell, hidden: true },
            ];
            var header = builder.withColumns(columns).build().getHeader(0);
            var cols = header.props.children;
            expect(cols.length).toBe(columns.length);
            for (var i = 0; i < columns.length; i++) {
                if (columns[i].hidden) {
                    expect(cols[i]).toBe(undefined);
                    continue;
                }
                var sortOrderClass = columns[i].sortOrder === SGSortOrder.Ascending && 'asc' || 'desc';
                expect(cols[i].props.className).toBe('sg-col sg-sorted-' + sortOrderClass);
                expect(cols[i].key).toBe('sg-head-' + i);
                expect(cols[i].props.style.flex).toBe("0 1 " + columns[i].width + "px");
                expect(cols[i].props['data-sgselected']).toBe(i === 0);
                expect(cols[i].props['aria-label']).toBe(columns[i].name);
                expect(cols[i].props['aria-rowindex']).toBe(0);
                expect(cols[i].props['aria-colindex']).toBe(i + 1);
                expect(cols[i].props['aria-sort']).toBe('none');
                expect(cols[i].props['aria-selected']).toBe(i === 0);
                expect(cols[i].props.role).toBe('columnheader');
                expect(cols[i].props.children[0].props.className).toBe('sg-headerplugin');
                expect(cols[i].props.children[0].props.role).toBe('presentation');
                expect(cols[i].props.children[0].props.children).toBeFalsy();
                expect(cols[i].props.children[1].props.children[0].props.className).toBe('sg-column-name');
                expect(cols[i].props.children[1].props.children[0].props.role).toBe('presentation');
                expect(cols[i].props.children[1].props.children[0].props.children).toBe(columns[i].name);
                expect(cols[i].props.children[1].props.role).toBe('presentation');
                expect(cols[i].props.children[2].props.className).toBe('sg-sortindicator');
                expect(cols[i].props.children[2].props.role).toBe('presentation');
                expect(cols[i].props.children[2].props.children).toBeFalsy();
            }
        });
        it('should return a child div for each column (with indicators)', function () {
            var columns = [
                { name: 'A', width: 75, cell: SGPlainCell, sortOrder: SGSortOrder.Ascending, sortable: true },
                { name: 'B', width: 25, cell: SGPlainCell },
            ];
            var indicatorAsc = React.createElement('div');
            var indicatorDesc = React.createElement('div');
            var indicatorNone = React.createElement('div');
            var indicators = { asc: indicatorAsc, desc: indicatorDesc, none: indicatorNone };
            var header = builder.withColumns(columns).withSortIndicators(indicators).build().getHeader(0);
            var cols = header.props.children;
            expect(cols.length).toBe(columns.length);
            for (var i = 0; i < columns.length; i++) {
                var selected = i === 0;
                var sortOrderClass = columns[i].sortOrder === SGSortOrder.Ascending && 'asc' || 'desc';
                var sortOrderIndicator = (selected && (columns[i].sortOrder === SGSortOrder.Ascending && indicatorAsc || indicatorDesc)) || indicatorNone;
                var ariaSort = columns[i].sortable &&
                    selected ? (columns[i].sortOrder === SGSortOrder.Ascending && 'ascending' || 'descending') : 'none';
                expect(cols[i].props.className).toBe('sg-col sg-sorted-' + sortOrderClass);
                expect(cols[i].key).toBe('sg-head-' + i);
                expect(cols[i].props.style.flex).toBe("0 1 " + columns[i].width + "px");
                expect(cols[i].props['data-sgselected']).toBe(selected);
                expect(cols[i].props['aria-sort']).toBe(ariaSort);
                expect(cols[i].props.children[0].props.className).toBe('sg-headerplugin');
                expect(cols[i].props.children[0].props.children).toBeFalsy();
                expect(cols[i].props.children[1].props.children[0].props.className).toBe('sg-column-name');
                expect(cols[i].props.children[1].props.children[0].props.role).toBe('presentation');
                expect(cols[i].props.children[1].props.children[0].props.children).toBe(columns[i].name);
                expect(cols[i].props.children[2].props.className).toBe('sg-sortindicator');
                expect(cols[i].props.children[2].props.children).toBe((columns[i].sortable) && sortOrderIndicator);
            }
        });
        it('should return a child div for each column (with header plugin)', function () {
            var headerplugin = React.createElement('div');
            var columns = [
                { name: 'A', width: 75, cell: SGPlainCell, sortOrder: SGSortOrder.Ascending, headerPlugin: function () { return headerplugin; } },
                { name: 'B', width: 25, cell: SGPlainCell },
            ];
            var header = builder.withColumns(columns).build().getHeader(0);
            var cols = header.props.children;
            expect(cols.length).toBe(columns.length);
            for (var i = 0; i < columns.length; i++) {
                var selected = i === 0;
                var sortOrderClass = columns[i].sortOrder === SGSortOrder.Ascending && 'asc' || 'desc';
                expect(cols[i].props.className).toBe('sg-col sg-sorted-' + sortOrderClass);
                expect(cols[i].key).toBe('sg-head-' + i);
                expect(cols[i].props.style.flex).toBe("0 1 " + columns[i].width + "px");
                expect(cols[i].props['data-sgselected']).toBe(selected);
                expect(cols[i].props.children[0].props.className).toBe('sg-headerplugin');
                expect(cols[i].props.children[0].props.children).toBe(i === 0 ? headerplugin : undefined);
                expect(cols[i].props.children[1].props.children[0].props.className).toBe('sg-column-name');
                expect(cols[i].props.children[1].props.children[0].props.role).toBe('presentation');
                expect(cols[i].props.children[1].props.children[0].props.children).toBe(columns[i].name);
            }
        });
        it('should return a child div for each column (with tooltip)', function () {
            var columns = [
                { name: 'A', width: 75, cell: SGPlainCell, sortOrder: SGSortOrder.Ascending, infoText: 'test' },
                { name: 'B', width: 25, cell: SGPlainCell },
            ];
            var header = builder.withColumns(columns).build().getHeader(0);
            var cols = header.props.children;
            expect(cols.length).toBe(columns.length);
            for (var i = 0; i < columns.length; i++) {
                var selected = i === 0;
                var sortOrderClass = columns[i].sortOrder === SGSortOrder.Ascending && 'asc' || 'desc';
                expect(cols[i].props.className).toBe('sg-col sg-sorted-' + sortOrderClass);
                expect(cols[i].key).toBe('sg-head-' + i);
                expect(cols[i].props.style.flex).toBe("0 1 " + columns[i].width + "px");
                expect(cols[i].props['data-sgselected']).toBe(selected);
                expect(cols[i].props.children[0].props.className).toBe('sg-headerplugin');
                expect(cols[i].props.children[0].props.children).toBeFalsy();
                if (i === 0) {
                    expect(cols[i].props.children[1].props.children[0].props.className).toBe('sg-column-name');
                    expect(cols[i].props.children[1].props.children[0].props.role).toBe('presentation');
                    expect(cols[i].props.children[1].props.children[0].props.children).toBe(columns[i].name);
                    expect(cols[i].props.children[1].props.children[1].props.className).toBe('sg-tooltip');
                }
                else {
                    expect(cols[i].props.children[0].props.className).toBe('sg-headerplugin');
                    expect(cols[i].props.children[0].props.children).toBeFalsy();
                    expect(cols[i].props.children[1].props.children[0].props.className).toBe('sg-column-name');
                    expect(cols[i].props.children[1].props.children[0].props.role).toBe('presentation');
                    expect(cols[i].props.children[1].props.children[0].props.children).toBe(columns[i].name);
                }
            }
        });
        it('should return a child div for each column (with custom class name)', function () {
            var columns = [
                { name: 'A', width: 75, cell: SGPlainCell, className: 'test' },
                { name: 'B', width: 25, cell: SGPlainCell },
            ];
            var header = builder.withColumns(columns).build().getHeader(0);
            var cols = header.props.children;
            expect(cols.length).toBe(columns.length);
            for (var i = 0; i < columns.length; i++) {
                var selected = i === 0;
                var sortOrderClass = columns[i].sortOrder === SGSortOrder.Ascending && 'asc' || 'desc';
                if (i === 0) {
                    expect(cols[i].props.className).toBe('sg-col sg-sorted-' + sortOrderClass + ' test');
                }
                else {
                    expect(cols[i].props.className).toBe('sg-col sg-sorted-' + sortOrderClass);
                }
                expect(cols[i].key).toBe('sg-head-' + i);
                expect(cols[i].props.style.flex).toBe("0 1 " + columns[i].width + "px");
                expect(cols[i].props['data-sgselected']).toBe(selected);
                expect(cols[i].props.children[0].props.className).toBe('sg-headerplugin');
                expect(cols[i].props.children[0].props.children).toBeFalsy();
            }
        });
    });
    describe('getRow', function () {
        it('should return a div for each column', function () {
            var columns = [
                { name: 'A', width: 50, cell: SGPlainCell, showSortBar: true },
                { name: 'B', width: 25, cell: SGPlainCell },
                { name: 'C', width: 25, cell: SGPlainCell, infoText: 'test' },
                { name: 'D', width: 25, cell: SGPlainCell, className: 'test' },
            ];
            var sg = builder.withColumns(columns).build();
            var rowContainer = sg.getRow(new SGDataRow(['test0', 'test1', 'test2', 'test3'], 0), 0, 0);
            expect(rowContainer.props.className).toBe('sg-row');
            expect(rowContainer.key).toBe('sgrow-0');
            expect(rowContainer.props['data-sgselected']).toBe(false);
            expect(rowContainer.props['aria-selected']).toBe(false);
            expect(rowContainer.props['data-sgdepth']).toBe(0);
            expect(rowContainer.props['data-sgchildren']).toBe(null);
            expect(rowContainer.props['data-sgexpanded']).toBe(false);
            expect(rowContainer.props['role']).toBe('row');
            expect(rowContainer.props['aria-rowindex']).toBe(0);
            var row = rowContainer.props.children;
            // Detect, then remove, the depthspacer
            expect(row[0].props.className).toBe('sg-row-depthspacer');
            row.shift();
            // With the depthspacer removed, row cols should match our SGColumns
            expect(row.length).toBe(columns.length);
            for (var i = 1; i < columns.length; i++) {
                expect(row[i].props.style.flex).toBe("0 1 " + columns[i].width + "px");
                if (columns[i].showSortBar && !columns[i].infoText) {
                    expect(row[i].props.className).toBe('sg-col sg-barbacked');
                    expect(row[i].props.children.length).toBe(2);
                    expect(row[i].props.children[0].props.className).toBe('sg-bb-colvm');
                    expect(row[i].props.children[0].props.children.props.children).toBe('test' + i);
                    expect(row[i].props.children[1].props.className).toBe('sg-bb-bar');
                }
                else if (columns[i].className) {
                    expect(row[i].props.className).toBe('sg-col test');
                    expect(row[i].props.children.props.children).toBe('test' + i);
                }
                else {
                    expect(row[i].props.className).toBe('sg-col');
                    expect(row[i].props.children.props.children).toBe('test' + i);
                }
            }
            var onClick = rowContainer.props.onClick;
            onClick();
            expect(builder.props.onSelect).toHaveBeenCalledTimes(1);
        });
        it('should disable if disabled', function () {
            var columns = [
                { name: 'A', width: 50, cell: SGPlainCell, showSortBar: true },
                { name: 'B', width: 25, cell: SGPlainCell },
                { name: 'C', width: 25, cell: SGPlainCell, infoText: 'test' },
                { name: 'D', width: 25, cell: SGPlainCell, className: 'test' },
            ];
            var sg = builder.withColumns(columns).build();
            var rowContainer = sg.getRow(new SGDataRow(['test0', 'test1', 'test2', 'test3'], 0, false, false, null, true), 0, 0);
            expect(rowContainer.props.className).toBe('sg-row');
            expect(rowContainer.key).toBe('sgrow-0');
            expect(rowContainer.props['data-sgselected']).toBe(false);
            expect(rowContainer.props['data-sgdepth']).toBe(0);
            expect(rowContainer.props['data-sgchildren']).toBe(null);
            expect(rowContainer.props['data-sgexpanded']).toBe(false);
            expect(rowContainer.props['data-sgdisabled']).toBe(true);
            var row = rowContainer.props.children;
            // Detect, then remove, the depthspacer
            expect(row[0].props.className).toBe('sg-row-depthspacer');
            row.shift();
            // With the depthspacer removed, row cols should match our SGColumns
            expect(row.length).toBe(columns.length);
            for (var i = 1; i < columns.length; i++) {
                expect(row[i].props.style.flex).toBe("0 1 " + columns[i].width + "px");
                if (columns[i].showSortBar && !columns[i].infoText) {
                    expect(row[i].props.className).toBe('sg-col sg-barbacked');
                    expect(row[i].props.children.length).toBe(2);
                    expect(row[i].props.children[0].props.className).toBe('sg-bb-colvm');
                    expect(row[i].props.children[0].props.children.props.children).toBe('test' + i);
                    expect(row[i].props.children[1].props.className).toBe('sg-bb-bar');
                }
                else if (columns[i].className) {
                    expect(row[i].props.className).toBe('sg-col test');
                    expect(row[i].props.children.props.children).toBe('test' + i);
                }
                else {
                    expect(row[i].props.className).toBe('sg-col');
                    expect(row[i].props.children.props.children).toBe('test' + i);
                }
            }
            var onClick = rowContainer.props.onClick;
            onClick();
            expect(builder.props.onSelect).toHaveBeenCalledTimes(0);
        });
        it('hscroll: should add proper ref for resizing', function () {
            var columns = [
                { name: 'A', width: 50, cell: SGPlainCell, showHorizontalScrollbar: true }
            ];
            var sg = builder.withColumns(columns).build();
            var rowContainer = sg.getRow(new SGDataRow(['test0'], 0), 0, 0);
            var row = rowContainer.props.children;
            var elm = {
                children: [{
                        scrollWidth: 100
                    }],
                style: {
                    marginLeft: 0
                },
                parentElement: {
                    querySelectorAll: function () { return []; }
                }
            };
            var body = sg['_horizontalScrollbarBodies'][0] = {
                style: {
                    width: 0
                },
                parentElement: {
                    style: {
                        pointerEvents: 'none'
                    }
                }
            };
            var minWidths = sg['_minColWidths'];
            minWidths[0] = 0;
            expect(row[1].ref).toBeTruthy();
            row[1].ref(elm);
            expect(body.style.width).toBe('110px');
            expect(body.parentElement.style.pointerEvents).toBe('all');
            expect(minWidths[0]).toBe(110);
        });
        it('hscroll: should not add ref when unnecessary', function () {
            var columns = [
                { name: 'A', width: 50, cell: SGPlainCell }
            ];
            var sg = builder.withColumns(columns).build();
            var rowContainer = sg.getRow(new SGDataRow(['test0'], 0), 0, 0);
            var row = rowContainer.props.children;
            expect(row[1].ref).toBeFalsy();
        });
    });
    describe('flattenRows', function () {
        it('should call traverse for each row', function () {
            var rows = [
                new SGDataRow(['test11', 'test12'], 0),
                new SGDataRow(['test21', 'test22'], 1),
            ];
            var sg = builder.build();
            spyOn(rows[0], 'traverse').and.callThrough();
            spyOn(rows[1], 'traverse').and.callThrough();
            var flattened = sg.flattenRows(rows, function (row) { return row.value; });
            expect(rows[0].traverse).toHaveBeenCalledTimes(1);
            expect(rows[1].traverse).toHaveBeenCalledTimes(1);
            expect(flattened.length).toBe(2);
            expect(flattened[0]).toBe(0);
            expect(flattened[1]).toBe(1);
        });
        it('should perform sorting at the root (ascending)', function () {
            var columns = [
                { name: 'A', width: 100, cell: SGPlainCell, sortOrder: 0 },
            ];
            var rows = [
                new SGDataRow([3], 0),
                new SGDataRow([2], 1),
            ];
            var sg = builder.withColumns(columns).build();
            sg.props.sortColumn = 0;
            var flattened = sg.flattenRows(rows, function (row) { return row.value; });
            expect(flattened.length).toBe(2);
            expect(flattened[0]).toBe(1);
            expect(flattened[1]).toBe(0);
        });
        it('should perform sorting at the root (descending)', function () {
            var columns = [
                { name: 'A', width: 100, cell: SGPlainCell, sortOrder: 1 },
            ];
            var rows = [
                new SGDataRow([2], 1),
                new SGDataRow([3], 0),
            ];
            var sg = builder.withColumns(columns).build();
            sg.props.sortColumn = 0;
            var flattened = sg.flattenRows(rows, function (row) { return row.value; });
            expect(flattened.length).toBe(2);
            expect(flattened[0]).toBe(0);
            expect(flattened[1]).toBe(1);
        });
    });
    describe('getRows', function () {
        it('should return an array filled with each column', function () {
            var columns = [
                { name: 'A', width: 75, cell: SGPlainCell },
                { name: 'B', width: 25, cell: SGPlainCell },
            ];
            var data = [
                new SGDataRow(['test11', 'test12'], 0),
                new SGDataRow(['test21', 'test22'], 1),
            ];
            var sg = builder.withColumns(columns).withData(data).build();
            spyOn(sg, 'getRow').and.returnValue('testGetRow');
            var rows = sg.getRows();
            expect(rows.length).toBe(data.length);
            for (var i = 0; i < rows.length; i++) {
                expect(rows[i].row).toBe(data[i]);
                expect(rows[i].depth).toBe(0);
            }
        });
        it('should return an array filled with each column plus the fixedRow if provided', function () {
            var columns = [
                { name: 'A', width: 75, cell: SGPlainCell },
                { name: 'B', width: 25, cell: SGPlainCell },
            ];
            var data = [
                new SGDataRow(['test21', 'test22'], 1),
                new SGDataRow(['test31', 'test32'], 2),
            ];
            var fixedRow = new SGDataRow(['test11', 'test12'], 0);
            var sg = builder.withColumns(columns).withData(data).withFixedRow(fixedRow).build();
            spyOn(sg, 'getRow').and.returnValue('testGetRow');
            var rows = sg.getRows();
            expect(rows.length).toBe(data.length + 1);
            for (var i = 0; i < rows.length; i++) {
                expect(rows[i].depth).toBe(0);
                expect(rows[i].row.value).toBe(i);
            }
        });
    });
    describe('render', function () {
        it('should render a div filled with the results of getHeader and getRows by default', function () {
            var sg = builder.build();
            var row = { row: 'a', depth: 0 };
            spyOn(sg, 'getHeader').and.returnValue('header');
            spyOn(sg, 'getRows').and.returnValue([row]);
            spyOn(sg, 'getRow').and.returnValue('getRow');
            var grid = sg.render();
            expect(grid.props.className).toBe('selectable-grid');
            expect(grid.props.children.length).toBe(2);
            expect(grid.props.children[0]).toBe('header');
            expect(grid.props.children[1].props.className).toBe('sg-body');
            expect(grid.props.children[1].props.children[0].type).toBe(AutoSizer);
            var list = grid.props.children[1].props.children[0].props.children({ width: 1, height: 1 });
            expect(list.type).toBe(List);
            expect(list.props.height).toBe(1);
            expect(list.props.width).toBe(1);
            expect(list.props.style.outline).toBe('none');
            expect(list.props.rowCount).toBe(1);
            expect(list.props.rowHeight).toBe(35);
            expect(list.props.overscanRowCount).toBe(Math.ceil(1 / 35));
            expect(list.props.rowRenderer({ index: 0 }).props.children).toBe('getRow');
            expect(sg.getHeader).toHaveBeenCalledTimes(1);
            expect(sg.getRows).toHaveBeenCalledTimes(1);
            expect(sg.getRow).toHaveBeenCalledTimes(1);
            expect(sg.getRow).toHaveBeenCalledWith(row.row, 0, row.depth);
        });
        it('should trigger onScrollToEnd if scrolled to end', function () {
            var c = {
                onScrollToEnd: function () { }
            };
            spyOn(c, 'onScrollToEnd');
            var sg = builder.withOnScroll(c.onScrollToEnd).build();
            var grid = sg.render();
            var list = grid.props.children[1].props.children[0].props.children({ width: 1, height: 1 });
            expect(list.props.onScroll).toBeTruthy();
            list.props.onScroll({
                clientHeight: 1000,
                scrollTop: 4000,
                scrollHeight: 5000
            });
            expect(c.onScrollToEnd).toHaveBeenCalledTimes(1);
        });
        it('should not trigger onScrollToEnd if scrolled but not to end', function () {
            var c = {
                onScrollToEnd: function () { }
            };
            spyOn(c, 'onScrollToEnd');
            var sg = builder.withOnScroll(c.onScrollToEnd).build();
            var grid = sg.render();
            var list = grid.props.children[1].props.children[0].props.children({ width: 1, height: 1 });
            expect(list.props.onScroll).toBeTruthy();
            list.props.onScroll({
                clientHeight: 500,
                scrollTop: 4000,
                scrollHeight: 5000
            });
            expect(c.onScrollToEnd).not.toHaveBeenCalled();
        });
        it('should not trigger anything if scrolled but onScrollToEnd is undefined', function () {
            var sg = builder.build();
            var grid = sg.render();
            var list = grid.props.children[1].props.children[0].props.children({ width: 1, height: 1 });
            expect(list.props.onScroll).toBeTruthy();
            list.props.onScroll({
                clientHeight: 500,
                scrollTop: 4000,
                scrollHeight: 5000
            });
        });
        it('should render a div filled without the results of getHeader when header is disabled', function () {
            var sg = builder.withHeaderHidden(true).build();
            var row = { row: 'a', depth: 0 };
            spyOn(sg, 'getHeader').and.returnValue('header');
            spyOn(sg, 'getRows').and.returnValue([row]);
            spyOn(sg, 'getRow').and.returnValue('getRow');
            var grid = sg.render();
            expect(grid.props.className).toBe('selectable-grid');
            expect(grid.props.children.length).toBe(2);
            expect(grid.props.children[0]).toBe(null);
            expect(grid.props.children[1].props.className).toBe('sg-body sg-noheader');
            expect(grid.props.children[1].props.children[0].type).toBe(AutoSizer);
            expect(sg.getHeader).toHaveBeenCalledTimes(0);
            expect(sg.getRows).toHaveBeenCalledTimes(1);
        });
        it('should not render the horizontal scrollbar area when there are no cols with horizontal scrollbars', function () {
            var sg = builder.withHeaderHidden(true).withColumns([
                { cell: SGPlainCell, name: 'col1', width: 0 },
                { cell: SGPlainCell, name: 'col2', width: 10 },
            ]).build();
            var grid = sg.render();
            var sgBody = grid.props.children[1];
            var horizScroll = sgBody.props.children[1];
            expect(horizScroll).toBeFalsy();
        });
        it('should render the horizontal scrollbar area when there are cols with horizontal scrollbars', function () {
            var sg = builder.withHeaderHidden(true).withColumns([
                { cell: SGPlainCell, name: 'col1', width: 0, showHorizontalScrollbar: true },
                { cell: SGPlainCell, name: 'col2', width: 10 },
            ]).build();
            sg.state = { scrollbarWidth: 50, gridBodyHeight: 50 };
            var row = { row: 'a', depth: 0 };
            spyOn(sg, 'getRows').and.returnValue([row, row]);
            var grid = sg.render();
            var sgBody = grid.props.children[1];
            var horizScroll = sgBody.props.children[1];
            expect(horizScroll.props.className).toBe('sg-hscroll-contain');
            expect(horizScroll.props.style.height).toBe('50px');
            expect(horizScroll.props.style.paddingRight).toBe('50px');
            var entries = horizScroll.props.children;
            expect(entries.length).toBe(2);
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];
                expect(entry.key).toBe("sg-hscroll-" + i);
                expect(entry.props.className).toBe('sg-hscroll');
                expect(entry.props.style.flex).toBe(sg.props.columns[i].width === 0 ? '1 1 0px' : "0 1 " + sg.props.columns[i].width + "px");
                expect(entry.props.onScroll).toBeDefined();
                expect(entry.props.children.props.className).toBe('sg-hscroll-body');
            }
            // Also verify we override the row height accordingly
            var list = grid.props.children[1].props.children[0].props.children({ width: 1, height: 1 });
            expect(list.props.rowHeight).toBe(60);
        });
        it('hscroll: should add correct ref to resize scroll body', function () {
            var sg = builder.withHeaderHidden(true).withColumns([
                { cell: SGPlainCell, name: 'col1', width: 0, showHorizontalScrollbar: true }
            ]).build();
            sg['_horizontalScrollAmounts'][0] = 150;
            var grid = sg.render();
            var sgBody = grid.props.children[1];
            var horizScroll = sgBody.props.children[1];
            var entry = horizScroll.props.children[0];
            var body = entry.props.children;
            var childElm = {
                parentElement: {
                    scrollLeft: 0
                }
            };
            body.ref(childElm);
            expect(childElm.parentElement.scrollLeft).toBe(150);
        });
        it('should correctly determine if the scrollbar is necessary', function () {
            var sg = builder.build();
            var row = { row: 'a', depth: 0 };
            sg.state = { scrollbarWidth: 50, gridBodyHeight: 50 };
            spyOn(sg, 'getRows').and.returnValue([row, row]);
            spyOn(sg, 'getHeader').and.returnValue('header');
            sg.render();
            expect(sg.getHeader).toHaveBeenCalledWith(sg.state.scrollbarWidth);
        });
        it('should correctly determine if the scrollbar is not necessary', function () {
            var sg = builder.build();
            var row = { row: 'a', depth: 0 };
            sg.state = { scrollbarWidth: 50, gridBodyHeight: 50 };
            spyOn(sg, 'getRows').and.returnValue([row]);
            spyOn(sg, 'getHeader').and.returnValue('header');
            sg.render();
            expect(sg.getHeader).toHaveBeenCalledWith(0);
        });
        it('should correctly scroll to a row if enabled', function () {
            var sg = builder.withScrollToRowWithValue('b').build();
            sg.props.data = [new SGDataRow([], 'a'), new SGDataRow([], 'b'), , new SGDataRow([], 'c')];
            var grid = sg.render();
            var list = grid.props.children[1].props.children[0].props.children({ width: 1, height: 1 });
            expect(list.props.scrollToIndex).toBe(1);
        });
    });
});
//# sourceMappingURL=SelectableGrid.spec.js.map