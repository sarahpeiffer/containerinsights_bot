export var SGSortOrder;
(function (SGSortOrder) {
    SGSortOrder[SGSortOrder["Ascending"] = 0] = "Ascending";
    SGSortOrder[SGSortOrder["Descending"] = 1] = "Descending";
})(SGSortOrder || (SGSortOrder = {}));
var SGDataRow = /** @class */ (function () {
    function SGDataRow(columnData, value, selected, expanded, children, disabled, className) {
        if (selected === void 0) { selected = false; }
        if (expanded === void 0) { expanded = false; }
        if (children === void 0) { children = null; }
        if (disabled === void 0) { disabled = false; }
        if (className === void 0) { className = null; }
        this.sortedColumn = null;
        this.columnData = columnData;
        this.value = value;
        this.children = children;
        this.selected = selected;
        this.expanded = expanded;
        this.disabled = disabled;
        this.className = className;
    }
    SGDataRow.prototype.traverse = function (fn, onlyExpandedChildren, sortColumn, sortFn, depth) {
        if (onlyExpandedChildren === void 0) { onlyExpandedChildren = true; }
        if (sortColumn === void 0) { sortColumn = null; }
        if (sortFn === void 0) { sortFn = null; }
        if (depth === void 0) { depth = 0; }
        // Call fn for ourselves
        fn(this, depth);
        // Recurse into children
        if (!onlyExpandedChildren || (this.children && this.expanded)) {
            // Sort children first (if we haven't already sorted)
            if (sortColumn !== null && sortColumn !== this.sortedColumn && sortFn) {
                this.children = this.children.sort(function (a, b) { return sortFn(a.columnData[sortColumn], b.columnData[sortColumn]); });
                this.sortedColumn = sortColumn;
            }
            this.children.forEach(function (child) {
                child.traverse(fn, onlyExpandedChildren, sortColumn, sortFn, depth + 1);
            });
        }
    };
    return SGDataRow;
}());
export { SGDataRow };
//# sourceMappingURL=SelectableGridData.js.map