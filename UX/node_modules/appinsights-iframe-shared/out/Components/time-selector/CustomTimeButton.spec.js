import { CustomTimeButton } from './CustomTimeButton';
import { DatePicker } from '../DatePicker';
import { TimeContext } from '../../TimeContext';
import { TestUtilities } from '../../TestUtilities';
var CustomTimeButtonBuilder = /** @class */ (function () {
    function CustomTimeButtonBuilder() {
        this.props = {
            onSelected: function (timeContext) { return null; },
            value: new TimeContext(0),
            isSelected: false,
            strings: {
                customTimeRangeTitle: 'custom',
                customTimeRangeStart: 'start',
                customTimeRangeEnd: 'end',
                validateStartTimeBeforeEndTime: 'start time must be before end time',
                validateStartTimeBeforeNow: 'start time must be in the past',
                billingDataTimeRangeValidationString: 'time range must be within {0} days'
            },
            shouldFocus: false
        };
        spyOn(this.props, 'onSelected');
    }
    CustomTimeButtonBuilder.prototype.withValue = function (value) {
        this.props.value = value;
        return this;
    };
    CustomTimeButtonBuilder.prototype.selected = function () {
        this.props.isSelected = true;
        return this;
    };
    CustomTimeButtonBuilder.prototype.build = function () {
        var timeButton = new CustomTimeButton(this.props);
        spyOn(timeButton, 'setState').and.callFake(function (statefn, cb) {
            timeButton.state = TestUtilities.SetState(timeButton.state, timeButton.props, statefn);
            return cb ? cb() : null;
        });
        return timeButton;
    };
    return CustomTimeButtonBuilder;
}());
describe('CustomTimeButton', function () {
    var builder;
    beforeEach(function () {
        builder = new CustomTimeButtonBuilder();
    });
    describe('onSelected', function () {
        it('should call props.onSelected with the return value of exportDates', function () {
            var component = builder.build();
            component.state.startDate = new Date(new Date().getTime() - 10000);
            spyOn(component, 'exportDates').and.returnValue(1234);
            component.onSelected();
            expect(component.exportDates).toHaveBeenCalledTimes(1);
            expect(component.props.onSelected).toHaveBeenCalledWith(1234, true);
        });
    });
    describe('importTimeContext', function () {
        it('should return a current-time end and start date for null timeContext', function () {
            var component = builder.build();
            var ret = component.importTimeContext(null);
            expect(ret.endDate).toBeTruthy();
            expect(ret.startDate).toBeTruthy();
        });
        it('should return a correctly calculated startDate from endTime and duration', function () {
            var component = builder.build();
            var startDate = new Date('1/1/2004');
            var endDate = new Date('1/2/2005');
            var duration = endDate.getTime() - startDate.getTime();
            var ret = component.importTimeContext(new TimeContext(duration, endDate));
            expect(ret.endDate.getTime()).toBe(endDate.getTime());
            expect(ret.startDate.getTime()).toBe(startDate.getTime());
        });
        it('should assume endTime is the current date if only given duration', function () {
            var component = builder.build();
            var startDate = new Date('1/1/2004');
            var endDate = new Date();
            var duration = endDate.getTime() - startDate.getTime();
            var ret = component.importTimeContext(new TimeContext(duration));
            expect(Math.abs(ret.endDate.getTime() - endDate.getTime())).toBeLessThan(10);
            expect(Math.abs(ret.startDate.getTime() - startDate.getTime())).toBeLessThan(10);
        });
    });
    describe('exportDates', function () {
        it('should return a correctly calculated TimeContext from state', function () {
            var component = builder.build();
            component.state.startDate = new Date('4/1/2004');
            component.state.endDate = new Date('4/1/2020');
            var ret = component.exportDates();
            expect(ret.durationMs).toBe(component.state.endDate.getTime() - component.state.startDate.getTime());
            expect(ret.endTime.getTime()).toBe(component.state.endDate.getTime());
        });
    });
    describe('onStartChanged', function () {
        it('should update state with the new startDate', function () {
            var component = builder.build();
            component.onStartChanged(new Date('3/3/3033'));
            expect(component.state.startDate.getTime()).toBe(new Date('3/3/3033').getTime());
        });
    });
    describe('onEndChanged', function () {
        it('should update state with the new endDate', function () {
            var component = builder.build();
            component.onEndChanged(new Date('3/3/3033'));
            expect(component.state.endDate.getTime()).toBe(new Date('3/3/3033').getTime());
        });
    });
    describe('startTimeValidator', function () {
        it('should fail if startDate is more than 90 days ago', function () {
            var component = builder.build();
            component.state.startDate = new Date(new Date().getTime() - 91 * 24 * 60 * 60 * 1000);
            component.state.endDate = new Date();
            var validation = component.startTimeValidator();
            expect(validation.isValid).toBeFalsy();
        });
        it('should fail if startDate is sooner than endDate', function () {
            var component = builder.build();
            component.state.startDate = new Date(new Date().getTime() - 1000);
            component.state.endDate = new Date(new Date().getTime() - 2000);
            var validation = component.startTimeValidator();
            expect(validation.isValid).toBeFalsy();
        });
        it('should fail if startDate is equal to endDate', function () {
            var component = builder.build();
            component.state.startDate = new Date(2000000);
            component.state.endDate = new Date(2000000);
            var validation = component.startTimeValidator();
            expect(validation.isValid).toBeFalsy();
        });
        it('should fail if startDate is in the future', function () {
            var component = builder.build();
            component.state.startDate = new Date(new Date().getTime() + 1000);
            component.state.endDate = new Date(new Date().getTime() + 2000);
            var validation = component.startTimeValidator();
            expect(validation.isValid).toBeFalsy();
        });
        it('should not fail if startDate is in the past but endDate is in the future', function () {
            var component = builder.build();
            component.state.startDate = new Date(new Date().getTime() - 1000);
            component.state.endDate = new Date(new Date().getTime() + 2000);
            var validation = component.startTimeValidator();
            expect(validation.isValid).toBeTruthy();
        });
        it('should not fail if startDate and endDate are less than 90 days ago and startDate is earlier', function () {
            var component = builder.build();
            component.state.startDate = new Date(new Date().getTime() - 3000);
            component.state.endDate = new Date(new Date().getTime() - 1000);
            var validation = component.startTimeValidator();
            expect(validation.isValid).toBeTruthy();
        });
    });
    describe('Render', function () {
        it('should have the section title as the first button element', function () {
            var component = builder.build();
            var content = component.render();
            var button = content.props.children;
            expect(button.props.children[0].type).toBe('div');
            expect(button.props.children[0].props.children).toBe(component.props.strings['customTimeRangeTitle']);
        });
        it('should have selected state if selected', function () {
            var component = builder.selected().build();
            var content = component.render();
            expect(content.props.className.indexOf('selected')).toBeGreaterThanOrEqual(0);
        });
        it('should generate two DatePicker components: start and end', function () {
            var component = builder.build();
            var content = component.render();
            var start = TestUtilities.FindElements(content, function (element) {
                return element.type === DatePicker &&
                    element.props.title === component.props.strings['customTimeRangeStart'] &&
                    element.props.selected === component.state.startDate;
            });
            var end = TestUtilities.FindElements(content, function (element) {
                return element.type === DatePicker &&
                    element.props.title === component.props.strings['customTimeRangeEnd'] &&
                    element.props.selected === component.state.endDate;
            });
            expect(start.length).toBe(1);
            expect(end.length).toBe(1);
        });
        it('should add startTimeValidator to the start field', function () {
            var component = builder.build();
            spyOn(component, 'startTimeValidator').and.returnValue('startTimeValidatorValue');
            var content = component.render();
            var start = TestUtilities.FindElements(content, function (element) {
                return element.type === DatePicker &&
                    element.props.title === component.props.strings['customTimeRangeStart'] &&
                    element.props.selected === component.state.startDate;
            });
            expect(start[0].props.validation).toBe('startTimeValidatorValue');
        });
        it('should add isValid:true to the end field validation', function () {
            var component = builder.build();
            var content = component.render();
            var end = TestUtilities.FindElements(content, function (element) {
                return element.type === DatePicker &&
                    element.props.title === component.props.strings['customTimeRangeEnd'] &&
                    element.props.selected === component.state.endDate;
            });
            expect(end[0].props.validation.isValid).toBeTruthy();
        });
    });
});
//# sourceMappingURL=CustomTimeButton.spec.js.map