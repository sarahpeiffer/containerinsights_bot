import * as tslib_1 from "tslib";
import { HttpDebouncer } from './HttpDebouncer';
import { Utils, HeaderNames, StatusCodes } from '../..';
import Axios from 'axios';
/**
 * Debouncer for Draft. Calls /$batch API on debounced request batches.
 */
var ArmDebouncer = /** @class */ (function (_super) {
    tslib_1.__extends(ArmDebouncer, _super);
    function ArmDebouncer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ArmDebouncer.prototype.getBatchScope = function (request) {
        var splitUri = Utils.GetUriSchemeAndAuthority(request.uri);
        var authority = splitUri.scheme + splitUri.authority;
        return {
            scope: authority,
            authority: authority
        };
    };
    ArmDebouncer.prototype.executeBatch = function (data, uri) {
        var _this = this;
        if (data.length) {
            var token = '';
            if (data[0].headers) {
                token = data[0].headers[HeaderNames.Authorization];
            }
            var endpoint = uri + '/batch?api-version=2015-11-01';
            var batchID_1 = Utils.RandomGuid();
            return Axios.post(endpoint, {
                requests: data.map(function (request) { return _this.getBatchRequestPayload(request); })
            }, {
                headers: {
                    Authorization: token
                }
            }).then(function (response) {
                (response.data.responses || []).forEach(function (armResponse, i) {
                    // Draft batch API doesn't guarantee same order of responses, so we need to find the right response.
                    var matchingRequest = data[i];
                    var actualResponse = {
                        data: armResponse.content,
                        headers: armResponse.headers,
                        status: armResponse.httpStatusCode,
                        statusText: '',
                        config: Object.assign({}, response.config, {
                            url: matchingRequest.uri,
                            method: matchingRequest.method,
                            headers: armResponse.headers ?
                                Object.assign(armResponse.headers, { BatchID: batchID_1, BatchURL: response.config.url }) : {}
                        }),
                        request: response.request
                    };
                    if (matchingRequest) {
                        if (actualResponse.status >= StatusCodes.BadRequest) {
                            matchingRequest.reject({ response: actualResponse });
                        }
                        else {
                            if (typeof actualResponse.data === 'string') {
                                actualResponse.data = JSON.parse(actualResponse.data);
                            }
                            if (!actualResponse.headers) {
                                actualResponse.headers = {};
                            }
                            matchingRequest.resolve(actualResponse);
                        }
                    }
                });
            }).catch(function (error) {
                data.forEach(function (batchRequest) {
                    batchRequest.reject(error);
                });
            });
        }
    };
    ArmDebouncer.prototype.getBatchRequestPayload = function (request) {
        var splitUri = Utils.GetUriSchemeAndAuthority(request.uri);
        var uri = request.uri.replace(splitUri.scheme + splitUri.authority, '');
        var payload = {
            url: uri,
            content: request.params,
            requestHeaderDetails: {
                commandName: (request.headers || {}).commandName
            },
            httpMethod: request.method
        };
        if (payload.requestHeaderDetails) {
            delete payload.requestHeaderDetails[HeaderNames.Authorization];
        }
        return payload;
    };
    return ArmDebouncer;
}(HttpDebouncer));
export { ArmDebouncer };
//# sourceMappingURL=ArmDebouncer.js.map