import { DataSyncManager } from './DataSyncManager';
describe('DataSyncManager', function () {
    var syncManager;
    var telemetryService;
    beforeEach(function () {
        telemetryService = {
            LogEvent: function () { },
            LogException: function () { },
            Register: function () { return null; }
        };
        syncManager = new DataSyncManager(telemetryService);
    });
    describe('IssueQuery', function () {
        it('should not call success callback if query out of date', function () {
            var resolve;
            var pr1 = new Promise(function (r) { resolve = r; });
            var pr2 = new Promise(function (r) { });
            var callback = {
                success: function (result) { },
                error: function (e) { },
                preQuery: function (syncId) { }
            };
            spyOn(callback, 'success');
            spyOn(callback, 'error');
            spyOn(callback, 'preQuery');
            var promise = syncManager.IssueQuery('query', pr1, callback.success, callback.error, callback.preQuery);
            syncManager.IssueQuery('query', pr2, callback.success, callback.error, callback.preQuery);
            expect(callback.preQuery).toHaveBeenCalledTimes(2);
            expect(callback.preQuery).toHaveBeenCalledWith(1);
            expect(callback.preQuery).toHaveBeenCalledWith(2);
            resolve({});
            return promise.then(function () {
                expect(callback.success).not.toHaveBeenCalled();
                expect(callback.error).not.toHaveBeenCalled();
            }).catch(function (e) {
                fail(JSON.stringify(e));
            });
        });
        it('should call success callback if query is current', function () {
            var resolve;
            var pr1 = new Promise(function (r) { });
            var pr2 = new Promise(function (r) { resolve = r; });
            var callback = {
                success: function (result) { },
                error: function (e) { }
            };
            spyOn(callback, 'success');
            spyOn(callback, 'error');
            syncManager.IssueQuery('query', pr1, callback.success, callback.error);
            var data = {};
            resolve(data);
            return syncManager.IssueQuery('query', pr2, callback.success, callback.error).then(function () {
                expect(callback.success).toHaveBeenCalledTimes(1);
                expect(callback.success).toHaveBeenCalledWith(data, 2);
                expect(callback.error).not.toHaveBeenCalled();
            }).catch(function (e) {
                fail(JSON.stringify(e));
            });
        });
        it('should call failure callback if query fails', function () {
            var reject;
            var pr1 = new Promise(function (r) { });
            var pr2 = new Promise(function (a, b) { reject = b; });
            var callback = {
                success: function (result) { },
                error: function (e) { }
            };
            spyOn(callback, 'success');
            spyOn(callback, 'error');
            syncManager.IssueQuery('query', pr1, callback.success, callback.error);
            var data = {};
            reject(data);
            return syncManager.IssueQuery('query', pr2, callback.success, callback.error).then(function () {
                fail('expected promise to reject');
            }).catch(function (e) {
                expect(callback.error).toHaveBeenCalledTimes(1);
                expect(callback.error).toHaveBeenCalledWith(data, 2);
                expect(callback.success).not.toHaveBeenCalled();
            });
        });
        it('should log error if query fails', function () {
            spyOn(telemetryService, 'LogException');
            var reject;
            var pr1 = new Promise(function (r) { });
            var pr2 = new Promise(function (a, b) { reject = b; });
            var callback = {
                success: function (result) { },
                error: function (e) { }
            };
            syncManager.IssueQuery('query', pr1, callback.success, callback.error);
            var data = {
                myerr: 'yay',
                message: 'my mesg'
            };
            reject(data);
            return syncManager.IssueQuery('query', pr2, callback.success, callback.error).then(function () {
                fail('expected promise to reject');
            }).catch(function (e) {
                expect(telemetryService.LogException).toHaveBeenCalledTimes(1);
                expect(telemetryService.LogException).toHaveBeenCalledWith(data);
            });
        });
        it('should not call failure callback if query out of date', function () {
            var reject;
            var pr1 = new Promise(function (a, b) { reject = b; });
            var pr2 = new Promise(function (r) { });
            var callback = {
                success: function (result) { },
                error: function (e) { }
            };
            spyOn(callback, 'success');
            spyOn(callback, 'error');
            var promise = syncManager.IssueQuery('query', pr1, callback.success, callback.error);
            syncManager.IssueQuery('query', pr2, callback.success, callback.error);
            reject({});
            return promise.then(function () {
                fail('expected promise to reject');
            }).catch(function (e) {
                expect(callback.success).not.toHaveBeenCalled();
                expect(callback.error).not.toHaveBeenCalled();
            });
        });
    });
});
//# sourceMappingURL=DataSyncManager.spec.js.map