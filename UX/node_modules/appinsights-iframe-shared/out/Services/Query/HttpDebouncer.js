import { Debouncer } from './Debouncer';
/**
 * Abstract class for creating a debouncers. Follows template-method pattern, allowing the specific debouncer to define
 * how to execute batches on its particular service.
 */
var HttpDebouncer = /** @class */ (function () {
    function HttpDebouncer(interval, maxBatchSize) {
        if (interval === void 0) { interval = 100; }
        if (maxBatchSize === void 0) { maxBatchSize = 20; }
        this._maxBatchSize = maxBatchSize;
        this._interval = interval;
        this._debouncers = {};
    }
    /**
     * Execute an HTTP request with debouncing, allowing the request to be batched if it was executed in close time proximity to other
     * batchable requests. Returns a promise with an AxiosResponse contract so it is interchangeable with a normal HTTP request.
     * @param request
     */
    HttpDebouncer.prototype.batch = function (request) {
        var scope = this.getBatchScope(request);
        var debouncer = this.getDebouncer(scope.scope, scope.authority);
        return new Promise(function (resolve, reject) {
            var deferredPayload = Object.assign(request, { resolve: resolve, reject: reject });
            debouncer.execute(deferredPayload);
        });
    };
    HttpDebouncer.prototype.getDebouncer = function (scope, authority) {
        var _this = this;
        var debouncer = this._debouncers[scope];
        if (!debouncer) {
            debouncer = this._debouncers[scope] = new Debouncer(this._maxBatchSize, function (data) {
                _this.executeBatch(data, authority);
                return [];
            }, this._interval);
        }
        return debouncer;
    };
    return HttpDebouncer;
}());
export { HttpDebouncer };
//# sourceMappingURL=HttpDebouncer.js.map