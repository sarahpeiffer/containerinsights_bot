import { TimeSeriesImpl, TimeSeriesCache } from './TimeSeriesCache';
describe('TimeSeries', function () {
    var startTime = new Date(2017, 5, 12, 15, 55, 0);
    var timeSeries;
    beforeEach(function () {
        timeSeries = new TimeSeriesImpl(60 * 1000);
    });
    describe('Get', function () {
        it('should get null range from empty time series', function () {
            var result = timeSeries.Get(startTime, new Date(startTime.getTime() + 1 * 60 * 1000));
            expect(result).toBeNull();
        });
        it('should get a range from time series - inclusive boundaries', function () {
            var endTime = new Date(startTime.getTime() + 60 * 60 * 1000);
            timeSeries['_chunks'] = [{
                    start: startTime,
                    end: endTime,
                    data: []
                }];
            var result = timeSeries.Get(startTime, endTime);
            expect(result).not.toBeNull();
        });
        it('should get a range from time series - subset', function () {
            var endTime = new Date(startTime.getTime() + 60 * 60 * 1000);
            timeSeries['_chunks'] = [{
                    start: startTime,
                    end: endTime,
                    data: []
                }];
            var result = timeSeries.Get(new Date(startTime.getTime() + 1 * 60 * 1000), new Date(endTime.getTime() - 1 * 60 * 1000));
            expect(result).not.toBeNull();
        });
        it('should not get a range if start is out of boundary', function () {
            var endTime = new Date(startTime.getTime() + 60 * 60 * 1000);
            timeSeries['_chunks'] = [{
                    start: startTime,
                    end: endTime,
                    data: []
                }];
            var result = timeSeries.Get(new Date(startTime.getTime() - 1 * 60 * 1000), endTime);
            expect(result).toBeNull();
        });
        it('should not get a range if end is out of boundary', function () {
            var endTime = new Date(startTime.getTime() + 60 * 60 * 1000);
            timeSeries['_chunks'] = [{
                    start: startTime,
                    end: endTime,
                    data: []
                }];
            var result = timeSeries.Get(startTime, new Date(endTime.getTime() + 1 * 60 * 1000));
            expect(result).toBeNull();
        });
        it('should get only expected dates', function () {
            var startTimePlus1 = new Date(startTime.getTime() + 1 * 60 * 1000);
            var startTimePlus2 = new Date(startTime.getTime() + 2 * 60 * 1000);
            var middleTime = new Date(startTime.getTime() + 30 * 60 * 1000);
            var endTime = new Date(startTime.getTime() + 60 * 60 * 1000);
            var endTimeMinus1 = new Date(endTime.getTime() - 1 * 60 * 1000);
            var endTimeMinus2 = new Date(endTime.getTime() - 2 * 60 * 1000);
            timeSeries['_chunks'] = [{
                    start: startTime,
                    end: endTime,
                    data: [
                        [startTime, 1], [startTimePlus1, 2], [startTimePlus2, 3],
                        [middleTime, 31],
                        [endTimeMinus2, 57], [endTimeMinus1, 58], [endTime, 59]
                    ]
                }];
            var result = timeSeries.Get(startTimePlus1, endTimeMinus1);
            expect(result).not.toBeNull();
            expect(result.length).toEqual(5);
            expect(result[0][0]).toEqual(startTimePlus1, 'result[0][0]');
            expect(result[1][0]).toEqual(startTimePlus2, 'result[1][0]');
            expect(result[2][0]).toEqual(middleTime, 'result[2][0]');
            expect(result[3][0]).toEqual(endTimeMinus2, 'result[3][0]');
            expect(result[4][0]).toEqual(endTimeMinus1, 'result[4][0]');
        });
    });
    describe('isChunkAffected', function () {
        it('should not get a chunk - start/end is the past', function () {
            // new: ++
            // old:   --
            var result = TimeSeriesImpl['isChunkAffected'](startTime, new Date(startTime.getTime() + 1 * 60 * 1000), new Date(startTime.getTime() + 2 * 60 * 1000), new Date(startTime.getTime() + 3 * 60 * 1000));
            expect(result).toBeFalsy();
        });
        it('should not get a chunk - start/end is in the future', function () {
            // new:     ++
            // old: --
            var result = TimeSeriesImpl['isChunkAffected'](startTime, new Date(startTime.getTime() + 1 * 60 * 1000), new Date(startTime.getTime() - 3 * 60 * 1000), new Date(startTime.getTime() - 2 * 60 * 1000));
            expect(result).toBeFalsy();
        });
        it('should get a chunk - start/end touches block start', function () {
            // new: ++++++
            // old:    -----
            var result = TimeSeriesImpl['isChunkAffected'](startTime, new Date(startTime.getTime() + 5 * 60 * 1000), new Date(startTime.getTime() + 3 * 60 * 1000), new Date(startTime.getTime() + 7 * 60 * 1000));
            expect(result).toBeTruthy();
        });
        it('should get a chunk - start/end touches block end', function () {
            // new:    ++++++
            // old: ------
            var result = TimeSeriesImpl['isChunkAffected'](startTime, new Date(startTime.getTime() + 5 * 60 * 1000), new Date(startTime.getTime() - 3 * 60 * 1000), new Date(startTime.getTime() + 2 * 60 * 1000));
            expect(result).toBeTruthy();
        });
        it('should get a chunk - start/end inside a block', function () {
            // new:   ++++++++
            // old: -----------------
            var result = TimeSeriesImpl['isChunkAffected'](startTime, new Date(startTime.getTime() + 7 * 60 * 1000), new Date(startTime.getTime() - 2 * 60 * 1000), new Date(startTime.getTime() + 14 * 60 * 1000));
            expect(result).toBeTruthy();
        });
        it('should get a chunk - start/end covers a block', function () {
            // new: ++++++++
            // old:   ---
            var result = TimeSeriesImpl['isChunkAffected'](startTime, new Date(startTime.getTime() + 7 * 60 * 1000), new Date(startTime.getTime() + 2 * 60 * 1000), new Date(startTime.getTime() + 4 * 60 * 1000));
            expect(result).toBeTruthy();
        });
    });
    describe('Store', function () {
        it('should store a new chunk', function () {
            timeSeries.Store(startTime, startTime, [[startTime, 2]]);
            expect(timeSeries['_chunks'].length).toEqual(1);
            expect(timeSeries['_chunks'][0].start).toEqual(startTime);
        });
        it('should store two chunks', function () {
            timeSeries.Store(startTime, startTime, [[startTime, 2]]);
            var nextChunkTime = new Date(startTime.getTime() + 5 * 60 * 1000);
            timeSeries.Store(nextChunkTime, nextChunkTime, [[nextChunkTime, 3]]);
            expect(timeSeries['_chunks'].length).toEqual(2);
            expect(timeSeries['_chunks'][0].start).toEqual(startTime);
            expect(timeSeries['_chunks'][1].start).toEqual(nextChunkTime);
        });
        it('should store two chunks in right sorting order', function () {
            var nextChunkTime = new Date(startTime.getTime() + 5 * 60 * 1000);
            timeSeries.Store(nextChunkTime, nextChunkTime, [[nextChunkTime, 3]]);
            timeSeries.Store(startTime, startTime, [[startTime, 2]]);
            expect(timeSeries['_chunks'].length).toEqual(2);
            expect(timeSeries['_chunks'][0].start).toEqual(startTime);
            expect(timeSeries['_chunks'][1].start).toEqual(nextChunkTime);
        });
        it('should collapse two chunks into one', function () {
            timeSeries.Store(startTime, startTime, [[startTime, 2]]);
            var nextChunkTime = new Date(startTime.getTime() + 1 * 60 * 1000);
            timeSeries.Store(nextChunkTime, nextChunkTime, [[nextChunkTime, 3]]);
            expect(timeSeries['_chunks'].length).toEqual(1);
            expect(timeSeries['_chunks'][0].start).toEqual(startTime);
            expect(timeSeries['_chunks'][0].end).toEqual(nextChunkTime);
        });
        it('should collapse two separate chunks into one by a middle one', function () {
            timeSeries.Store(startTime, startTime, [[startTime, 2]]);
            var nextChunkTime = new Date(startTime.getTime() + 2 * 60 * 1000);
            timeSeries.Store(nextChunkTime, nextChunkTime, [[nextChunkTime, 3]]);
            var middleChunkTime = new Date(startTime.getTime() + 1 * 60 * 1000);
            timeSeries.Store(middleChunkTime, middleChunkTime, [[middleChunkTime, 3]]);
            expect(timeSeries['_chunks'].length).toEqual(1);
            expect(timeSeries['_chunks'][0].start).toEqual(startTime);
            expect(timeSeries['_chunks'][0].end).toEqual(nextChunkTime);
        });
        it('should collapse two separate chunks into one by a big one', function () {
            timeSeries.Store(startTime, startTime, [[startTime, 2]]);
            var nextChunkTime = new Date(startTime.getTime() + 2 * 60 * 1000);
            timeSeries.Store(nextChunkTime, nextChunkTime, [[nextChunkTime, 3]]);
            var bigChunkStartTime = new Date(startTime.getTime() - 1 * 60 * 1000);
            var bigChunkEndTime = new Date(startTime.getTime() + 5 * 60 * 1000);
            timeSeries.Store(bigChunkStartTime, bigChunkEndTime, []);
            expect(timeSeries['_chunks'].length).toEqual(1);
            expect(timeSeries['_chunks'][0].start).toEqual(bigChunkStartTime);
            expect(timeSeries['_chunks'][0].end).toEqual(bigChunkEndTime);
        });
        it('should insert a chunk in the middle', function () {
            timeSeries.Store(startTime, startTime, [[startTime, 2]]);
            var nextChunkTime = new Date(startTime.getTime() + 4 * 60 * 1000);
            timeSeries.Store(nextChunkTime, nextChunkTime, [[nextChunkTime, 3]]);
            var middleChunkTime = new Date(startTime.getTime() + 2 * 60 * 1000);
            timeSeries.Store(middleChunkTime, middleChunkTime, [[middleChunkTime, 3]]);
            expect(timeSeries['_chunks'].length).toEqual(3);
            expect(timeSeries['_chunks'][0].start).toEqual(startTime);
            expect(timeSeries['_chunks'][1].start).toEqual(middleChunkTime);
            expect(timeSeries['_chunks'][2].start).toEqual(nextChunkTime);
        });
        it('should insert data in the right order', function () {
            timeSeries.Store(startTime, new Date(startTime.getTime() + 4 * 60 * 1000), [[new Date(startTime.getTime() + 4 * 60 * 1000), 4],
                [new Date(startTime.getTime() + 3 * 60 * 1000), 3],
                [new Date(startTime.getTime() + 0 * 60 * 1000), 0],
                [new Date(startTime.getTime() + 1 * 60 * 1000), 1],
                [new Date(startTime.getTime() + 2 * 60 * 1000), 2]]);
            expect(timeSeries['_chunks'].length).toEqual(1);
            expect(timeSeries['_chunks'][0].data.length).toEqual(5);
            expect(timeSeries['_chunks'][0].data[0][1]).toEqual(0);
            expect(timeSeries['_chunks'][0].data[1][1]).toEqual(1);
            expect(timeSeries['_chunks'][0].data[2][1]).toEqual(2);
            expect(timeSeries['_chunks'][0].data[3][1]).toEqual(3);
            expect(timeSeries['_chunks'][0].data[4][1]).toEqual(4);
        });
        it('should overwrite data', function () {
            timeSeries.Store(startTime, startTime, [[startTime, 0]]);
            timeSeries.Store(startTime, startTime, [[startTime, 1]]);
            expect(timeSeries['_chunks'].length).toEqual(1);
            expect(timeSeries['_chunks'][0].data.length).toEqual(1);
            expect(timeSeries['_chunks'][0].data[0][1]).toEqual(1);
        });
    });
});
describe('TimeSeriesCache', function () {
    describe('Store', function () {
        it('should store key', function () {
            var cache = new TimeSeriesCache();
            cache.Store('mykey', 1 * 60 * 1000, new Date(), new Date(), []);
            expect(cache['_cache']['mykey']).not.toBeNull();
        });
    });
    describe('Get', function () {
        it('should get value', function () {
            var startTime = new Date(2017, 5, 12, 15, 55, 0);
            var cache = new TimeSeriesCache();
            cache.Store('mykey', 1 * 60 * 1000, startTime, startTime, []);
            var value = cache.Get('mykey', startTime, startTime);
            expect(value).not.toBeNull();
        });
    });
    describe('Clear', function () {
        it('should clear cache', function () {
            var startTime = new Date(2017, 5, 12, 15, 55, 0);
            var cache = new TimeSeriesCache();
            cache.Store('mykey', 1 * 60 * 1000, startTime, startTime, []);
            var value = cache.Get('mykey', startTime, startTime);
            expect(value).not.toBeNull();
            cache.Clear();
            expect(cache.Get('mykey', startTime, startTime)).toBeNull();
        });
    });
});
//# sourceMappingURL=TimeSeriesCache.spec.js.map