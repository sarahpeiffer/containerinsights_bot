import { TimeSeriesCache } from './TimeSeriesCache';
import { TimeConstants, Grain } from '../../TimeContext';
import { GrainToMilliseconds } from '../..';
var TimeSeriesManager = /** @class */ (function () {
    function TimeSeriesManager() {
    }
    TimeSeriesManager.RetrieveMetricData = function (key, tc, metricName) {
        var grain = GrainToMilliseconds(tc);
        var data = this._timeSeriesCache.Get(TimeSeriesManager.composeMetricKey(key, metricName, grain), tc.startTime, tc.endTime);
        return data;
    };
    TimeSeriesManager.ClearCache = function () {
        this._timeSeriesCache.Clear();
    };
    TimeSeriesManager.ProcessMetricData = function (key, tc, metricName, aggregation, data) {
        var grain = GrainToMilliseconds(tc);
        // Parse metric query into time series
        var chartData = TimeSeriesManager.convertMetricQueryToTimeSeries(metricName, aggregation, data);
        // Store in a cache
        this._timeSeriesCache.Store(TimeSeriesManager.composeMetricKey(key, metricName, grain), grain, tc.startTime, tc.endTime, chartData);
        return chartData;
    };
    TimeSeriesManager.RetrieveGroupedKQLData = function (key, tc, columns, selectedOperations) {
        var grain = GrainToMilliseconds(tc);
        var cachedData = {};
        for (var j = 0; j < selectedOperations.length; ++j) {
            if (!cachedData[selectedOperations[j]]) {
                cachedData[selectedOperations[j]] = {};
            }
            for (var i = 0; i < columns.length; ++i) {
                var data = this._timeSeriesCache.Get(TimeSeriesManager.composeKQLkey(key, selectedOperations[j], columns[i], grain), tc.startTime, tc.endTime);
                if (!data) {
                    return null;
                }
                cachedData[selectedOperations[j]][columns[i]] = data;
            }
        }
        return cachedData;
    };
    TimeSeriesManager.ProcessGroupedKQLData = function (key, tc, columns, selectedOperations, data, groupnameGen) {
        var grain = GrainToMilliseconds(tc);
        // Parse query into time series
        var results = TimeSeriesManager.extractGroupedKQLData(data, columns, groupnameGen);
        // Store in a cache
        for (var j = 0; j < selectedOperations.length; ++j) {
            for (var i = 0; i < columns.length; ++i) {
                if (results[selectedOperations[j]]) {
                    var singleTimeSeriesData = results[selectedOperations[j]][columns[i]];
                    if (singleTimeSeriesData) {
                        this._timeSeriesCache.Store(TimeSeriesManager.composeKQLkey(key, selectedOperations[j], columns[i], grain), grain, tc.startTime, tc.endTime, singleTimeSeriesData);
                    }
                }
            }
        }
        return results;
    };
    TimeSeriesManager.RetrieveKQLData = function (key, tc, columns) {
        var grain = GrainToMilliseconds(tc);
        var cachedData = {};
        for (var i = 0; i < columns.length; ++i) {
            var data = this._timeSeriesCache.Get(TimeSeriesManager.composeKQLkey(key, '_overall_', columns[i], grain), tc.startTime, tc.endTime);
            if (!data) {
                return null;
            }
            cachedData[columns[i]] = data;
        }
        return cachedData;
    };
    TimeSeriesManager.ProcessKQLData = function (key, tc, columns, data) {
        var grain = GrainToMilliseconds(tc);
        // Parse query into time series
        var results = TimeSeriesManager.extractKQLData(data, columns);
        // Store in a cache
        for (var i = 0; i < columns.length; ++i) {
            this._timeSeriesCache.Store(TimeSeriesManager.composeKQLkey(key, '_overall_', columns[i], grain), grain, tc.startTime, tc.endTime, results[columns[i]]);
        }
        return results;
    };
    TimeSeriesManager.AdjustTimeContextForCache = function (tc, globalTimeContext) {
        // We start with 5 min intervals, so, we have full data already (for the whole day)
        if (GrainToMilliseconds(tc) !== TimeConstants.minute) {
            return tc;
        }
        // We'll query for up to 8 hours
        if (tc.durationMs >= 8 * TimeConstants.hour) {
            return tc;
        }
        var delta = Math.round((8 * TimeConstants.hour - tc.durationMs) / TimeConstants.minute / 2) * TimeConstants.minute;
        var queryTimeContext = tc.clone();
        queryTimeContext.grain = Grain.Minutely; // Setting it explicitly since we will be querying for large duration
        // Go back for delta. If we went too far - reset based on global time context
        var startTime = new Date(queryTimeContext.startTime.getTime() - delta);
        if (startTime < globalTimeContext.startTime) {
            startTime = globalTimeContext.startTime;
        }
        // Go forward for delta. If we went too far - reset based on global time context
        queryTimeContext.endTime = new Date(queryTimeContext.endTime.getTime() + delta);
        if (queryTimeContext.endTime > globalTimeContext.endTime) {
            queryTimeContext.endTime = globalTimeContext.endTime;
        }
        queryTimeContext.durationMs = queryTimeContext.endTime.getTime() - startTime.getTime();
        return queryTimeContext;
    };
    TimeSeriesManager.convertMetricQueryToTimeSeries = function (metricName, aggregation, result) {
        if (result && result.segments) {
            var chartData_1 = new Array(result.segments.length);
            result.segments.forEach(function (metric, i) {
                chartData_1[i] = [new Date(metric.start),
                    metric[metricName][aggregation]];
            });
            return chartData_1;
        }
        else {
            return [];
        }
    };
    TimeSeriesManager.extractKQLData = function (query, columns) {
        var result = {};
        columns.forEach(function (column) {
            result[column] = new Array(query.length);
        });
        query.forEach(function (row, i) {
            var date = new Date(row['timestamp']);
            columns.forEach(function (column) {
                result[column][i] = [date, parseFloat(row[column])];
            });
        });
        return result;
    };
    TimeSeriesManager.extractGroupedKQLData = function (query, columns, groupnameGen) {
        var result = {};
        query.forEach(function (row, i) {
            var groupby = groupnameGen(row);
            if (!result[groupby]) {
                result[groupby] = {};
            }
            var date = new Date(row['timestamp']);
            columns.forEach(function (column) {
                if (!result[groupby][column]) {
                    result[groupby][column] = [];
                }
                result[groupby][column].push([date, parseFloat(row[column])]);
            });
        });
        return result;
    };
    TimeSeriesManager.composeMetricKey = function (key, metricName, grain) {
        return [key, metricName, grain.toString()].join('/');
    };
    TimeSeriesManager.composeKQLkey = function (key, operation, metricName, grain) {
        return [key, operation, metricName, grain.toString()].join('/');
    };
    TimeSeriesManager._timeSeriesCache = new TimeSeriesCache();
    return TimeSeriesManager;
}());
export { TimeSeriesManager };
//# sourceMappingURL=TimeSeriesManager.js.map