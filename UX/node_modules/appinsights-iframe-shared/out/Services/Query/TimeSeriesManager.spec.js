import { TimeSeriesManager } from './TimeSeriesManager';
import { Grain, TimeConstants, TimeContext } from '../../TimeContext';
import { TimeContextToISODuration } from '../..';
describe('TimeSeriesManager', function () {
    describe('convertMetricQueryToTimeSeries', function () {
        it('should extract metric from result', function () {
            var query = {
                metricName: 'requestsCount',
                aggregation: 'sum',
                result: {
                    segments: [{
                            start: new Date(2017, 5, 23),
                            requestsCount: {
                                sum: 4
                            }
                        }, {
                            start: new Date(2017, 5, 24),
                            requestsCount: {
                                sum: 5
                            }
                        }]
                }
            };
            var result = TimeSeriesManager['convertMetricQueryToTimeSeries'](query.metricName, query.aggregation, query.result);
            expect(result.length).toBe(2);
            expect(result[0][0].getTime()).toBe(query.result.segments[0].start.getTime());
            expect(result[0][1]).toBe(4);
            expect(result[1][0].getTime()).toBe(query.result.segments[1].start.getTime());
            expect(result[1][1]).toBe(5);
        });
    });
    describe('extractKQLData', function () {
        it('should extract 2 metrics from KQL table', function () {
            var table = [{
                    timestamp: new Date(2017, 5, 14),
                    metric1: 2,
                    metric2: 5
                }, {
                    timestamp: new Date(2017, 5, 15),
                    metric1: 3,
                    metric2: 6
                }];
            var results = TimeSeriesManager['extractKQLData'](table, ['metric1', 'metric2']);
            expect(results['metric1'].length).toBe(2);
            expect(results['metric2'].length).toBe(2);
            expect(results['metric1'][0][0].getTime()).toBe(table[0].timestamp.getTime());
            expect(results['metric1'][0][1]).toBe(2);
            expect(results['metric1'][1][0].getTime()).toBe(table[1].timestamp.getTime());
            expect(results['metric1'][1][1]).toBe(3);
            expect(results['metric2'][0][0].getTime()).toBe(table[0].timestamp.getTime());
            expect(results['metric2'][0][1]).toBe(5);
            expect(results['metric2'][1][0].getTime()).toBe(table[1].timestamp.getTime());
            expect(results['metric2'][1][1]).toBe(6);
        });
    });
    describe('extractGroupedKQLData', function () {
        it('should extract aggregate KQL data by aggregate column', function () {
            var table = [{
                    timestamp: new Date(2017, 5, 14),
                    name: 'operation1',
                    metric1: 2,
                    metric2: 5
                }, {
                    timestamp: new Date(2017, 5, 15),
                    name: 'operation1',
                    metric1: 3,
                    metric2: 6
                }, {
                    timestamp: new Date(2017, 5, 14),
                    name: 'operation2',
                    metric1: 3,
                    metric2: 4
                }, {
                    timestamp: new Date(2017, 5, 15),
                    name: 'operation2',
                    metric1: 7,
                    metric2: 1
                }];
            var results = TimeSeriesManager['extractGroupedKQLData'](table, ['metric1', 'metric2'], function (v) { return v.name; });
            expect(results['operation1']['metric1'].length).toBe(2);
            expect(results['operation1']['metric2'].length).toBe(2);
            expect(results['operation1']['metric1'][0][0].getTime()).toBe(table[0].timestamp.getTime());
            expect(results['operation1']['metric1'][0][1]).toBe(2);
            expect(results['operation1']['metric1'][1][0].getTime()).toBe(table[1].timestamp.getTime());
            expect(results['operation1']['metric1'][1][1]).toBe(3);
            expect(results['operation1']['metric2'][0][0].getTime()).toBe(table[0].timestamp.getTime());
            expect(results['operation1']['metric2'][0][1]).toBe(5);
            expect(results['operation1']['metric2'][1][0].getTime()).toBe(table[1].timestamp.getTime());
            expect(results['operation1']['metric2'][1][1]).toBe(6);
            expect(results['operation2']['metric1'].length).toBe(2);
            expect(results['operation2']['metric2'].length).toBe(2);
            expect(results['operation2']['metric1'][0][0].getTime()).toBe(table[0].timestamp.getTime());
            expect(results['operation2']['metric1'][0][1]).toBe(3);
            expect(results['operation2']['metric1'][1][0].getTime()).toBe(table[1].timestamp.getTime());
            expect(results['operation2']['metric1'][1][1]).toBe(7);
            expect(results['operation2']['metric2'][0][0].getTime()).toBe(table[0].timestamp.getTime());
            expect(results['operation2']['metric2'][0][1]).toBe(4);
            expect(results['operation2']['metric2'][1][0].getTime()).toBe(table[1].timestamp.getTime());
            expect(results['operation2']['metric2'][1][1]).toBe(1);
        });
    });
    describe('AdjustTimeContextForCache', function () {
        var endDate = new Date(Date.UTC(2017, 5, 13, 14, 42));
        var globalTimeContext = new TimeContext(TimeConstants.day, endDate);
        it('should not change time context when it matches global time context', function () {
            var timeContext = globalTimeContext.clone();
            var result = TimeSeriesManager['AdjustTimeContextForCache'](timeContext, globalTimeContext);
            expect(TimeContextToISODuration(result)).toBe('2017-06-12T14:42:00.000Z/2017-06-13T14:42:00.000Z');
        });
        it('should not change time context when it is 5 min granularity', function () {
            var timeContext = new TimeContext(12 * TimeConstants.hour, endDate);
            var result = TimeSeriesManager['AdjustTimeContextForCache'](timeContext, globalTimeContext);
            expect(TimeContextToISODuration(result)).toBe('2017-06-13T02:42:00.000Z/2017-06-13T14:42:00.000Z');
        });
        it('should not change time context when it is 1 min granularity but more than 8 hours', function () {
            var timeContext = new TimeContext(8 * TimeConstants.hour, new Date(Date.UTC(2017, 5, 13, 14, 42)), undefined, undefined, Grain.Minutely);
            var result = TimeSeriesManager['AdjustTimeContextForCache'](timeContext, globalTimeContext);
            expect(TimeContextToISODuration(result)).toBe('2017-06-13T06:42:00.000Z/2017-06-13T14:42:00.000Z');
        });
        it('should expand time context to 8 hours', function () {
            var timeContext = new TimeContext(2 * TimeConstants.hour, new Date(Date.UTC(2017, 5, 13, 10, 42)));
            var result = TimeSeriesManager['AdjustTimeContextForCache'](timeContext, globalTimeContext);
            expect(TimeContextToISODuration(result)).toBe('2017-06-13T05:42:00.000Z/2017-06-13T13:42:00.000Z');
        });
        it('should expand but not exceed the end time of global time context', function () {
            var timeContext = new TimeContext(2 * TimeConstants.hour, new Date(Date.UTC(2017, 5, 13, 12, 42)));
            var result = TimeSeriesManager['AdjustTimeContextForCache'](timeContext, globalTimeContext);
            expect(TimeContextToISODuration(result)).toBe('2017-06-13T07:42:00.000Z/2017-06-13T14:42:00.000Z');
        });
        it('should expand but not exceed the start time of global time context', function () {
            var timeContext = new TimeContext(2 * TimeConstants.hour, new Date(Date.UTC(2017, 5, 12, 18, 42)));
            var result = TimeSeriesManager['AdjustTimeContextForCache'](timeContext, globalTimeContext);
            expect(TimeContextToISODuration(result)).toBe('2017-06-12T14:42:00.000Z/2017-06-12T21:42:00.000Z');
        });
    });
    describe('ClearCache', function () {
        it('should clear time series cache', function () {
            spyOn(TimeSeriesManager['_timeSeriesCache'], 'Clear');
            TimeSeriesManager.ClearCache();
            expect(TimeSeriesManager['_timeSeriesCache'].Clear).toHaveBeenCalledTimes(1);
        });
    });
});
//# sourceMappingURL=TimeSeriesManager.spec.js.map