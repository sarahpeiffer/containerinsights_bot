/**
* Converts a resource ID string to a IResourceInfo instance.
*
* @param resourceId A resource ID string in the format "/subscriptions/{0}/resourcegroups/{1}/providers/microsoft.insights/{type}/{2}"
* @param parseResourceGroup: option parameter indicating whether to parse "resourcegroups".
*   Some Ajax query sent to backend does not have resourcegroups. E.g.
*   "/subscriptions/00000000-0000-0000-0000-000000000000/providers/microsoft.insights/queries/components/views/LatencyMonitoring/getdata"
* @param parseResourceTypeName: option parameter to allow parsing to fetch the ResourceTypeName.
*   Consider UX sending query like  /subscriptions/sub_1/resourcegroups/rc_2/providers/microsoft.insights/webtests"
*   Specify parseResourceTypeName be false so we can determine API version to use.
* @param validateIsInsightsResource: option parameter to validate whether the resource provider is "microsoft.insights".
*   Parameter is default to true and will return null if the resource provider is not "microsoft.insights".
*   Specify validateIsInsightsResource to be false so we will take any resourceId and return the resourceInfo.
*/
export function ResourceIdToResourceInfo(resourceId, parseResourceGroup, parseResourceTypeName, validateIsInsightsResource) {
    if (parseResourceGroup === void 0) { parseResourceGroup = true; }
    if (parseResourceTypeName === void 0) { parseResourceTypeName = true; }
    if (validateIsInsightsResource === void 0) { validateIsInsightsResource = true; }
    var result = {};
    var decodedResourceId = decodeURI(resourceId);
    var parts = (decodedResourceId + '')
        .split('/')
        .filter(function (item) { return item !== ''; });
    // If there are not at least 5 segments, this is not a resource.
    if (parts.length < 5) {
        return null;
    }
    // Keep track of our current state in parsing the url.
    var parsingState = {
        parts: parts,
        location: 0
    };
    // Parse the segments of the path.
    var value = _getSegmentValue(parsingState, 'subscriptions');
    if (!value) {
        return null;
    }
    result.SubscriptionId = value;
    if (parseResourceGroup) {
        value = _getSegmentValue(parsingState, 'resourcegroups');
        if (!value) {
            return null;
        }
        result.ResourceGroup = value;
    }
    value = _getSegmentValue(parsingState, 'providers');
    if (!value) {
        return null;
    }
    // Make sure it is our provider.
    if (validateIsInsightsResource && value.toLowerCase() !== 'microsoft.insights') {
        return null;
    }
    // Save off the current position as the resource type.
    result.ResourceType = parsingState.parts[parsingState.location].toLowerCase();
    value = _getSegmentValue(parsingState);
    if (!value) {
        // Cannot find ResourceType name,
        return parseResourceTypeName ? null : result;
    }
    result.Name = value;
    // Get remaining path segments.
    if (parsingState.location < parsingState.parts.length) {
        result.RemainingPathSegments = parsingState.parts.slice(parsingState.location).filter(function (item) {
            return item !== '';
        });
        if (result.RemainingPathSegments.length === 0) {
            delete result.RemainingPathSegments;
        }
    }
    return result;
}
function _getSegmentValue(parsingState, expectedName) {
    var nameSegment = parsingState.parts[parsingState.location];
    // Do not do segment name check when expected name is not provided.
    // Otherwise make sure the segment name matches and return if it does not.
    if (expectedName &&
        nameSegment.toLowerCase() !== expectedName.toLowerCase()) {
        return null;
    }
    // Get the value segment.
    parsingState.location++;
    var result = parsingState.parts[parsingState.location];
    parsingState.location++;
    return result;
}
//# sourceMappingURL=ResourceCore.js.map