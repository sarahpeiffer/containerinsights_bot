import { PerformanceMeasurement } from '../SharedIFrameMessages';
import { TelemetryConstants } from '../TelemetryConstants';
import { PerformanceNow } from '../PerformanceNow';
var TelemetryQueryContext = /** @class */ (function () {
    function TelemetryQueryContext(name, issued) {
        this.batchedQueries = [];
        this.queryName = name;
        this.issued = issued;
    }
    TelemetryQueryContext.prototype.hasBatch = function (name) {
        return !!this.batchedQueries.filter(function (t) { return t === name; }).length;
    };
    return TelemetryQueryContext;
}());
export { TelemetryQueryContext };
var TelemetryControlDataSet = /** @class */ (function () {
    function TelemetryControlDataSet(name, complete, visible, queryName, isBatch) {
        this.name = name;
        this.complete = complete;
        this.isVisible = visible;
        this.queryName = queryName;
        this.isBatch = isBatch;
    }
    return TelemetryControlDataSet;
}());
export { TelemetryControlDataSet };
var TelemetryControlContext = /** @class */ (function () {
    function TelemetryControlContext(name, start) {
        this.dataSets = {};
        this.controlName = name;
        this.updateStart = start;
        this.updateCount = 1;
    }
    return TelemetryControlContext;
}());
export { TelemetryControlContext };
var TelemetryOperation = /** @class */ (function () {
    function TelemetryOperation(id, name, started) {
        this.controls = {};
        this.queries = {};
        this.customProps = {};
        this.id = id;
        this.name = name;
        this.started = started;
    }
    /**
     * Set the measurements for initial load time that include performance measurements from the viewmodel.
     */
    TelemetryOperation.SetViewModelMeasurements = function (measurements) {
        this.globalMeasurements = measurements;
    };
    TelemetryOperation.prototype.getTelemetryProperties = function () {
        // TODO: We should keep track of the current operation for exceptions, so they can cause part load to be unsuccessful
        // As of today, only query failures contribute (and exceptions in the callback chain of a query)
        var successful = true;
        var failedQueries = [];
        var status = 200;
        var statusText = 'OK';
        var allCached = true;
        // Determine if all queries were cached or if any failed
        for (var q in this.queries) {
            if (this.queries[q]) {
                var query = this.queries[q];
                if (query.succeeded === false) {
                    successful = false;
                    status = query.statusCode;
                    statusText = query.statusText;
                    failedQueries.push(query.queryName);
                }
                if (!query.cached) {
                    allCached = false;
                }
            }
        }
        var lastControl;
        var lastQuery;
        var lastQueryComplete = 0;
        var max = 0;
        // Find the slowest control. A control is counted as finished loading when the last visible data set loaded
        for (var c in this.controls) {
            if (this.controls[c]) {
                var control = this.controls[c];
                var lastDataSetLoaded = 0;
                for (var d in control.dataSets) {
                    if (control.dataSets[d]) {
                        var dataSet = control.dataSets[d];
                        if (dataSet.isVisible && dataSet.complete && dataSet.complete.perf > lastDataSetLoaded) {
                            lastDataSetLoaded = dataSet.complete.perf;
                        }
                        // The slowest query is the last visible query to complete
                        if (dataSet.isVisible &&
                            this.queries[dataSet.queryName] && this.queries[dataSet.queryName].completed &&
                            this.queries[dataSet.queryName].completed.perf > lastQueryComplete) {
                            lastQuery = dataSet.queryName;
                            lastQueryComplete = this.queries[dataSet.queryName].completed.perf;
                        }
                        else if (dataSet.isVisible && dataSet.isBatch) {
                            // Search through queries to find the batch
                            for (var q in this.queries) {
                                if (this.queries[q] && this.queries[q].hasBatch(dataSet.queryName)) {
                                    if (this.queries[q].completed && this.queries[q].completed.perf > lastQueryComplete) {
                                        lastQuery = this.queries[q].queryName;
                                        lastQueryComplete = this.queries[q].completed.perf;
                                    }
                                }
                            }
                        }
                    }
                }
                if (lastDataSetLoaded > max) {
                    lastControl = control.controlName;
                    max = lastDataSetLoaded;
                }
            }
        }
        return Object.assign(this.customProps, {
            ActionName: this.name,
            Result: successful ? 'Succeed' : 'Fail',
            AllCached: allCached,
            OperationId: this.id,
            FailedQueries: failedQueries.reduce(function (a, b) { return a + (a ? ',' : '') + b; }, ''),
            LastQuery: lastQuery,
            LastControl: lastControl,
            Status: status,
            StatusText: statusText,
            ErrorMessage: successful ? '' : 'Query failed',
            FrameHeight: window.innerHeight,
            FrameWidth: window.innerWidth,
            ScreenHeight: window.screen.height,
            ScreenWidth: window.screen.width,
            ScreenPixelRatio: window.devicePixelRatio
        });
    };
    TelemetryOperation.prototype.getTelemetryMeasurements = function () {
        var measurements = {};
        var lastControlComplete = new PerformanceMeasurement(0, 0);
        var lastControlVisible = new PerformanceMeasurement(0, 0);
        var lastQueryComplete = new PerformanceMeasurement(0, 0);
        var lastVisibleQueryComplete = new PerformanceMeasurement(0, 0);
        for (var c in this.controls) {
            if (this.controls[c]) {
                // A control's visibility duration is measured by the time from control's first update start
                // to the end of the last update triggered by visible data.
                // Its total duration is measured by the time from the control's first update start
                // to the end of the last update triggered by all data (visible or not).
                var control = this.controls[c];
                var lastDataSetVisible = new PerformanceMeasurement(0, 0);
                var lastDataSetComplete = new PerformanceMeasurement(0, 0);
                var lastControlQueryComplete = new PerformanceMeasurement(0, 0);
                for (var d in control.dataSets) {
                    if (control.dataSets[d]) {
                        var dataSet = control.dataSets[d];
                        if (dataSet.isVisible && dataSet.complete && dataSet.complete.perf > lastDataSetVisible.perf) {
                            if (this.queries[dataSet.queryName] && this.queries[dataSet.queryName].completed) {
                                lastVisibleQueryComplete = this.queries[dataSet.queryName].completed;
                            }
                            lastDataSetVisible = dataSet.complete;
                        }
                        if (dataSet.complete && dataSet.complete.perf > lastDataSetComplete.perf) {
                            lastDataSetComplete = dataSet.complete;
                        }
                        if (this.queries[dataSet.queryName]
                            && this.queries[dataSet.queryName].completed) {
                            if (this.queries[dataSet.queryName].completed.perf > lastControlQueryComplete.perf) {
                                lastControlQueryComplete = this.queries[dataSet.queryName].completed;
                            }
                            if (this.queries[dataSet.queryName].completed.perf > lastQueryComplete.perf) {
                                lastQueryComplete = this.queries[dataSet.queryName].completed;
                            }
                        }
                        else if (dataSet.isBatch) {
                            for (var q in this.queries) {
                                if (this.queries[q] && this.queries[q].hasBatch(dataSet.queryName)) {
                                    if (this.queries[q].completed) {
                                        if (this.queries[q].completed.perf > lastControlQueryComplete.perf) {
                                            lastControlQueryComplete = this.queries[q].completed;
                                        }
                                        if (this.queries[q].completed.perf > lastQueryComplete.perf) {
                                            lastQueryComplete = this.queries[q].completed;
                                        }
                                        if (dataSet.isVisible && this.queries[q].completed.perf > lastVisibleQueryComplete.perf) {
                                            lastVisibleQueryComplete = this.queries[q].completed;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (lastDataSetComplete.perf > lastControlComplete.perf) {
                    lastControlComplete = lastDataSetComplete;
                }
                if (lastDataSetVisible.perf > lastControlVisible.perf) {
                    lastControlVisible = lastDataSetVisible;
                }
                measurements["duration_" + control.controlName + "_visible"] =
                    this.recordMeasurement(control.updateStart.perf, lastDataSetVisible.perf);
                measurements["duration_" + control.controlName + "_total"] =
                    this.recordMeasurement(control.updateStart.perf, lastDataSetComplete.perf);
                measurements[control.controlName + "_update_count"] = control.updateCount;
                if (lastControlQueryComplete) {
                    measurements["duration_" + control.controlName + "_post_query"] =
                        this.recordMeasurement(lastControlQueryComplete.perf, lastDataSetComplete.perf);
                }
            }
        }
        var firstQueryStarted = new PerformanceMeasurement(Infinity, Infinity);
        for (var q in this.queries) {
            if (this.queries[q]) {
                var query = this.queries[q];
                if (query.issued && query.issued.perf < firstQueryStarted.perf) {
                    firstQueryStarted = query.issued;
                }
            }
        }
        measurements['duration_visible_queries'] = this.recordMeasurement(firstQueryStarted.perf, lastVisibleQueryComplete.perf);
        measurements['duration_total_queries'] = this.recordMeasurement(firstQueryStarted.perf, lastQueryComplete.perf);
        measurements['duration_visible'] = this.recordMeasurement(this.started.perf, lastControlVisible.perf);
        measurements['duration_total'] = this.recordMeasurement(this.started.perf, lastControlComplete.perf);
        measurements['duration_start_to_queries'] = this.recordMeasurement(this.started.perf, firstQueryStarted.perf);
        measurements['duration_visible_post_query'] = this.recordMeasurement(lastVisibleQueryComplete.perf, lastControlVisible.perf);
        measurements['duration_total_post_query'] = this.recordMeasurement(lastQueryComplete.perf, lastControlComplete.perf);
        // only log these on first load, we X out globalMeasurements after the first load
        if (TelemetryOperation.globalMeasurements) {
            // time from FramePart view model constructor to iframe head
            measurements['duration_ctor_to_head'] = this.recordMeasurement(TelemetryOperation.globalMeasurements.partConstructor.date, TelemetryOperation.globalMeasurements.iframeHead.date);
            // time from iframe head to this operation started
            measurements['duration_head_to_start'] = this.recordMeasurement(TelemetryOperation.globalMeasurements.iframeHead.perf, this.started.perf);
            // time from FramePart view model constructor to last control finished loading
            measurements['duration_total'] = this.recordMeasurement(TelemetryOperation.globalMeasurements.partConstructor.date, lastControlComplete.date);
            // time from FramePart view model constructor to last control visible loading finished
            measurements['duration_visible'] = this.recordMeasurement(TelemetryOperation.globalMeasurements.partConstructor.date, lastControlVisible.date);
            // time from FramePart view model constructor to communication channel open between iframe and FramePart
            measurements['duration_ctor_to_comms'] = this.recordMeasurement(TelemetryOperation.globalMeasurements.partConstructor.perf, TelemetryOperation.globalMeasurements.communicationInitialized.perf);
        }
        return measurements;
    };
    TelemetryOperation.prototype.recordMeasurement = function (start, end) {
        if (end > start) {
            return end - start;
        }
        return 0;
    };
    return TelemetryOperation;
}());
export { TelemetryOperation };
var TelemetryContext = /** @class */ (function () {
    function TelemetryContext(telemetryService) {
        this._operations = {};
        this._telemetryService = telemetryService;
        if (!window.performanceNow || typeof window.performanceNow !== 'function') {
            PerformanceNow.polyfill();
        }
    }
    /**
     * Start a telemetry operation. Once an operation is started, queries and controls can register measurements to be logged until
     * the operation completes (when the last query issued during the operation completes).
     * @param id - Operation ID for the current operation
     * @param name - Name of the operation
     */
    TelemetryContext.prototype.StartOperation = function (name, id) {
        this._operations[id] = new TelemetryOperation(id, name, new PerformanceMeasurement(Date.now(), window.performanceNow()));
        // We log trace message here so we can track operations that were started but never logged if necessary.
        this._telemetryService.LogTrace('OperationStarted', {
            OperationId: id,
            ActionName: name
        });
    };
    TelemetryContext.prototype.GetOperationName = function (id) {
        return this._operations[id] ? this._operations[id].name : null;
    };
    TelemetryContext.prototype.UpdateCustomProps = function (id, props) {
        if (this._operations[id]) {
            this._operations[id].customProps =
                Object.assign((this._operations[id].customProps || {}), props);
        }
    };
    /**
     * Record a control componentWillUpdate() called. The operation keeps track of when update was called for the first time
     * on each control and how many times update was called during an operation.
     * @param id - Operation ID for the current operation
     * @param partName - Name of the control recording data
     */
    TelemetryContext.prototype.RecordControlUpdated = function (id, partName) {
        var operation = this._operations[id];
        if (operation) {
            if (!operation.controls[partName]) {
                operation.controls[partName] = new TelemetryControlContext(partName, new PerformanceMeasurement(Date.now(), window.performanceNow()));
            }
            else {
                operation.controls[partName].updateCount++;
            }
        }
    };
    /**
     * Record a control updated with data from a particular data set. Data set is defined as results from
     * a query that the control receives as a separate event.
     * @param id - Operation ID for the current operation
     * @param partName - Name of the control recording data
     * @param dataSet - Name of the data set that was updated
     * @param queryName - Name of the query that generated the data set update
     * @param isVisible - Set to true if the data set is currently visible to the user
     */
    TelemetryContext.prototype.RecordDataSetUpdated = function (id, partName, dataSet, queryName, isVisible, isBatch) {
        var operation = this._operations[id];
        if (operation) {
            if (operation.controls[partName]) {
                operation.controls[partName].dataSets[dataSet] = new TelemetryControlDataSet(dataSet, new PerformanceMeasurement(Date.now(), window.performanceNow()), isVisible, queryName, isBatch);
            }
        }
    };
    /**
     * Record a query issued.
     * @param id - Operation ID for the current operation
     * @param queryName - Name of the query
     */
    TelemetryContext.prototype.RecordQueryIssued = function (id, queryName) {
        var operation = this._operations[id];
        if (operation) {
            operation.queries[queryName] = new TelemetryQueryContext(queryName, new PerformanceMeasurement(Date.now(), window.performanceNow()));
        }
    };
    /**
     * Record a query completed.
     * @param id - Operation ID for the current operation
     * @param queryName - Name of the query
     * @param success - Set to true if the query was successful
     * @param cached - Set to true if the query was retreived from in-memory cache
     * @param status - Status code of the query result
     * @param statusText - Status text of the query result
     */
    TelemetryContext.prototype.RecordQueryComplete = function (id, queryName, success, cached, status, statusText, batchedQueries) {
        var operation = this._operations[id];
        if (operation) {
            if (operation.queries[queryName]) {
                operation.queries[queryName].completed = new PerformanceMeasurement(Date.now(), window.performanceNow());
                operation.queries[queryName].succeeded = success;
                operation.queries[queryName].cached = cached;
                operation.queries[queryName].statusCode = status;
                operation.queries[queryName].statusText = statusText;
                operation.queries[queryName].batchedQueries = batchedQueries;
                var allLoaded = true;
                for (var i in operation.queries) {
                    if (operation.queries[i] && !operation.queries[i].completed) {
                        allLoaded = false;
                        break;
                    }
                }
                if (allLoaded) {
                    this.EndOperation(id);
                }
            }
        }
    };
    TelemetryContext.prototype.RecordClick = function (button, properties) {
        this._telemetryService.LogEvent(TelemetryConstants.HotspotClicked + " " + button, properties);
    };
    /**
     * Ends the operation by removing its registration and logging data to App Insights
     * @param id - Operation ID of the current operation
     */
    TelemetryContext.prototype.EndOperation = function (id) {
        var _this = this;
        // Log on a timeout so we can make sure controls are finished updating after the queries complete.
        window.setTimeout(function () {
            var operation = _this._operations[id];
            if (operation) {
                _this._telemetryService.LogEvent(TelemetryConstants.PartLoad, operation.getTelemetryProperties(), operation.getTelemetryMeasurements());
                _this._telemetryService.LogTrace('OperationEnded', {
                    OperationId: id,
                    ActionName: operation.name
                });
                delete _this._operations[id];
                TelemetryOperation.SetViewModelMeasurements(null);
            }
        }, 1500);
    };
    return TelemetryContext;
}());
export { TelemetryContext };
//# sourceMappingURL=TelemetryContext.js.map