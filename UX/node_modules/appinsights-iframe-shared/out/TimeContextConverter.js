import { Grain, TimeConstants } from './TimeContext';
import { Utils } from './Utils';
var MaxGrainBuckets = 60;
// todo: incorporate age of resource in calculation
export function GrainToKQLInterval(tc, maxGrainBuckets) {
    if (maxGrainBuckets === void 0) { maxGrainBuckets = MaxGrainBuckets; }
    switch (tc.grain) {
        case Grain.Minutely: return '1m';
        case Grain.Hourly: return '1h';
        case Grain.Daily: return '1d';
        case Grain.Weekly: return '7d';
        case Grain.Monthly: return '30d';
        default: return durationToKQLInterval(computeAutomaticTimeGrain(tc, maxGrainBuckets));
    }
}
export function GrainToISOInterval(tc) {
    var duration = grainToMs(tc);
    return toISODuration(duration);
}
export function GrainToMilliseconds(tc) {
    return grainToMs(tc);
}
export function GetKQLDuration(tc) {
    return durationToKQLInterval(tc.durationMs);
}
export function TimeContextToISODuration(tc) {
    var endTime = tc.endTime || new Date();
    var start = new Date(endTime.getTime() - tc.durationMs);
    return start.toISOString() + "/" + endTime.toISOString();
}
export function TimeContextToKQLTimeRange(tc) {
    var endTime = tc.endTime || new Date();
    var start = new Date(endTime.getTime() - tc.durationMs);
    return TimeRangeToKQLTimeRange(start, endTime);
}
export function TimeRangeToKQLTimeRange(start, end, includeWhere) {
    if (includeWhere === void 0) { includeWhere = true; }
    return (includeWhere ? '| where ' : '') +
        ("timestamp > datetime(\"" + start.toISOString() + "\") and timestamp < datetime(\"" + end.toISOString() + "\")");
}
export function TimeContextToRelativeKQLTimeRange(tc, includeWhere) {
    if (includeWhere === void 0) { includeWhere = true; }
    return (includeWhere ? '| where ' : '') + ("timestamp > ago(" + GetKQLDuration(tc) + ")");
}
export function TimeContextToSmartDetectionKQLTimeRange(tc) {
    var endTime = tc.endTime || new Date();
    var startTime = new Date(endTime.getTime() - tc.durationMs);
    return "| where dimensions.InsightEndTime >= datetime(\"" + startTime.toISOString() + "\") and " +
        ("dimensions.InsightStartTime <= datetime(\"" + endTime.toISOString() + "\")");
}
export function GetDatesInKQL(tc) {
    var endTime = tc.endTime || new Date();
    var start = new Date(endTime.getTime() - tc.durationMs);
    return {
        start: "datetime(\"" + start.toISOString() + "\")",
        end: "datetime(\"" + endTime.toISOString() + "\")"
    };
}
export function FloorTimeContextToMinute(tc) {
    var coeff = 60 * 1000;
    tc.endTime = new Date(Math.floor(tc.endTime.getTime() / coeff) * coeff);
}
function format(date, locale) {
    return date.toLocaleDateString(locale) + " " + date.toLocaleTimeString(locale);
}
export function GetLocalizedTimeRangeString(tc, localizationStrings, locale) {
    var custom = localizationStrings['customTimeRangeTitle'];
    if (tc.endTime) {
        return format(tc.startTime, locale) + " - " + format(tc.endTime, locale);
    }
    if (tc.durationMs === TimeConstants.minutes30) {
        return Utils.GetValueOrDefault(localizationStrings, 'timeRangeLastMinutes', '').format('30');
    }
    if (tc.durationMs === TimeConstants.hour) {
        return Utils.GetValueOrDefault(localizationStrings, 'timeRangeLastHour', '');
    }
    if (tc.durationMs === TimeConstants.hours4) {
        return Utils.GetValueOrDefault(localizationStrings, 'timeRangeLastHours', '').format('4');
    }
    if (tc.durationMs === TimeConstants.hours12) {
        return Utils.GetValueOrDefault(localizationStrings, 'timeRangeLastHours', '').format('12');
    }
    if (tc.durationMs === TimeConstants.day) {
        return Utils.GetValueOrDefault(localizationStrings, 'timeRangeLastHours', '').format('24');
    }
    if (tc.durationMs === TimeConstants.hours48) {
        return Utils.GetValueOrDefault(localizationStrings, 'timeRangeLastHours', '').format('48');
    }
    if (tc.durationMs === TimeConstants.days3) {
        return Utils.GetValueOrDefault(localizationStrings, 'timeRangeLastDays', '').format('3');
    }
    if (tc.durationMs === TimeConstants.days7) {
        return Utils.GetValueOrDefault(localizationStrings, 'timeRangeLastDays', '').format('7');
    }
    if (tc.durationMs === TimeConstants.days30) {
        return Utils.GetValueOrDefault(localizationStrings, 'timeRangeLastDays', '').format('30');
    }
    return custom;
}
/**
 * Convert duration to buckets for telemetry
 */
export function GetBucketizedDuration(tc) {
    if (tc.durationMs === TimeConstants.minutes30) {
        return '30 minutes';
    }
    if (tc.durationMs === TimeConstants.hour) {
        return '1 hour';
    }
    if (tc.durationMs === TimeConstants.hours4) {
        return '4 hours';
    }
    if (tc.durationMs === TimeConstants.hours12) {
        return '12 hours';
    }
    if (tc.durationMs === TimeConstants.day) {
        return '24 hours';
    }
    if (tc.durationMs === TimeConstants.hours48) {
        return '48 hours';
    }
    if (tc.durationMs === TimeConstants.days3) {
        return '3 days';
    }
    if (tc.durationMs === TimeConstants.days7) {
        return '7 days';
    }
    if (tc.durationMs === TimeConstants.days30) {
        return '30 days';
    }
    // should we bucketize further?
    return 'Custom';
}
function durationToKQLInterval(durationMs) {
    var days = Math.floor(durationMs / TimeConstants.day);
    var hours = Math.floor(durationMs / TimeConstants.hour);
    var minutes = Math.floor(durationMs / TimeConstants.minute);
    if (days >= 1) {
        return days + 'd';
    }
    else if (hours >= 1) {
        return hours + 'h';
    }
    else if (minutes >= 1) {
        return minutes + 'm';
    }
    else {
        return '1m';
    }
}
function computeAutomaticTimeGrain(tc, maxGrainBuckets) {
    var days = tc.durationMs / TimeConstants.day;
    var hours = tc.durationMs / TimeConstants.hour;
    if (days >= 30) {
        var intervals = [1, 2, 7, 14, 30, 60];
        return getSmallestInterval(days, intervals, 1, maxGrainBuckets) * TimeConstants.day;
    }
    else if (days > 1) {
        var intervals = [1, 2, 3, 4, 6, 12];
        return getSmallestInterval(days, intervals, 24, maxGrainBuckets) * TimeConstants.hour;
    }
    else {
        var intervals = [1, 5, 10, 30, 60, 120, 180, 240, 300];
        if (hours > 5) {
            return maxGrainBuckets === MaxGrainBuckets ? TimeConstants.minute * 5 :
                getSmallestInterval(hours, intervals, 60, maxGrainBuckets) * TimeConstants.minute;
        }
        else {
            return maxGrainBuckets === MaxGrainBuckets ? TimeConstants.minute :
                getSmallestInterval(hours, intervals, 60, maxGrainBuckets) * TimeConstants.minute;
        }
    }
}
function grainToMs(tc, maxGrainBuckets) {
    if (maxGrainBuckets === void 0) { maxGrainBuckets = MaxGrainBuckets; }
    var dduration;
    switch (tc.grain) {
        case Grain.Minutely:
            dduration = TimeConstants.minute;
            break;
        case Grain.Hourly:
            dduration = TimeConstants.hour;
            break;
        case Grain.Daily:
            dduration = TimeConstants.day;
            break;
        case Grain.Weekly:
            dduration = TimeConstants.days7;
            break;
        case Grain.Monthly:
            dduration = TimeConstants.days30;
            break;
        default: dduration = computeAutomaticTimeGrain(tc, maxGrainBuckets);
    }
    return dduration;
}
/**
 * This method chooses the smallest interval that partitions the "numerator" value into at most MaxGrainBuckets buckets
 * @param numerator, the total interval we wish to partition
 * @param intervals, a (sorted) array of valid smaller intervals that we can choose to partition numerator
 * @param conversion the conversion factor between the intervals unit and the numerator unit
 * @return The smallest intervals[i] that partitions numerator into at most MaxGrainBuckets buckets
 */
function getSmallestInterval(numerator, intervals, conversion, maxGrainBuckets) {
    for (var i = 0; i < intervals.length; i++) {
        if ((numerator / intervals[i]) * conversion <= maxGrainBuckets) {
            return intervals[i];
        }
    }
    // numerator is larger than MaxGrainBuckets * largest interval[i] / conversion, so determine a grain that will have the max buckets
    return Math.ceil(numerator * conversion / maxGrainBuckets);
}
function toISODuration(durationMs) {
    var original = new Date(0);
    var newDate = new Date(durationMs);
    var years = newDate.getUTCFullYear() - original.getUTCFullYear();
    var months = newDate.getUTCMonth();
    var days = newDate.getUTCDate() - 1;
    var hours = newDate.getUTCHours();
    var minutes = newDate.getUTCMinutes();
    var seconds = (newDate.getUTCSeconds() + newDate.getUTCMilliseconds() / 1000);
    var time = (hours > 0 || minutes > 0 || seconds > 0 ? 'T' : '') +
        (hours > 0 ? hours + 'H' : '') + (minutes > 0 ? minutes + 'M' : '') +
        (seconds > 0 ? seconds.toFixed(3) + 'S' : '');
    if (!years && !months && !days && !time) {
        return 'P0D';
    }
    else {
        return 'P' + (years > 0 ? years + 'Y' : '') + (months > 0 ? months + 'M' : '') + (days > 0 ? days + 'D' : '') + time;
    }
}
//# sourceMappingURL=TimeContextConverter.js.map