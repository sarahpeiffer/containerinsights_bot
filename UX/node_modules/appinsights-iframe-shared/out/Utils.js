export var StorageType;
(function (StorageType) {
    StorageType[StorageType["LocalStorage"] = 0] = "LocalStorage";
    StorageType[StorageType["SessionStorage"] = 1] = "SessionStorage";
})(StorageType || (StorageType = {}));
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /** Provides a safe way to require localizable strings from within shared components.
     *  Consider specifying a default value if your component is already in use in multiple places,
     *  as users may update IFrameShared for another reason and not notice the new strings for
     *  your component.
     */
    Utils.getString = function (strings, key, defaultValue) {
        if (defaultValue === void 0) { defaultValue = ''; }
        var ret = strings && key && strings[key];
        if (!ret) {
            try {
                // Edge apparently has a chance of throwing an internal exception on calls to console methods
                console.warn("Required localizable string \"" + key + "\" was not provided to shared component");
            }
            catch (e) { }
            ret = defaultValue;
        }
        return ret;
    };
    Utils.deepEqual = function (objectA, objectB, caseInsensitive, excludedProps) {
        if (caseInsensitive === void 0) { caseInsensitive = false; }
        if (excludedProps === void 0) { excludedProps = []; }
        if (!objectA && !objectB) {
            return true;
        }
        if (!objectA || !objectB) {
            return false;
        }
        if (objectA === objectB) { // Triple equals is always deep equal
            return true;
        }
        else if (typeof objectA !== typeof objectB) { // Types must match
            return false;
        }
        else if (objectA instanceof Date && objectB instanceof Date) { // Date objects should compare by date they hold
            return objectA.getTime() === objectB.getTime();
        }
        else if (objectA instanceof Date || objectB instanceof Date) { // Date has typeof object. Ensure no mismatch
            return false;
        }
        else if (typeof objectA === 'object') { // Compare by same number and value of properties (with case insensitive overrides)
            var keysA = Object.keys(objectA);
            var keysB = Object.keys(objectB);
            var keysBCaseInsensitiveMap = {};
            if (keysA.length !== keysB.length) {
                return false;
            }
            else {
                if (caseInsensitive) {
                    for (var _i = 0, keysB_1 = keysB; _i < keysB_1.length; _i++) {
                        var key = keysB_1[_i];
                        keysBCaseInsensitiveMap[key.toLowerCase()] = key;
                    }
                }
                var _loop_1 = function (i) {
                    var s1Key = keysA[i];
                    var s2Key = caseInsensitive ? keysBCaseInsensitiveMap[s1Key.toLowerCase()] : s1Key;
                    if (!excludedProps.filter(function (t) { return t === s2Key; }).length &&
                        (!s2Key || !Utils.deepEqual(objectA[s1Key], objectB[s2Key], caseInsensitive))) {
                        return { value: false };
                    }
                };
                for (var i = 0; i < keysA.length; i++) {
                    var state_1 = _loop_1(i);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
                return true;
            }
        }
        else if (caseInsensitive && typeof objectA === 'string') { // Compare strings case insensitively if necessary
            return objectA.toLowerCase() === objectB.toLowerCase();
        }
        return false;
    };
    Utils.GetValueOrDefault = function (stringMap, key, def) {
        if (!stringMap) {
            return def;
        }
        if (!stringMap[key]) {
            return def;
        }
        return stringMap[key];
    };
    Utils.ArrayPushAll = function (array, items) {
        if (items) {
            for (var i = 0; i < items.length; i++) {
                array.push(items[i]);
            }
        }
        return array;
    };
    /**
     * Node.contains that's safe to use for SVGs in all supported browsers.
     */
    Utils.SvgContains = function (element, target) {
        if (element && element.contains) {
            return element.contains(target);
        }
        else {
            // terrible polyfill for IE 11 because it doesn't support contains on SVG
            var stack = [];
            stack.push(element);
            var cur = void 0;
            while (stack.length) {
                cur = stack.pop();
                if (cur === target) {
                    return true;
                }
                if (cur.hasChildNodes()) {
                    var children = cur.childNodes;
                    for (var i = 0; i < children.length; i++) {
                        var curChild = children.item(i);
                        stack.push(curChild);
                    }
                }
            }
            return false;
        }
    };
    Utils.ClearAllChildren = function (el) {
        while (el && el.firstChild) {
            el.removeChild(el.firstChild);
        }
    };
    /**
     * Random "Guid" generator. Generates random numbers that resemble GUIDs.
     */
    Utils.RandomGuid = function () {
        function get4RandomChars() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return get4RandomChars() + get4RandomChars() + '-' + get4RandomChars() + '-' + get4RandomChars() + '-' +
            get4RandomChars() + '-' + get4RandomChars() + get4RandomChars() + get4RandomChars();
    };
    Utils.EnumToString = function (e, selected) {
        var keys = Object.keys(e);
        for (var i = 0; i < keys.length; i++) {
            if (e[keys[i]] === selected) {
                return keys[i];
            }
        }
        return '';
    };
    /**
     * Gets a value from a local or session storage
     */
    Utils.GetStorage = function (key, storageType) {
        if (storageType === void 0) { storageType = StorageType.LocalStorage; }
        if (Utils.CanUseStorage(storageType)) {
            var storage = Utils.GetVerifiedStorageObject(storageType);
            if (storage) {
                return storage.getItem(key);
            }
        }
        return undefined;
    };
    /**
     * Sets a value in a local or session storage
     */
    Utils.SetStorage = function (key, data, storageType) {
        if (storageType === void 0) { storageType = StorageType.LocalStorage; }
        if (Utils.CanUseStorage(storageType)) {
            var storage = Utils.GetVerifiedStorageObject(storageType);
            if (storage) {
                return storage.setItem(key, data);
            }
        }
    };
    Utils.CanUseStorage = function (storageType) {
        if (storageType === void 0) { storageType = StorageType.LocalStorage; }
        if (storageType === StorageType.LocalStorage) {
            if (Utils._canUseLocalStorage === undefined) {
                Utils._canUseLocalStorage = !!Utils.GetVerifiedStorageObject(StorageType.LocalStorage);
            }
            return Utils._canUseLocalStorage;
        }
        if (storageType === StorageType.SessionStorage) {
            if (Utils._canUseSessionStorage === undefined) {
                Utils._canUseSessionStorage = !!Utils.GetVerifiedStorageObject(StorageType.SessionStorage);
            }
            return Utils._canUseSessionStorage;
        }
    };
    /**
     * Tests storage object (localStorage or sessionStorage) to verify that it is usable
     * More details here: https://mathiasbynens.be/notes/localstorage-pattern
     * @param storageType Type of storage
     * @return {Storage} Returns storage object verified that it is usable
     */
    Utils.GetVerifiedStorageObject = function (storageType) {
        var storage = null;
        var fail;
        var uid;
        try {
            uid = 'storageTest';
            storage = storageType === StorageType.LocalStorage ? window.localStorage : window.sessionStorage;
            storage.setItem(uid, uid);
            fail = storage.getItem(uid) !== uid;
            storage.removeItem(uid);
            if (fail) {
                storage = null;
            }
        }
        catch (exception) {
            storage = null;
        }
        return storage;
    };
    /**
     * Split a URI and get the scheme and authority. For example, given URL https://bing.com/query?q=dkjf,
     * scheme would be "https://" and authority would be "bing.com"
     * @param uri
     */
    Utils.GetUriSchemeAndAuthority = function (uri) {
        var split = uri.split('//');
        var scheme = split[0] + '//';
        var authority = split[1].split('/')[0];
        return {
            scheme: scheme,
            authority: authority
        };
    };
    /**
     * Saves content to file with the given name.
     * @param fileName File name
     * @param content File content
     */
    Utils.SaveToFile = function (fileName, content) {
        // Convert.FromBase64String
        var binaryString = window.atob(content);
        // convert to unsigned int 8
        var bytes = new Uint8Array(binaryString.length);
        for (var i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        var blob = new Blob([bytes.buffer], { type: 'application/octet-stream' });
        if (window.navigator.msSaveBlob) {
            // IE workaround for "HTML7007: One or more blob URLs were revoked by closing the blob for which they were created.
            // These URLs will no longer resolve as the data backing the URL has been freed."
            window.navigator.msSaveBlob(blob, fileName);
        }
        else {
            var winUrl = window.URL || window.webkitURL;
            var downloadUrl = winUrl.createObjectURL(blob);
            var link = document.createElement('a');
            // note that a.download is typically set to empty string upon creation 
            // (which is different from undefined when not supported)
            if (link.download !== undefined) {
                // use HTML5 a[download] attribute to specify filename
                link.download = fileName;
                link.href = downloadUrl;
                // required for Firefox (optional for Chrome)
                link.target = '_self';
                // Firefox requires the link to be in the body (optional for Chrome)
                document.body.appendChild(link);
                // simulate click
                link.click();
                // remove the link when done to clean up DOM (for Firefox)
                document.body.removeChild(link);
            }
            else {
                // Safari doesn't support this yet so fallback to this
                window.location.assign(downloadUrl);
            }
        }
    };
    return Utils;
}());
export { Utils };
//# sourceMappingURL=Utils.js.map